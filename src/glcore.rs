
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(unpredictable_function_pointer_comparisons)]
use std::{
	mem::transmute,
	ffi::{c_void, CStr},
	fmt::{self, Debug, Formatter},
	panic::catch_unwind,
	ptr::null,
};

/// The OpenGL error type
#[derive(Debug, Clone, Copy)]
pub enum GLCoreError {
	NullFunctionPointer(&'static str),
	InvalidEnum(&'static str),
	InvalidValue(&'static str),
	InvalidOperation(&'static str),
	InvalidFramebufferOperation(&'static str),
	OutOfMemory(&'static str),
	StackUnderflow(&'static str),
	StackOverflow(&'static str),
	UnknownError((GLenum, &'static str)),
}

/// The result returns from this crate. It's the alias of `Result<T, GLCoreError>`
type Result<T> = std::result::Result<T, GLCoreError>;

/// Convert the constants returns from `glGetError()` to `Result<T>`
pub fn to_result<T>(funcname: &'static str, ret: T, gl_error: GLenum) -> Result<T> {
	match gl_error {
		GL_NO_ERROR => Ok(ret),
		GL_INVALID_ENUM => Err(GLCoreError::InvalidEnum(funcname)),
		GL_INVALID_VALUE => Err(GLCoreError::InvalidValue(funcname)),
		GL_INVALID_OPERATION => Err(GLCoreError::InvalidOperation(funcname)),
		GL_INVALID_FRAMEBUFFER_OPERATION => Err(GLCoreError::InvalidFramebufferOperation(funcname)),
		GL_OUT_OF_MEMORY => Err(GLCoreError::OutOfMemory(funcname)),
		GL_STACK_UNDERFLOW => Err(GLCoreError::StackUnderflow(funcname)),
		GL_STACK_OVERFLOW => Err(GLCoreError::StackOverflow(funcname)),
		_ => Err(GLCoreError::UnknownError((gl_error, funcname))),
	}
}

/// Translate the returned `Result<T>` from `std::panic::catch_unwind()` to our `Result<T>`
pub fn process_catch<T>(funcname: &'static str, ret: std::thread::Result<T>) -> Result<T> {
	match ret {
		Ok(ret) => Ok(ret),
		Err(_) => {
			Err(GLCoreError::NullFunctionPointer(funcname))
		}
	}
}

/// Alias to `f32`
pub type khronos_float_t = f32;

/// Alias to `usize`
pub type khronos_ssize_t = usize;

/// Alias to `usize`
pub type khronos_intptr_t = usize;

/// Alias to `i16`
pub type khronos_int16_t = i16;

/// Alias to `i8`
pub type khronos_int8_t = i8;

/// Alias to `u16`
pub type khronos_uint16_t = u16;

/// Alias to `i64`
pub type khronos_int64_t = i64;

/// Alias to `u64`
pub type khronos_uint64_t = u64;
/// The prototype to the OpenGL callback function `GLDEBUGPROC`
pub type GLDEBUGPROC = extern "system" fn(GLenum, GLenum, GLuint, GLenum, GLsizei, *const GLchar, *const c_void);
/// Alias to `c_void`
pub type GLvoid = c_void;

/// Alias to `u32`
pub type GLenum = u32;

/// Alias to `u32`
pub type GLbitfield = u32;

/// Alias to `u32`
pub type GLuint = u32;

/// Alias to `f32`
pub type GLfloat = f32;

/// Alias to `i32`
pub type GLint = i32;

/// Alias to `i32`
pub type GLsizei = i32;

/// Alias to `f64`
pub type GLdouble = f64;

/// Alias to `u8`
pub type GLboolean = u8;

/// Alias to `u8`
pub type GLubyte = u8;

/// Alias to `i16`
pub type GLshort = i16;

/// Alias to `i8`
pub type GLbyte = i8;

/// Alias to `u16`
pub type GLushort = u16;

/// The prototype to the OpenGL function `CullFace`
type PFNGLCULLFACEPROC = extern "system" fn(GLenum);

/// The prototype to the OpenGL function `FrontFace`
type PFNGLFRONTFACEPROC = extern "system" fn(GLenum);

/// The prototype to the OpenGL function `Hint`
type PFNGLHINTPROC = extern "system" fn(GLenum, GLenum);

/// The prototype to the OpenGL function `LineWidth`
type PFNGLLINEWIDTHPROC = extern "system" fn(GLfloat);

/// The prototype to the OpenGL function `PointSize`
type PFNGLPOINTSIZEPROC = extern "system" fn(GLfloat);

/// The prototype to the OpenGL function `PolygonMode`
type PFNGLPOLYGONMODEPROC = extern "system" fn(GLenum, GLenum);

/// The prototype to the OpenGL function `Scissor`
type PFNGLSCISSORPROC = extern "system" fn(GLint, GLint, GLsizei, GLsizei);

/// The prototype to the OpenGL function `TexParameterf`
type PFNGLTEXPARAMETERFPROC = extern "system" fn(GLenum, GLenum, GLfloat);

/// The prototype to the OpenGL function `TexParameterfv`
type PFNGLTEXPARAMETERFVPROC = extern "system" fn(GLenum, GLenum, *const GLfloat);

/// The prototype to the OpenGL function `TexParameteri`
type PFNGLTEXPARAMETERIPROC = extern "system" fn(GLenum, GLenum, GLint);

/// The prototype to the OpenGL function `TexParameteriv`
type PFNGLTEXPARAMETERIVPROC = extern "system" fn(GLenum, GLenum, *const GLint);

/// The prototype to the OpenGL function `TexImage1D`
type PFNGLTEXIMAGE1DPROC = extern "system" fn(GLenum, GLint, GLint, GLsizei, GLint, GLenum, GLenum, *const c_void);

/// The prototype to the OpenGL function `TexImage2D`
type PFNGLTEXIMAGE2DPROC = extern "system" fn(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, *const c_void);

/// The prototype to the OpenGL function `DrawBuffer`
type PFNGLDRAWBUFFERPROC = extern "system" fn(GLenum);

/// The prototype to the OpenGL function `Clear`
type PFNGLCLEARPROC = extern "system" fn(GLbitfield);

/// The prototype to the OpenGL function `ClearColor`
type PFNGLCLEARCOLORPROC = extern "system" fn(GLfloat, GLfloat, GLfloat, GLfloat);

/// The prototype to the OpenGL function `ClearStencil`
type PFNGLCLEARSTENCILPROC = extern "system" fn(GLint);

/// The prototype to the OpenGL function `ClearDepth`
type PFNGLCLEARDEPTHPROC = extern "system" fn(GLdouble);

/// The prototype to the OpenGL function `StencilMask`
type PFNGLSTENCILMASKPROC = extern "system" fn(GLuint);

/// The prototype to the OpenGL function `ColorMask`
type PFNGLCOLORMASKPROC = extern "system" fn(GLboolean, GLboolean, GLboolean, GLboolean);

/// The prototype to the OpenGL function `DepthMask`
type PFNGLDEPTHMASKPROC = extern "system" fn(GLboolean);

/// The prototype to the OpenGL function `Disable`
type PFNGLDISABLEPROC = extern "system" fn(GLenum);

/// The prototype to the OpenGL function `Enable`
type PFNGLENABLEPROC = extern "system" fn(GLenum);

/// The prototype to the OpenGL function `Finish`
type PFNGLFINISHPROC = extern "system" fn();

/// The prototype to the OpenGL function `Flush`
type PFNGLFLUSHPROC = extern "system" fn();

/// The prototype to the OpenGL function `BlendFunc`
type PFNGLBLENDFUNCPROC = extern "system" fn(GLenum, GLenum);

/// The prototype to the OpenGL function `LogicOp`
type PFNGLLOGICOPPROC = extern "system" fn(GLenum);

/// The prototype to the OpenGL function `StencilFunc`
type PFNGLSTENCILFUNCPROC = extern "system" fn(GLenum, GLint, GLuint);

/// The prototype to the OpenGL function `StencilOp`
type PFNGLSTENCILOPPROC = extern "system" fn(GLenum, GLenum, GLenum);

/// The prototype to the OpenGL function `DepthFunc`
type PFNGLDEPTHFUNCPROC = extern "system" fn(GLenum);

/// The prototype to the OpenGL function `PixelStoref`
type PFNGLPIXELSTOREFPROC = extern "system" fn(GLenum, GLfloat);

/// The prototype to the OpenGL function `PixelStorei`
type PFNGLPIXELSTOREIPROC = extern "system" fn(GLenum, GLint);

/// The prototype to the OpenGL function `ReadBuffer`
type PFNGLREADBUFFERPROC = extern "system" fn(GLenum);

/// The prototype to the OpenGL function `ReadPixels`
type PFNGLREADPIXELSPROC = extern "system" fn(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, *mut c_void);

/// The prototype to the OpenGL function `GetBooleanv`
type PFNGLGETBOOLEANVPROC = extern "system" fn(GLenum, *mut GLboolean);

/// The prototype to the OpenGL function `GetDoublev`
type PFNGLGETDOUBLEVPROC = extern "system" fn(GLenum, *mut GLdouble);

/// The prototype to the OpenGL function `GetError`
type PFNGLGETERRORPROC = extern "system" fn() -> GLenum;

/// The prototype to the OpenGL function `GetFloatv`
type PFNGLGETFLOATVPROC = extern "system" fn(GLenum, *mut GLfloat);

/// The prototype to the OpenGL function `GetIntegerv`
type PFNGLGETINTEGERVPROC = extern "system" fn(GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetString`
type PFNGLGETSTRINGPROC = extern "system" fn(GLenum) -> *const GLubyte;

/// The prototype to the OpenGL function `GetTexImage`
type PFNGLGETTEXIMAGEPROC = extern "system" fn(GLenum, GLint, GLenum, GLenum, *mut c_void);

/// The prototype to the OpenGL function `GetTexParameterfv`
type PFNGLGETTEXPARAMETERFVPROC = extern "system" fn(GLenum, GLenum, *mut GLfloat);

/// The prototype to the OpenGL function `GetTexParameteriv`
type PFNGLGETTEXPARAMETERIVPROC = extern "system" fn(GLenum, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetTexLevelParameterfv`
type PFNGLGETTEXLEVELPARAMETERFVPROC = extern "system" fn(GLenum, GLint, GLenum, *mut GLfloat);

/// The prototype to the OpenGL function `GetTexLevelParameteriv`
type PFNGLGETTEXLEVELPARAMETERIVPROC = extern "system" fn(GLenum, GLint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `IsEnabled`
type PFNGLISENABLEDPROC = extern "system" fn(GLenum) -> GLboolean;

/// The prototype to the OpenGL function `DepthRange`
type PFNGLDEPTHRANGEPROC = extern "system" fn(GLdouble, GLdouble);

/// The prototype to the OpenGL function `Viewport`
type PFNGLVIEWPORTPROC = extern "system" fn(GLint, GLint, GLsizei, GLsizei);

/// The dummy function of `CullFace()`
extern "system" fn dummy_pfnglcullfaceproc (_: GLenum) {
	panic!("OpenGL function pointer `glCullFace()` is null.")
}

/// The dummy function of `FrontFace()`
extern "system" fn dummy_pfnglfrontfaceproc (_: GLenum) {
	panic!("OpenGL function pointer `glFrontFace()` is null.")
}

/// The dummy function of `Hint()`
extern "system" fn dummy_pfnglhintproc (_: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glHint()` is null.")
}

/// The dummy function of `LineWidth()`
extern "system" fn dummy_pfngllinewidthproc (_: GLfloat) {
	panic!("OpenGL function pointer `glLineWidth()` is null.")
}

/// The dummy function of `PointSize()`
extern "system" fn dummy_pfnglpointsizeproc (_: GLfloat) {
	panic!("OpenGL function pointer `glPointSize()` is null.")
}

/// The dummy function of `PolygonMode()`
extern "system" fn dummy_pfnglpolygonmodeproc (_: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glPolygonMode()` is null.")
}

/// The dummy function of `Scissor()`
extern "system" fn dummy_pfnglscissorproc (_: GLint, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glScissor()` is null.")
}

/// The dummy function of `TexParameterf()`
extern "system" fn dummy_pfngltexparameterfproc (_: GLenum, _: GLenum, _: GLfloat) {
	panic!("OpenGL function pointer `glTexParameterf()` is null.")
}

/// The dummy function of `TexParameterfv()`
extern "system" fn dummy_pfngltexparameterfvproc (_: GLenum, _: GLenum, _: *const GLfloat) {
	panic!("OpenGL function pointer `glTexParameterfv()` is null.")
}

/// The dummy function of `TexParameteri()`
extern "system" fn dummy_pfngltexparameteriproc (_: GLenum, _: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glTexParameteri()` is null.")
}

/// The dummy function of `TexParameteriv()`
extern "system" fn dummy_pfngltexparameterivproc (_: GLenum, _: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glTexParameteriv()` is null.")
}

/// The dummy function of `TexImage1D()`
extern "system" fn dummy_pfnglteximage1dproc (_: GLenum, _: GLint, _: GLint, _: GLsizei, _: GLint, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glTexImage1D()` is null.")
}

/// The dummy function of `TexImage2D()`
extern "system" fn dummy_pfnglteximage2dproc (_: GLenum, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLint, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glTexImage2D()` is null.")
}

/// The dummy function of `DrawBuffer()`
extern "system" fn dummy_pfngldrawbufferproc (_: GLenum) {
	panic!("OpenGL function pointer `glDrawBuffer()` is null.")
}

/// The dummy function of `Clear()`
extern "system" fn dummy_pfnglclearproc (_: GLbitfield) {
	panic!("OpenGL function pointer `glClear()` is null.")
}

/// The dummy function of `ClearColor()`
extern "system" fn dummy_pfnglclearcolorproc (_: GLfloat, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glClearColor()` is null.")
}

/// The dummy function of `ClearStencil()`
extern "system" fn dummy_pfnglclearstencilproc (_: GLint) {
	panic!("OpenGL function pointer `glClearStencil()` is null.")
}

/// The dummy function of `ClearDepth()`
extern "system" fn dummy_pfnglcleardepthproc (_: GLdouble) {
	panic!("OpenGL function pointer `glClearDepth()` is null.")
}

/// The dummy function of `StencilMask()`
extern "system" fn dummy_pfnglstencilmaskproc (_: GLuint) {
	panic!("OpenGL function pointer `glStencilMask()` is null.")
}

/// The dummy function of `ColorMask()`
extern "system" fn dummy_pfnglcolormaskproc (_: GLboolean, _: GLboolean, _: GLboolean, _: GLboolean) {
	panic!("OpenGL function pointer `glColorMask()` is null.")
}

/// The dummy function of `DepthMask()`
extern "system" fn dummy_pfngldepthmaskproc (_: GLboolean) {
	panic!("OpenGL function pointer `glDepthMask()` is null.")
}

/// The dummy function of `Disable()`
extern "system" fn dummy_pfngldisableproc (_: GLenum) {
	panic!("OpenGL function pointer `glDisable()` is null.")
}

/// The dummy function of `Enable()`
extern "system" fn dummy_pfnglenableproc (_: GLenum) {
	panic!("OpenGL function pointer `glEnable()` is null.")
}

/// The dummy function of `Finish()`
extern "system" fn dummy_pfnglfinishproc () {
	panic!("OpenGL function pointer `glFinish()` is null.")
}

/// The dummy function of `Flush()`
extern "system" fn dummy_pfnglflushproc () {
	panic!("OpenGL function pointer `glFlush()` is null.")
}

/// The dummy function of `BlendFunc()`
extern "system" fn dummy_pfnglblendfuncproc (_: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glBlendFunc()` is null.")
}

/// The dummy function of `LogicOp()`
extern "system" fn dummy_pfngllogicopproc (_: GLenum) {
	panic!("OpenGL function pointer `glLogicOp()` is null.")
}

/// The dummy function of `StencilFunc()`
extern "system" fn dummy_pfnglstencilfuncproc (_: GLenum, _: GLint, _: GLuint) {
	panic!("OpenGL function pointer `glStencilFunc()` is null.")
}

/// The dummy function of `StencilOp()`
extern "system" fn dummy_pfnglstencilopproc (_: GLenum, _: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glStencilOp()` is null.")
}

/// The dummy function of `DepthFunc()`
extern "system" fn dummy_pfngldepthfuncproc (_: GLenum) {
	panic!("OpenGL function pointer `glDepthFunc()` is null.")
}

/// The dummy function of `PixelStoref()`
extern "system" fn dummy_pfnglpixelstorefproc (_: GLenum, _: GLfloat) {
	panic!("OpenGL function pointer `glPixelStoref()` is null.")
}

/// The dummy function of `PixelStorei()`
extern "system" fn dummy_pfnglpixelstoreiproc (_: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glPixelStorei()` is null.")
}

/// The dummy function of `ReadBuffer()`
extern "system" fn dummy_pfnglreadbufferproc (_: GLenum) {
	panic!("OpenGL function pointer `glReadBuffer()` is null.")
}

/// The dummy function of `ReadPixels()`
extern "system" fn dummy_pfnglreadpixelsproc (_: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLenum, _: GLenum, _: *mut c_void) {
	panic!("OpenGL function pointer `glReadPixels()` is null.")
}

/// The dummy function of `GetBooleanv()`
extern "system" fn dummy_pfnglgetbooleanvproc (_: GLenum, _: *mut GLboolean) {
	panic!("OpenGL function pointer `glGetBooleanv()` is null.")
}

/// The dummy function of `GetDoublev()`
extern "system" fn dummy_pfnglgetdoublevproc (_: GLenum, _: *mut GLdouble) {
	panic!("OpenGL function pointer `glGetDoublev()` is null.")
}

/// The dummy function of `GetError()`
extern "system" fn dummy_pfnglgeterrorproc () -> GLenum {
	panic!("OpenGL function pointer `glGetError()` is null.")
}

/// The dummy function of `GetFloatv()`
extern "system" fn dummy_pfnglgetfloatvproc (_: GLenum, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetFloatv()` is null.")
}

/// The dummy function of `GetIntegerv()`
extern "system" fn dummy_pfnglgetintegervproc (_: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetIntegerv()` is null.")
}

/// The dummy function of `GetString()`
extern "system" fn dummy_pfnglgetstringproc (_: GLenum) -> *const GLubyte {
	panic!("OpenGL function pointer `glGetString()` is null.")
}

/// The dummy function of `GetTexImage()`
extern "system" fn dummy_pfnglgetteximageproc (_: GLenum, _: GLint, _: GLenum, _: GLenum, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetTexImage()` is null.")
}

/// The dummy function of `GetTexParameterfv()`
extern "system" fn dummy_pfnglgettexparameterfvproc (_: GLenum, _: GLenum, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetTexParameterfv()` is null.")
}

/// The dummy function of `GetTexParameteriv()`
extern "system" fn dummy_pfnglgettexparameterivproc (_: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetTexParameteriv()` is null.")
}

/// The dummy function of `GetTexLevelParameterfv()`
extern "system" fn dummy_pfnglgettexlevelparameterfvproc (_: GLenum, _: GLint, _: GLenum, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetTexLevelParameterfv()` is null.")
}

/// The dummy function of `GetTexLevelParameteriv()`
extern "system" fn dummy_pfnglgettexlevelparameterivproc (_: GLenum, _: GLint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetTexLevelParameteriv()` is null.")
}

/// The dummy function of `IsEnabled()`
extern "system" fn dummy_pfnglisenabledproc (_: GLenum) -> GLboolean {
	panic!("OpenGL function pointer `glIsEnabled()` is null.")
}

/// The dummy function of `DepthRange()`
extern "system" fn dummy_pfngldepthrangeproc (_: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glDepthRange()` is null.")
}

/// The dummy function of `Viewport()`
extern "system" fn dummy_pfnglviewportproc (_: GLint, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glViewport()` is null.")
}
/// Constant value defined from OpenGL 1.0
pub const GL_DEPTH_BUFFER_BIT: GLbitfield = 0x00000100;

/// Constant value defined from OpenGL 1.0
pub const GL_STENCIL_BUFFER_BIT: GLbitfield = 0x00000400;

/// Constant value defined from OpenGL 1.0
pub const GL_COLOR_BUFFER_BIT: GLbitfield = 0x00004000;

/// Constant value defined from OpenGL 1.0
pub const GL_FALSE: GLenum = 0;

/// Constant value defined from OpenGL 1.0
pub const GL_TRUE: GLenum = 1;

/// Constant value defined from OpenGL 1.0
pub const GL_POINTS: GLenum = 0x0000;

/// Constant value defined from OpenGL 1.0
pub const GL_LINES: GLenum = 0x0001;

/// Constant value defined from OpenGL 1.0
pub const GL_LINE_LOOP: GLenum = 0x0002;

/// Constant value defined from OpenGL 1.0
pub const GL_LINE_STRIP: GLenum = 0x0003;

/// Constant value defined from OpenGL 1.0
pub const GL_TRIANGLES: GLenum = 0x0004;

/// Constant value defined from OpenGL 1.0
pub const GL_TRIANGLE_STRIP: GLenum = 0x0005;

/// Constant value defined from OpenGL 1.0
pub const GL_TRIANGLE_FAN: GLenum = 0x0006;

/// Constant value defined from OpenGL 1.0
pub const GL_QUADS: GLenum = 0x0007;

/// Constant value defined from OpenGL 1.0
pub const GL_NEVER: GLenum = 0x0200;

/// Constant value defined from OpenGL 1.0
pub const GL_LESS: GLenum = 0x0201;

/// Constant value defined from OpenGL 1.0
pub const GL_EQUAL: GLenum = 0x0202;

/// Constant value defined from OpenGL 1.0
pub const GL_LEQUAL: GLenum = 0x0203;

/// Constant value defined from OpenGL 1.0
pub const GL_GREATER: GLenum = 0x0204;

/// Constant value defined from OpenGL 1.0
pub const GL_NOTEQUAL: GLenum = 0x0205;

/// Constant value defined from OpenGL 1.0
pub const GL_GEQUAL: GLenum = 0x0206;

/// Constant value defined from OpenGL 1.0
pub const GL_ALWAYS: GLenum = 0x0207;

/// Constant value defined from OpenGL 1.0
pub const GL_ZERO: GLenum = 0;

/// Constant value defined from OpenGL 1.0
pub const GL_ONE: GLenum = 1;

/// Constant value defined from OpenGL 1.0
pub const GL_SRC_COLOR: GLenum = 0x0300;

/// Constant value defined from OpenGL 1.0
pub const GL_ONE_MINUS_SRC_COLOR: GLenum = 0x0301;

/// Constant value defined from OpenGL 1.0
pub const GL_SRC_ALPHA: GLenum = 0x0302;

/// Constant value defined from OpenGL 1.0
pub const GL_ONE_MINUS_SRC_ALPHA: GLenum = 0x0303;

/// Constant value defined from OpenGL 1.0
pub const GL_DST_ALPHA: GLenum = 0x0304;

/// Constant value defined from OpenGL 1.0
pub const GL_ONE_MINUS_DST_ALPHA: GLenum = 0x0305;

/// Constant value defined from OpenGL 1.0
pub const GL_DST_COLOR: GLenum = 0x0306;

/// Constant value defined from OpenGL 1.0
pub const GL_ONE_MINUS_DST_COLOR: GLenum = 0x0307;

/// Constant value defined from OpenGL 1.0
pub const GL_SRC_ALPHA_SATURATE: GLenum = 0x0308;

/// Constant value defined from OpenGL 1.0
pub const GL_NONE: GLenum = 0;

/// Constant value defined from OpenGL 1.0
pub const GL_FRONT_LEFT: GLenum = 0x0400;

/// Constant value defined from OpenGL 1.0
pub const GL_FRONT_RIGHT: GLenum = 0x0401;

/// Constant value defined from OpenGL 1.0
pub const GL_BACK_LEFT: GLenum = 0x0402;

/// Constant value defined from OpenGL 1.0
pub const GL_BACK_RIGHT: GLenum = 0x0403;

/// Constant value defined from OpenGL 1.0
pub const GL_FRONT: GLenum = 0x0404;

/// Constant value defined from OpenGL 1.0
pub const GL_BACK: GLenum = 0x0405;

/// Constant value defined from OpenGL 1.0
pub const GL_LEFT: GLenum = 0x0406;

/// Constant value defined from OpenGL 1.0
pub const GL_RIGHT: GLenum = 0x0407;

/// Constant value defined from OpenGL 1.0
pub const GL_FRONT_AND_BACK: GLenum = 0x0408;

/// Constant value defined from OpenGL 1.0
pub const GL_NO_ERROR: GLenum = 0;

/// Constant value defined from OpenGL 1.0
pub const GL_INVALID_ENUM: GLenum = 0x0500;

/// Constant value defined from OpenGL 1.0
pub const GL_INVALID_VALUE: GLenum = 0x0501;

/// Constant value defined from OpenGL 1.0
pub const GL_INVALID_OPERATION: GLenum = 0x0502;

/// Constant value defined from OpenGL 1.0
pub const GL_OUT_OF_MEMORY: GLenum = 0x0505;

/// Constant value defined from OpenGL 1.0
pub const GL_CW: GLenum = 0x0900;

/// Constant value defined from OpenGL 1.0
pub const GL_CCW: GLenum = 0x0901;

/// Constant value defined from OpenGL 1.0
pub const GL_POINT_SIZE: GLenum = 0x0B11;

/// Constant value defined from OpenGL 1.0
pub const GL_POINT_SIZE_RANGE: GLenum = 0x0B12;

/// Constant value defined from OpenGL 1.0
pub const GL_POINT_SIZE_GRANULARITY: GLenum = 0x0B13;

/// Constant value defined from OpenGL 1.0
pub const GL_LINE_SMOOTH: GLenum = 0x0B20;

/// Constant value defined from OpenGL 1.0
pub const GL_LINE_WIDTH: GLenum = 0x0B21;

/// Constant value defined from OpenGL 1.0
pub const GL_LINE_WIDTH_RANGE: GLenum = 0x0B22;

/// Constant value defined from OpenGL 1.0
pub const GL_LINE_WIDTH_GRANULARITY: GLenum = 0x0B23;

/// Constant value defined from OpenGL 1.0
pub const GL_POLYGON_MODE: GLenum = 0x0B40;

/// Constant value defined from OpenGL 1.0
pub const GL_POLYGON_SMOOTH: GLenum = 0x0B41;

/// Constant value defined from OpenGL 1.0
pub const GL_CULL_FACE: GLenum = 0x0B44;

/// Constant value defined from OpenGL 1.0
pub const GL_CULL_FACE_MODE: GLenum = 0x0B45;

/// Constant value defined from OpenGL 1.0
pub const GL_FRONT_FACE: GLenum = 0x0B46;

/// Constant value defined from OpenGL 1.0
pub const GL_DEPTH_RANGE: GLenum = 0x0B70;

/// Constant value defined from OpenGL 1.0
pub const GL_DEPTH_TEST: GLenum = 0x0B71;

/// Constant value defined from OpenGL 1.0
pub const GL_DEPTH_WRITEMASK: GLenum = 0x0B72;

/// Constant value defined from OpenGL 1.0
pub const GL_DEPTH_CLEAR_VALUE: GLenum = 0x0B73;

/// Constant value defined from OpenGL 1.0
pub const GL_DEPTH_FUNC: GLenum = 0x0B74;

/// Constant value defined from OpenGL 1.0
pub const GL_STENCIL_TEST: GLenum = 0x0B90;

/// Constant value defined from OpenGL 1.0
pub const GL_STENCIL_CLEAR_VALUE: GLenum = 0x0B91;

/// Constant value defined from OpenGL 1.0
pub const GL_STENCIL_FUNC: GLenum = 0x0B92;

/// Constant value defined from OpenGL 1.0
pub const GL_STENCIL_VALUE_MASK: GLenum = 0x0B93;

/// Constant value defined from OpenGL 1.0
pub const GL_STENCIL_FAIL: GLenum = 0x0B94;

/// Constant value defined from OpenGL 1.0
pub const GL_STENCIL_PASS_DEPTH_FAIL: GLenum = 0x0B95;

/// Constant value defined from OpenGL 1.0
pub const GL_STENCIL_PASS_DEPTH_PASS: GLenum = 0x0B96;

/// Constant value defined from OpenGL 1.0
pub const GL_STENCIL_REF: GLenum = 0x0B97;

/// Constant value defined from OpenGL 1.0
pub const GL_STENCIL_WRITEMASK: GLenum = 0x0B98;

/// Constant value defined from OpenGL 1.0
pub const GL_VIEWPORT: GLenum = 0x0BA2;

/// Constant value defined from OpenGL 1.0
pub const GL_DITHER: GLenum = 0x0BD0;

/// Constant value defined from OpenGL 1.0
pub const GL_BLEND_DST: GLenum = 0x0BE0;

/// Constant value defined from OpenGL 1.0
pub const GL_BLEND_SRC: GLenum = 0x0BE1;

/// Constant value defined from OpenGL 1.0
pub const GL_BLEND: GLenum = 0x0BE2;

/// Constant value defined from OpenGL 1.0
pub const GL_LOGIC_OP_MODE: GLenum = 0x0BF0;

/// Constant value defined from OpenGL 1.0
pub const GL_DRAW_BUFFER: GLenum = 0x0C01;

/// Constant value defined from OpenGL 1.0
pub const GL_READ_BUFFER: GLenum = 0x0C02;

/// Constant value defined from OpenGL 1.0
pub const GL_SCISSOR_BOX: GLenum = 0x0C10;

/// Constant value defined from OpenGL 1.0
pub const GL_SCISSOR_TEST: GLenum = 0x0C11;

/// Constant value defined from OpenGL 1.0
pub const GL_COLOR_CLEAR_VALUE: GLenum = 0x0C22;

/// Constant value defined from OpenGL 1.0
pub const GL_COLOR_WRITEMASK: GLenum = 0x0C23;

/// Constant value defined from OpenGL 1.0
pub const GL_DOUBLEBUFFER: GLenum = 0x0C32;

/// Constant value defined from OpenGL 1.0
pub const GL_STEREO: GLenum = 0x0C33;

/// Constant value defined from OpenGL 1.0
pub const GL_LINE_SMOOTH_HINT: GLenum = 0x0C52;

/// Constant value defined from OpenGL 1.0
pub const GL_POLYGON_SMOOTH_HINT: GLenum = 0x0C53;

/// Constant value defined from OpenGL 1.0
pub const GL_UNPACK_SWAP_BYTES: GLenum = 0x0CF0;

/// Constant value defined from OpenGL 1.0
pub const GL_UNPACK_LSB_FIRST: GLenum = 0x0CF1;

/// Constant value defined from OpenGL 1.0
pub const GL_UNPACK_ROW_LENGTH: GLenum = 0x0CF2;

/// Constant value defined from OpenGL 1.0
pub const GL_UNPACK_SKIP_ROWS: GLenum = 0x0CF3;

/// Constant value defined from OpenGL 1.0
pub const GL_UNPACK_SKIP_PIXELS: GLenum = 0x0CF4;

/// Constant value defined from OpenGL 1.0
pub const GL_UNPACK_ALIGNMENT: GLenum = 0x0CF5;

/// Constant value defined from OpenGL 1.0
pub const GL_PACK_SWAP_BYTES: GLenum = 0x0D00;

/// Constant value defined from OpenGL 1.0
pub const GL_PACK_LSB_FIRST: GLenum = 0x0D01;

/// Constant value defined from OpenGL 1.0
pub const GL_PACK_ROW_LENGTH: GLenum = 0x0D02;

/// Constant value defined from OpenGL 1.0
pub const GL_PACK_SKIP_ROWS: GLenum = 0x0D03;

/// Constant value defined from OpenGL 1.0
pub const GL_PACK_SKIP_PIXELS: GLenum = 0x0D04;

/// Constant value defined from OpenGL 1.0
pub const GL_PACK_ALIGNMENT: GLenum = 0x0D05;

/// Constant value defined from OpenGL 1.0
pub const GL_MAX_TEXTURE_SIZE: GLenum = 0x0D33;

/// Constant value defined from OpenGL 1.0
pub const GL_MAX_VIEWPORT_DIMS: GLenum = 0x0D3A;

/// Constant value defined from OpenGL 1.0
pub const GL_SUBPIXEL_BITS: GLenum = 0x0D50;

/// Constant value defined from OpenGL 1.0
pub const GL_TEXTURE_1D: GLenum = 0x0DE0;

/// Constant value defined from OpenGL 1.0
pub const GL_TEXTURE_2D: GLenum = 0x0DE1;

/// Constant value defined from OpenGL 1.0
pub const GL_TEXTURE_WIDTH: GLenum = 0x1000;

/// Constant value defined from OpenGL 1.0
pub const GL_TEXTURE_HEIGHT: GLenum = 0x1001;

/// Constant value defined from OpenGL 1.0
pub const GL_TEXTURE_BORDER_COLOR: GLenum = 0x1004;

/// Constant value defined from OpenGL 1.0
pub const GL_DONT_CARE: GLenum = 0x1100;

/// Constant value defined from OpenGL 1.0
pub const GL_FASTEST: GLenum = 0x1101;

/// Constant value defined from OpenGL 1.0
pub const GL_NICEST: GLenum = 0x1102;

/// Constant value defined from OpenGL 1.0
pub const GL_BYTE: GLenum = 0x1400;

/// Constant value defined from OpenGL 1.0
pub const GL_UNSIGNED_BYTE: GLenum = 0x1401;

/// Constant value defined from OpenGL 1.0
pub const GL_SHORT: GLenum = 0x1402;

/// Constant value defined from OpenGL 1.0
pub const GL_UNSIGNED_SHORT: GLenum = 0x1403;

/// Constant value defined from OpenGL 1.0
pub const GL_INT: GLenum = 0x1404;

/// Constant value defined from OpenGL 1.0
pub const GL_UNSIGNED_INT: GLenum = 0x1405;

/// Constant value defined from OpenGL 1.0
pub const GL_FLOAT: GLenum = 0x1406;

/// Constant value defined from OpenGL 1.0
pub const GL_STACK_OVERFLOW: GLenum = 0x0503;

/// Constant value defined from OpenGL 1.0
pub const GL_STACK_UNDERFLOW: GLenum = 0x0504;

/// Constant value defined from OpenGL 1.0
pub const GL_CLEAR: GLenum = 0x1500;

/// Constant value defined from OpenGL 1.0
pub const GL_AND: GLenum = 0x1501;

/// Constant value defined from OpenGL 1.0
pub const GL_AND_REVERSE: GLenum = 0x1502;

/// Constant value defined from OpenGL 1.0
pub const GL_COPY: GLenum = 0x1503;

/// Constant value defined from OpenGL 1.0
pub const GL_AND_INVERTED: GLenum = 0x1504;

/// Constant value defined from OpenGL 1.0
pub const GL_NOOP: GLenum = 0x1505;

/// Constant value defined from OpenGL 1.0
pub const GL_XOR: GLenum = 0x1506;

/// Constant value defined from OpenGL 1.0
pub const GL_OR: GLenum = 0x1507;

/// Constant value defined from OpenGL 1.0
pub const GL_NOR: GLenum = 0x1508;

/// Constant value defined from OpenGL 1.0
pub const GL_EQUIV: GLenum = 0x1509;

/// Constant value defined from OpenGL 1.0
pub const GL_INVERT: GLenum = 0x150A;

/// Constant value defined from OpenGL 1.0
pub const GL_OR_REVERSE: GLenum = 0x150B;

/// Constant value defined from OpenGL 1.0
pub const GL_COPY_INVERTED: GLenum = 0x150C;

/// Constant value defined from OpenGL 1.0
pub const GL_OR_INVERTED: GLenum = 0x150D;

/// Constant value defined from OpenGL 1.0
pub const GL_NAND: GLenum = 0x150E;

/// Constant value defined from OpenGL 1.0
pub const GL_SET: GLenum = 0x150F;

/// Constant value defined from OpenGL 1.0
pub const GL_TEXTURE: GLenum = 0x1702;

/// Constant value defined from OpenGL 1.0
pub const GL_COLOR: GLenum = 0x1800;

/// Constant value defined from OpenGL 1.0
pub const GL_DEPTH: GLenum = 0x1801;

/// Constant value defined from OpenGL 1.0
pub const GL_STENCIL: GLenum = 0x1802;

/// Constant value defined from OpenGL 1.0
pub const GL_STENCIL_INDEX: GLenum = 0x1901;

/// Constant value defined from OpenGL 1.0
pub const GL_DEPTH_COMPONENT: GLenum = 0x1902;

/// Constant value defined from OpenGL 1.0
pub const GL_RED: GLenum = 0x1903;

/// Constant value defined from OpenGL 1.0
pub const GL_GREEN: GLenum = 0x1904;

/// Constant value defined from OpenGL 1.0
pub const GL_BLUE: GLenum = 0x1905;

/// Constant value defined from OpenGL 1.0
pub const GL_ALPHA: GLenum = 0x1906;

/// Constant value defined from OpenGL 1.0
pub const GL_RGB: GLenum = 0x1907;

/// Constant value defined from OpenGL 1.0
pub const GL_RGBA: GLenum = 0x1908;

/// Constant value defined from OpenGL 1.0
pub const GL_POINT: GLenum = 0x1B00;

/// Constant value defined from OpenGL 1.0
pub const GL_LINE: GLenum = 0x1B01;

/// Constant value defined from OpenGL 1.0
pub const GL_FILL: GLenum = 0x1B02;

/// Constant value defined from OpenGL 1.0
pub const GL_KEEP: GLenum = 0x1E00;

/// Constant value defined from OpenGL 1.0
pub const GL_REPLACE: GLenum = 0x1E01;

/// Constant value defined from OpenGL 1.0
pub const GL_INCR: GLenum = 0x1E02;

/// Constant value defined from OpenGL 1.0
pub const GL_DECR: GLenum = 0x1E03;

/// Constant value defined from OpenGL 1.0
pub const GL_VENDOR: GLenum = 0x1F00;

/// Constant value defined from OpenGL 1.0
pub const GL_RENDERER: GLenum = 0x1F01;

/// Constant value defined from OpenGL 1.0
pub const GL_VERSION: GLenum = 0x1F02;

/// Constant value defined from OpenGL 1.0
pub const GL_EXTENSIONS: GLenum = 0x1F03;

/// Constant value defined from OpenGL 1.0
pub const GL_NEAREST: GLint = 0x2600;

/// Constant value defined from OpenGL 1.0
pub const GL_LINEAR: GLint = 0x2601;

/// Constant value defined from OpenGL 1.0
pub const GL_NEAREST_MIPMAP_NEAREST: GLint = 0x2700;

/// Constant value defined from OpenGL 1.0
pub const GL_LINEAR_MIPMAP_NEAREST: GLint = 0x2701;

/// Constant value defined from OpenGL 1.0
pub const GL_NEAREST_MIPMAP_LINEAR: GLint = 0x2702;

/// Constant value defined from OpenGL 1.0
pub const GL_LINEAR_MIPMAP_LINEAR: GLint = 0x2703;

/// Constant value defined from OpenGL 1.0
pub const GL_TEXTURE_MAG_FILTER: GLenum = 0x2800;

/// Constant value defined from OpenGL 1.0
pub const GL_TEXTURE_MIN_FILTER: GLenum = 0x2801;

/// Constant value defined from OpenGL 1.0
pub const GL_TEXTURE_WRAP_S: GLenum = 0x2802;

/// Constant value defined from OpenGL 1.0
pub const GL_TEXTURE_WRAP_T: GLenum = 0x2803;

/// Constant value defined from OpenGL 1.0
pub const GL_REPEAT: GLint = 0x2901;

/// Functions from OpenGL version 1.0
pub trait GL_1_0 {

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCullFace.xhtml>
	fn glCullFace(&self, mode: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFrontFace.xhtml>
	fn glFrontFace(&self, mode: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glHint.xhtml>
	fn glHint(&self, target: GLenum, mode: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLineWidth.xhtml>
	fn glLineWidth(&self, width: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPointSize.xhtml>
	fn glPointSize(&self, size: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPolygonMode.xhtml>
	fn glPolygonMode(&self, face: GLenum, mode: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glScissor.xhtml>
	fn glScissor(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameterf.xhtml>
	fn glTexParameterf(&self, target: GLenum, pname: GLenum, param: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameterfv.xhtml>
	fn glTexParameterfv(&self, target: GLenum, pname: GLenum, params: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameteri.xhtml>
	fn glTexParameteri(&self, target: GLenum, pname: GLenum, param: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameteriv.xhtml>
	fn glTexParameteriv(&self, target: GLenum, pname: GLenum, params: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexImage1D.xhtml>
	fn glTexImage1D(&self, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml>
	fn glTexImage2D(&self, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawBuffer.xhtml>
	fn glDrawBuffer(&self, buf: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClear.xhtml>
	fn glClear(&self, mask: GLbitfield) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearColor.xhtml>
	fn glClearColor(&self, red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearStencil.xhtml>
	fn glClearStencil(&self, s: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearDepth.xhtml>
	fn glClearDepth(&self, depth: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilMask.xhtml>
	fn glStencilMask(&self, mask: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glColorMask.xhtml>
	fn glColorMask(&self, red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDepthMask.xhtml>
	fn glDepthMask(&self, flag: GLboolean) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDisable.xhtml>
	fn glDisable(&self, cap: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEnable.xhtml>
	fn glEnable(&self, cap: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFinish.xhtml>
	fn glFinish(&self) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFlush.xhtml>
	fn glFlush(&self) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml>
	fn glBlendFunc(&self, sfactor: GLenum, dfactor: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLogicOp.xhtml>
	fn glLogicOp(&self, opcode: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilFunc.xhtml>
	fn glStencilFunc(&self, func: GLenum, ref_: GLint, mask: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilOp.xhtml>
	fn glStencilOp(&self, fail: GLenum, zfail: GLenum, zpass: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDepthFunc.xhtml>
	fn glDepthFunc(&self, func: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPixelStoref.xhtml>
	fn glPixelStoref(&self, pname: GLenum, param: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPixelStorei.xhtml>
	fn glPixelStorei(&self, pname: GLenum, param: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glReadBuffer.xhtml>
	fn glReadBuffer(&self, src: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glReadPixels.xhtml>
	fn glReadPixels(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetBooleanv.xhtml>
	fn glGetBooleanv(&self, pname: GLenum, data: *mut GLboolean) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetDoublev.xhtml>
	fn glGetDoublev(&self, pname: GLenum, data: *mut GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	fn glGetError(&self) -> GLenum;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetFloatv.xhtml>
	fn glGetFloatv(&self, pname: GLenum, data: *mut GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetIntegerv.xhtml>
	fn glGetIntegerv(&self, pname: GLenum, data: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetString.xhtml>
	fn glGetString(&self, name: GLenum) -> Result<&'static str>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml>
	fn glGetTexImage(&self, target: GLenum, level: GLint, format: GLenum, type_: GLenum, pixels: *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexParameterfv.xhtml>
	fn glGetTexParameterfv(&self, target: GLenum, pname: GLenum, params: *mut GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexParameteriv.xhtml>
	fn glGetTexParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexLevelParameterfv.xhtml>
	fn glGetTexLevelParameterfv(&self, target: GLenum, level: GLint, pname: GLenum, params: *mut GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexLevelParameteriv.xhtml>
	fn glGetTexLevelParameteriv(&self, target: GLenum, level: GLint, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsEnabled.xhtml>
	fn glIsEnabled(&self, cap: GLenum) -> Result<GLboolean>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDepthRange.xhtml>
	fn glDepthRange(&self, n: GLdouble, f: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glViewport.xhtml>
	fn glViewport(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()>;
	fn get_version(&self) -> (&'static str, u32, u32, u32);
	fn get_vendor(&self) -> &'static str;
	fn get_renderer(&self) -> &'static str;
	fn get_versionstr(&self) -> &'static str;
}
/// Functions from OpenGL version 1.0
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version10 {
	spec: &'static str,
	major_version: u32,
	minor_version: u32,
	release_version: u32,
	vendor: &'static str,
	renderer: &'static str,
	version: &'static str,
	/// Is OpenGL version 1.0 available
	available: bool,
	/// The function pointer to `glCullFace()`
	pub cullface: PFNGLCULLFACEPROC,

	/// The function pointer to `glFrontFace()`
	pub frontface: PFNGLFRONTFACEPROC,

	/// The function pointer to `glHint()`
	pub hint: PFNGLHINTPROC,

	/// The function pointer to `glLineWidth()`
	pub linewidth: PFNGLLINEWIDTHPROC,

	/// The function pointer to `glPointSize()`
	pub pointsize: PFNGLPOINTSIZEPROC,

	/// The function pointer to `glPolygonMode()`
	pub polygonmode: PFNGLPOLYGONMODEPROC,

	/// The function pointer to `glScissor()`
	pub scissor: PFNGLSCISSORPROC,

	/// The function pointer to `glTexParameterf()`
	pub texparameterf: PFNGLTEXPARAMETERFPROC,

	/// The function pointer to `glTexParameterfv()`
	pub texparameterfv: PFNGLTEXPARAMETERFVPROC,

	/// The function pointer to `glTexParameteri()`
	pub texparameteri: PFNGLTEXPARAMETERIPROC,

	/// The function pointer to `glTexParameteriv()`
	pub texparameteriv: PFNGLTEXPARAMETERIVPROC,

	/// The function pointer to `glTexImage1D()`
	pub teximage1d: PFNGLTEXIMAGE1DPROC,

	/// The function pointer to `glTexImage2D()`
	pub teximage2d: PFNGLTEXIMAGE2DPROC,

	/// The function pointer to `glDrawBuffer()`
	pub drawbuffer: PFNGLDRAWBUFFERPROC,

	/// The function pointer to `glClear()`
	pub clear: PFNGLCLEARPROC,

	/// The function pointer to `glClearColor()`
	pub clearcolor: PFNGLCLEARCOLORPROC,

	/// The function pointer to `glClearStencil()`
	pub clearstencil: PFNGLCLEARSTENCILPROC,

	/// The function pointer to `glClearDepth()`
	pub cleardepth: PFNGLCLEARDEPTHPROC,

	/// The function pointer to `glStencilMask()`
	pub stencilmask: PFNGLSTENCILMASKPROC,

	/// The function pointer to `glColorMask()`
	pub colormask: PFNGLCOLORMASKPROC,

	/// The function pointer to `glDepthMask()`
	pub depthmask: PFNGLDEPTHMASKPROC,

	/// The function pointer to `glDisable()`
	pub disable: PFNGLDISABLEPROC,

	/// The function pointer to `glEnable()`
	pub enable: PFNGLENABLEPROC,

	/// The function pointer to `glFinish()`
	pub finish: PFNGLFINISHPROC,

	/// The function pointer to `glFlush()`
	pub flush: PFNGLFLUSHPROC,

	/// The function pointer to `glBlendFunc()`
	pub blendfunc: PFNGLBLENDFUNCPROC,

	/// The function pointer to `glLogicOp()`
	pub logicop: PFNGLLOGICOPPROC,

	/// The function pointer to `glStencilFunc()`
	pub stencilfunc: PFNGLSTENCILFUNCPROC,

	/// The function pointer to `glStencilOp()`
	pub stencilop: PFNGLSTENCILOPPROC,

	/// The function pointer to `glDepthFunc()`
	pub depthfunc: PFNGLDEPTHFUNCPROC,

	/// The function pointer to `glPixelStoref()`
	pub pixelstoref: PFNGLPIXELSTOREFPROC,

	/// The function pointer to `glPixelStorei()`
	pub pixelstorei: PFNGLPIXELSTOREIPROC,

	/// The function pointer to `glReadBuffer()`
	pub readbuffer: PFNGLREADBUFFERPROC,

	/// The function pointer to `glReadPixels()`
	pub readpixels: PFNGLREADPIXELSPROC,

	/// The function pointer to `glGetBooleanv()`
	pub getbooleanv: PFNGLGETBOOLEANVPROC,

	/// The function pointer to `glGetDoublev()`
	pub getdoublev: PFNGLGETDOUBLEVPROC,

	/// The function pointer to `glGetError()`
	pub geterror: PFNGLGETERRORPROC,

	/// The function pointer to `glGetFloatv()`
	pub getfloatv: PFNGLGETFLOATVPROC,

	/// The function pointer to `glGetIntegerv()`
	pub getintegerv: PFNGLGETINTEGERVPROC,

	/// The function pointer to `glGetString()`
	pub getstring: PFNGLGETSTRINGPROC,

	/// The function pointer to `glGetTexImage()`
	pub getteximage: PFNGLGETTEXIMAGEPROC,

	/// The function pointer to `glGetTexParameterfv()`
	pub gettexparameterfv: PFNGLGETTEXPARAMETERFVPROC,

	/// The function pointer to `glGetTexParameteriv()`
	pub gettexparameteriv: PFNGLGETTEXPARAMETERIVPROC,

	/// The function pointer to `glGetTexLevelParameterfv()`
	pub gettexlevelparameterfv: PFNGLGETTEXLEVELPARAMETERFVPROC,

	/// The function pointer to `glGetTexLevelParameteriv()`
	pub gettexlevelparameteriv: PFNGLGETTEXLEVELPARAMETERIVPROC,

	/// The function pointer to `glIsEnabled()`
	pub isenabled: PFNGLISENABLEDPROC,

	/// The function pointer to `glDepthRange()`
	pub depthrange: PFNGLDEPTHRANGEPROC,

	/// The function pointer to `glViewport()`
	pub viewport: PFNGLVIEWPORTPROC,
}

impl GL_1_0 for Version10 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCullFace.xhtml>
	#[inline(always)]
	fn glCullFace(&self, mode: GLenum) -> Result<()> {
		let ret = process_catch("glCullFace", catch_unwind(||(self.cullface)(mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCullFace", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFrontFace.xhtml>
	#[inline(always)]
	fn glFrontFace(&self, mode: GLenum) -> Result<()> {
		let ret = process_catch("glFrontFace", catch_unwind(||(self.frontface)(mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFrontFace", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glHint.xhtml>
	#[inline(always)]
	fn glHint(&self, target: GLenum, mode: GLenum) -> Result<()> {
		let ret = process_catch("glHint", catch_unwind(||(self.hint)(target, mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glHint", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLineWidth.xhtml>
	#[inline(always)]
	fn glLineWidth(&self, width: GLfloat) -> Result<()> {
		let ret = process_catch("glLineWidth", catch_unwind(||(self.linewidth)(width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLineWidth", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPointSize.xhtml>
	#[inline(always)]
	fn glPointSize(&self, size: GLfloat) -> Result<()> {
		let ret = process_catch("glPointSize", catch_unwind(||(self.pointsize)(size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointSize", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPolygonMode.xhtml>
	#[inline(always)]
	fn glPolygonMode(&self, face: GLenum, mode: GLenum) -> Result<()> {
		let ret = process_catch("glPolygonMode", catch_unwind(||(self.polygonmode)(face, mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPolygonMode", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glScissor.xhtml>
	#[inline(always)]
	fn glScissor(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glScissor", catch_unwind(||(self.scissor)(x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glScissor", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameterf.xhtml>
	#[inline(always)]
	fn glTexParameterf(&self, target: GLenum, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glTexParameterf", catch_unwind(||(self.texparameterf)(target, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameterf", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameterfv.xhtml>
	#[inline(always)]
	fn glTexParameterfv(&self, target: GLenum, pname: GLenum, params: *const GLfloat) -> Result<()> {
		let ret = process_catch("glTexParameterfv", catch_unwind(||(self.texparameterfv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameteri.xhtml>
	#[inline(always)]
	fn glTexParameteri(&self, target: GLenum, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glTexParameteri", catch_unwind(||(self.texparameteri)(target, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameteri", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameteriv.xhtml>
	#[inline(always)]
	fn glTexParameteriv(&self, target: GLenum, pname: GLenum, params: *const GLint) -> Result<()> {
		let ret = process_catch("glTexParameteriv", catch_unwind(||(self.texparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexImage1D.xhtml>
	#[inline(always)]
	fn glTexImage1D(&self, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexImage1D", catch_unwind(||(self.teximage1d)(target, level, internalformat, width, border, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml>
	#[inline(always)]
	fn glTexImage2D(&self, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexImage2D", catch_unwind(||(self.teximage2d)(target, level, internalformat, width, height, border, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawBuffer.xhtml>
	#[inline(always)]
	fn glDrawBuffer(&self, buf: GLenum) -> Result<()> {
		let ret = process_catch("glDrawBuffer", catch_unwind(||(self.drawbuffer)(buf)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClear.xhtml>
	#[inline(always)]
	fn glClear(&self, mask: GLbitfield) -> Result<()> {
		let ret = process_catch("glClear", catch_unwind(||(self.clear)(mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClear", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearColor.xhtml>
	#[inline(always)]
	fn glClearColor(&self, red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) -> Result<()> {
		let ret = process_catch("glClearColor", catch_unwind(||(self.clearcolor)(red, green, blue, alpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearColor", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearStencil.xhtml>
	#[inline(always)]
	fn glClearStencil(&self, s: GLint) -> Result<()> {
		let ret = process_catch("glClearStencil", catch_unwind(||(self.clearstencil)(s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearStencil", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearDepth.xhtml>
	#[inline(always)]
	fn glClearDepth(&self, depth: GLdouble) -> Result<()> {
		let ret = process_catch("glClearDepth", catch_unwind(||(self.cleardepth)(depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearDepth", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilMask.xhtml>
	#[inline(always)]
	fn glStencilMask(&self, mask: GLuint) -> Result<()> {
		let ret = process_catch("glStencilMask", catch_unwind(||(self.stencilmask)(mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilMask", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glColorMask.xhtml>
	#[inline(always)]
	fn glColorMask(&self, red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean) -> Result<()> {
		let ret = process_catch("glColorMask", catch_unwind(||(self.colormask)(red, green, blue, alpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorMask", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDepthMask.xhtml>
	#[inline(always)]
	fn glDepthMask(&self, flag: GLboolean) -> Result<()> {
		let ret = process_catch("glDepthMask", catch_unwind(||(self.depthmask)(flag)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthMask", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDisable.xhtml>
	#[inline(always)]
	fn glDisable(&self, cap: GLenum) -> Result<()> {
		let ret = process_catch("glDisable", catch_unwind(||(self.disable)(cap)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDisable", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEnable.xhtml>
	#[inline(always)]
	fn glEnable(&self, cap: GLenum) -> Result<()> {
		let ret = process_catch("glEnable", catch_unwind(||(self.enable)(cap)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEnable", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFinish.xhtml>
	#[inline(always)]
	fn glFinish(&self) -> Result<()> {
		let ret = process_catch("glFinish", catch_unwind(||(self.finish)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFinish", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFlush.xhtml>
	#[inline(always)]
	fn glFlush(&self) -> Result<()> {
		let ret = process_catch("glFlush", catch_unwind(||(self.flush)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFlush", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml>
	#[inline(always)]
	fn glBlendFunc(&self, sfactor: GLenum, dfactor: GLenum) -> Result<()> {
		let ret = process_catch("glBlendFunc", catch_unwind(||(self.blendfunc)(sfactor, dfactor)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendFunc", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLogicOp.xhtml>
	#[inline(always)]
	fn glLogicOp(&self, opcode: GLenum) -> Result<()> {
		let ret = process_catch("glLogicOp", catch_unwind(||(self.logicop)(opcode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLogicOp", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilFunc.xhtml>
	#[inline(always)]
	fn glStencilFunc(&self, func: GLenum, ref_: GLint, mask: GLuint) -> Result<()> {
		let ret = process_catch("glStencilFunc", catch_unwind(||(self.stencilfunc)(func, ref_, mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilFunc", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilOp.xhtml>
	#[inline(always)]
	fn glStencilOp(&self, fail: GLenum, zfail: GLenum, zpass: GLenum) -> Result<()> {
		let ret = process_catch("glStencilOp", catch_unwind(||(self.stencilop)(fail, zfail, zpass)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilOp", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDepthFunc.xhtml>
	#[inline(always)]
	fn glDepthFunc(&self, func: GLenum) -> Result<()> {
		let ret = process_catch("glDepthFunc", catch_unwind(||(self.depthfunc)(func)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthFunc", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPixelStoref.xhtml>
	#[inline(always)]
	fn glPixelStoref(&self, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glPixelStoref", catch_unwind(||(self.pixelstoref)(pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPixelStoref", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPixelStorei.xhtml>
	#[inline(always)]
	fn glPixelStorei(&self, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glPixelStorei", catch_unwind(||(self.pixelstorei)(pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPixelStorei", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glReadBuffer.xhtml>
	#[inline(always)]
	fn glReadBuffer(&self, src: GLenum) -> Result<()> {
		let ret = process_catch("glReadBuffer", catch_unwind(||(self.readbuffer)(src)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glReadBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glReadPixels.xhtml>
	#[inline(always)]
	fn glReadPixels(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glReadPixels", catch_unwind(||(self.readpixels)(x, y, width, height, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glReadPixels", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetBooleanv.xhtml>
	#[inline(always)]
	fn glGetBooleanv(&self, pname: GLenum, data: *mut GLboolean) -> Result<()> {
		let ret = process_catch("glGetBooleanv", catch_unwind(||(self.getbooleanv)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBooleanv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetDoublev.xhtml>
	#[inline(always)]
	fn glGetDoublev(&self, pname: GLenum, data: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetDoublev", catch_unwind(||(self.getdoublev)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetDoublev", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetFloatv.xhtml>
	#[inline(always)]
	fn glGetFloatv(&self, pname: GLenum, data: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetFloatv", catch_unwind(||(self.getfloatv)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFloatv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetIntegerv.xhtml>
	#[inline(always)]
	fn glGetIntegerv(&self, pname: GLenum, data: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetIntegerv", catch_unwind(||(self.getintegerv)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetIntegerv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetString.xhtml>
	#[inline(always)]
	fn glGetString(&self, name: GLenum) -> Result<&'static str> {
		let ret = process_catch("glGetString", catch_unwind(||unsafe{CStr::from_ptr((self.getstring)(name) as *const i8)}.to_str().unwrap()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetString", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml>
	#[inline(always)]
	fn glGetTexImage(&self, target: GLenum, level: GLint, format: GLenum, type_: GLenum, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetTexImage", catch_unwind(||(self.getteximage)(target, level, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexParameterfv.xhtml>
	#[inline(always)]
	fn glGetTexParameterfv(&self, target: GLenum, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetTexParameterfv", catch_unwind(||(self.gettexparameterfv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexParameteriv.xhtml>
	#[inline(always)]
	fn glGetTexParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTexParameteriv", catch_unwind(||(self.gettexparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexLevelParameterfv.xhtml>
	#[inline(always)]
	fn glGetTexLevelParameterfv(&self, target: GLenum, level: GLint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetTexLevelParameterfv", catch_unwind(||(self.gettexlevelparameterfv)(target, level, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexLevelParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexLevelParameteriv.xhtml>
	#[inline(always)]
	fn glGetTexLevelParameteriv(&self, target: GLenum, level: GLint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTexLevelParameteriv", catch_unwind(||(self.gettexlevelparameteriv)(target, level, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexLevelParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsEnabled.xhtml>
	#[inline(always)]
	fn glIsEnabled(&self, cap: GLenum) -> Result<GLboolean> {
		let ret = process_catch("glIsEnabled", catch_unwind(||(self.isenabled)(cap)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsEnabled", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDepthRange.xhtml>
	#[inline(always)]
	fn glDepthRange(&self, n: GLdouble, f: GLdouble) -> Result<()> {
		let ret = process_catch("glDepthRange", catch_unwind(||(self.depthrange)(n, f)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glViewport.xhtml>
	#[inline(always)]
	fn glViewport(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glViewport", catch_unwind(||(self.viewport)(x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glViewport", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn get_version(&self) -> (&'static str, u32, u32, u32) {
		(self.spec, self.major_version, self.minor_version, self.release_version)
	}
	#[inline(always)]
	fn get_vendor(&self) -> &'static str {
		self.vendor
	}
	#[inline(always)]
	fn get_renderer(&self) -> &'static str {
		self.renderer
	}
	#[inline(always)]
	fn get_versionstr(&self) -> &'static str {
		self.version
	}
}

impl Version10 {
	pub fn new(mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Result<Self> {
		let mut ret = Self {
			available: true,
			spec: "unknown",
			major_version: 0,
			minor_version: 0,
			release_version: 0,
			vendor: "unknown",
			renderer: "unknown",
			version: "unknown",
			cullface: {let proc = get_proc_address("glCullFace"); if proc == null() {dummy_pfnglcullfaceproc} else {unsafe{transmute(proc)}}},
			frontface: {let proc = get_proc_address("glFrontFace"); if proc == null() {dummy_pfnglfrontfaceproc} else {unsafe{transmute(proc)}}},
			hint: {let proc = get_proc_address("glHint"); if proc == null() {dummy_pfnglhintproc} else {unsafe{transmute(proc)}}},
			linewidth: {let proc = get_proc_address("glLineWidth"); if proc == null() {dummy_pfngllinewidthproc} else {unsafe{transmute(proc)}}},
			pointsize: {let proc = get_proc_address("glPointSize"); if proc == null() {dummy_pfnglpointsizeproc} else {unsafe{transmute(proc)}}},
			polygonmode: {let proc = get_proc_address("glPolygonMode"); if proc == null() {dummy_pfnglpolygonmodeproc} else {unsafe{transmute(proc)}}},
			scissor: {let proc = get_proc_address("glScissor"); if proc == null() {dummy_pfnglscissorproc} else {unsafe{transmute(proc)}}},
			texparameterf: {let proc = get_proc_address("glTexParameterf"); if proc == null() {dummy_pfngltexparameterfproc} else {unsafe{transmute(proc)}}},
			texparameterfv: {let proc = get_proc_address("glTexParameterfv"); if proc == null() {dummy_pfngltexparameterfvproc} else {unsafe{transmute(proc)}}},
			texparameteri: {let proc = get_proc_address("glTexParameteri"); if proc == null() {dummy_pfngltexparameteriproc} else {unsafe{transmute(proc)}}},
			texparameteriv: {let proc = get_proc_address("glTexParameteriv"); if proc == null() {dummy_pfngltexparameterivproc} else {unsafe{transmute(proc)}}},
			teximage1d: {let proc = get_proc_address("glTexImage1D"); if proc == null() {dummy_pfnglteximage1dproc} else {unsafe{transmute(proc)}}},
			teximage2d: {let proc = get_proc_address("glTexImage2D"); if proc == null() {dummy_pfnglteximage2dproc} else {unsafe{transmute(proc)}}},
			drawbuffer: {let proc = get_proc_address("glDrawBuffer"); if proc == null() {dummy_pfngldrawbufferproc} else {unsafe{transmute(proc)}}},
			clear: {let proc = get_proc_address("glClear"); if proc == null() {dummy_pfnglclearproc} else {unsafe{transmute(proc)}}},
			clearcolor: {let proc = get_proc_address("glClearColor"); if proc == null() {dummy_pfnglclearcolorproc} else {unsafe{transmute(proc)}}},
			clearstencil: {let proc = get_proc_address("glClearStencil"); if proc == null() {dummy_pfnglclearstencilproc} else {unsafe{transmute(proc)}}},
			cleardepth: {let proc = get_proc_address("glClearDepth"); if proc == null() {dummy_pfnglcleardepthproc} else {unsafe{transmute(proc)}}},
			stencilmask: {let proc = get_proc_address("glStencilMask"); if proc == null() {dummy_pfnglstencilmaskproc} else {unsafe{transmute(proc)}}},
			colormask: {let proc = get_proc_address("glColorMask"); if proc == null() {dummy_pfnglcolormaskproc} else {unsafe{transmute(proc)}}},
			depthmask: {let proc = get_proc_address("glDepthMask"); if proc == null() {dummy_pfngldepthmaskproc} else {unsafe{transmute(proc)}}},
			disable: {let proc = get_proc_address("glDisable"); if proc == null() {dummy_pfngldisableproc} else {unsafe{transmute(proc)}}},
			enable: {let proc = get_proc_address("glEnable"); if proc == null() {dummy_pfnglenableproc} else {unsafe{transmute(proc)}}},
			finish: {let proc = get_proc_address("glFinish"); if proc == null() {dummy_pfnglfinishproc} else {unsafe{transmute(proc)}}},
			flush: {let proc = get_proc_address("glFlush"); if proc == null() {dummy_pfnglflushproc} else {unsafe{transmute(proc)}}},
			blendfunc: {let proc = get_proc_address("glBlendFunc"); if proc == null() {dummy_pfnglblendfuncproc} else {unsafe{transmute(proc)}}},
			logicop: {let proc = get_proc_address("glLogicOp"); if proc == null() {dummy_pfngllogicopproc} else {unsafe{transmute(proc)}}},
			stencilfunc: {let proc = get_proc_address("glStencilFunc"); if proc == null() {dummy_pfnglstencilfuncproc} else {unsafe{transmute(proc)}}},
			stencilop: {let proc = get_proc_address("glStencilOp"); if proc == null() {dummy_pfnglstencilopproc} else {unsafe{transmute(proc)}}},
			depthfunc: {let proc = get_proc_address("glDepthFunc"); if proc == null() {dummy_pfngldepthfuncproc} else {unsafe{transmute(proc)}}},
			pixelstoref: {let proc = get_proc_address("glPixelStoref"); if proc == null() {dummy_pfnglpixelstorefproc} else {unsafe{transmute(proc)}}},
			pixelstorei: {let proc = get_proc_address("glPixelStorei"); if proc == null() {dummy_pfnglpixelstoreiproc} else {unsafe{transmute(proc)}}},
			readbuffer: {let proc = get_proc_address("glReadBuffer"); if proc == null() {dummy_pfnglreadbufferproc} else {unsafe{transmute(proc)}}},
			readpixels: {let proc = get_proc_address("glReadPixels"); if proc == null() {dummy_pfnglreadpixelsproc} else {unsafe{transmute(proc)}}},
			getbooleanv: {let proc = get_proc_address("glGetBooleanv"); if proc == null() {dummy_pfnglgetbooleanvproc} else {unsafe{transmute(proc)}}},
			getdoublev: {let proc = get_proc_address("glGetDoublev"); if proc == null() {dummy_pfnglgetdoublevproc} else {unsafe{transmute(proc)}}},
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			getfloatv: {let proc = get_proc_address("glGetFloatv"); if proc == null() {dummy_pfnglgetfloatvproc} else {unsafe{transmute(proc)}}},
			getintegerv: {let proc = get_proc_address("glGetIntegerv"); if proc == null() {dummy_pfnglgetintegervproc} else {unsafe{transmute(proc)}}},
			getstring: {let proc = get_proc_address("glGetString"); if proc == null() {dummy_pfnglgetstringproc} else {unsafe{transmute(proc)}}},
			getteximage: {let proc = get_proc_address("glGetTexImage"); if proc == null() {dummy_pfnglgetteximageproc} else {unsafe{transmute(proc)}}},
			gettexparameterfv: {let proc = get_proc_address("glGetTexParameterfv"); if proc == null() {dummy_pfnglgettexparameterfvproc} else {unsafe{transmute(proc)}}},
			gettexparameteriv: {let proc = get_proc_address("glGetTexParameteriv"); if proc == null() {dummy_pfnglgettexparameterivproc} else {unsafe{transmute(proc)}}},
			gettexlevelparameterfv: {let proc = get_proc_address("glGetTexLevelParameterfv"); if proc == null() {dummy_pfnglgettexlevelparameterfvproc} else {unsafe{transmute(proc)}}},
			gettexlevelparameteriv: {let proc = get_proc_address("glGetTexLevelParameteriv"); if proc == null() {dummy_pfnglgettexlevelparameterivproc} else {unsafe{transmute(proc)}}},
			isenabled: {let proc = get_proc_address("glIsEnabled"); if proc == null() {dummy_pfnglisenabledproc} else {unsafe{transmute(proc)}}},
			depthrange: {let proc = get_proc_address("glDepthRange"); if proc == null() {dummy_pfngldepthrangeproc} else {unsafe{transmute(proc)}}},
			viewport: {let proc = get_proc_address("glViewport"); if proc == null() {dummy_pfnglviewportproc} else {unsafe{transmute(proc)}}},
		};
		ret.fetch_version()?;
		Ok(ret)
	}
	#[inline(always)]
	fn fetch_version(&mut self) -> Result<()> {
		self.vendor = self.glGetString(GL_VENDOR)?;
		self.renderer = self.glGetString(GL_RENDERER)?;
		self.version = self.glGetString(GL_VERSION)?;
		self.spec = "OpenGL";
		let mut verstr = self.version;
		if verstr.starts_with("OpenGL ES ") {
			verstr = &verstr["OpenGL ES ".len()..];
			self.spec = "OpenGL ES ";
		} else if let Some((left, right)) = verstr.split_once(' ') {
			verstr = left;
			self.spec = right;
		}
		let mut v: Vec<&str> = verstr.split('.').collect();
		v.resize(3, "0");
		v = v.into_iter().map(|x|if x == "" {"0"} else {x}).collect();
		self.major_version = v[0].parse().unwrap();
		self.minor_version = v[1].parse().unwrap();
		self.release_version = v[2].parse().unwrap();
		Ok(())
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version10 {
	fn default() -> Self {
		Self {
			available: false,
			spec: "unknown",
			major_version: 0,
			minor_version: 0,
			release_version: 0,
			vendor: "unknown",
			renderer: "unknown",
			version: "unknown",
			cullface: dummy_pfnglcullfaceproc,
			frontface: dummy_pfnglfrontfaceproc,
			hint: dummy_pfnglhintproc,
			linewidth: dummy_pfngllinewidthproc,
			pointsize: dummy_pfnglpointsizeproc,
			polygonmode: dummy_pfnglpolygonmodeproc,
			scissor: dummy_pfnglscissorproc,
			texparameterf: dummy_pfngltexparameterfproc,
			texparameterfv: dummy_pfngltexparameterfvproc,
			texparameteri: dummy_pfngltexparameteriproc,
			texparameteriv: dummy_pfngltexparameterivproc,
			teximage1d: dummy_pfnglteximage1dproc,
			teximage2d: dummy_pfnglteximage2dproc,
			drawbuffer: dummy_pfngldrawbufferproc,
			clear: dummy_pfnglclearproc,
			clearcolor: dummy_pfnglclearcolorproc,
			clearstencil: dummy_pfnglclearstencilproc,
			cleardepth: dummy_pfnglcleardepthproc,
			stencilmask: dummy_pfnglstencilmaskproc,
			colormask: dummy_pfnglcolormaskproc,
			depthmask: dummy_pfngldepthmaskproc,
			disable: dummy_pfngldisableproc,
			enable: dummy_pfnglenableproc,
			finish: dummy_pfnglfinishproc,
			flush: dummy_pfnglflushproc,
			blendfunc: dummy_pfnglblendfuncproc,
			logicop: dummy_pfngllogicopproc,
			stencilfunc: dummy_pfnglstencilfuncproc,
			stencilop: dummy_pfnglstencilopproc,
			depthfunc: dummy_pfngldepthfuncproc,
			pixelstoref: dummy_pfnglpixelstorefproc,
			pixelstorei: dummy_pfnglpixelstoreiproc,
			readbuffer: dummy_pfnglreadbufferproc,
			readpixels: dummy_pfnglreadpixelsproc,
			getbooleanv: dummy_pfnglgetbooleanvproc,
			getdoublev: dummy_pfnglgetdoublevproc,
			geterror: dummy_pfnglgeterrorproc,
			getfloatv: dummy_pfnglgetfloatvproc,
			getintegerv: dummy_pfnglgetintegervproc,
			getstring: dummy_pfnglgetstringproc,
			getteximage: dummy_pfnglgetteximageproc,
			gettexparameterfv: dummy_pfnglgettexparameterfvproc,
			gettexparameteriv: dummy_pfnglgettexparameterivproc,
			gettexlevelparameterfv: dummy_pfnglgettexlevelparameterfvproc,
			gettexlevelparameteriv: dummy_pfnglgettexlevelparameterivproc,
			isenabled: dummy_pfnglisenabledproc,
			depthrange: dummy_pfngldepthrangeproc,
			viewport: dummy_pfnglviewportproc,
		}
	}
}
impl Debug for Version10 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version10")
			.field("available", &self.available)
			.field("spec", &self.spec)
			.field("major_version", &self.major_version)
			.field("minor_version", &self.minor_version)
			.field("release_version", &self.release_version)
			.field("vendor", &self.vendor)
			.field("renderer", &self.renderer)
			.field("version", &self.version)
			.field("cullface", unsafe{if transmute::<_, *const c_void>(self.cullface) == (dummy_pfnglcullfaceproc as *const c_void) {&null::<PFNGLCULLFACEPROC>()} else {&self.cullface}})
			.field("frontface", unsafe{if transmute::<_, *const c_void>(self.frontface) == (dummy_pfnglfrontfaceproc as *const c_void) {&null::<PFNGLFRONTFACEPROC>()} else {&self.frontface}})
			.field("hint", unsafe{if transmute::<_, *const c_void>(self.hint) == (dummy_pfnglhintproc as *const c_void) {&null::<PFNGLHINTPROC>()} else {&self.hint}})
			.field("linewidth", unsafe{if transmute::<_, *const c_void>(self.linewidth) == (dummy_pfngllinewidthproc as *const c_void) {&null::<PFNGLLINEWIDTHPROC>()} else {&self.linewidth}})
			.field("pointsize", unsafe{if transmute::<_, *const c_void>(self.pointsize) == (dummy_pfnglpointsizeproc as *const c_void) {&null::<PFNGLPOINTSIZEPROC>()} else {&self.pointsize}})
			.field("polygonmode", unsafe{if transmute::<_, *const c_void>(self.polygonmode) == (dummy_pfnglpolygonmodeproc as *const c_void) {&null::<PFNGLPOLYGONMODEPROC>()} else {&self.polygonmode}})
			.field("scissor", unsafe{if transmute::<_, *const c_void>(self.scissor) == (dummy_pfnglscissorproc as *const c_void) {&null::<PFNGLSCISSORPROC>()} else {&self.scissor}})
			.field("texparameterf", unsafe{if transmute::<_, *const c_void>(self.texparameterf) == (dummy_pfngltexparameterfproc as *const c_void) {&null::<PFNGLTEXPARAMETERFPROC>()} else {&self.texparameterf}})
			.field("texparameterfv", unsafe{if transmute::<_, *const c_void>(self.texparameterfv) == (dummy_pfngltexparameterfvproc as *const c_void) {&null::<PFNGLTEXPARAMETERFVPROC>()} else {&self.texparameterfv}})
			.field("texparameteri", unsafe{if transmute::<_, *const c_void>(self.texparameteri) == (dummy_pfngltexparameteriproc as *const c_void) {&null::<PFNGLTEXPARAMETERIPROC>()} else {&self.texparameteri}})
			.field("texparameteriv", unsafe{if transmute::<_, *const c_void>(self.texparameteriv) == (dummy_pfngltexparameterivproc as *const c_void) {&null::<PFNGLTEXPARAMETERIVPROC>()} else {&self.texparameteriv}})
			.field("teximage1d", unsafe{if transmute::<_, *const c_void>(self.teximage1d) == (dummy_pfnglteximage1dproc as *const c_void) {&null::<PFNGLTEXIMAGE1DPROC>()} else {&self.teximage1d}})
			.field("teximage2d", unsafe{if transmute::<_, *const c_void>(self.teximage2d) == (dummy_pfnglteximage2dproc as *const c_void) {&null::<PFNGLTEXIMAGE2DPROC>()} else {&self.teximage2d}})
			.field("drawbuffer", unsafe{if transmute::<_, *const c_void>(self.drawbuffer) == (dummy_pfngldrawbufferproc as *const c_void) {&null::<PFNGLDRAWBUFFERPROC>()} else {&self.drawbuffer}})
			.field("clear", unsafe{if transmute::<_, *const c_void>(self.clear) == (dummy_pfnglclearproc as *const c_void) {&null::<PFNGLCLEARPROC>()} else {&self.clear}})
			.field("clearcolor", unsafe{if transmute::<_, *const c_void>(self.clearcolor) == (dummy_pfnglclearcolorproc as *const c_void) {&null::<PFNGLCLEARCOLORPROC>()} else {&self.clearcolor}})
			.field("clearstencil", unsafe{if transmute::<_, *const c_void>(self.clearstencil) == (dummy_pfnglclearstencilproc as *const c_void) {&null::<PFNGLCLEARSTENCILPROC>()} else {&self.clearstencil}})
			.field("cleardepth", unsafe{if transmute::<_, *const c_void>(self.cleardepth) == (dummy_pfnglcleardepthproc as *const c_void) {&null::<PFNGLCLEARDEPTHPROC>()} else {&self.cleardepth}})
			.field("stencilmask", unsafe{if transmute::<_, *const c_void>(self.stencilmask) == (dummy_pfnglstencilmaskproc as *const c_void) {&null::<PFNGLSTENCILMASKPROC>()} else {&self.stencilmask}})
			.field("colormask", unsafe{if transmute::<_, *const c_void>(self.colormask) == (dummy_pfnglcolormaskproc as *const c_void) {&null::<PFNGLCOLORMASKPROC>()} else {&self.colormask}})
			.field("depthmask", unsafe{if transmute::<_, *const c_void>(self.depthmask) == (dummy_pfngldepthmaskproc as *const c_void) {&null::<PFNGLDEPTHMASKPROC>()} else {&self.depthmask}})
			.field("disable", unsafe{if transmute::<_, *const c_void>(self.disable) == (dummy_pfngldisableproc as *const c_void) {&null::<PFNGLDISABLEPROC>()} else {&self.disable}})
			.field("enable", unsafe{if transmute::<_, *const c_void>(self.enable) == (dummy_pfnglenableproc as *const c_void) {&null::<PFNGLENABLEPROC>()} else {&self.enable}})
			.field("finish", unsafe{if transmute::<_, *const c_void>(self.finish) == (dummy_pfnglfinishproc as *const c_void) {&null::<PFNGLFINISHPROC>()} else {&self.finish}})
			.field("flush", unsafe{if transmute::<_, *const c_void>(self.flush) == (dummy_pfnglflushproc as *const c_void) {&null::<PFNGLFLUSHPROC>()} else {&self.flush}})
			.field("blendfunc", unsafe{if transmute::<_, *const c_void>(self.blendfunc) == (dummy_pfnglblendfuncproc as *const c_void) {&null::<PFNGLBLENDFUNCPROC>()} else {&self.blendfunc}})
			.field("logicop", unsafe{if transmute::<_, *const c_void>(self.logicop) == (dummy_pfngllogicopproc as *const c_void) {&null::<PFNGLLOGICOPPROC>()} else {&self.logicop}})
			.field("stencilfunc", unsafe{if transmute::<_, *const c_void>(self.stencilfunc) == (dummy_pfnglstencilfuncproc as *const c_void) {&null::<PFNGLSTENCILFUNCPROC>()} else {&self.stencilfunc}})
			.field("stencilop", unsafe{if transmute::<_, *const c_void>(self.stencilop) == (dummy_pfnglstencilopproc as *const c_void) {&null::<PFNGLSTENCILOPPROC>()} else {&self.stencilop}})
			.field("depthfunc", unsafe{if transmute::<_, *const c_void>(self.depthfunc) == (dummy_pfngldepthfuncproc as *const c_void) {&null::<PFNGLDEPTHFUNCPROC>()} else {&self.depthfunc}})
			.field("pixelstoref", unsafe{if transmute::<_, *const c_void>(self.pixelstoref) == (dummy_pfnglpixelstorefproc as *const c_void) {&null::<PFNGLPIXELSTOREFPROC>()} else {&self.pixelstoref}})
			.field("pixelstorei", unsafe{if transmute::<_, *const c_void>(self.pixelstorei) == (dummy_pfnglpixelstoreiproc as *const c_void) {&null::<PFNGLPIXELSTOREIPROC>()} else {&self.pixelstorei}})
			.field("readbuffer", unsafe{if transmute::<_, *const c_void>(self.readbuffer) == (dummy_pfnglreadbufferproc as *const c_void) {&null::<PFNGLREADBUFFERPROC>()} else {&self.readbuffer}})
			.field("readpixels", unsafe{if transmute::<_, *const c_void>(self.readpixels) == (dummy_pfnglreadpixelsproc as *const c_void) {&null::<PFNGLREADPIXELSPROC>()} else {&self.readpixels}})
			.field("getbooleanv", unsafe{if transmute::<_, *const c_void>(self.getbooleanv) == (dummy_pfnglgetbooleanvproc as *const c_void) {&null::<PFNGLGETBOOLEANVPROC>()} else {&self.getbooleanv}})
			.field("getdoublev", unsafe{if transmute::<_, *const c_void>(self.getdoublev) == (dummy_pfnglgetdoublevproc as *const c_void) {&null::<PFNGLGETDOUBLEVPROC>()} else {&self.getdoublev}})
			.field("geterror", unsafe{if transmute::<_, *const c_void>(self.geterror) == (dummy_pfnglgeterrorproc as *const c_void) {&null::<PFNGLGETERRORPROC>()} else {&self.geterror}})
			.field("getfloatv", unsafe{if transmute::<_, *const c_void>(self.getfloatv) == (dummy_pfnglgetfloatvproc as *const c_void) {&null::<PFNGLGETFLOATVPROC>()} else {&self.getfloatv}})
			.field("getintegerv", unsafe{if transmute::<_, *const c_void>(self.getintegerv) == (dummy_pfnglgetintegervproc as *const c_void) {&null::<PFNGLGETINTEGERVPROC>()} else {&self.getintegerv}})
			.field("getstring", unsafe{if transmute::<_, *const c_void>(self.getstring) == (dummy_pfnglgetstringproc as *const c_void) {&null::<PFNGLGETSTRINGPROC>()} else {&self.getstring}})
			.field("getteximage", unsafe{if transmute::<_, *const c_void>(self.getteximage) == (dummy_pfnglgetteximageproc as *const c_void) {&null::<PFNGLGETTEXIMAGEPROC>()} else {&self.getteximage}})
			.field("gettexparameterfv", unsafe{if transmute::<_, *const c_void>(self.gettexparameterfv) == (dummy_pfnglgettexparameterfvproc as *const c_void) {&null::<PFNGLGETTEXPARAMETERFVPROC>()} else {&self.gettexparameterfv}})
			.field("gettexparameteriv", unsafe{if transmute::<_, *const c_void>(self.gettexparameteriv) == (dummy_pfnglgettexparameterivproc as *const c_void) {&null::<PFNGLGETTEXPARAMETERIVPROC>()} else {&self.gettexparameteriv}})
			.field("gettexlevelparameterfv", unsafe{if transmute::<_, *const c_void>(self.gettexlevelparameterfv) == (dummy_pfnglgettexlevelparameterfvproc as *const c_void) {&null::<PFNGLGETTEXLEVELPARAMETERFVPROC>()} else {&self.gettexlevelparameterfv}})
			.field("gettexlevelparameteriv", unsafe{if transmute::<_, *const c_void>(self.gettexlevelparameteriv) == (dummy_pfnglgettexlevelparameterivproc as *const c_void) {&null::<PFNGLGETTEXLEVELPARAMETERIVPROC>()} else {&self.gettexlevelparameteriv}})
			.field("isenabled", unsafe{if transmute::<_, *const c_void>(self.isenabled) == (dummy_pfnglisenabledproc as *const c_void) {&null::<PFNGLISENABLEDPROC>()} else {&self.isenabled}})
			.field("depthrange", unsafe{if transmute::<_, *const c_void>(self.depthrange) == (dummy_pfngldepthrangeproc as *const c_void) {&null::<PFNGLDEPTHRANGEPROC>()} else {&self.depthrange}})
			.field("viewport", unsafe{if transmute::<_, *const c_void>(self.viewport) == (dummy_pfnglviewportproc as *const c_void) {&null::<PFNGLVIEWPORTPROC>()} else {&self.viewport}})
			.finish()
		} else {
			f.debug_struct("Version10")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

/// Alias to `khronos_float_t`
pub type GLclampf = khronos_float_t;

/// Alias to `f64`
pub type GLclampd = f64;

/// The prototype to the OpenGL function `DrawArrays`
type PFNGLDRAWARRAYSPROC = extern "system" fn(GLenum, GLint, GLsizei);

/// The prototype to the OpenGL function `DrawElements`
type PFNGLDRAWELEMENTSPROC = extern "system" fn(GLenum, GLsizei, GLenum, *const c_void);

/// The prototype to the OpenGL function `GetPointerv`
type PFNGLGETPOINTERVPROC = extern "system" fn(GLenum, *mut *mut c_void);

/// The prototype to the OpenGL function `PolygonOffset`
type PFNGLPOLYGONOFFSETPROC = extern "system" fn(GLfloat, GLfloat);

/// The prototype to the OpenGL function `CopyTexImage1D`
type PFNGLCOPYTEXIMAGE1DPROC = extern "system" fn(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);

/// The prototype to the OpenGL function `CopyTexImage2D`
type PFNGLCOPYTEXIMAGE2DPROC = extern "system" fn(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);

/// The prototype to the OpenGL function `CopyTexSubImage1D`
type PFNGLCOPYTEXSUBIMAGE1DPROC = extern "system" fn(GLenum, GLint, GLint, GLint, GLint, GLsizei);

/// The prototype to the OpenGL function `CopyTexSubImage2D`
type PFNGLCOPYTEXSUBIMAGE2DPROC = extern "system" fn(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);

/// The prototype to the OpenGL function `TexSubImage1D`
type PFNGLTEXSUBIMAGE1DPROC = extern "system" fn(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, *const c_void);

/// The prototype to the OpenGL function `TexSubImage2D`
type PFNGLTEXSUBIMAGE2DPROC = extern "system" fn(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, *const c_void);

/// The prototype to the OpenGL function `BindTexture`
type PFNGLBINDTEXTUREPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `DeleteTextures`
type PFNGLDELETETEXTURESPROC = extern "system" fn(GLsizei, *const GLuint);

/// The prototype to the OpenGL function `GenTextures`
type PFNGLGENTEXTURESPROC = extern "system" fn(GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `IsTexture`
type PFNGLISTEXTUREPROC = extern "system" fn(GLuint) -> GLboolean;

/// The dummy function of `DrawArrays()`
extern "system" fn dummy_pfngldrawarraysproc (_: GLenum, _: GLint, _: GLsizei) {
	panic!("OpenGL function pointer `glDrawArrays()` is null.")
}

/// The dummy function of `DrawElements()`
extern "system" fn dummy_pfngldrawelementsproc (_: GLenum, _: GLsizei, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glDrawElements()` is null.")
}

/// The dummy function of `GetPointerv()`
extern "system" fn dummy_pfnglgetpointervproc (_: GLenum, _: *mut *mut c_void) {
	panic!("OpenGL function pointer `glGetPointerv()` is null.")
}

/// The dummy function of `PolygonOffset()`
extern "system" fn dummy_pfnglpolygonoffsetproc (_: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glPolygonOffset()` is null.")
}

/// The dummy function of `CopyTexImage1D()`
extern "system" fn dummy_pfnglcopyteximage1dproc (_: GLenum, _: GLint, _: GLenum, _: GLint, _: GLint, _: GLsizei, _: GLint) {
	panic!("OpenGL function pointer `glCopyTexImage1D()` is null.")
}

/// The dummy function of `CopyTexImage2D()`
extern "system" fn dummy_pfnglcopyteximage2dproc (_: GLenum, _: GLint, _: GLenum, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLint) {
	panic!("OpenGL function pointer `glCopyTexImage2D()` is null.")
}

/// The dummy function of `CopyTexSubImage1D()`
extern "system" fn dummy_pfnglcopytexsubimage1dproc (_: GLenum, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei) {
	panic!("OpenGL function pointer `glCopyTexSubImage1D()` is null.")
}

/// The dummy function of `CopyTexSubImage2D()`
extern "system" fn dummy_pfnglcopytexsubimage2dproc (_: GLenum, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glCopyTexSubImage2D()` is null.")
}

/// The dummy function of `TexSubImage1D()`
extern "system" fn dummy_pfngltexsubimage1dproc (_: GLenum, _: GLint, _: GLint, _: GLsizei, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glTexSubImage1D()` is null.")
}

/// The dummy function of `TexSubImage2D()`
extern "system" fn dummy_pfngltexsubimage2dproc (_: GLenum, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glTexSubImage2D()` is null.")
}

/// The dummy function of `BindTexture()`
extern "system" fn dummy_pfnglbindtextureproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glBindTexture()` is null.")
}

/// The dummy function of `DeleteTextures()`
extern "system" fn dummy_pfngldeletetexturesproc (_: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glDeleteTextures()` is null.")
}

/// The dummy function of `GenTextures()`
extern "system" fn dummy_pfnglgentexturesproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGenTextures()` is null.")
}

/// The dummy function of `IsTexture()`
extern "system" fn dummy_pfnglistextureproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsTexture()` is null.")
}
/// Constant value defined from OpenGL 1.1
pub const GL_COLOR_LOGIC_OP: GLenum = 0x0BF2;

/// Constant value defined from OpenGL 1.1
pub const GL_POLYGON_OFFSET_UNITS: GLenum = 0x2A00;

/// Constant value defined from OpenGL 1.1
pub const GL_POLYGON_OFFSET_POINT: GLenum = 0x2A01;

/// Constant value defined from OpenGL 1.1
pub const GL_POLYGON_OFFSET_LINE: GLenum = 0x2A02;

/// Constant value defined from OpenGL 1.1
pub const GL_POLYGON_OFFSET_FILL: GLenum = 0x8037;

/// Constant value defined from OpenGL 1.1
pub const GL_POLYGON_OFFSET_FACTOR: GLenum = 0x8038;

/// Constant value defined from OpenGL 1.1
pub const GL_TEXTURE_BINDING_1D: GLenum = 0x8068;

/// Constant value defined from OpenGL 1.1
pub const GL_TEXTURE_BINDING_2D: GLenum = 0x8069;

/// Constant value defined from OpenGL 1.1
pub const GL_TEXTURE_INTERNAL_FORMAT: GLenum = 0x1003;

/// Constant value defined from OpenGL 1.1
pub const GL_TEXTURE_RED_SIZE: GLenum = 0x805C;

/// Constant value defined from OpenGL 1.1
pub const GL_TEXTURE_GREEN_SIZE: GLenum = 0x805D;

/// Constant value defined from OpenGL 1.1
pub const GL_TEXTURE_BLUE_SIZE: GLenum = 0x805E;

/// Constant value defined from OpenGL 1.1
pub const GL_TEXTURE_ALPHA_SIZE: GLenum = 0x805F;

/// Constant value defined from OpenGL 1.1
pub const GL_DOUBLE: GLenum = 0x140A;

/// Constant value defined from OpenGL 1.1
pub const GL_PROXY_TEXTURE_1D: GLenum = 0x8063;

/// Constant value defined from OpenGL 1.1
pub const GL_PROXY_TEXTURE_2D: GLenum = 0x8064;

/// Constant value defined from OpenGL 1.1
pub const GL_R3_G3_B2: GLenum = 0x2A10;

/// Constant value defined from OpenGL 1.1
pub const GL_RGB4: GLenum = 0x804F;

/// Constant value defined from OpenGL 1.1
pub const GL_RGB5: GLenum = 0x8050;

/// Constant value defined from OpenGL 1.1
pub const GL_RGB8: GLenum = 0x8051;

/// Constant value defined from OpenGL 1.1
pub const GL_RGB10: GLenum = 0x8052;

/// Constant value defined from OpenGL 1.1
pub const GL_RGB12: GLenum = 0x8053;

/// Constant value defined from OpenGL 1.1
pub const GL_RGB16: GLenum = 0x8054;

/// Constant value defined from OpenGL 1.1
pub const GL_RGBA2: GLenum = 0x8055;

/// Constant value defined from OpenGL 1.1
pub const GL_RGBA4: GLenum = 0x8056;

/// Constant value defined from OpenGL 1.1
pub const GL_RGB5_A1: GLenum = 0x8057;

/// Constant value defined from OpenGL 1.1
pub const GL_RGBA8: GLenum = 0x8058;

/// Constant value defined from OpenGL 1.1
pub const GL_RGB10_A2: GLenum = 0x8059;

/// Constant value defined from OpenGL 1.1
pub const GL_RGBA12: GLenum = 0x805A;

/// Constant value defined from OpenGL 1.1
pub const GL_RGBA16: GLenum = 0x805B;

/// Constant value defined from OpenGL 1.1
pub const GL_VERTEX_ARRAY: GLenum = 0x8074;

/// Functions from OpenGL version 1.1
pub trait GL_1_1 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	fn glGetError(&self) -> GLenum;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml>
	fn glDrawArrays(&self, mode: GLenum, first: GLint, count: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElements.xhtml>
	fn glDrawElements(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetPointerv.xhtml>
	fn glGetPointerv(&self, pname: GLenum, params: *mut *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPolygonOffset.xhtml>
	fn glPolygonOffset(&self, factor: GLfloat, units: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTexImage1D.xhtml>
	fn glCopyTexImage1D(&self, target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, border: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTexImage2D.xhtml>
	fn glCopyTexImage2D(&self, target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTexSubImage1D.xhtml>
	fn glCopyTexSubImage1D(&self, target: GLenum, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTexSubImage2D.xhtml>
	fn glCopyTexSubImage2D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexSubImage1D.xhtml>
	fn glTexSubImage1D(&self, target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexSubImage2D.xhtml>
	fn glTexSubImage2D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindTexture.xhtml>
	fn glBindTexture(&self, target: GLenum, texture: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteTextures.xhtml>
	fn glDeleteTextures(&self, n: GLsizei, textures: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenTextures.xhtml>
	fn glGenTextures(&self, n: GLsizei, textures: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsTexture.xhtml>
	fn glIsTexture(&self, texture: GLuint) -> Result<GLboolean>;
}
/// Functions from OpenGL version 1.1
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version11 {
	/// Is OpenGL version 1.1 available
	available: bool,

	/// The function pointer to `glGetError()`
	pub geterror: PFNGLGETERRORPROC,

	/// The function pointer to `glDrawArrays()`
	pub drawarrays: PFNGLDRAWARRAYSPROC,

	/// The function pointer to `glDrawElements()`
	pub drawelements: PFNGLDRAWELEMENTSPROC,

	/// The function pointer to `glGetPointerv()`
	pub getpointerv: PFNGLGETPOINTERVPROC,

	/// The function pointer to `glPolygonOffset()`
	pub polygonoffset: PFNGLPOLYGONOFFSETPROC,

	/// The function pointer to `glCopyTexImage1D()`
	pub copyteximage1d: PFNGLCOPYTEXIMAGE1DPROC,

	/// The function pointer to `glCopyTexImage2D()`
	pub copyteximage2d: PFNGLCOPYTEXIMAGE2DPROC,

	/// The function pointer to `glCopyTexSubImage1D()`
	pub copytexsubimage1d: PFNGLCOPYTEXSUBIMAGE1DPROC,

	/// The function pointer to `glCopyTexSubImage2D()`
	pub copytexsubimage2d: PFNGLCOPYTEXSUBIMAGE2DPROC,

	/// The function pointer to `glTexSubImage1D()`
	pub texsubimage1d: PFNGLTEXSUBIMAGE1DPROC,

	/// The function pointer to `glTexSubImage2D()`
	pub texsubimage2d: PFNGLTEXSUBIMAGE2DPROC,

	/// The function pointer to `glBindTexture()`
	pub bindtexture: PFNGLBINDTEXTUREPROC,

	/// The function pointer to `glDeleteTextures()`
	pub deletetextures: PFNGLDELETETEXTURESPROC,

	/// The function pointer to `glGenTextures()`
	pub gentextures: PFNGLGENTEXTURESPROC,

	/// The function pointer to `glIsTexture()`
	pub istexture: PFNGLISTEXTUREPROC,
}

impl GL_1_1 for Version11 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml>
	#[inline(always)]
	fn glDrawArrays(&self, mode: GLenum, first: GLint, count: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawArrays", catch_unwind(||(self.drawarrays)(mode, first, count)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawArrays", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElements.xhtml>
	#[inline(always)]
	fn glDrawElements(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void) -> Result<()> {
		let ret = process_catch("glDrawElements", catch_unwind(||(self.drawelements)(mode, count, type_, indices)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElements", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetPointerv.xhtml>
	#[inline(always)]
	fn glGetPointerv(&self, pname: GLenum, params: *mut *mut c_void) -> Result<()> {
		let ret = process_catch("glGetPointerv", catch_unwind(||(self.getpointerv)(pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetPointerv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPolygonOffset.xhtml>
	#[inline(always)]
	fn glPolygonOffset(&self, factor: GLfloat, units: GLfloat) -> Result<()> {
		let ret = process_catch("glPolygonOffset", catch_unwind(||(self.polygonoffset)(factor, units)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPolygonOffset", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTexImage1D.xhtml>
	#[inline(always)]
	fn glCopyTexImage1D(&self, target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, border: GLint) -> Result<()> {
		let ret = process_catch("glCopyTexImage1D", catch_unwind(||(self.copyteximage1d)(target, level, internalformat, x, y, width, border)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexImage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTexImage2D.xhtml>
	#[inline(always)]
	fn glCopyTexImage2D(&self, target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint) -> Result<()> {
		let ret = process_catch("glCopyTexImage2D", catch_unwind(||(self.copyteximage2d)(target, level, internalformat, x, y, width, height, border)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexImage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTexSubImage1D.xhtml>
	#[inline(always)]
	fn glCopyTexSubImage1D(&self, target: GLenum, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTexSubImage1D", catch_unwind(||(self.copytexsubimage1d)(target, level, xoffset, x, y, width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexSubImage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTexSubImage2D.xhtml>
	#[inline(always)]
	fn glCopyTexSubImage2D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTexSubImage2D", catch_unwind(||(self.copytexsubimage2d)(target, level, xoffset, yoffset, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexSubImage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexSubImage1D.xhtml>
	#[inline(always)]
	fn glTexSubImage1D(&self, target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexSubImage1D", catch_unwind(||(self.texsubimage1d)(target, level, xoffset, width, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexSubImage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexSubImage2D.xhtml>
	#[inline(always)]
	fn glTexSubImage2D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexSubImage2D", catch_unwind(||(self.texsubimage2d)(target, level, xoffset, yoffset, width, height, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexSubImage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindTexture.xhtml>
	#[inline(always)]
	fn glBindTexture(&self, target: GLenum, texture: GLuint) -> Result<()> {
		let ret = process_catch("glBindTexture", catch_unwind(||(self.bindtexture)(target, texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindTexture", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteTextures.xhtml>
	#[inline(always)]
	fn glDeleteTextures(&self, n: GLsizei, textures: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteTextures", catch_unwind(||(self.deletetextures)(n, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteTextures", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenTextures.xhtml>
	#[inline(always)]
	fn glGenTextures(&self, n: GLsizei, textures: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenTextures", catch_unwind(||(self.gentextures)(n, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenTextures", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsTexture.xhtml>
	#[inline(always)]
	fn glIsTexture(&self, texture: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsTexture", catch_unwind(||(self.istexture)(texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsTexture", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version11 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (1, 1, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			drawarrays: {let proc = get_proc_address("glDrawArrays"); if proc == null() {dummy_pfngldrawarraysproc} else {unsafe{transmute(proc)}}},
			drawelements: {let proc = get_proc_address("glDrawElements"); if proc == null() {dummy_pfngldrawelementsproc} else {unsafe{transmute(proc)}}},
			getpointerv: {let proc = get_proc_address("glGetPointerv"); if proc == null() {dummy_pfnglgetpointervproc} else {unsafe{transmute(proc)}}},
			polygonoffset: {let proc = get_proc_address("glPolygonOffset"); if proc == null() {dummy_pfnglpolygonoffsetproc} else {unsafe{transmute(proc)}}},
			copyteximage1d: {let proc = get_proc_address("glCopyTexImage1D"); if proc == null() {dummy_pfnglcopyteximage1dproc} else {unsafe{transmute(proc)}}},
			copyteximage2d: {let proc = get_proc_address("glCopyTexImage2D"); if proc == null() {dummy_pfnglcopyteximage2dproc} else {unsafe{transmute(proc)}}},
			copytexsubimage1d: {let proc = get_proc_address("glCopyTexSubImage1D"); if proc == null() {dummy_pfnglcopytexsubimage1dproc} else {unsafe{transmute(proc)}}},
			copytexsubimage2d: {let proc = get_proc_address("glCopyTexSubImage2D"); if proc == null() {dummy_pfnglcopytexsubimage2dproc} else {unsafe{transmute(proc)}}},
			texsubimage1d: {let proc = get_proc_address("glTexSubImage1D"); if proc == null() {dummy_pfngltexsubimage1dproc} else {unsafe{transmute(proc)}}},
			texsubimage2d: {let proc = get_proc_address("glTexSubImage2D"); if proc == null() {dummy_pfngltexsubimage2dproc} else {unsafe{transmute(proc)}}},
			bindtexture: {let proc = get_proc_address("glBindTexture"); if proc == null() {dummy_pfnglbindtextureproc} else {unsafe{transmute(proc)}}},
			deletetextures: {let proc = get_proc_address("glDeleteTextures"); if proc == null() {dummy_pfngldeletetexturesproc} else {unsafe{transmute(proc)}}},
			gentextures: {let proc = get_proc_address("glGenTextures"); if proc == null() {dummy_pfnglgentexturesproc} else {unsafe{transmute(proc)}}},
			istexture: {let proc = get_proc_address("glIsTexture"); if proc == null() {dummy_pfnglistextureproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version11 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			drawarrays: dummy_pfngldrawarraysproc,
			drawelements: dummy_pfngldrawelementsproc,
			getpointerv: dummy_pfnglgetpointervproc,
			polygonoffset: dummy_pfnglpolygonoffsetproc,
			copyteximage1d: dummy_pfnglcopyteximage1dproc,
			copyteximage2d: dummy_pfnglcopyteximage2dproc,
			copytexsubimage1d: dummy_pfnglcopytexsubimage1dproc,
			copytexsubimage2d: dummy_pfnglcopytexsubimage2dproc,
			texsubimage1d: dummy_pfngltexsubimage1dproc,
			texsubimage2d: dummy_pfngltexsubimage2dproc,
			bindtexture: dummy_pfnglbindtextureproc,
			deletetextures: dummy_pfngldeletetexturesproc,
			gentextures: dummy_pfnglgentexturesproc,
			istexture: dummy_pfnglistextureproc,
		}
	}
}
impl Debug for Version11 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version11")
			.field("available", &self.available)
			.field("drawarrays", unsafe{if transmute::<_, *const c_void>(self.drawarrays) == (dummy_pfngldrawarraysproc as *const c_void) {&null::<PFNGLDRAWARRAYSPROC>()} else {&self.drawarrays}})
			.field("drawelements", unsafe{if transmute::<_, *const c_void>(self.drawelements) == (dummy_pfngldrawelementsproc as *const c_void) {&null::<PFNGLDRAWELEMENTSPROC>()} else {&self.drawelements}})
			.field("getpointerv", unsafe{if transmute::<_, *const c_void>(self.getpointerv) == (dummy_pfnglgetpointervproc as *const c_void) {&null::<PFNGLGETPOINTERVPROC>()} else {&self.getpointerv}})
			.field("polygonoffset", unsafe{if transmute::<_, *const c_void>(self.polygonoffset) == (dummy_pfnglpolygonoffsetproc as *const c_void) {&null::<PFNGLPOLYGONOFFSETPROC>()} else {&self.polygonoffset}})
			.field("copyteximage1d", unsafe{if transmute::<_, *const c_void>(self.copyteximage1d) == (dummy_pfnglcopyteximage1dproc as *const c_void) {&null::<PFNGLCOPYTEXIMAGE1DPROC>()} else {&self.copyteximage1d}})
			.field("copyteximage2d", unsafe{if transmute::<_, *const c_void>(self.copyteximage2d) == (dummy_pfnglcopyteximage2dproc as *const c_void) {&null::<PFNGLCOPYTEXIMAGE2DPROC>()} else {&self.copyteximage2d}})
			.field("copytexsubimage1d", unsafe{if transmute::<_, *const c_void>(self.copytexsubimage1d) == (dummy_pfnglcopytexsubimage1dproc as *const c_void) {&null::<PFNGLCOPYTEXSUBIMAGE1DPROC>()} else {&self.copytexsubimage1d}})
			.field("copytexsubimage2d", unsafe{if transmute::<_, *const c_void>(self.copytexsubimage2d) == (dummy_pfnglcopytexsubimage2dproc as *const c_void) {&null::<PFNGLCOPYTEXSUBIMAGE2DPROC>()} else {&self.copytexsubimage2d}})
			.field("texsubimage1d", unsafe{if transmute::<_, *const c_void>(self.texsubimage1d) == (dummy_pfngltexsubimage1dproc as *const c_void) {&null::<PFNGLTEXSUBIMAGE1DPROC>()} else {&self.texsubimage1d}})
			.field("texsubimage2d", unsafe{if transmute::<_, *const c_void>(self.texsubimage2d) == (dummy_pfngltexsubimage2dproc as *const c_void) {&null::<PFNGLTEXSUBIMAGE2DPROC>()} else {&self.texsubimage2d}})
			.field("bindtexture", unsafe{if transmute::<_, *const c_void>(self.bindtexture) == (dummy_pfnglbindtextureproc as *const c_void) {&null::<PFNGLBINDTEXTUREPROC>()} else {&self.bindtexture}})
			.field("deletetextures", unsafe{if transmute::<_, *const c_void>(self.deletetextures) == (dummy_pfngldeletetexturesproc as *const c_void) {&null::<PFNGLDELETETEXTURESPROC>()} else {&self.deletetextures}})
			.field("gentextures", unsafe{if transmute::<_, *const c_void>(self.gentextures) == (dummy_pfnglgentexturesproc as *const c_void) {&null::<PFNGLGENTEXTURESPROC>()} else {&self.gentextures}})
			.field("istexture", unsafe{if transmute::<_, *const c_void>(self.istexture) == (dummy_pfnglistextureproc as *const c_void) {&null::<PFNGLISTEXTUREPROC>()} else {&self.istexture}})
			.finish()
		} else {
			f.debug_struct("Version11")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

/// The prototype to the OpenGL function `DrawRangeElements`
type PFNGLDRAWRANGEELEMENTSPROC = extern "system" fn(GLenum, GLuint, GLuint, GLsizei, GLenum, *const c_void);

/// The prototype to the OpenGL function `TexImage3D`
type PFNGLTEXIMAGE3DPROC = extern "system" fn(GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, *const c_void);

/// The prototype to the OpenGL function `TexSubImage3D`
type PFNGLTEXSUBIMAGE3DPROC = extern "system" fn(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, *const c_void);

/// The prototype to the OpenGL function `CopyTexSubImage3D`
type PFNGLCOPYTEXSUBIMAGE3DPROC = extern "system" fn(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);

/// The dummy function of `DrawRangeElements()`
extern "system" fn dummy_pfngldrawrangeelementsproc (_: GLenum, _: GLuint, _: GLuint, _: GLsizei, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glDrawRangeElements()` is null.")
}

/// The dummy function of `TexImage3D()`
extern "system" fn dummy_pfnglteximage3dproc (_: GLenum, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei, _: GLint, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glTexImage3D()` is null.")
}

/// The dummy function of `TexSubImage3D()`
extern "system" fn dummy_pfngltexsubimage3dproc (_: GLenum, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glTexSubImage3D()` is null.")
}

/// The dummy function of `CopyTexSubImage3D()`
extern "system" fn dummy_pfnglcopytexsubimage3dproc (_: GLenum, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glCopyTexSubImage3D()` is null.")
}
/// Constant value defined from OpenGL 1.2
pub const GL_UNSIGNED_BYTE_3_3_2: GLenum = 0x8032;

/// Constant value defined from OpenGL 1.2
pub const GL_UNSIGNED_SHORT_4_4_4_4: GLenum = 0x8033;

/// Constant value defined from OpenGL 1.2
pub const GL_UNSIGNED_SHORT_5_5_5_1: GLenum = 0x8034;

/// Constant value defined from OpenGL 1.2
pub const GL_UNSIGNED_INT_8_8_8_8: GLenum = 0x8035;

/// Constant value defined from OpenGL 1.2
pub const GL_UNSIGNED_INT_10_10_10_2: GLenum = 0x8036;

/// Constant value defined from OpenGL 1.2
pub const GL_TEXTURE_BINDING_3D: GLenum = 0x806A;

/// Constant value defined from OpenGL 1.2
pub const GL_PACK_SKIP_IMAGES: GLenum = 0x806B;

/// Constant value defined from OpenGL 1.2
pub const GL_PACK_IMAGE_HEIGHT: GLenum = 0x806C;

/// Constant value defined from OpenGL 1.2
pub const GL_UNPACK_SKIP_IMAGES: GLenum = 0x806D;

/// Constant value defined from OpenGL 1.2
pub const GL_UNPACK_IMAGE_HEIGHT: GLenum = 0x806E;

/// Constant value defined from OpenGL 1.2
pub const GL_TEXTURE_3D: GLenum = 0x806F;

/// Constant value defined from OpenGL 1.2
pub const GL_PROXY_TEXTURE_3D: GLenum = 0x8070;

/// Constant value defined from OpenGL 1.2
pub const GL_TEXTURE_DEPTH: GLenum = 0x8071;

/// Constant value defined from OpenGL 1.2
pub const GL_TEXTURE_WRAP_R: GLenum = 0x8072;

/// Constant value defined from OpenGL 1.2
pub const GL_MAX_3D_TEXTURE_SIZE: GLenum = 0x8073;

/// Constant value defined from OpenGL 1.2
pub const GL_UNSIGNED_BYTE_2_3_3_REV: GLenum = 0x8362;

/// Constant value defined from OpenGL 1.2
pub const GL_UNSIGNED_SHORT_5_6_5: GLenum = 0x8363;

/// Constant value defined from OpenGL 1.2
pub const GL_UNSIGNED_SHORT_5_6_5_REV: GLenum = 0x8364;

/// Constant value defined from OpenGL 1.2
pub const GL_UNSIGNED_SHORT_4_4_4_4_REV: GLenum = 0x8365;

/// Constant value defined from OpenGL 1.2
pub const GL_UNSIGNED_SHORT_1_5_5_5_REV: GLenum = 0x8366;

/// Constant value defined from OpenGL 1.2
pub const GL_UNSIGNED_INT_8_8_8_8_REV: GLenum = 0x8367;

/// Constant value defined from OpenGL 1.2
pub const GL_UNSIGNED_INT_2_10_10_10_REV: GLenum = 0x8368;

/// Constant value defined from OpenGL 1.2
pub const GL_BGR: GLenum = 0x80E0;

/// Constant value defined from OpenGL 1.2
pub const GL_BGRA: GLenum = 0x80E1;

/// Constant value defined from OpenGL 1.2
pub const GL_MAX_ELEMENTS_VERTICES: GLenum = 0x80E8;

/// Constant value defined from OpenGL 1.2
pub const GL_MAX_ELEMENTS_INDICES: GLenum = 0x80E9;

/// Constant value defined from OpenGL 1.2
pub const GL_CLAMP_TO_EDGE: GLint = 0x812F;

/// Constant value defined from OpenGL 1.2
pub const GL_TEXTURE_MIN_LOD: GLenum = 0x813A;

/// Constant value defined from OpenGL 1.2
pub const GL_TEXTURE_MAX_LOD: GLenum = 0x813B;

/// Constant value defined from OpenGL 1.2
pub const GL_TEXTURE_BASE_LEVEL: GLenum = 0x813C;

/// Constant value defined from OpenGL 1.2
pub const GL_TEXTURE_MAX_LEVEL: GLenum = 0x813D;

/// Constant value defined from OpenGL 1.2
pub const GL_SMOOTH_POINT_SIZE_RANGE: GLenum = 0x0B12;

/// Constant value defined from OpenGL 1.2
pub const GL_SMOOTH_POINT_SIZE_GRANULARITY: GLenum = 0x0B13;

/// Constant value defined from OpenGL 1.2
pub const GL_SMOOTH_LINE_WIDTH_RANGE: GLenum = 0x0B22;

/// Constant value defined from OpenGL 1.2
pub const GL_SMOOTH_LINE_WIDTH_GRANULARITY: GLenum = 0x0B23;

/// Constant value defined from OpenGL 1.2
pub const GL_ALIASED_LINE_WIDTH_RANGE: GLenum = 0x846E;

/// Constant value defined from OpenGL 1.2
pub const GL_RESCALE_NORMAL: GLenum = 0x803A;

/// Constant value defined from OpenGL 1.2
pub const GL_LIGHT_MODEL_COLOR_CONTROL: GLenum = 0x81F8;

/// Constant value defined from OpenGL 1.2
pub const GL_SINGLE_COLOR: GLenum = 0x81F9;

/// Constant value defined from OpenGL 1.2
pub const GL_SEPARATE_SPECULAR_COLOR: GLenum = 0x81FA;

/// Constant value defined from OpenGL 1.2
pub const GL_ALIASED_POINT_SIZE_RANGE: GLenum = 0x846D;

/// Functions from OpenGL version 1.2
pub trait GL_1_2 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	fn glGetError(&self) -> GLenum;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawRangeElements.xhtml>
	fn glDrawRangeElements(&self, mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type_: GLenum, indices: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexImage3D.xhtml>
	fn glTexImage3D(&self, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexSubImage3D.xhtml>
	fn glTexSubImage3D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTexSubImage3D.xhtml>
	fn glCopyTexSubImage3D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()>;
}
/// Functions from OpenGL version 1.2
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version12 {
	/// Is OpenGL version 1.2 available
	available: bool,

	/// The function pointer to `glGetError()`
	pub geterror: PFNGLGETERRORPROC,

	/// The function pointer to `glDrawRangeElements()`
	pub drawrangeelements: PFNGLDRAWRANGEELEMENTSPROC,

	/// The function pointer to `glTexImage3D()`
	pub teximage3d: PFNGLTEXIMAGE3DPROC,

	/// The function pointer to `glTexSubImage3D()`
	pub texsubimage3d: PFNGLTEXSUBIMAGE3DPROC,

	/// The function pointer to `glCopyTexSubImage3D()`
	pub copytexsubimage3d: PFNGLCOPYTEXSUBIMAGE3DPROC,
}

impl GL_1_2 for Version12 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawRangeElements.xhtml>
	#[inline(always)]
	fn glDrawRangeElements(&self, mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type_: GLenum, indices: *const c_void) -> Result<()> {
		let ret = process_catch("glDrawRangeElements", catch_unwind(||(self.drawrangeelements)(mode, start, end, count, type_, indices)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawRangeElements", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexImage3D.xhtml>
	#[inline(always)]
	fn glTexImage3D(&self, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexImage3D", catch_unwind(||(self.teximage3d)(target, level, internalformat, width, height, depth, border, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexSubImage3D.xhtml>
	#[inline(always)]
	fn glTexSubImage3D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexSubImage3D", catch_unwind(||(self.texsubimage3d)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexSubImage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTexSubImage3D.xhtml>
	#[inline(always)]
	fn glCopyTexSubImage3D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTexSubImage3D", catch_unwind(||(self.copytexsubimage3d)(target, level, xoffset, yoffset, zoffset, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexSubImage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version12 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (1, 2, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			drawrangeelements: {let proc = get_proc_address("glDrawRangeElements"); if proc == null() {dummy_pfngldrawrangeelementsproc} else {unsafe{transmute(proc)}}},
			teximage3d: {let proc = get_proc_address("glTexImage3D"); if proc == null() {dummy_pfnglteximage3dproc} else {unsafe{transmute(proc)}}},
			texsubimage3d: {let proc = get_proc_address("glTexSubImage3D"); if proc == null() {dummy_pfngltexsubimage3dproc} else {unsafe{transmute(proc)}}},
			copytexsubimage3d: {let proc = get_proc_address("glCopyTexSubImage3D"); if proc == null() {dummy_pfnglcopytexsubimage3dproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version12 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			drawrangeelements: dummy_pfngldrawrangeelementsproc,
			teximage3d: dummy_pfnglteximage3dproc,
			texsubimage3d: dummy_pfngltexsubimage3dproc,
			copytexsubimage3d: dummy_pfnglcopytexsubimage3dproc,
		}
	}
}
impl Debug for Version12 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version12")
			.field("available", &self.available)
			.field("drawrangeelements", unsafe{if transmute::<_, *const c_void>(self.drawrangeelements) == (dummy_pfngldrawrangeelementsproc as *const c_void) {&null::<PFNGLDRAWRANGEELEMENTSPROC>()} else {&self.drawrangeelements}})
			.field("teximage3d", unsafe{if transmute::<_, *const c_void>(self.teximage3d) == (dummy_pfnglteximage3dproc as *const c_void) {&null::<PFNGLTEXIMAGE3DPROC>()} else {&self.teximage3d}})
			.field("texsubimage3d", unsafe{if transmute::<_, *const c_void>(self.texsubimage3d) == (dummy_pfngltexsubimage3dproc as *const c_void) {&null::<PFNGLTEXSUBIMAGE3DPROC>()} else {&self.texsubimage3d}})
			.field("copytexsubimage3d", unsafe{if transmute::<_, *const c_void>(self.copytexsubimage3d) == (dummy_pfnglcopytexsubimage3dproc as *const c_void) {&null::<PFNGLCOPYTEXSUBIMAGE3DPROC>()} else {&self.copytexsubimage3d}})
			.finish()
		} else {
			f.debug_struct("Version12")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

/// The prototype to the OpenGL function `ActiveTexture`
type PFNGLACTIVETEXTUREPROC = extern "system" fn(GLenum);

/// The prototype to the OpenGL function `SampleCoverage`
type PFNGLSAMPLECOVERAGEPROC = extern "system" fn(GLfloat, GLboolean);

/// The prototype to the OpenGL function `CompressedTexImage3D`
type PFNGLCOMPRESSEDTEXIMAGE3DPROC = extern "system" fn(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, *const c_void);

/// The prototype to the OpenGL function `CompressedTexImage2D`
type PFNGLCOMPRESSEDTEXIMAGE2DPROC = extern "system" fn(GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, *const c_void);

/// The prototype to the OpenGL function `CompressedTexImage1D`
type PFNGLCOMPRESSEDTEXIMAGE1DPROC = extern "system" fn(GLenum, GLint, GLenum, GLsizei, GLint, GLsizei, *const c_void);

/// The prototype to the OpenGL function `CompressedTexSubImage3D`
type PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC = extern "system" fn(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, *const c_void);

/// The prototype to the OpenGL function `CompressedTexSubImage2D`
type PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC = extern "system" fn(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, *const c_void);

/// The prototype to the OpenGL function `CompressedTexSubImage1D`
type PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC = extern "system" fn(GLenum, GLint, GLint, GLsizei, GLenum, GLsizei, *const c_void);

/// The prototype to the OpenGL function `GetCompressedTexImage`
type PFNGLGETCOMPRESSEDTEXIMAGEPROC = extern "system" fn(GLenum, GLint, *mut c_void);

/// The prototype to the OpenGL function `ClientActiveTexture`
type PFNGLCLIENTACTIVETEXTUREPROC = extern "system" fn(GLenum);

/// The prototype to the OpenGL function `MultiTexCoord1d`
type PFNGLMULTITEXCOORD1DPROC = extern "system" fn(GLenum, GLdouble);

/// The prototype to the OpenGL function `MultiTexCoord1dv`
type PFNGLMULTITEXCOORD1DVPROC = extern "system" fn(GLenum, *const GLdouble);

/// The prototype to the OpenGL function `MultiTexCoord1f`
type PFNGLMULTITEXCOORD1FPROC = extern "system" fn(GLenum, GLfloat);

/// The prototype to the OpenGL function `MultiTexCoord1fv`
type PFNGLMULTITEXCOORD1FVPROC = extern "system" fn(GLenum, *const GLfloat);

/// The prototype to the OpenGL function `MultiTexCoord1i`
type PFNGLMULTITEXCOORD1IPROC = extern "system" fn(GLenum, GLint);

/// The prototype to the OpenGL function `MultiTexCoord1iv`
type PFNGLMULTITEXCOORD1IVPROC = extern "system" fn(GLenum, *const GLint);

/// The prototype to the OpenGL function `MultiTexCoord1s`
type PFNGLMULTITEXCOORD1SPROC = extern "system" fn(GLenum, GLshort);

/// The prototype to the OpenGL function `MultiTexCoord1sv`
type PFNGLMULTITEXCOORD1SVPROC = extern "system" fn(GLenum, *const GLshort);

/// The prototype to the OpenGL function `MultiTexCoord2d`
type PFNGLMULTITEXCOORD2DPROC = extern "system" fn(GLenum, GLdouble, GLdouble);

/// The prototype to the OpenGL function `MultiTexCoord2dv`
type PFNGLMULTITEXCOORD2DVPROC = extern "system" fn(GLenum, *const GLdouble);

/// The prototype to the OpenGL function `MultiTexCoord2f`
type PFNGLMULTITEXCOORD2FPROC = extern "system" fn(GLenum, GLfloat, GLfloat);

/// The prototype to the OpenGL function `MultiTexCoord2fv`
type PFNGLMULTITEXCOORD2FVPROC = extern "system" fn(GLenum, *const GLfloat);

/// The prototype to the OpenGL function `MultiTexCoord2i`
type PFNGLMULTITEXCOORD2IPROC = extern "system" fn(GLenum, GLint, GLint);

/// The prototype to the OpenGL function `MultiTexCoord2iv`
type PFNGLMULTITEXCOORD2IVPROC = extern "system" fn(GLenum, *const GLint);

/// The prototype to the OpenGL function `MultiTexCoord2s`
type PFNGLMULTITEXCOORD2SPROC = extern "system" fn(GLenum, GLshort, GLshort);

/// The prototype to the OpenGL function `MultiTexCoord2sv`
type PFNGLMULTITEXCOORD2SVPROC = extern "system" fn(GLenum, *const GLshort);

/// The prototype to the OpenGL function `MultiTexCoord3d`
type PFNGLMULTITEXCOORD3DPROC = extern "system" fn(GLenum, GLdouble, GLdouble, GLdouble);

/// The prototype to the OpenGL function `MultiTexCoord3dv`
type PFNGLMULTITEXCOORD3DVPROC = extern "system" fn(GLenum, *const GLdouble);

/// The prototype to the OpenGL function `MultiTexCoord3f`
type PFNGLMULTITEXCOORD3FPROC = extern "system" fn(GLenum, GLfloat, GLfloat, GLfloat);

/// The prototype to the OpenGL function `MultiTexCoord3fv`
type PFNGLMULTITEXCOORD3FVPROC = extern "system" fn(GLenum, *const GLfloat);

/// The prototype to the OpenGL function `MultiTexCoord3i`
type PFNGLMULTITEXCOORD3IPROC = extern "system" fn(GLenum, GLint, GLint, GLint);

/// The prototype to the OpenGL function `MultiTexCoord3iv`
type PFNGLMULTITEXCOORD3IVPROC = extern "system" fn(GLenum, *const GLint);

/// The prototype to the OpenGL function `MultiTexCoord3s`
type PFNGLMULTITEXCOORD3SPROC = extern "system" fn(GLenum, GLshort, GLshort, GLshort);

/// The prototype to the OpenGL function `MultiTexCoord3sv`
type PFNGLMULTITEXCOORD3SVPROC = extern "system" fn(GLenum, *const GLshort);

/// The prototype to the OpenGL function `MultiTexCoord4d`
type PFNGLMULTITEXCOORD4DPROC = extern "system" fn(GLenum, GLdouble, GLdouble, GLdouble, GLdouble);

/// The prototype to the OpenGL function `MultiTexCoord4dv`
type PFNGLMULTITEXCOORD4DVPROC = extern "system" fn(GLenum, *const GLdouble);

/// The prototype to the OpenGL function `MultiTexCoord4f`
type PFNGLMULTITEXCOORD4FPROC = extern "system" fn(GLenum, GLfloat, GLfloat, GLfloat, GLfloat);

/// The prototype to the OpenGL function `MultiTexCoord4fv`
type PFNGLMULTITEXCOORD4FVPROC = extern "system" fn(GLenum, *const GLfloat);

/// The prototype to the OpenGL function `MultiTexCoord4i`
type PFNGLMULTITEXCOORD4IPROC = extern "system" fn(GLenum, GLint, GLint, GLint, GLint);

/// The prototype to the OpenGL function `MultiTexCoord4iv`
type PFNGLMULTITEXCOORD4IVPROC = extern "system" fn(GLenum, *const GLint);

/// The prototype to the OpenGL function `MultiTexCoord4s`
type PFNGLMULTITEXCOORD4SPROC = extern "system" fn(GLenum, GLshort, GLshort, GLshort, GLshort);

/// The prototype to the OpenGL function `MultiTexCoord4sv`
type PFNGLMULTITEXCOORD4SVPROC = extern "system" fn(GLenum, *const GLshort);

/// The prototype to the OpenGL function `LoadTransposeMatrixf`
type PFNGLLOADTRANSPOSEMATRIXFPROC = extern "system" fn(*const GLfloat);

/// The prototype to the OpenGL function `LoadTransposeMatrixd`
type PFNGLLOADTRANSPOSEMATRIXDPROC = extern "system" fn(*const GLdouble);

/// The prototype to the OpenGL function `MultTransposeMatrixf`
type PFNGLMULTTRANSPOSEMATRIXFPROC = extern "system" fn(*const GLfloat);

/// The prototype to the OpenGL function `MultTransposeMatrixd`
type PFNGLMULTTRANSPOSEMATRIXDPROC = extern "system" fn(*const GLdouble);

/// The dummy function of `ActiveTexture()`
extern "system" fn dummy_pfnglactivetextureproc (_: GLenum) {
	panic!("OpenGL function pointer `glActiveTexture()` is null.")
}

/// The dummy function of `SampleCoverage()`
extern "system" fn dummy_pfnglsamplecoverageproc (_: GLfloat, _: GLboolean) {
	panic!("OpenGL function pointer `glSampleCoverage()` is null.")
}

/// The dummy function of `CompressedTexImage3D()`
extern "system" fn dummy_pfnglcompressedteximage3dproc (_: GLenum, _: GLint, _: GLenum, _: GLsizei, _: GLsizei, _: GLsizei, _: GLint, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glCompressedTexImage3D()` is null.")
}

/// The dummy function of `CompressedTexImage2D()`
extern "system" fn dummy_pfnglcompressedteximage2dproc (_: GLenum, _: GLint, _: GLenum, _: GLsizei, _: GLsizei, _: GLint, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glCompressedTexImage2D()` is null.")
}

/// The dummy function of `CompressedTexImage1D()`
extern "system" fn dummy_pfnglcompressedteximage1dproc (_: GLenum, _: GLint, _: GLenum, _: GLsizei, _: GLint, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glCompressedTexImage1D()` is null.")
}

/// The dummy function of `CompressedTexSubImage3D()`
extern "system" fn dummy_pfnglcompressedtexsubimage3dproc (_: GLenum, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei, _: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glCompressedTexSubImage3D()` is null.")
}

/// The dummy function of `CompressedTexSubImage2D()`
extern "system" fn dummy_pfnglcompressedtexsubimage2dproc (_: GLenum, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glCompressedTexSubImage2D()` is null.")
}

/// The dummy function of `CompressedTexSubImage1D()`
extern "system" fn dummy_pfnglcompressedtexsubimage1dproc (_: GLenum, _: GLint, _: GLint, _: GLsizei, _: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glCompressedTexSubImage1D()` is null.")
}

/// The dummy function of `GetCompressedTexImage()`
extern "system" fn dummy_pfnglgetcompressedteximageproc (_: GLenum, _: GLint, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetCompressedTexImage()` is null.")
}

/// The dummy function of `ClientActiveTexture()`
extern "system" fn dummy_pfnglclientactivetextureproc (_: GLenum) {
	panic!("OpenGL function pointer `glClientActiveTexture()` is null.")
}

/// The dummy function of `MultiTexCoord1d()`
extern "system" fn dummy_pfnglmultitexcoord1dproc (_: GLenum, _: GLdouble) {
	panic!("OpenGL function pointer `glMultiTexCoord1d()` is null.")
}

/// The dummy function of `MultiTexCoord1dv()`
extern "system" fn dummy_pfnglmultitexcoord1dvproc (_: GLenum, _: *const GLdouble) {
	panic!("OpenGL function pointer `glMultiTexCoord1dv()` is null.")
}

/// The dummy function of `MultiTexCoord1f()`
extern "system" fn dummy_pfnglmultitexcoord1fproc (_: GLenum, _: GLfloat) {
	panic!("OpenGL function pointer `glMultiTexCoord1f()` is null.")
}

/// The dummy function of `MultiTexCoord1fv()`
extern "system" fn dummy_pfnglmultitexcoord1fvproc (_: GLenum, _: *const GLfloat) {
	panic!("OpenGL function pointer `glMultiTexCoord1fv()` is null.")
}

/// The dummy function of `MultiTexCoord1i()`
extern "system" fn dummy_pfnglmultitexcoord1iproc (_: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glMultiTexCoord1i()` is null.")
}

/// The dummy function of `MultiTexCoord1iv()`
extern "system" fn dummy_pfnglmultitexcoord1ivproc (_: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glMultiTexCoord1iv()` is null.")
}

/// The dummy function of `MultiTexCoord1s()`
extern "system" fn dummy_pfnglmultitexcoord1sproc (_: GLenum, _: GLshort) {
	panic!("OpenGL function pointer `glMultiTexCoord1s()` is null.")
}

/// The dummy function of `MultiTexCoord1sv()`
extern "system" fn dummy_pfnglmultitexcoord1svproc (_: GLenum, _: *const GLshort) {
	panic!("OpenGL function pointer `glMultiTexCoord1sv()` is null.")
}

/// The dummy function of `MultiTexCoord2d()`
extern "system" fn dummy_pfnglmultitexcoord2dproc (_: GLenum, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glMultiTexCoord2d()` is null.")
}

/// The dummy function of `MultiTexCoord2dv()`
extern "system" fn dummy_pfnglmultitexcoord2dvproc (_: GLenum, _: *const GLdouble) {
	panic!("OpenGL function pointer `glMultiTexCoord2dv()` is null.")
}

/// The dummy function of `MultiTexCoord2f()`
extern "system" fn dummy_pfnglmultitexcoord2fproc (_: GLenum, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glMultiTexCoord2f()` is null.")
}

/// The dummy function of `MultiTexCoord2fv()`
extern "system" fn dummy_pfnglmultitexcoord2fvproc (_: GLenum, _: *const GLfloat) {
	panic!("OpenGL function pointer `glMultiTexCoord2fv()` is null.")
}

/// The dummy function of `MultiTexCoord2i()`
extern "system" fn dummy_pfnglmultitexcoord2iproc (_: GLenum, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glMultiTexCoord2i()` is null.")
}

/// The dummy function of `MultiTexCoord2iv()`
extern "system" fn dummy_pfnglmultitexcoord2ivproc (_: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glMultiTexCoord2iv()` is null.")
}

/// The dummy function of `MultiTexCoord2s()`
extern "system" fn dummy_pfnglmultitexcoord2sproc (_: GLenum, _: GLshort, _: GLshort) {
	panic!("OpenGL function pointer `glMultiTexCoord2s()` is null.")
}

/// The dummy function of `MultiTexCoord2sv()`
extern "system" fn dummy_pfnglmultitexcoord2svproc (_: GLenum, _: *const GLshort) {
	panic!("OpenGL function pointer `glMultiTexCoord2sv()` is null.")
}

/// The dummy function of `MultiTexCoord3d()`
extern "system" fn dummy_pfnglmultitexcoord3dproc (_: GLenum, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glMultiTexCoord3d()` is null.")
}

/// The dummy function of `MultiTexCoord3dv()`
extern "system" fn dummy_pfnglmultitexcoord3dvproc (_: GLenum, _: *const GLdouble) {
	panic!("OpenGL function pointer `glMultiTexCoord3dv()` is null.")
}

/// The dummy function of `MultiTexCoord3f()`
extern "system" fn dummy_pfnglmultitexcoord3fproc (_: GLenum, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glMultiTexCoord3f()` is null.")
}

/// The dummy function of `MultiTexCoord3fv()`
extern "system" fn dummy_pfnglmultitexcoord3fvproc (_: GLenum, _: *const GLfloat) {
	panic!("OpenGL function pointer `glMultiTexCoord3fv()` is null.")
}

/// The dummy function of `MultiTexCoord3i()`
extern "system" fn dummy_pfnglmultitexcoord3iproc (_: GLenum, _: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glMultiTexCoord3i()` is null.")
}

/// The dummy function of `MultiTexCoord3iv()`
extern "system" fn dummy_pfnglmultitexcoord3ivproc (_: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glMultiTexCoord3iv()` is null.")
}

/// The dummy function of `MultiTexCoord3s()`
extern "system" fn dummy_pfnglmultitexcoord3sproc (_: GLenum, _: GLshort, _: GLshort, _: GLshort) {
	panic!("OpenGL function pointer `glMultiTexCoord3s()` is null.")
}

/// The dummy function of `MultiTexCoord3sv()`
extern "system" fn dummy_pfnglmultitexcoord3svproc (_: GLenum, _: *const GLshort) {
	panic!("OpenGL function pointer `glMultiTexCoord3sv()` is null.")
}

/// The dummy function of `MultiTexCoord4d()`
extern "system" fn dummy_pfnglmultitexcoord4dproc (_: GLenum, _: GLdouble, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glMultiTexCoord4d()` is null.")
}

/// The dummy function of `MultiTexCoord4dv()`
extern "system" fn dummy_pfnglmultitexcoord4dvproc (_: GLenum, _: *const GLdouble) {
	panic!("OpenGL function pointer `glMultiTexCoord4dv()` is null.")
}

/// The dummy function of `MultiTexCoord4f()`
extern "system" fn dummy_pfnglmultitexcoord4fproc (_: GLenum, _: GLfloat, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glMultiTexCoord4f()` is null.")
}

/// The dummy function of `MultiTexCoord4fv()`
extern "system" fn dummy_pfnglmultitexcoord4fvproc (_: GLenum, _: *const GLfloat) {
	panic!("OpenGL function pointer `glMultiTexCoord4fv()` is null.")
}

/// The dummy function of `MultiTexCoord4i()`
extern "system" fn dummy_pfnglmultitexcoord4iproc (_: GLenum, _: GLint, _: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glMultiTexCoord4i()` is null.")
}

/// The dummy function of `MultiTexCoord4iv()`
extern "system" fn dummy_pfnglmultitexcoord4ivproc (_: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glMultiTexCoord4iv()` is null.")
}

/// The dummy function of `MultiTexCoord4s()`
extern "system" fn dummy_pfnglmultitexcoord4sproc (_: GLenum, _: GLshort, _: GLshort, _: GLshort, _: GLshort) {
	panic!("OpenGL function pointer `glMultiTexCoord4s()` is null.")
}

/// The dummy function of `MultiTexCoord4sv()`
extern "system" fn dummy_pfnglmultitexcoord4svproc (_: GLenum, _: *const GLshort) {
	panic!("OpenGL function pointer `glMultiTexCoord4sv()` is null.")
}

/// The dummy function of `LoadTransposeMatrixf()`
extern "system" fn dummy_pfnglloadtransposematrixfproc (_: *const GLfloat) {
	panic!("OpenGL function pointer `glLoadTransposeMatrixf()` is null.")
}

/// The dummy function of `LoadTransposeMatrixd()`
extern "system" fn dummy_pfnglloadtransposematrixdproc (_: *const GLdouble) {
	panic!("OpenGL function pointer `glLoadTransposeMatrixd()` is null.")
}

/// The dummy function of `MultTransposeMatrixf()`
extern "system" fn dummy_pfnglmulttransposematrixfproc (_: *const GLfloat) {
	panic!("OpenGL function pointer `glMultTransposeMatrixf()` is null.")
}

/// The dummy function of `MultTransposeMatrixd()`
extern "system" fn dummy_pfnglmulttransposematrixdproc (_: *const GLdouble) {
	panic!("OpenGL function pointer `glMultTransposeMatrixd()` is null.")
}
/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE0: GLenum = 0x84C0;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE1: GLenum = 0x84C1;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE2: GLenum = 0x84C2;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE3: GLenum = 0x84C3;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE4: GLenum = 0x84C4;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE5: GLenum = 0x84C5;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE6: GLenum = 0x84C6;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE7: GLenum = 0x84C7;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE8: GLenum = 0x84C8;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE9: GLenum = 0x84C9;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE10: GLenum = 0x84CA;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE11: GLenum = 0x84CB;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE12: GLenum = 0x84CC;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE13: GLenum = 0x84CD;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE14: GLenum = 0x84CE;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE15: GLenum = 0x84CF;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE16: GLenum = 0x84D0;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE17: GLenum = 0x84D1;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE18: GLenum = 0x84D2;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE19: GLenum = 0x84D3;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE20: GLenum = 0x84D4;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE21: GLenum = 0x84D5;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE22: GLenum = 0x84D6;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE23: GLenum = 0x84D7;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE24: GLenum = 0x84D8;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE25: GLenum = 0x84D9;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE26: GLenum = 0x84DA;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE27: GLenum = 0x84DB;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE28: GLenum = 0x84DC;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE29: GLenum = 0x84DD;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE30: GLenum = 0x84DE;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE31: GLenum = 0x84DF;

/// Constant value defined from OpenGL 1.3
pub const GL_ACTIVE_TEXTURE: GLenum = 0x84E0;

/// Constant value defined from OpenGL 1.3
pub const GL_MULTISAMPLE: GLenum = 0x809D;

/// Constant value defined from OpenGL 1.3
pub const GL_SAMPLE_ALPHA_TO_COVERAGE: GLenum = 0x809E;

/// Constant value defined from OpenGL 1.3
pub const GL_SAMPLE_ALPHA_TO_ONE: GLenum = 0x809F;

/// Constant value defined from OpenGL 1.3
pub const GL_SAMPLE_COVERAGE: GLenum = 0x80A0;

/// Constant value defined from OpenGL 1.3
pub const GL_SAMPLE_BUFFERS: GLenum = 0x80A8;

/// Constant value defined from OpenGL 1.3
pub const GL_SAMPLES: GLenum = 0x80A9;

/// Constant value defined from OpenGL 1.3
pub const GL_SAMPLE_COVERAGE_VALUE: GLenum = 0x80AA;

/// Constant value defined from OpenGL 1.3
pub const GL_SAMPLE_COVERAGE_INVERT: GLenum = 0x80AB;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE_CUBE_MAP: GLenum = 0x8513;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE_BINDING_CUBE_MAP: GLenum = 0x8514;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE_CUBE_MAP_POSITIVE_X: GLenum = 0x8515;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_X: GLenum = 0x8516;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Y: GLenum = 0x8517;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: GLenum = 0x8518;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Z: GLenum = 0x8519;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: GLenum = 0x851A;

/// Constant value defined from OpenGL 1.3
pub const GL_PROXY_TEXTURE_CUBE_MAP: GLenum = 0x851B;

/// Constant value defined from OpenGL 1.3
pub const GL_MAX_CUBE_MAP_TEXTURE_SIZE: GLenum = 0x851C;

/// Constant value defined from OpenGL 1.3
pub const GL_COMPRESSED_RGB: GLenum = 0x84ED;

/// Constant value defined from OpenGL 1.3
pub const GL_COMPRESSED_RGBA: GLenum = 0x84EE;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE_COMPRESSION_HINT: GLenum = 0x84EF;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE_COMPRESSED_IMAGE_SIZE: GLenum = 0x86A0;

/// Constant value defined from OpenGL 1.3
pub const GL_TEXTURE_COMPRESSED: GLenum = 0x86A1;

/// Constant value defined from OpenGL 1.3
pub const GL_NUM_COMPRESSED_TEXTURE_FORMATS: GLenum = 0x86A2;

/// Constant value defined from OpenGL 1.3
pub const GL_COMPRESSED_TEXTURE_FORMATS: GLenum = 0x86A3;

/// Constant value defined from OpenGL 1.3
pub const GL_CLAMP_TO_BORDER: GLint = 0x812D;

/// Constant value defined from OpenGL 1.3
pub const GL_CLIENT_ACTIVE_TEXTURE: GLenum = 0x84E1;

/// Constant value defined from OpenGL 1.3
pub const GL_MAX_TEXTURE_UNITS: GLenum = 0x84E2;

/// Constant value defined from OpenGL 1.3
pub const GL_TRANSPOSE_MODELVIEW_MATRIX: GLenum = 0x84E3;

/// Constant value defined from OpenGL 1.3
pub const GL_TRANSPOSE_PROJECTION_MATRIX: GLenum = 0x84E4;

/// Constant value defined from OpenGL 1.3
pub const GL_TRANSPOSE_TEXTURE_MATRIX: GLenum = 0x84E5;

/// Constant value defined from OpenGL 1.3
pub const GL_TRANSPOSE_COLOR_MATRIX: GLenum = 0x84E6;

/// Constant value defined from OpenGL 1.3
pub const GL_MULTISAMPLE_BIT: GLbitfield = 0x20000000;

/// Constant value defined from OpenGL 1.3
pub const GL_NORMAL_MAP: GLenum = 0x8511;

/// Constant value defined from OpenGL 1.3
pub const GL_REFLECTION_MAP: GLenum = 0x8512;

/// Constant value defined from OpenGL 1.3
pub const GL_COMPRESSED_ALPHA: GLenum = 0x84E9;

/// Constant value defined from OpenGL 1.3
pub const GL_COMPRESSED_LUMINANCE: GLenum = 0x84EA;

/// Constant value defined from OpenGL 1.3
pub const GL_COMPRESSED_LUMINANCE_ALPHA: GLenum = 0x84EB;

/// Constant value defined from OpenGL 1.3
pub const GL_COMPRESSED_INTENSITY: GLenum = 0x84EC;

/// Constant value defined from OpenGL 1.3
pub const GL_COMBINE: GLenum = 0x8570;

/// Constant value defined from OpenGL 1.3
pub const GL_COMBINE_RGB: GLenum = 0x8571;

/// Constant value defined from OpenGL 1.3
pub const GL_COMBINE_ALPHA: GLenum = 0x8572;

/// Constant value defined from OpenGL 1.3
pub const GL_SOURCE0_RGB: GLenum = 0x8580;

/// Constant value defined from OpenGL 1.3
pub const GL_SOURCE1_RGB: GLenum = 0x8581;

/// Constant value defined from OpenGL 1.3
pub const GL_SOURCE2_RGB: GLenum = 0x8582;

/// Constant value defined from OpenGL 1.3
pub const GL_SOURCE0_ALPHA: GLenum = 0x8588;

/// Constant value defined from OpenGL 1.3
pub const GL_SOURCE1_ALPHA: GLenum = 0x8589;

/// Constant value defined from OpenGL 1.3
pub const GL_SOURCE2_ALPHA: GLenum = 0x858A;

/// Constant value defined from OpenGL 1.3
pub const GL_OPERAND0_RGB: GLenum = 0x8590;

/// Constant value defined from OpenGL 1.3
pub const GL_OPERAND1_RGB: GLenum = 0x8591;

/// Constant value defined from OpenGL 1.3
pub const GL_OPERAND2_RGB: GLenum = 0x8592;

/// Constant value defined from OpenGL 1.3
pub const GL_OPERAND0_ALPHA: GLenum = 0x8598;

/// Constant value defined from OpenGL 1.3
pub const GL_OPERAND1_ALPHA: GLenum = 0x8599;

/// Constant value defined from OpenGL 1.3
pub const GL_OPERAND2_ALPHA: GLenum = 0x859A;

/// Constant value defined from OpenGL 1.3
pub const GL_RGB_SCALE: GLenum = 0x8573;

/// Constant value defined from OpenGL 1.3
pub const GL_ADD_SIGNED: GLenum = 0x8574;

/// Constant value defined from OpenGL 1.3
pub const GL_INTERPOLATE: GLenum = 0x8575;

/// Constant value defined from OpenGL 1.3
pub const GL_SUBTRACT: GLenum = 0x84E7;

/// Constant value defined from OpenGL 1.3
pub const GL_CONSTANT: GLenum = 0x8576;

/// Constant value defined from OpenGL 1.3
pub const GL_PRIMARY_COLOR: GLenum = 0x8577;

/// Constant value defined from OpenGL 1.3
pub const GL_PREVIOUS: GLenum = 0x8578;

/// Constant value defined from OpenGL 1.3
pub const GL_DOT3_RGB: GLenum = 0x86AE;

/// Constant value defined from OpenGL 1.3
pub const GL_DOT3_RGBA: GLenum = 0x86AF;

/// Functions from OpenGL version 1.3
pub trait GL_1_3 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	fn glGetError(&self) -> GLenum;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glActiveTexture.xhtml>
	fn glActiveTexture(&self, texture: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSampleCoverage.xhtml>
	fn glSampleCoverage(&self, value: GLfloat, invert: GLboolean) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTexImage3D.xhtml>
	fn glCompressedTexImage3D(&self, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTexImage2D.xhtml>
	fn glCompressedTexImage2D(&self, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTexImage1D.xhtml>
	fn glCompressedTexImage1D(&self, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTexSubImage3D.xhtml>
	fn glCompressedTexSubImage3D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTexSubImage2D.xhtml>
	fn glCompressedTexSubImage2D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTexSubImage1D.xhtml>
	fn glCompressedTexSubImage1D(&self, target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml>
	fn glGetCompressedTexImage(&self, target: GLenum, level: GLint, img: *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClientActiveTexture.xhtml>
	fn glClientActiveTexture(&self, texture: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1d.xhtml>
	fn glMultiTexCoord1d(&self, target: GLenum, s: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1dv.xhtml>
	fn glMultiTexCoord1dv(&self, target: GLenum, v: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1f.xhtml>
	fn glMultiTexCoord1f(&self, target: GLenum, s: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1fv.xhtml>
	fn glMultiTexCoord1fv(&self, target: GLenum, v: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1i.xhtml>
	fn glMultiTexCoord1i(&self, target: GLenum, s: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1iv.xhtml>
	fn glMultiTexCoord1iv(&self, target: GLenum, v: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1s.xhtml>
	fn glMultiTexCoord1s(&self, target: GLenum, s: GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1sv.xhtml>
	fn glMultiTexCoord1sv(&self, target: GLenum, v: *const GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2d.xhtml>
	fn glMultiTexCoord2d(&self, target: GLenum, s: GLdouble, t: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2dv.xhtml>
	fn glMultiTexCoord2dv(&self, target: GLenum, v: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2f.xhtml>
	fn glMultiTexCoord2f(&self, target: GLenum, s: GLfloat, t: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2fv.xhtml>
	fn glMultiTexCoord2fv(&self, target: GLenum, v: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2i.xhtml>
	fn glMultiTexCoord2i(&self, target: GLenum, s: GLint, t: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2iv.xhtml>
	fn glMultiTexCoord2iv(&self, target: GLenum, v: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2s.xhtml>
	fn glMultiTexCoord2s(&self, target: GLenum, s: GLshort, t: GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2sv.xhtml>
	fn glMultiTexCoord2sv(&self, target: GLenum, v: *const GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3d.xhtml>
	fn glMultiTexCoord3d(&self, target: GLenum, s: GLdouble, t: GLdouble, r: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3dv.xhtml>
	fn glMultiTexCoord3dv(&self, target: GLenum, v: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3f.xhtml>
	fn glMultiTexCoord3f(&self, target: GLenum, s: GLfloat, t: GLfloat, r: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3fv.xhtml>
	fn glMultiTexCoord3fv(&self, target: GLenum, v: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3i.xhtml>
	fn glMultiTexCoord3i(&self, target: GLenum, s: GLint, t: GLint, r: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3iv.xhtml>
	fn glMultiTexCoord3iv(&self, target: GLenum, v: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3s.xhtml>
	fn glMultiTexCoord3s(&self, target: GLenum, s: GLshort, t: GLshort, r: GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3sv.xhtml>
	fn glMultiTexCoord3sv(&self, target: GLenum, v: *const GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4d.xhtml>
	fn glMultiTexCoord4d(&self, target: GLenum, s: GLdouble, t: GLdouble, r: GLdouble, q: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4dv.xhtml>
	fn glMultiTexCoord4dv(&self, target: GLenum, v: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4f.xhtml>
	fn glMultiTexCoord4f(&self, target: GLenum, s: GLfloat, t: GLfloat, r: GLfloat, q: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4fv.xhtml>
	fn glMultiTexCoord4fv(&self, target: GLenum, v: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4i.xhtml>
	fn glMultiTexCoord4i(&self, target: GLenum, s: GLint, t: GLint, r: GLint, q: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4iv.xhtml>
	fn glMultiTexCoord4iv(&self, target: GLenum, v: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4s.xhtml>
	fn glMultiTexCoord4s(&self, target: GLenum, s: GLshort, t: GLshort, r: GLshort, q: GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4sv.xhtml>
	fn glMultiTexCoord4sv(&self, target: GLenum, v: *const GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLoadTransposeMatrixf.xhtml>
	fn glLoadTransposeMatrixf(&self, m: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLoadTransposeMatrixd.xhtml>
	fn glLoadTransposeMatrixd(&self, m: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultTransposeMatrixf.xhtml>
	fn glMultTransposeMatrixf(&self, m: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultTransposeMatrixd.xhtml>
	fn glMultTransposeMatrixd(&self, m: *const GLdouble) -> Result<()>;
}
/// Functions from OpenGL version 1.3
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version13 {
	/// Is OpenGL version 1.3 available
	available: bool,

	/// The function pointer to `glGetError()`
	pub geterror: PFNGLGETERRORPROC,

	/// The function pointer to `glActiveTexture()`
	pub activetexture: PFNGLACTIVETEXTUREPROC,

	/// The function pointer to `glSampleCoverage()`
	pub samplecoverage: PFNGLSAMPLECOVERAGEPROC,

	/// The function pointer to `glCompressedTexImage3D()`
	pub compressedteximage3d: PFNGLCOMPRESSEDTEXIMAGE3DPROC,

	/// The function pointer to `glCompressedTexImage2D()`
	pub compressedteximage2d: PFNGLCOMPRESSEDTEXIMAGE2DPROC,

	/// The function pointer to `glCompressedTexImage1D()`
	pub compressedteximage1d: PFNGLCOMPRESSEDTEXIMAGE1DPROC,

	/// The function pointer to `glCompressedTexSubImage3D()`
	pub compressedtexsubimage3d: PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC,

	/// The function pointer to `glCompressedTexSubImage2D()`
	pub compressedtexsubimage2d: PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC,

	/// The function pointer to `glCompressedTexSubImage1D()`
	pub compressedtexsubimage1d: PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC,

	/// The function pointer to `glGetCompressedTexImage()`
	pub getcompressedteximage: PFNGLGETCOMPRESSEDTEXIMAGEPROC,

	/// The function pointer to `glClientActiveTexture()`
	pub clientactivetexture: PFNGLCLIENTACTIVETEXTUREPROC,

	/// The function pointer to `glMultiTexCoord1d()`
	pub multitexcoord1d: PFNGLMULTITEXCOORD1DPROC,

	/// The function pointer to `glMultiTexCoord1dv()`
	pub multitexcoord1dv: PFNGLMULTITEXCOORD1DVPROC,

	/// The function pointer to `glMultiTexCoord1f()`
	pub multitexcoord1f: PFNGLMULTITEXCOORD1FPROC,

	/// The function pointer to `glMultiTexCoord1fv()`
	pub multitexcoord1fv: PFNGLMULTITEXCOORD1FVPROC,

	/// The function pointer to `glMultiTexCoord1i()`
	pub multitexcoord1i: PFNGLMULTITEXCOORD1IPROC,

	/// The function pointer to `glMultiTexCoord1iv()`
	pub multitexcoord1iv: PFNGLMULTITEXCOORD1IVPROC,

	/// The function pointer to `glMultiTexCoord1s()`
	pub multitexcoord1s: PFNGLMULTITEXCOORD1SPROC,

	/// The function pointer to `glMultiTexCoord1sv()`
	pub multitexcoord1sv: PFNGLMULTITEXCOORD1SVPROC,

	/// The function pointer to `glMultiTexCoord2d()`
	pub multitexcoord2d: PFNGLMULTITEXCOORD2DPROC,

	/// The function pointer to `glMultiTexCoord2dv()`
	pub multitexcoord2dv: PFNGLMULTITEXCOORD2DVPROC,

	/// The function pointer to `glMultiTexCoord2f()`
	pub multitexcoord2f: PFNGLMULTITEXCOORD2FPROC,

	/// The function pointer to `glMultiTexCoord2fv()`
	pub multitexcoord2fv: PFNGLMULTITEXCOORD2FVPROC,

	/// The function pointer to `glMultiTexCoord2i()`
	pub multitexcoord2i: PFNGLMULTITEXCOORD2IPROC,

	/// The function pointer to `glMultiTexCoord2iv()`
	pub multitexcoord2iv: PFNGLMULTITEXCOORD2IVPROC,

	/// The function pointer to `glMultiTexCoord2s()`
	pub multitexcoord2s: PFNGLMULTITEXCOORD2SPROC,

	/// The function pointer to `glMultiTexCoord2sv()`
	pub multitexcoord2sv: PFNGLMULTITEXCOORD2SVPROC,

	/// The function pointer to `glMultiTexCoord3d()`
	pub multitexcoord3d: PFNGLMULTITEXCOORD3DPROC,

	/// The function pointer to `glMultiTexCoord3dv()`
	pub multitexcoord3dv: PFNGLMULTITEXCOORD3DVPROC,

	/// The function pointer to `glMultiTexCoord3f()`
	pub multitexcoord3f: PFNGLMULTITEXCOORD3FPROC,

	/// The function pointer to `glMultiTexCoord3fv()`
	pub multitexcoord3fv: PFNGLMULTITEXCOORD3FVPROC,

	/// The function pointer to `glMultiTexCoord3i()`
	pub multitexcoord3i: PFNGLMULTITEXCOORD3IPROC,

	/// The function pointer to `glMultiTexCoord3iv()`
	pub multitexcoord3iv: PFNGLMULTITEXCOORD3IVPROC,

	/// The function pointer to `glMultiTexCoord3s()`
	pub multitexcoord3s: PFNGLMULTITEXCOORD3SPROC,

	/// The function pointer to `glMultiTexCoord3sv()`
	pub multitexcoord3sv: PFNGLMULTITEXCOORD3SVPROC,

	/// The function pointer to `glMultiTexCoord4d()`
	pub multitexcoord4d: PFNGLMULTITEXCOORD4DPROC,

	/// The function pointer to `glMultiTexCoord4dv()`
	pub multitexcoord4dv: PFNGLMULTITEXCOORD4DVPROC,

	/// The function pointer to `glMultiTexCoord4f()`
	pub multitexcoord4f: PFNGLMULTITEXCOORD4FPROC,

	/// The function pointer to `glMultiTexCoord4fv()`
	pub multitexcoord4fv: PFNGLMULTITEXCOORD4FVPROC,

	/// The function pointer to `glMultiTexCoord4i()`
	pub multitexcoord4i: PFNGLMULTITEXCOORD4IPROC,

	/// The function pointer to `glMultiTexCoord4iv()`
	pub multitexcoord4iv: PFNGLMULTITEXCOORD4IVPROC,

	/// The function pointer to `glMultiTexCoord4s()`
	pub multitexcoord4s: PFNGLMULTITEXCOORD4SPROC,

	/// The function pointer to `glMultiTexCoord4sv()`
	pub multitexcoord4sv: PFNGLMULTITEXCOORD4SVPROC,

	/// The function pointer to `glLoadTransposeMatrixf()`
	pub loadtransposematrixf: PFNGLLOADTRANSPOSEMATRIXFPROC,

	/// The function pointer to `glLoadTransposeMatrixd()`
	pub loadtransposematrixd: PFNGLLOADTRANSPOSEMATRIXDPROC,

	/// The function pointer to `glMultTransposeMatrixf()`
	pub multtransposematrixf: PFNGLMULTTRANSPOSEMATRIXFPROC,

	/// The function pointer to `glMultTransposeMatrixd()`
	pub multtransposematrixd: PFNGLMULTTRANSPOSEMATRIXDPROC,
}

impl GL_1_3 for Version13 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glActiveTexture.xhtml>
	#[inline(always)]
	fn glActiveTexture(&self, texture: GLenum) -> Result<()> {
		let ret = process_catch("glActiveTexture", catch_unwind(||(self.activetexture)(texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glActiveTexture", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSampleCoverage.xhtml>
	#[inline(always)]
	fn glSampleCoverage(&self, value: GLfloat, invert: GLboolean) -> Result<()> {
		let ret = process_catch("glSampleCoverage", catch_unwind(||(self.samplecoverage)(value, invert)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSampleCoverage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTexImage3D.xhtml>
	#[inline(always)]
	fn glCompressedTexImage3D(&self, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexImage3D", catch_unwind(||(self.compressedteximage3d)(target, level, internalformat, width, height, depth, border, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexImage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTexImage2D.xhtml>
	#[inline(always)]
	fn glCompressedTexImage2D(&self, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexImage2D", catch_unwind(||(self.compressedteximage2d)(target, level, internalformat, width, height, border, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexImage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTexImage1D.xhtml>
	#[inline(always)]
	fn glCompressedTexImage1D(&self, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexImage1D", catch_unwind(||(self.compressedteximage1d)(target, level, internalformat, width, border, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexImage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTexSubImage3D.xhtml>
	#[inline(always)]
	fn glCompressedTexSubImage3D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexSubImage3D", catch_unwind(||(self.compressedtexsubimage3d)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexSubImage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTexSubImage2D.xhtml>
	#[inline(always)]
	fn glCompressedTexSubImage2D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexSubImage2D", catch_unwind(||(self.compressedtexsubimage2d)(target, level, xoffset, yoffset, width, height, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexSubImage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTexSubImage1D.xhtml>
	#[inline(always)]
	fn glCompressedTexSubImage1D(&self, target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexSubImage1D", catch_unwind(||(self.compressedtexsubimage1d)(target, level, xoffset, width, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexSubImage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml>
	#[inline(always)]
	fn glGetCompressedTexImage(&self, target: GLenum, level: GLint, img: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetCompressedTexImage", catch_unwind(||(self.getcompressedteximage)(target, level, img)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetCompressedTexImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClientActiveTexture.xhtml>
	#[inline(always)]
	fn glClientActiveTexture(&self, texture: GLenum) -> Result<()> {
		let ret = process_catch("glClientActiveTexture", catch_unwind(||(self.clientactivetexture)(texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClientActiveTexture", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1d.xhtml>
	#[inline(always)]
	fn glMultiTexCoord1d(&self, target: GLenum, s: GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1d", catch_unwind(||(self.multitexcoord1d)(target, s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1dv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord1dv(&self, target: GLenum, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1dv", catch_unwind(||(self.multitexcoord1dv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1f.xhtml>
	#[inline(always)]
	fn glMultiTexCoord1f(&self, target: GLenum, s: GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1f", catch_unwind(||(self.multitexcoord1f)(target, s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1fv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord1fv(&self, target: GLenum, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1fv", catch_unwind(||(self.multitexcoord1fv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1i.xhtml>
	#[inline(always)]
	fn glMultiTexCoord1i(&self, target: GLenum, s: GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1i", catch_unwind(||(self.multitexcoord1i)(target, s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1iv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord1iv(&self, target: GLenum, v: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1iv", catch_unwind(||(self.multitexcoord1iv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1s.xhtml>
	#[inline(always)]
	fn glMultiTexCoord1s(&self, target: GLenum, s: GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1s", catch_unwind(||(self.multitexcoord1s)(target, s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1sv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord1sv(&self, target: GLenum, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1sv", catch_unwind(||(self.multitexcoord1sv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2d.xhtml>
	#[inline(always)]
	fn glMultiTexCoord2d(&self, target: GLenum, s: GLdouble, t: GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2d", catch_unwind(||(self.multitexcoord2d)(target, s, t)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2dv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord2dv(&self, target: GLenum, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2dv", catch_unwind(||(self.multitexcoord2dv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2f.xhtml>
	#[inline(always)]
	fn glMultiTexCoord2f(&self, target: GLenum, s: GLfloat, t: GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2f", catch_unwind(||(self.multitexcoord2f)(target, s, t)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2fv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord2fv(&self, target: GLenum, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2fv", catch_unwind(||(self.multitexcoord2fv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2i.xhtml>
	#[inline(always)]
	fn glMultiTexCoord2i(&self, target: GLenum, s: GLint, t: GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2i", catch_unwind(||(self.multitexcoord2i)(target, s, t)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2iv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord2iv(&self, target: GLenum, v: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2iv", catch_unwind(||(self.multitexcoord2iv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2s.xhtml>
	#[inline(always)]
	fn glMultiTexCoord2s(&self, target: GLenum, s: GLshort, t: GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2s", catch_unwind(||(self.multitexcoord2s)(target, s, t)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2sv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord2sv(&self, target: GLenum, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2sv", catch_unwind(||(self.multitexcoord2sv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3d.xhtml>
	#[inline(always)]
	fn glMultiTexCoord3d(&self, target: GLenum, s: GLdouble, t: GLdouble, r: GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3d", catch_unwind(||(self.multitexcoord3d)(target, s, t, r)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3dv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord3dv(&self, target: GLenum, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3dv", catch_unwind(||(self.multitexcoord3dv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3f.xhtml>
	#[inline(always)]
	fn glMultiTexCoord3f(&self, target: GLenum, s: GLfloat, t: GLfloat, r: GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3f", catch_unwind(||(self.multitexcoord3f)(target, s, t, r)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3fv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord3fv(&self, target: GLenum, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3fv", catch_unwind(||(self.multitexcoord3fv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3i.xhtml>
	#[inline(always)]
	fn glMultiTexCoord3i(&self, target: GLenum, s: GLint, t: GLint, r: GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3i", catch_unwind(||(self.multitexcoord3i)(target, s, t, r)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3iv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord3iv(&self, target: GLenum, v: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3iv", catch_unwind(||(self.multitexcoord3iv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3s.xhtml>
	#[inline(always)]
	fn glMultiTexCoord3s(&self, target: GLenum, s: GLshort, t: GLshort, r: GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3s", catch_unwind(||(self.multitexcoord3s)(target, s, t, r)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3sv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord3sv(&self, target: GLenum, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3sv", catch_unwind(||(self.multitexcoord3sv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4d.xhtml>
	#[inline(always)]
	fn glMultiTexCoord4d(&self, target: GLenum, s: GLdouble, t: GLdouble, r: GLdouble, q: GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4d", catch_unwind(||(self.multitexcoord4d)(target, s, t, r, q)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4dv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord4dv(&self, target: GLenum, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4dv", catch_unwind(||(self.multitexcoord4dv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4f.xhtml>
	#[inline(always)]
	fn glMultiTexCoord4f(&self, target: GLenum, s: GLfloat, t: GLfloat, r: GLfloat, q: GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4f", catch_unwind(||(self.multitexcoord4f)(target, s, t, r, q)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4fv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord4fv(&self, target: GLenum, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4fv", catch_unwind(||(self.multitexcoord4fv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4i.xhtml>
	#[inline(always)]
	fn glMultiTexCoord4i(&self, target: GLenum, s: GLint, t: GLint, r: GLint, q: GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4i", catch_unwind(||(self.multitexcoord4i)(target, s, t, r, q)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4iv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord4iv(&self, target: GLenum, v: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4iv", catch_unwind(||(self.multitexcoord4iv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4s.xhtml>
	#[inline(always)]
	fn glMultiTexCoord4s(&self, target: GLenum, s: GLshort, t: GLshort, r: GLshort, q: GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4s", catch_unwind(||(self.multitexcoord4s)(target, s, t, r, q)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4sv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord4sv(&self, target: GLenum, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4sv", catch_unwind(||(self.multitexcoord4sv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLoadTransposeMatrixf.xhtml>
	#[inline(always)]
	fn glLoadTransposeMatrixf(&self, m: *const GLfloat) -> Result<()> {
		let ret = process_catch("glLoadTransposeMatrixf", catch_unwind(||(self.loadtransposematrixf)(m)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLoadTransposeMatrixf", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLoadTransposeMatrixd.xhtml>
	#[inline(always)]
	fn glLoadTransposeMatrixd(&self, m: *const GLdouble) -> Result<()> {
		let ret = process_catch("glLoadTransposeMatrixd", catch_unwind(||(self.loadtransposematrixd)(m)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLoadTransposeMatrixd", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultTransposeMatrixf.xhtml>
	#[inline(always)]
	fn glMultTransposeMatrixf(&self, m: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultTransposeMatrixf", catch_unwind(||(self.multtransposematrixf)(m)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultTransposeMatrixf", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultTransposeMatrixd.xhtml>
	#[inline(always)]
	fn glMultTransposeMatrixd(&self, m: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultTransposeMatrixd", catch_unwind(||(self.multtransposematrixd)(m)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultTransposeMatrixd", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version13 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (1, 3, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			activetexture: {let proc = get_proc_address("glActiveTexture"); if proc == null() {dummy_pfnglactivetextureproc} else {unsafe{transmute(proc)}}},
			samplecoverage: {let proc = get_proc_address("glSampleCoverage"); if proc == null() {dummy_pfnglsamplecoverageproc} else {unsafe{transmute(proc)}}},
			compressedteximage3d: {let proc = get_proc_address("glCompressedTexImage3D"); if proc == null() {dummy_pfnglcompressedteximage3dproc} else {unsafe{transmute(proc)}}},
			compressedteximage2d: {let proc = get_proc_address("glCompressedTexImage2D"); if proc == null() {dummy_pfnglcompressedteximage2dproc} else {unsafe{transmute(proc)}}},
			compressedteximage1d: {let proc = get_proc_address("glCompressedTexImage1D"); if proc == null() {dummy_pfnglcompressedteximage1dproc} else {unsafe{transmute(proc)}}},
			compressedtexsubimage3d: {let proc = get_proc_address("glCompressedTexSubImage3D"); if proc == null() {dummy_pfnglcompressedtexsubimage3dproc} else {unsafe{transmute(proc)}}},
			compressedtexsubimage2d: {let proc = get_proc_address("glCompressedTexSubImage2D"); if proc == null() {dummy_pfnglcompressedtexsubimage2dproc} else {unsafe{transmute(proc)}}},
			compressedtexsubimage1d: {let proc = get_proc_address("glCompressedTexSubImage1D"); if proc == null() {dummy_pfnglcompressedtexsubimage1dproc} else {unsafe{transmute(proc)}}},
			getcompressedteximage: {let proc = get_proc_address("glGetCompressedTexImage"); if proc == null() {dummy_pfnglgetcompressedteximageproc} else {unsafe{transmute(proc)}}},
			clientactivetexture: {let proc = get_proc_address("glClientActiveTexture"); if proc == null() {dummy_pfnglclientactivetextureproc} else {unsafe{transmute(proc)}}},
			multitexcoord1d: {let proc = get_proc_address("glMultiTexCoord1d"); if proc == null() {dummy_pfnglmultitexcoord1dproc} else {unsafe{transmute(proc)}}},
			multitexcoord1dv: {let proc = get_proc_address("glMultiTexCoord1dv"); if proc == null() {dummy_pfnglmultitexcoord1dvproc} else {unsafe{transmute(proc)}}},
			multitexcoord1f: {let proc = get_proc_address("glMultiTexCoord1f"); if proc == null() {dummy_pfnglmultitexcoord1fproc} else {unsafe{transmute(proc)}}},
			multitexcoord1fv: {let proc = get_proc_address("glMultiTexCoord1fv"); if proc == null() {dummy_pfnglmultitexcoord1fvproc} else {unsafe{transmute(proc)}}},
			multitexcoord1i: {let proc = get_proc_address("glMultiTexCoord1i"); if proc == null() {dummy_pfnglmultitexcoord1iproc} else {unsafe{transmute(proc)}}},
			multitexcoord1iv: {let proc = get_proc_address("glMultiTexCoord1iv"); if proc == null() {dummy_pfnglmultitexcoord1ivproc} else {unsafe{transmute(proc)}}},
			multitexcoord1s: {let proc = get_proc_address("glMultiTexCoord1s"); if proc == null() {dummy_pfnglmultitexcoord1sproc} else {unsafe{transmute(proc)}}},
			multitexcoord1sv: {let proc = get_proc_address("glMultiTexCoord1sv"); if proc == null() {dummy_pfnglmultitexcoord1svproc} else {unsafe{transmute(proc)}}},
			multitexcoord2d: {let proc = get_proc_address("glMultiTexCoord2d"); if proc == null() {dummy_pfnglmultitexcoord2dproc} else {unsafe{transmute(proc)}}},
			multitexcoord2dv: {let proc = get_proc_address("glMultiTexCoord2dv"); if proc == null() {dummy_pfnglmultitexcoord2dvproc} else {unsafe{transmute(proc)}}},
			multitexcoord2f: {let proc = get_proc_address("glMultiTexCoord2f"); if proc == null() {dummy_pfnglmultitexcoord2fproc} else {unsafe{transmute(proc)}}},
			multitexcoord2fv: {let proc = get_proc_address("glMultiTexCoord2fv"); if proc == null() {dummy_pfnglmultitexcoord2fvproc} else {unsafe{transmute(proc)}}},
			multitexcoord2i: {let proc = get_proc_address("glMultiTexCoord2i"); if proc == null() {dummy_pfnglmultitexcoord2iproc} else {unsafe{transmute(proc)}}},
			multitexcoord2iv: {let proc = get_proc_address("glMultiTexCoord2iv"); if proc == null() {dummy_pfnglmultitexcoord2ivproc} else {unsafe{transmute(proc)}}},
			multitexcoord2s: {let proc = get_proc_address("glMultiTexCoord2s"); if proc == null() {dummy_pfnglmultitexcoord2sproc} else {unsafe{transmute(proc)}}},
			multitexcoord2sv: {let proc = get_proc_address("glMultiTexCoord2sv"); if proc == null() {dummy_pfnglmultitexcoord2svproc} else {unsafe{transmute(proc)}}},
			multitexcoord3d: {let proc = get_proc_address("glMultiTexCoord3d"); if proc == null() {dummy_pfnglmultitexcoord3dproc} else {unsafe{transmute(proc)}}},
			multitexcoord3dv: {let proc = get_proc_address("glMultiTexCoord3dv"); if proc == null() {dummy_pfnglmultitexcoord3dvproc} else {unsafe{transmute(proc)}}},
			multitexcoord3f: {let proc = get_proc_address("glMultiTexCoord3f"); if proc == null() {dummy_pfnglmultitexcoord3fproc} else {unsafe{transmute(proc)}}},
			multitexcoord3fv: {let proc = get_proc_address("glMultiTexCoord3fv"); if proc == null() {dummy_pfnglmultitexcoord3fvproc} else {unsafe{transmute(proc)}}},
			multitexcoord3i: {let proc = get_proc_address("glMultiTexCoord3i"); if proc == null() {dummy_pfnglmultitexcoord3iproc} else {unsafe{transmute(proc)}}},
			multitexcoord3iv: {let proc = get_proc_address("glMultiTexCoord3iv"); if proc == null() {dummy_pfnglmultitexcoord3ivproc} else {unsafe{transmute(proc)}}},
			multitexcoord3s: {let proc = get_proc_address("glMultiTexCoord3s"); if proc == null() {dummy_pfnglmultitexcoord3sproc} else {unsafe{transmute(proc)}}},
			multitexcoord3sv: {let proc = get_proc_address("glMultiTexCoord3sv"); if proc == null() {dummy_pfnglmultitexcoord3svproc} else {unsafe{transmute(proc)}}},
			multitexcoord4d: {let proc = get_proc_address("glMultiTexCoord4d"); if proc == null() {dummy_pfnglmultitexcoord4dproc} else {unsafe{transmute(proc)}}},
			multitexcoord4dv: {let proc = get_proc_address("glMultiTexCoord4dv"); if proc == null() {dummy_pfnglmultitexcoord4dvproc} else {unsafe{transmute(proc)}}},
			multitexcoord4f: {let proc = get_proc_address("glMultiTexCoord4f"); if proc == null() {dummy_pfnglmultitexcoord4fproc} else {unsafe{transmute(proc)}}},
			multitexcoord4fv: {let proc = get_proc_address("glMultiTexCoord4fv"); if proc == null() {dummy_pfnglmultitexcoord4fvproc} else {unsafe{transmute(proc)}}},
			multitexcoord4i: {let proc = get_proc_address("glMultiTexCoord4i"); if proc == null() {dummy_pfnglmultitexcoord4iproc} else {unsafe{transmute(proc)}}},
			multitexcoord4iv: {let proc = get_proc_address("glMultiTexCoord4iv"); if proc == null() {dummy_pfnglmultitexcoord4ivproc} else {unsafe{transmute(proc)}}},
			multitexcoord4s: {let proc = get_proc_address("glMultiTexCoord4s"); if proc == null() {dummy_pfnglmultitexcoord4sproc} else {unsafe{transmute(proc)}}},
			multitexcoord4sv: {let proc = get_proc_address("glMultiTexCoord4sv"); if proc == null() {dummy_pfnglmultitexcoord4svproc} else {unsafe{transmute(proc)}}},
			loadtransposematrixf: {let proc = get_proc_address("glLoadTransposeMatrixf"); if proc == null() {dummy_pfnglloadtransposematrixfproc} else {unsafe{transmute(proc)}}},
			loadtransposematrixd: {let proc = get_proc_address("glLoadTransposeMatrixd"); if proc == null() {dummy_pfnglloadtransposematrixdproc} else {unsafe{transmute(proc)}}},
			multtransposematrixf: {let proc = get_proc_address("glMultTransposeMatrixf"); if proc == null() {dummy_pfnglmulttransposematrixfproc} else {unsafe{transmute(proc)}}},
			multtransposematrixd: {let proc = get_proc_address("glMultTransposeMatrixd"); if proc == null() {dummy_pfnglmulttransposematrixdproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version13 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			activetexture: dummy_pfnglactivetextureproc,
			samplecoverage: dummy_pfnglsamplecoverageproc,
			compressedteximage3d: dummy_pfnglcompressedteximage3dproc,
			compressedteximage2d: dummy_pfnglcompressedteximage2dproc,
			compressedteximage1d: dummy_pfnglcompressedteximage1dproc,
			compressedtexsubimage3d: dummy_pfnglcompressedtexsubimage3dproc,
			compressedtexsubimage2d: dummy_pfnglcompressedtexsubimage2dproc,
			compressedtexsubimage1d: dummy_pfnglcompressedtexsubimage1dproc,
			getcompressedteximage: dummy_pfnglgetcompressedteximageproc,
			clientactivetexture: dummy_pfnglclientactivetextureproc,
			multitexcoord1d: dummy_pfnglmultitexcoord1dproc,
			multitexcoord1dv: dummy_pfnglmultitexcoord1dvproc,
			multitexcoord1f: dummy_pfnglmultitexcoord1fproc,
			multitexcoord1fv: dummy_pfnglmultitexcoord1fvproc,
			multitexcoord1i: dummy_pfnglmultitexcoord1iproc,
			multitexcoord1iv: dummy_pfnglmultitexcoord1ivproc,
			multitexcoord1s: dummy_pfnglmultitexcoord1sproc,
			multitexcoord1sv: dummy_pfnglmultitexcoord1svproc,
			multitexcoord2d: dummy_pfnglmultitexcoord2dproc,
			multitexcoord2dv: dummy_pfnglmultitexcoord2dvproc,
			multitexcoord2f: dummy_pfnglmultitexcoord2fproc,
			multitexcoord2fv: dummy_pfnglmultitexcoord2fvproc,
			multitexcoord2i: dummy_pfnglmultitexcoord2iproc,
			multitexcoord2iv: dummy_pfnglmultitexcoord2ivproc,
			multitexcoord2s: dummy_pfnglmultitexcoord2sproc,
			multitexcoord2sv: dummy_pfnglmultitexcoord2svproc,
			multitexcoord3d: dummy_pfnglmultitexcoord3dproc,
			multitexcoord3dv: dummy_pfnglmultitexcoord3dvproc,
			multitexcoord3f: dummy_pfnglmultitexcoord3fproc,
			multitexcoord3fv: dummy_pfnglmultitexcoord3fvproc,
			multitexcoord3i: dummy_pfnglmultitexcoord3iproc,
			multitexcoord3iv: dummy_pfnglmultitexcoord3ivproc,
			multitexcoord3s: dummy_pfnglmultitexcoord3sproc,
			multitexcoord3sv: dummy_pfnglmultitexcoord3svproc,
			multitexcoord4d: dummy_pfnglmultitexcoord4dproc,
			multitexcoord4dv: dummy_pfnglmultitexcoord4dvproc,
			multitexcoord4f: dummy_pfnglmultitexcoord4fproc,
			multitexcoord4fv: dummy_pfnglmultitexcoord4fvproc,
			multitexcoord4i: dummy_pfnglmultitexcoord4iproc,
			multitexcoord4iv: dummy_pfnglmultitexcoord4ivproc,
			multitexcoord4s: dummy_pfnglmultitexcoord4sproc,
			multitexcoord4sv: dummy_pfnglmultitexcoord4svproc,
			loadtransposematrixf: dummy_pfnglloadtransposematrixfproc,
			loadtransposematrixd: dummy_pfnglloadtransposematrixdproc,
			multtransposematrixf: dummy_pfnglmulttransposematrixfproc,
			multtransposematrixd: dummy_pfnglmulttransposematrixdproc,
		}
	}
}
impl Debug for Version13 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version13")
			.field("available", &self.available)
			.field("activetexture", unsafe{if transmute::<_, *const c_void>(self.activetexture) == (dummy_pfnglactivetextureproc as *const c_void) {&null::<PFNGLACTIVETEXTUREPROC>()} else {&self.activetexture}})
			.field("samplecoverage", unsafe{if transmute::<_, *const c_void>(self.samplecoverage) == (dummy_pfnglsamplecoverageproc as *const c_void) {&null::<PFNGLSAMPLECOVERAGEPROC>()} else {&self.samplecoverage}})
			.field("compressedteximage3d", unsafe{if transmute::<_, *const c_void>(self.compressedteximage3d) == (dummy_pfnglcompressedteximage3dproc as *const c_void) {&null::<PFNGLCOMPRESSEDTEXIMAGE3DPROC>()} else {&self.compressedteximage3d}})
			.field("compressedteximage2d", unsafe{if transmute::<_, *const c_void>(self.compressedteximage2d) == (dummy_pfnglcompressedteximage2dproc as *const c_void) {&null::<PFNGLCOMPRESSEDTEXIMAGE2DPROC>()} else {&self.compressedteximage2d}})
			.field("compressedteximage1d", unsafe{if transmute::<_, *const c_void>(self.compressedteximage1d) == (dummy_pfnglcompressedteximage1dproc as *const c_void) {&null::<PFNGLCOMPRESSEDTEXIMAGE1DPROC>()} else {&self.compressedteximage1d}})
			.field("compressedtexsubimage3d", unsafe{if transmute::<_, *const c_void>(self.compressedtexsubimage3d) == (dummy_pfnglcompressedtexsubimage3dproc as *const c_void) {&null::<PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC>()} else {&self.compressedtexsubimage3d}})
			.field("compressedtexsubimage2d", unsafe{if transmute::<_, *const c_void>(self.compressedtexsubimage2d) == (dummy_pfnglcompressedtexsubimage2dproc as *const c_void) {&null::<PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC>()} else {&self.compressedtexsubimage2d}})
			.field("compressedtexsubimage1d", unsafe{if transmute::<_, *const c_void>(self.compressedtexsubimage1d) == (dummy_pfnglcompressedtexsubimage1dproc as *const c_void) {&null::<PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC>()} else {&self.compressedtexsubimage1d}})
			.field("getcompressedteximage", unsafe{if transmute::<_, *const c_void>(self.getcompressedteximage) == (dummy_pfnglgetcompressedteximageproc as *const c_void) {&null::<PFNGLGETCOMPRESSEDTEXIMAGEPROC>()} else {&self.getcompressedteximage}})
			.field("clientactivetexture", unsafe{if transmute::<_, *const c_void>(self.clientactivetexture) == (dummy_pfnglclientactivetextureproc as *const c_void) {&null::<PFNGLCLIENTACTIVETEXTUREPROC>()} else {&self.clientactivetexture}})
			.field("multitexcoord1d", unsafe{if transmute::<_, *const c_void>(self.multitexcoord1d) == (dummy_pfnglmultitexcoord1dproc as *const c_void) {&null::<PFNGLMULTITEXCOORD1DPROC>()} else {&self.multitexcoord1d}})
			.field("multitexcoord1dv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord1dv) == (dummy_pfnglmultitexcoord1dvproc as *const c_void) {&null::<PFNGLMULTITEXCOORD1DVPROC>()} else {&self.multitexcoord1dv}})
			.field("multitexcoord1f", unsafe{if transmute::<_, *const c_void>(self.multitexcoord1f) == (dummy_pfnglmultitexcoord1fproc as *const c_void) {&null::<PFNGLMULTITEXCOORD1FPROC>()} else {&self.multitexcoord1f}})
			.field("multitexcoord1fv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord1fv) == (dummy_pfnglmultitexcoord1fvproc as *const c_void) {&null::<PFNGLMULTITEXCOORD1FVPROC>()} else {&self.multitexcoord1fv}})
			.field("multitexcoord1i", unsafe{if transmute::<_, *const c_void>(self.multitexcoord1i) == (dummy_pfnglmultitexcoord1iproc as *const c_void) {&null::<PFNGLMULTITEXCOORD1IPROC>()} else {&self.multitexcoord1i}})
			.field("multitexcoord1iv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord1iv) == (dummy_pfnglmultitexcoord1ivproc as *const c_void) {&null::<PFNGLMULTITEXCOORD1IVPROC>()} else {&self.multitexcoord1iv}})
			.field("multitexcoord1s", unsafe{if transmute::<_, *const c_void>(self.multitexcoord1s) == (dummy_pfnglmultitexcoord1sproc as *const c_void) {&null::<PFNGLMULTITEXCOORD1SPROC>()} else {&self.multitexcoord1s}})
			.field("multitexcoord1sv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord1sv) == (dummy_pfnglmultitexcoord1svproc as *const c_void) {&null::<PFNGLMULTITEXCOORD1SVPROC>()} else {&self.multitexcoord1sv}})
			.field("multitexcoord2d", unsafe{if transmute::<_, *const c_void>(self.multitexcoord2d) == (dummy_pfnglmultitexcoord2dproc as *const c_void) {&null::<PFNGLMULTITEXCOORD2DPROC>()} else {&self.multitexcoord2d}})
			.field("multitexcoord2dv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord2dv) == (dummy_pfnglmultitexcoord2dvproc as *const c_void) {&null::<PFNGLMULTITEXCOORD2DVPROC>()} else {&self.multitexcoord2dv}})
			.field("multitexcoord2f", unsafe{if transmute::<_, *const c_void>(self.multitexcoord2f) == (dummy_pfnglmultitexcoord2fproc as *const c_void) {&null::<PFNGLMULTITEXCOORD2FPROC>()} else {&self.multitexcoord2f}})
			.field("multitexcoord2fv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord2fv) == (dummy_pfnglmultitexcoord2fvproc as *const c_void) {&null::<PFNGLMULTITEXCOORD2FVPROC>()} else {&self.multitexcoord2fv}})
			.field("multitexcoord2i", unsafe{if transmute::<_, *const c_void>(self.multitexcoord2i) == (dummy_pfnglmultitexcoord2iproc as *const c_void) {&null::<PFNGLMULTITEXCOORD2IPROC>()} else {&self.multitexcoord2i}})
			.field("multitexcoord2iv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord2iv) == (dummy_pfnglmultitexcoord2ivproc as *const c_void) {&null::<PFNGLMULTITEXCOORD2IVPROC>()} else {&self.multitexcoord2iv}})
			.field("multitexcoord2s", unsafe{if transmute::<_, *const c_void>(self.multitexcoord2s) == (dummy_pfnglmultitexcoord2sproc as *const c_void) {&null::<PFNGLMULTITEXCOORD2SPROC>()} else {&self.multitexcoord2s}})
			.field("multitexcoord2sv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord2sv) == (dummy_pfnglmultitexcoord2svproc as *const c_void) {&null::<PFNGLMULTITEXCOORD2SVPROC>()} else {&self.multitexcoord2sv}})
			.field("multitexcoord3d", unsafe{if transmute::<_, *const c_void>(self.multitexcoord3d) == (dummy_pfnglmultitexcoord3dproc as *const c_void) {&null::<PFNGLMULTITEXCOORD3DPROC>()} else {&self.multitexcoord3d}})
			.field("multitexcoord3dv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord3dv) == (dummy_pfnglmultitexcoord3dvproc as *const c_void) {&null::<PFNGLMULTITEXCOORD3DVPROC>()} else {&self.multitexcoord3dv}})
			.field("multitexcoord3f", unsafe{if transmute::<_, *const c_void>(self.multitexcoord3f) == (dummy_pfnglmultitexcoord3fproc as *const c_void) {&null::<PFNGLMULTITEXCOORD3FPROC>()} else {&self.multitexcoord3f}})
			.field("multitexcoord3fv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord3fv) == (dummy_pfnglmultitexcoord3fvproc as *const c_void) {&null::<PFNGLMULTITEXCOORD3FVPROC>()} else {&self.multitexcoord3fv}})
			.field("multitexcoord3i", unsafe{if transmute::<_, *const c_void>(self.multitexcoord3i) == (dummy_pfnglmultitexcoord3iproc as *const c_void) {&null::<PFNGLMULTITEXCOORD3IPROC>()} else {&self.multitexcoord3i}})
			.field("multitexcoord3iv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord3iv) == (dummy_pfnglmultitexcoord3ivproc as *const c_void) {&null::<PFNGLMULTITEXCOORD3IVPROC>()} else {&self.multitexcoord3iv}})
			.field("multitexcoord3s", unsafe{if transmute::<_, *const c_void>(self.multitexcoord3s) == (dummy_pfnglmultitexcoord3sproc as *const c_void) {&null::<PFNGLMULTITEXCOORD3SPROC>()} else {&self.multitexcoord3s}})
			.field("multitexcoord3sv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord3sv) == (dummy_pfnglmultitexcoord3svproc as *const c_void) {&null::<PFNGLMULTITEXCOORD3SVPROC>()} else {&self.multitexcoord3sv}})
			.field("multitexcoord4d", unsafe{if transmute::<_, *const c_void>(self.multitexcoord4d) == (dummy_pfnglmultitexcoord4dproc as *const c_void) {&null::<PFNGLMULTITEXCOORD4DPROC>()} else {&self.multitexcoord4d}})
			.field("multitexcoord4dv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord4dv) == (dummy_pfnglmultitexcoord4dvproc as *const c_void) {&null::<PFNGLMULTITEXCOORD4DVPROC>()} else {&self.multitexcoord4dv}})
			.field("multitexcoord4f", unsafe{if transmute::<_, *const c_void>(self.multitexcoord4f) == (dummy_pfnglmultitexcoord4fproc as *const c_void) {&null::<PFNGLMULTITEXCOORD4FPROC>()} else {&self.multitexcoord4f}})
			.field("multitexcoord4fv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord4fv) == (dummy_pfnglmultitexcoord4fvproc as *const c_void) {&null::<PFNGLMULTITEXCOORD4FVPROC>()} else {&self.multitexcoord4fv}})
			.field("multitexcoord4i", unsafe{if transmute::<_, *const c_void>(self.multitexcoord4i) == (dummy_pfnglmultitexcoord4iproc as *const c_void) {&null::<PFNGLMULTITEXCOORD4IPROC>()} else {&self.multitexcoord4i}})
			.field("multitexcoord4iv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord4iv) == (dummy_pfnglmultitexcoord4ivproc as *const c_void) {&null::<PFNGLMULTITEXCOORD4IVPROC>()} else {&self.multitexcoord4iv}})
			.field("multitexcoord4s", unsafe{if transmute::<_, *const c_void>(self.multitexcoord4s) == (dummy_pfnglmultitexcoord4sproc as *const c_void) {&null::<PFNGLMULTITEXCOORD4SPROC>()} else {&self.multitexcoord4s}})
			.field("multitexcoord4sv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord4sv) == (dummy_pfnglmultitexcoord4svproc as *const c_void) {&null::<PFNGLMULTITEXCOORD4SVPROC>()} else {&self.multitexcoord4sv}})
			.field("loadtransposematrixf", unsafe{if transmute::<_, *const c_void>(self.loadtransposematrixf) == (dummy_pfnglloadtransposematrixfproc as *const c_void) {&null::<PFNGLLOADTRANSPOSEMATRIXFPROC>()} else {&self.loadtransposematrixf}})
			.field("loadtransposematrixd", unsafe{if transmute::<_, *const c_void>(self.loadtransposematrixd) == (dummy_pfnglloadtransposematrixdproc as *const c_void) {&null::<PFNGLLOADTRANSPOSEMATRIXDPROC>()} else {&self.loadtransposematrixd}})
			.field("multtransposematrixf", unsafe{if transmute::<_, *const c_void>(self.multtransposematrixf) == (dummy_pfnglmulttransposematrixfproc as *const c_void) {&null::<PFNGLMULTTRANSPOSEMATRIXFPROC>()} else {&self.multtransposematrixf}})
			.field("multtransposematrixd", unsafe{if transmute::<_, *const c_void>(self.multtransposematrixd) == (dummy_pfnglmulttransposematrixdproc as *const c_void) {&null::<PFNGLMULTTRANSPOSEMATRIXDPROC>()} else {&self.multtransposematrixd}})
			.finish()
		} else {
			f.debug_struct("Version13")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

/// The prototype to the OpenGL function `BlendFuncSeparate`
type PFNGLBLENDFUNCSEPARATEPROC = extern "system" fn(GLenum, GLenum, GLenum, GLenum);

/// The prototype to the OpenGL function `MultiDrawArrays`
type PFNGLMULTIDRAWARRAYSPROC = extern "system" fn(GLenum, *const GLint, *const GLsizei, GLsizei);

/// The prototype to the OpenGL function `MultiDrawElements`
type PFNGLMULTIDRAWELEMENTSPROC = extern "system" fn(GLenum, *const GLsizei, GLenum, *const *const c_void, GLsizei);

/// The prototype to the OpenGL function `PointParameterf`
type PFNGLPOINTPARAMETERFPROC = extern "system" fn(GLenum, GLfloat);

/// The prototype to the OpenGL function `PointParameterfv`
type PFNGLPOINTPARAMETERFVPROC = extern "system" fn(GLenum, *const GLfloat);

/// The prototype to the OpenGL function `PointParameteri`
type PFNGLPOINTPARAMETERIPROC = extern "system" fn(GLenum, GLint);

/// The prototype to the OpenGL function `PointParameteriv`
type PFNGLPOINTPARAMETERIVPROC = extern "system" fn(GLenum, *const GLint);

/// The prototype to the OpenGL function `FogCoordf`
type PFNGLFOGCOORDFPROC = extern "system" fn(GLfloat);

/// The prototype to the OpenGL function `FogCoordfv`
type PFNGLFOGCOORDFVPROC = extern "system" fn(*const GLfloat);

/// The prototype to the OpenGL function `FogCoordd`
type PFNGLFOGCOORDDPROC = extern "system" fn(GLdouble);

/// The prototype to the OpenGL function `FogCoorddv`
type PFNGLFOGCOORDDVPROC = extern "system" fn(*const GLdouble);

/// The prototype to the OpenGL function `FogCoordPointer`
type PFNGLFOGCOORDPOINTERPROC = extern "system" fn(GLenum, GLsizei, *const c_void);

/// The prototype to the OpenGL function `SecondaryColor3b`
type PFNGLSECONDARYCOLOR3BPROC = extern "system" fn(GLbyte, GLbyte, GLbyte);

/// The prototype to the OpenGL function `SecondaryColor3bv`
type PFNGLSECONDARYCOLOR3BVPROC = extern "system" fn(*const GLbyte);

/// The prototype to the OpenGL function `SecondaryColor3d`
type PFNGLSECONDARYCOLOR3DPROC = extern "system" fn(GLdouble, GLdouble, GLdouble);

/// The prototype to the OpenGL function `SecondaryColor3dv`
type PFNGLSECONDARYCOLOR3DVPROC = extern "system" fn(*const GLdouble);

/// The prototype to the OpenGL function `SecondaryColor3f`
type PFNGLSECONDARYCOLOR3FPROC = extern "system" fn(GLfloat, GLfloat, GLfloat);

/// The prototype to the OpenGL function `SecondaryColor3fv`
type PFNGLSECONDARYCOLOR3FVPROC = extern "system" fn(*const GLfloat);

/// The prototype to the OpenGL function `SecondaryColor3i`
type PFNGLSECONDARYCOLOR3IPROC = extern "system" fn(GLint, GLint, GLint);

/// The prototype to the OpenGL function `SecondaryColor3iv`
type PFNGLSECONDARYCOLOR3IVPROC = extern "system" fn(*const GLint);

/// The prototype to the OpenGL function `SecondaryColor3s`
type PFNGLSECONDARYCOLOR3SPROC = extern "system" fn(GLshort, GLshort, GLshort);

/// The prototype to the OpenGL function `SecondaryColor3sv`
type PFNGLSECONDARYCOLOR3SVPROC = extern "system" fn(*const GLshort);

/// The prototype to the OpenGL function `SecondaryColor3ub`
type PFNGLSECONDARYCOLOR3UBPROC = extern "system" fn(GLubyte, GLubyte, GLubyte);

/// The prototype to the OpenGL function `SecondaryColor3ubv`
type PFNGLSECONDARYCOLOR3UBVPROC = extern "system" fn(*const GLubyte);

/// The prototype to the OpenGL function `SecondaryColor3ui`
type PFNGLSECONDARYCOLOR3UIPROC = extern "system" fn(GLuint, GLuint, GLuint);

/// The prototype to the OpenGL function `SecondaryColor3uiv`
type PFNGLSECONDARYCOLOR3UIVPROC = extern "system" fn(*const GLuint);

/// The prototype to the OpenGL function `SecondaryColor3us`
type PFNGLSECONDARYCOLOR3USPROC = extern "system" fn(GLushort, GLushort, GLushort);

/// The prototype to the OpenGL function `SecondaryColor3usv`
type PFNGLSECONDARYCOLOR3USVPROC = extern "system" fn(*const GLushort);

/// The prototype to the OpenGL function `SecondaryColorPointer`
type PFNGLSECONDARYCOLORPOINTERPROC = extern "system" fn(GLint, GLenum, GLsizei, *const c_void);

/// The prototype to the OpenGL function `WindowPos2d`
type PFNGLWINDOWPOS2DPROC = extern "system" fn(GLdouble, GLdouble);

/// The prototype to the OpenGL function `WindowPos2dv`
type PFNGLWINDOWPOS2DVPROC = extern "system" fn(*const GLdouble);

/// The prototype to the OpenGL function `WindowPos2f`
type PFNGLWINDOWPOS2FPROC = extern "system" fn(GLfloat, GLfloat);

/// The prototype to the OpenGL function `WindowPos2fv`
type PFNGLWINDOWPOS2FVPROC = extern "system" fn(*const GLfloat);

/// The prototype to the OpenGL function `WindowPos2i`
type PFNGLWINDOWPOS2IPROC = extern "system" fn(GLint, GLint);

/// The prototype to the OpenGL function `WindowPos2iv`
type PFNGLWINDOWPOS2IVPROC = extern "system" fn(*const GLint);

/// The prototype to the OpenGL function `WindowPos2s`
type PFNGLWINDOWPOS2SPROC = extern "system" fn(GLshort, GLshort);

/// The prototype to the OpenGL function `WindowPos2sv`
type PFNGLWINDOWPOS2SVPROC = extern "system" fn(*const GLshort);

/// The prototype to the OpenGL function `WindowPos3d`
type PFNGLWINDOWPOS3DPROC = extern "system" fn(GLdouble, GLdouble, GLdouble);

/// The prototype to the OpenGL function `WindowPos3dv`
type PFNGLWINDOWPOS3DVPROC = extern "system" fn(*const GLdouble);

/// The prototype to the OpenGL function `WindowPos3f`
type PFNGLWINDOWPOS3FPROC = extern "system" fn(GLfloat, GLfloat, GLfloat);

/// The prototype to the OpenGL function `WindowPos3fv`
type PFNGLWINDOWPOS3FVPROC = extern "system" fn(*const GLfloat);

/// The prototype to the OpenGL function `WindowPos3i`
type PFNGLWINDOWPOS3IPROC = extern "system" fn(GLint, GLint, GLint);

/// The prototype to the OpenGL function `WindowPos3iv`
type PFNGLWINDOWPOS3IVPROC = extern "system" fn(*const GLint);

/// The prototype to the OpenGL function `WindowPos3s`
type PFNGLWINDOWPOS3SPROC = extern "system" fn(GLshort, GLshort, GLshort);

/// The prototype to the OpenGL function `WindowPos3sv`
type PFNGLWINDOWPOS3SVPROC = extern "system" fn(*const GLshort);

/// The prototype to the OpenGL function `BlendColor`
type PFNGLBLENDCOLORPROC = extern "system" fn(GLfloat, GLfloat, GLfloat, GLfloat);

/// The prototype to the OpenGL function `BlendEquation`
type PFNGLBLENDEQUATIONPROC = extern "system" fn(GLenum);

/// The dummy function of `BlendFuncSeparate()`
extern "system" fn dummy_pfnglblendfuncseparateproc (_: GLenum, _: GLenum, _: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glBlendFuncSeparate()` is null.")
}

/// The dummy function of `MultiDrawArrays()`
extern "system" fn dummy_pfnglmultidrawarraysproc (_: GLenum, _: *const GLint, _: *const GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glMultiDrawArrays()` is null.")
}

/// The dummy function of `MultiDrawElements()`
extern "system" fn dummy_pfnglmultidrawelementsproc (_: GLenum, _: *const GLsizei, _: GLenum, _: *const *const c_void, _: GLsizei) {
	panic!("OpenGL function pointer `glMultiDrawElements()` is null.")
}

/// The dummy function of `PointParameterf()`
extern "system" fn dummy_pfnglpointparameterfproc (_: GLenum, _: GLfloat) {
	panic!("OpenGL function pointer `glPointParameterf()` is null.")
}

/// The dummy function of `PointParameterfv()`
extern "system" fn dummy_pfnglpointparameterfvproc (_: GLenum, _: *const GLfloat) {
	panic!("OpenGL function pointer `glPointParameterfv()` is null.")
}

/// The dummy function of `PointParameteri()`
extern "system" fn dummy_pfnglpointparameteriproc (_: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glPointParameteri()` is null.")
}

/// The dummy function of `PointParameteriv()`
extern "system" fn dummy_pfnglpointparameterivproc (_: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glPointParameteriv()` is null.")
}

/// The dummy function of `FogCoordf()`
extern "system" fn dummy_pfnglfogcoordfproc (_: GLfloat) {
	panic!("OpenGL function pointer `glFogCoordf()` is null.")
}

/// The dummy function of `FogCoordfv()`
extern "system" fn dummy_pfnglfogcoordfvproc (_: *const GLfloat) {
	panic!("OpenGL function pointer `glFogCoordfv()` is null.")
}

/// The dummy function of `FogCoordd()`
extern "system" fn dummy_pfnglfogcoorddproc (_: GLdouble) {
	panic!("OpenGL function pointer `glFogCoordd()` is null.")
}

/// The dummy function of `FogCoorddv()`
extern "system" fn dummy_pfnglfogcoorddvproc (_: *const GLdouble) {
	panic!("OpenGL function pointer `glFogCoorddv()` is null.")
}

/// The dummy function of `FogCoordPointer()`
extern "system" fn dummy_pfnglfogcoordpointerproc (_: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glFogCoordPointer()` is null.")
}

/// The dummy function of `SecondaryColor3b()`
extern "system" fn dummy_pfnglsecondarycolor3bproc (_: GLbyte, _: GLbyte, _: GLbyte) {
	panic!("OpenGL function pointer `glSecondaryColor3b()` is null.")
}

/// The dummy function of `SecondaryColor3bv()`
extern "system" fn dummy_pfnglsecondarycolor3bvproc (_: *const GLbyte) {
	panic!("OpenGL function pointer `glSecondaryColor3bv()` is null.")
}

/// The dummy function of `SecondaryColor3d()`
extern "system" fn dummy_pfnglsecondarycolor3dproc (_: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glSecondaryColor3d()` is null.")
}

/// The dummy function of `SecondaryColor3dv()`
extern "system" fn dummy_pfnglsecondarycolor3dvproc (_: *const GLdouble) {
	panic!("OpenGL function pointer `glSecondaryColor3dv()` is null.")
}

/// The dummy function of `SecondaryColor3f()`
extern "system" fn dummy_pfnglsecondarycolor3fproc (_: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glSecondaryColor3f()` is null.")
}

/// The dummy function of `SecondaryColor3fv()`
extern "system" fn dummy_pfnglsecondarycolor3fvproc (_: *const GLfloat) {
	panic!("OpenGL function pointer `glSecondaryColor3fv()` is null.")
}

/// The dummy function of `SecondaryColor3i()`
extern "system" fn dummy_pfnglsecondarycolor3iproc (_: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glSecondaryColor3i()` is null.")
}

/// The dummy function of `SecondaryColor3iv()`
extern "system" fn dummy_pfnglsecondarycolor3ivproc (_: *const GLint) {
	panic!("OpenGL function pointer `glSecondaryColor3iv()` is null.")
}

/// The dummy function of `SecondaryColor3s()`
extern "system" fn dummy_pfnglsecondarycolor3sproc (_: GLshort, _: GLshort, _: GLshort) {
	panic!("OpenGL function pointer `glSecondaryColor3s()` is null.")
}

/// The dummy function of `SecondaryColor3sv()`
extern "system" fn dummy_pfnglsecondarycolor3svproc (_: *const GLshort) {
	panic!("OpenGL function pointer `glSecondaryColor3sv()` is null.")
}

/// The dummy function of `SecondaryColor3ub()`
extern "system" fn dummy_pfnglsecondarycolor3ubproc (_: GLubyte, _: GLubyte, _: GLubyte) {
	panic!("OpenGL function pointer `glSecondaryColor3ub()` is null.")
}

/// The dummy function of `SecondaryColor3ubv()`
extern "system" fn dummy_pfnglsecondarycolor3ubvproc (_: *const GLubyte) {
	panic!("OpenGL function pointer `glSecondaryColor3ubv()` is null.")
}

/// The dummy function of `SecondaryColor3ui()`
extern "system" fn dummy_pfnglsecondarycolor3uiproc (_: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glSecondaryColor3ui()` is null.")
}

/// The dummy function of `SecondaryColor3uiv()`
extern "system" fn dummy_pfnglsecondarycolor3uivproc (_: *const GLuint) {
	panic!("OpenGL function pointer `glSecondaryColor3uiv()` is null.")
}

/// The dummy function of `SecondaryColor3us()`
extern "system" fn dummy_pfnglsecondarycolor3usproc (_: GLushort, _: GLushort, _: GLushort) {
	panic!("OpenGL function pointer `glSecondaryColor3us()` is null.")
}

/// The dummy function of `SecondaryColor3usv()`
extern "system" fn dummy_pfnglsecondarycolor3usvproc (_: *const GLushort) {
	panic!("OpenGL function pointer `glSecondaryColor3usv()` is null.")
}

/// The dummy function of `SecondaryColorPointer()`
extern "system" fn dummy_pfnglsecondarycolorpointerproc (_: GLint, _: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glSecondaryColorPointer()` is null.")
}

/// The dummy function of `WindowPos2d()`
extern "system" fn dummy_pfnglwindowpos2dproc (_: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glWindowPos2d()` is null.")
}

/// The dummy function of `WindowPos2dv()`
extern "system" fn dummy_pfnglwindowpos2dvproc (_: *const GLdouble) {
	panic!("OpenGL function pointer `glWindowPos2dv()` is null.")
}

/// The dummy function of `WindowPos2f()`
extern "system" fn dummy_pfnglwindowpos2fproc (_: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glWindowPos2f()` is null.")
}

/// The dummy function of `WindowPos2fv()`
extern "system" fn dummy_pfnglwindowpos2fvproc (_: *const GLfloat) {
	panic!("OpenGL function pointer `glWindowPos2fv()` is null.")
}

/// The dummy function of `WindowPos2i()`
extern "system" fn dummy_pfnglwindowpos2iproc (_: GLint, _: GLint) {
	panic!("OpenGL function pointer `glWindowPos2i()` is null.")
}

/// The dummy function of `WindowPos2iv()`
extern "system" fn dummy_pfnglwindowpos2ivproc (_: *const GLint) {
	panic!("OpenGL function pointer `glWindowPos2iv()` is null.")
}

/// The dummy function of `WindowPos2s()`
extern "system" fn dummy_pfnglwindowpos2sproc (_: GLshort, _: GLshort) {
	panic!("OpenGL function pointer `glWindowPos2s()` is null.")
}

/// The dummy function of `WindowPos2sv()`
extern "system" fn dummy_pfnglwindowpos2svproc (_: *const GLshort) {
	panic!("OpenGL function pointer `glWindowPos2sv()` is null.")
}

/// The dummy function of `WindowPos3d()`
extern "system" fn dummy_pfnglwindowpos3dproc (_: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glWindowPos3d()` is null.")
}

/// The dummy function of `WindowPos3dv()`
extern "system" fn dummy_pfnglwindowpos3dvproc (_: *const GLdouble) {
	panic!("OpenGL function pointer `glWindowPos3dv()` is null.")
}

/// The dummy function of `WindowPos3f()`
extern "system" fn dummy_pfnglwindowpos3fproc (_: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glWindowPos3f()` is null.")
}

/// The dummy function of `WindowPos3fv()`
extern "system" fn dummy_pfnglwindowpos3fvproc (_: *const GLfloat) {
	panic!("OpenGL function pointer `glWindowPos3fv()` is null.")
}

/// The dummy function of `WindowPos3i()`
extern "system" fn dummy_pfnglwindowpos3iproc (_: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glWindowPos3i()` is null.")
}

/// The dummy function of `WindowPos3iv()`
extern "system" fn dummy_pfnglwindowpos3ivproc (_: *const GLint) {
	panic!("OpenGL function pointer `glWindowPos3iv()` is null.")
}

/// The dummy function of `WindowPos3s()`
extern "system" fn dummy_pfnglwindowpos3sproc (_: GLshort, _: GLshort, _: GLshort) {
	panic!("OpenGL function pointer `glWindowPos3s()` is null.")
}

/// The dummy function of `WindowPos3sv()`
extern "system" fn dummy_pfnglwindowpos3svproc (_: *const GLshort) {
	panic!("OpenGL function pointer `glWindowPos3sv()` is null.")
}

/// The dummy function of `BlendColor()`
extern "system" fn dummy_pfnglblendcolorproc (_: GLfloat, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glBlendColor()` is null.")
}

/// The dummy function of `BlendEquation()`
extern "system" fn dummy_pfnglblendequationproc (_: GLenum) {
	panic!("OpenGL function pointer `glBlendEquation()` is null.")
}
/// Constant value defined from OpenGL 1.4
pub const GL_BLEND_DST_RGB: GLenum = 0x80C8;

/// Constant value defined from OpenGL 1.4
pub const GL_BLEND_SRC_RGB: GLenum = 0x80C9;

/// Constant value defined from OpenGL 1.4
pub const GL_BLEND_DST_ALPHA: GLenum = 0x80CA;

/// Constant value defined from OpenGL 1.4
pub const GL_BLEND_SRC_ALPHA: GLenum = 0x80CB;

/// Constant value defined from OpenGL 1.4
pub const GL_POINT_FADE_THRESHOLD_SIZE: GLenum = 0x8128;

/// Constant value defined from OpenGL 1.4
pub const GL_DEPTH_COMPONENT16: GLenum = 0x81A5;

/// Constant value defined from OpenGL 1.4
pub const GL_DEPTH_COMPONENT24: GLenum = 0x81A6;

/// Constant value defined from OpenGL 1.4
pub const GL_DEPTH_COMPONENT32: GLenum = 0x81A7;

/// Constant value defined from OpenGL 1.4
pub const GL_MIRRORED_REPEAT: GLint = 0x8370;

/// Constant value defined from OpenGL 1.4
pub const GL_MAX_TEXTURE_LOD_BIAS: GLenum = 0x84FD;

/// Constant value defined from OpenGL 1.4
pub const GL_TEXTURE_LOD_BIAS: GLenum = 0x8501;

/// Constant value defined from OpenGL 1.4
pub const GL_INCR_WRAP: GLenum = 0x8507;

/// Constant value defined from OpenGL 1.4
pub const GL_DECR_WRAP: GLenum = 0x8508;

/// Constant value defined from OpenGL 1.4
pub const GL_TEXTURE_DEPTH_SIZE: GLenum = 0x884A;

/// Constant value defined from OpenGL 1.4
pub const GL_TEXTURE_COMPARE_MODE: GLenum = 0x884C;

/// Constant value defined from OpenGL 1.4
pub const GL_TEXTURE_COMPARE_FUNC: GLenum = 0x884D;

/// Constant value defined from OpenGL 1.4
pub const GL_POINT_SIZE_MIN: GLenum = 0x8126;

/// Constant value defined from OpenGL 1.4
pub const GL_POINT_SIZE_MAX: GLenum = 0x8127;

/// Constant value defined from OpenGL 1.4
pub const GL_POINT_DISTANCE_ATTENUATION: GLenum = 0x8129;

/// Constant value defined from OpenGL 1.4
pub const GL_GENERATE_MIPMAP: GLenum = 0x8191;

/// Constant value defined from OpenGL 1.4
pub const GL_GENERATE_MIPMAP_HINT: GLenum = 0x8192;

/// Constant value defined from OpenGL 1.4
pub const GL_FOG_COORDINATE_SOURCE: GLenum = 0x8450;

/// Constant value defined from OpenGL 1.4
pub const GL_FOG_COORDINATE: GLenum = 0x8451;

/// Constant value defined from OpenGL 1.4
pub const GL_FRAGMENT_DEPTH: GLenum = 0x8452;

/// Constant value defined from OpenGL 1.4
pub const GL_CURRENT_FOG_COORDINATE: GLenum = 0x8453;

/// Constant value defined from OpenGL 1.4
pub const GL_FOG_COORDINATE_ARRAY_TYPE: GLenum = 0x8454;

/// Constant value defined from OpenGL 1.4
pub const GL_FOG_COORDINATE_ARRAY_STRIDE: GLenum = 0x8455;

/// Constant value defined from OpenGL 1.4
pub const GL_FOG_COORDINATE_ARRAY_POINTER: GLenum = 0x8456;

/// Constant value defined from OpenGL 1.4
pub const GL_FOG_COORDINATE_ARRAY: GLenum = 0x8457;

/// Constant value defined from OpenGL 1.4
pub const GL_COLOR_SUM: GLenum = 0x8458;

/// Constant value defined from OpenGL 1.4
pub const GL_CURRENT_SECONDARY_COLOR: GLenum = 0x8459;

/// Constant value defined from OpenGL 1.4
pub const GL_SECONDARY_COLOR_ARRAY_SIZE: GLenum = 0x845A;

/// Constant value defined from OpenGL 1.4
pub const GL_SECONDARY_COLOR_ARRAY_TYPE: GLenum = 0x845B;

/// Constant value defined from OpenGL 1.4
pub const GL_SECONDARY_COLOR_ARRAY_STRIDE: GLenum = 0x845C;

/// Constant value defined from OpenGL 1.4
pub const GL_SECONDARY_COLOR_ARRAY_POINTER: GLenum = 0x845D;

/// Constant value defined from OpenGL 1.4
pub const GL_SECONDARY_COLOR_ARRAY: GLenum = 0x845E;

/// Constant value defined from OpenGL 1.4
pub const GL_TEXTURE_FILTER_CONTROL: GLenum = 0x8500;

/// Constant value defined from OpenGL 1.4
pub const GL_DEPTH_TEXTURE_MODE: GLenum = 0x884B;

/// Constant value defined from OpenGL 1.4
pub const GL_COMPARE_R_TO_TEXTURE: GLenum = 0x884E;

/// Constant value defined from OpenGL 1.4
pub const GL_BLEND_COLOR: GLenum = 0x8005;

/// Constant value defined from OpenGL 1.4
pub const GL_BLEND_EQUATION: GLenum = 0x8009;

/// Constant value defined from OpenGL 1.4
pub const GL_CONSTANT_COLOR: GLenum = 0x8001;

/// Constant value defined from OpenGL 1.4
pub const GL_ONE_MINUS_CONSTANT_COLOR: GLenum = 0x8002;

/// Constant value defined from OpenGL 1.4
pub const GL_CONSTANT_ALPHA: GLenum = 0x8003;

/// Constant value defined from OpenGL 1.4
pub const GL_ONE_MINUS_CONSTANT_ALPHA: GLenum = 0x8004;

/// Constant value defined from OpenGL 1.4
pub const GL_FUNC_ADD: GLenum = 0x8006;

/// Constant value defined from OpenGL 1.4
pub const GL_FUNC_REVERSE_SUBTRACT: GLenum = 0x800B;

/// Constant value defined from OpenGL 1.4
pub const GL_FUNC_SUBTRACT: GLenum = 0x800A;

/// Constant value defined from OpenGL 1.4
pub const GL_MIN: GLenum = 0x8007;

/// Constant value defined from OpenGL 1.4
pub const GL_MAX: GLenum = 0x8008;

/// Functions from OpenGL version 1.4
pub trait GL_1_4 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	fn glGetError(&self) -> GLenum;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendFuncSeparate.xhtml>
	fn glBlendFuncSeparate(&self, sfactorRGB: GLenum, dfactorRGB: GLenum, sfactorAlpha: GLenum, dfactorAlpha: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawArrays.xhtml>
	fn glMultiDrawArrays(&self, mode: GLenum, first: *const GLint, count: *const GLsizei, drawcount: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawElements.xhtml>
	fn glMultiDrawElements(&self, mode: GLenum, count: *const GLsizei, type_: GLenum, indices: *const *const c_void, drawcount: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPointParameterf.xhtml>
	fn glPointParameterf(&self, pname: GLenum, param: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPointParameterfv.xhtml>
	fn glPointParameterfv(&self, pname: GLenum, params: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPointParameteri.xhtml>
	fn glPointParameteri(&self, pname: GLenum, param: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPointParameteriv.xhtml>
	fn glPointParameteriv(&self, pname: GLenum, params: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFogCoordf.xhtml>
	fn glFogCoordf(&self, coord: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFogCoordfv.xhtml>
	fn glFogCoordfv(&self, coord: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFogCoordd.xhtml>
	fn glFogCoordd(&self, coord: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFogCoorddv.xhtml>
	fn glFogCoorddv(&self, coord: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFogCoordPointer.xhtml>
	fn glFogCoordPointer(&self, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3b.xhtml>
	fn glSecondaryColor3b(&self, red: GLbyte, green: GLbyte, blue: GLbyte) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3bv.xhtml>
	fn glSecondaryColor3bv(&self, v: *const GLbyte) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3d.xhtml>
	fn glSecondaryColor3d(&self, red: GLdouble, green: GLdouble, blue: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3dv.xhtml>
	fn glSecondaryColor3dv(&self, v: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3f.xhtml>
	fn glSecondaryColor3f(&self, red: GLfloat, green: GLfloat, blue: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3fv.xhtml>
	fn glSecondaryColor3fv(&self, v: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3i.xhtml>
	fn glSecondaryColor3i(&self, red: GLint, green: GLint, blue: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3iv.xhtml>
	fn glSecondaryColor3iv(&self, v: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3s.xhtml>
	fn glSecondaryColor3s(&self, red: GLshort, green: GLshort, blue: GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3sv.xhtml>
	fn glSecondaryColor3sv(&self, v: *const GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3ub.xhtml>
	fn glSecondaryColor3ub(&self, red: GLubyte, green: GLubyte, blue: GLubyte) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3ubv.xhtml>
	fn glSecondaryColor3ubv(&self, v: *const GLubyte) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3ui.xhtml>
	fn glSecondaryColor3ui(&self, red: GLuint, green: GLuint, blue: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3uiv.xhtml>
	fn glSecondaryColor3uiv(&self, v: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3us.xhtml>
	fn glSecondaryColor3us(&self, red: GLushort, green: GLushort, blue: GLushort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3usv.xhtml>
	fn glSecondaryColor3usv(&self, v: *const GLushort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColorPointer.xhtml>
	fn glSecondaryColorPointer(&self, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2d.xhtml>
	fn glWindowPos2d(&self, x: GLdouble, y: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2dv.xhtml>
	fn glWindowPos2dv(&self, v: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2f.xhtml>
	fn glWindowPos2f(&self, x: GLfloat, y: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2fv.xhtml>
	fn glWindowPos2fv(&self, v: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2i.xhtml>
	fn glWindowPos2i(&self, x: GLint, y: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2iv.xhtml>
	fn glWindowPos2iv(&self, v: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2s.xhtml>
	fn glWindowPos2s(&self, x: GLshort, y: GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2sv.xhtml>
	fn glWindowPos2sv(&self, v: *const GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3d.xhtml>
	fn glWindowPos3d(&self, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3dv.xhtml>
	fn glWindowPos3dv(&self, v: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3f.xhtml>
	fn glWindowPos3f(&self, x: GLfloat, y: GLfloat, z: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3fv.xhtml>
	fn glWindowPos3fv(&self, v: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3i.xhtml>
	fn glWindowPos3i(&self, x: GLint, y: GLint, z: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3iv.xhtml>
	fn glWindowPos3iv(&self, v: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3s.xhtml>
	fn glWindowPos3s(&self, x: GLshort, y: GLshort, z: GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3sv.xhtml>
	fn glWindowPos3sv(&self, v: *const GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendColor.xhtml>
	fn glBlendColor(&self, red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendEquation.xhtml>
	fn glBlendEquation(&self, mode: GLenum) -> Result<()>;
}
/// Functions from OpenGL version 1.4
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version14 {
	/// Is OpenGL version 1.4 available
	available: bool,

	/// The function pointer to `glGetError()`
	pub geterror: PFNGLGETERRORPROC,

	/// The function pointer to `glBlendFuncSeparate()`
	pub blendfuncseparate: PFNGLBLENDFUNCSEPARATEPROC,

	/// The function pointer to `glMultiDrawArrays()`
	pub multidrawarrays: PFNGLMULTIDRAWARRAYSPROC,

	/// The function pointer to `glMultiDrawElements()`
	pub multidrawelements: PFNGLMULTIDRAWELEMENTSPROC,

	/// The function pointer to `glPointParameterf()`
	pub pointparameterf: PFNGLPOINTPARAMETERFPROC,

	/// The function pointer to `glPointParameterfv()`
	pub pointparameterfv: PFNGLPOINTPARAMETERFVPROC,

	/// The function pointer to `glPointParameteri()`
	pub pointparameteri: PFNGLPOINTPARAMETERIPROC,

	/// The function pointer to `glPointParameteriv()`
	pub pointparameteriv: PFNGLPOINTPARAMETERIVPROC,

	/// The function pointer to `glFogCoordf()`
	pub fogcoordf: PFNGLFOGCOORDFPROC,

	/// The function pointer to `glFogCoordfv()`
	pub fogcoordfv: PFNGLFOGCOORDFVPROC,

	/// The function pointer to `glFogCoordd()`
	pub fogcoordd: PFNGLFOGCOORDDPROC,

	/// The function pointer to `glFogCoorddv()`
	pub fogcoorddv: PFNGLFOGCOORDDVPROC,

	/// The function pointer to `glFogCoordPointer()`
	pub fogcoordpointer: PFNGLFOGCOORDPOINTERPROC,

	/// The function pointer to `glSecondaryColor3b()`
	pub secondarycolor3b: PFNGLSECONDARYCOLOR3BPROC,

	/// The function pointer to `glSecondaryColor3bv()`
	pub secondarycolor3bv: PFNGLSECONDARYCOLOR3BVPROC,

	/// The function pointer to `glSecondaryColor3d()`
	pub secondarycolor3d: PFNGLSECONDARYCOLOR3DPROC,

	/// The function pointer to `glSecondaryColor3dv()`
	pub secondarycolor3dv: PFNGLSECONDARYCOLOR3DVPROC,

	/// The function pointer to `glSecondaryColor3f()`
	pub secondarycolor3f: PFNGLSECONDARYCOLOR3FPROC,

	/// The function pointer to `glSecondaryColor3fv()`
	pub secondarycolor3fv: PFNGLSECONDARYCOLOR3FVPROC,

	/// The function pointer to `glSecondaryColor3i()`
	pub secondarycolor3i: PFNGLSECONDARYCOLOR3IPROC,

	/// The function pointer to `glSecondaryColor3iv()`
	pub secondarycolor3iv: PFNGLSECONDARYCOLOR3IVPROC,

	/// The function pointer to `glSecondaryColor3s()`
	pub secondarycolor3s: PFNGLSECONDARYCOLOR3SPROC,

	/// The function pointer to `glSecondaryColor3sv()`
	pub secondarycolor3sv: PFNGLSECONDARYCOLOR3SVPROC,

	/// The function pointer to `glSecondaryColor3ub()`
	pub secondarycolor3ub: PFNGLSECONDARYCOLOR3UBPROC,

	/// The function pointer to `glSecondaryColor3ubv()`
	pub secondarycolor3ubv: PFNGLSECONDARYCOLOR3UBVPROC,

	/// The function pointer to `glSecondaryColor3ui()`
	pub secondarycolor3ui: PFNGLSECONDARYCOLOR3UIPROC,

	/// The function pointer to `glSecondaryColor3uiv()`
	pub secondarycolor3uiv: PFNGLSECONDARYCOLOR3UIVPROC,

	/// The function pointer to `glSecondaryColor3us()`
	pub secondarycolor3us: PFNGLSECONDARYCOLOR3USPROC,

	/// The function pointer to `glSecondaryColor3usv()`
	pub secondarycolor3usv: PFNGLSECONDARYCOLOR3USVPROC,

	/// The function pointer to `glSecondaryColorPointer()`
	pub secondarycolorpointer: PFNGLSECONDARYCOLORPOINTERPROC,

	/// The function pointer to `glWindowPos2d()`
	pub windowpos2d: PFNGLWINDOWPOS2DPROC,

	/// The function pointer to `glWindowPos2dv()`
	pub windowpos2dv: PFNGLWINDOWPOS2DVPROC,

	/// The function pointer to `glWindowPos2f()`
	pub windowpos2f: PFNGLWINDOWPOS2FPROC,

	/// The function pointer to `glWindowPos2fv()`
	pub windowpos2fv: PFNGLWINDOWPOS2FVPROC,

	/// The function pointer to `glWindowPos2i()`
	pub windowpos2i: PFNGLWINDOWPOS2IPROC,

	/// The function pointer to `glWindowPos2iv()`
	pub windowpos2iv: PFNGLWINDOWPOS2IVPROC,

	/// The function pointer to `glWindowPos2s()`
	pub windowpos2s: PFNGLWINDOWPOS2SPROC,

	/// The function pointer to `glWindowPos2sv()`
	pub windowpos2sv: PFNGLWINDOWPOS2SVPROC,

	/// The function pointer to `glWindowPos3d()`
	pub windowpos3d: PFNGLWINDOWPOS3DPROC,

	/// The function pointer to `glWindowPos3dv()`
	pub windowpos3dv: PFNGLWINDOWPOS3DVPROC,

	/// The function pointer to `glWindowPos3f()`
	pub windowpos3f: PFNGLWINDOWPOS3FPROC,

	/// The function pointer to `glWindowPos3fv()`
	pub windowpos3fv: PFNGLWINDOWPOS3FVPROC,

	/// The function pointer to `glWindowPos3i()`
	pub windowpos3i: PFNGLWINDOWPOS3IPROC,

	/// The function pointer to `glWindowPos3iv()`
	pub windowpos3iv: PFNGLWINDOWPOS3IVPROC,

	/// The function pointer to `glWindowPos3s()`
	pub windowpos3s: PFNGLWINDOWPOS3SPROC,

	/// The function pointer to `glWindowPos3sv()`
	pub windowpos3sv: PFNGLWINDOWPOS3SVPROC,

	/// The function pointer to `glBlendColor()`
	pub blendcolor: PFNGLBLENDCOLORPROC,

	/// The function pointer to `glBlendEquation()`
	pub blendequation: PFNGLBLENDEQUATIONPROC,
}

impl GL_1_4 for Version14 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendFuncSeparate.xhtml>
	#[inline(always)]
	fn glBlendFuncSeparate(&self, sfactorRGB: GLenum, dfactorRGB: GLenum, sfactorAlpha: GLenum, dfactorAlpha: GLenum) -> Result<()> {
		let ret = process_catch("glBlendFuncSeparate", catch_unwind(||(self.blendfuncseparate)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendFuncSeparate", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawArrays.xhtml>
	#[inline(always)]
	fn glMultiDrawArrays(&self, mode: GLenum, first: *const GLint, count: *const GLsizei, drawcount: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawArrays", catch_unwind(||(self.multidrawarrays)(mode, first, count, drawcount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawArrays", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawElements.xhtml>
	#[inline(always)]
	fn glMultiDrawElements(&self, mode: GLenum, count: *const GLsizei, type_: GLenum, indices: *const *const c_void, drawcount: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawElements", catch_unwind(||(self.multidrawelements)(mode, count, type_, indices, drawcount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawElements", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPointParameterf.xhtml>
	#[inline(always)]
	fn glPointParameterf(&self, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glPointParameterf", catch_unwind(||(self.pointparameterf)(pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointParameterf", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPointParameterfv.xhtml>
	#[inline(always)]
	fn glPointParameterfv(&self, pname: GLenum, params: *const GLfloat) -> Result<()> {
		let ret = process_catch("glPointParameterfv", catch_unwind(||(self.pointparameterfv)(pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPointParameteri.xhtml>
	#[inline(always)]
	fn glPointParameteri(&self, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glPointParameteri", catch_unwind(||(self.pointparameteri)(pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointParameteri", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPointParameteriv.xhtml>
	#[inline(always)]
	fn glPointParameteriv(&self, pname: GLenum, params: *const GLint) -> Result<()> {
		let ret = process_catch("glPointParameteriv", catch_unwind(||(self.pointparameteriv)(pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFogCoordf.xhtml>
	#[inline(always)]
	fn glFogCoordf(&self, coord: GLfloat) -> Result<()> {
		let ret = process_catch("glFogCoordf", catch_unwind(||(self.fogcoordf)(coord)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoordf", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFogCoordfv.xhtml>
	#[inline(always)]
	fn glFogCoordfv(&self, coord: *const GLfloat) -> Result<()> {
		let ret = process_catch("glFogCoordfv", catch_unwind(||(self.fogcoordfv)(coord)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoordfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFogCoordd.xhtml>
	#[inline(always)]
	fn glFogCoordd(&self, coord: GLdouble) -> Result<()> {
		let ret = process_catch("glFogCoordd", catch_unwind(||(self.fogcoordd)(coord)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoordd", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFogCoorddv.xhtml>
	#[inline(always)]
	fn glFogCoorddv(&self, coord: *const GLdouble) -> Result<()> {
		let ret = process_catch("glFogCoorddv", catch_unwind(||(self.fogcoorddv)(coord)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoorddv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFogCoordPointer.xhtml>
	#[inline(always)]
	fn glFogCoordPointer(&self, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glFogCoordPointer", catch_unwind(||(self.fogcoordpointer)(type_, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoordPointer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3b.xhtml>
	#[inline(always)]
	fn glSecondaryColor3b(&self, red: GLbyte, green: GLbyte, blue: GLbyte) -> Result<()> {
		let ret = process_catch("glSecondaryColor3b", catch_unwind(||(self.secondarycolor3b)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3b", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3bv.xhtml>
	#[inline(always)]
	fn glSecondaryColor3bv(&self, v: *const GLbyte) -> Result<()> {
		let ret = process_catch("glSecondaryColor3bv", catch_unwind(||(self.secondarycolor3bv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3bv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3d.xhtml>
	#[inline(always)]
	fn glSecondaryColor3d(&self, red: GLdouble, green: GLdouble, blue: GLdouble) -> Result<()> {
		let ret = process_catch("glSecondaryColor3d", catch_unwind(||(self.secondarycolor3d)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3dv.xhtml>
	#[inline(always)]
	fn glSecondaryColor3dv(&self, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glSecondaryColor3dv", catch_unwind(||(self.secondarycolor3dv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3f.xhtml>
	#[inline(always)]
	fn glSecondaryColor3f(&self, red: GLfloat, green: GLfloat, blue: GLfloat) -> Result<()> {
		let ret = process_catch("glSecondaryColor3f", catch_unwind(||(self.secondarycolor3f)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3fv.xhtml>
	#[inline(always)]
	fn glSecondaryColor3fv(&self, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glSecondaryColor3fv", catch_unwind(||(self.secondarycolor3fv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3i.xhtml>
	#[inline(always)]
	fn glSecondaryColor3i(&self, red: GLint, green: GLint, blue: GLint) -> Result<()> {
		let ret = process_catch("glSecondaryColor3i", catch_unwind(||(self.secondarycolor3i)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3iv.xhtml>
	#[inline(always)]
	fn glSecondaryColor3iv(&self, v: *const GLint) -> Result<()> {
		let ret = process_catch("glSecondaryColor3iv", catch_unwind(||(self.secondarycolor3iv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3s.xhtml>
	#[inline(always)]
	fn glSecondaryColor3s(&self, red: GLshort, green: GLshort, blue: GLshort) -> Result<()> {
		let ret = process_catch("glSecondaryColor3s", catch_unwind(||(self.secondarycolor3s)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3sv.xhtml>
	#[inline(always)]
	fn glSecondaryColor3sv(&self, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glSecondaryColor3sv", catch_unwind(||(self.secondarycolor3sv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3ub.xhtml>
	#[inline(always)]
	fn glSecondaryColor3ub(&self, red: GLubyte, green: GLubyte, blue: GLubyte) -> Result<()> {
		let ret = process_catch("glSecondaryColor3ub", catch_unwind(||(self.secondarycolor3ub)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3ub", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3ubv.xhtml>
	#[inline(always)]
	fn glSecondaryColor3ubv(&self, v: *const GLubyte) -> Result<()> {
		let ret = process_catch("glSecondaryColor3ubv", catch_unwind(||(self.secondarycolor3ubv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3ubv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3ui.xhtml>
	#[inline(always)]
	fn glSecondaryColor3ui(&self, red: GLuint, green: GLuint, blue: GLuint) -> Result<()> {
		let ret = process_catch("glSecondaryColor3ui", catch_unwind(||(self.secondarycolor3ui)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3uiv.xhtml>
	#[inline(always)]
	fn glSecondaryColor3uiv(&self, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glSecondaryColor3uiv", catch_unwind(||(self.secondarycolor3uiv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3us.xhtml>
	#[inline(always)]
	fn glSecondaryColor3us(&self, red: GLushort, green: GLushort, blue: GLushort) -> Result<()> {
		let ret = process_catch("glSecondaryColor3us", catch_unwind(||(self.secondarycolor3us)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3us", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3usv.xhtml>
	#[inline(always)]
	fn glSecondaryColor3usv(&self, v: *const GLushort) -> Result<()> {
		let ret = process_catch("glSecondaryColor3usv", catch_unwind(||(self.secondarycolor3usv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3usv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColorPointer.xhtml>
	#[inline(always)]
	fn glSecondaryColorPointer(&self, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glSecondaryColorPointer", catch_unwind(||(self.secondarycolorpointer)(size, type_, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColorPointer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2d.xhtml>
	#[inline(always)]
	fn glWindowPos2d(&self, x: GLdouble, y: GLdouble) -> Result<()> {
		let ret = process_catch("glWindowPos2d", catch_unwind(||(self.windowpos2d)(x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2dv.xhtml>
	#[inline(always)]
	fn glWindowPos2dv(&self, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glWindowPos2dv", catch_unwind(||(self.windowpos2dv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2f.xhtml>
	#[inline(always)]
	fn glWindowPos2f(&self, x: GLfloat, y: GLfloat) -> Result<()> {
		let ret = process_catch("glWindowPos2f", catch_unwind(||(self.windowpos2f)(x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2fv.xhtml>
	#[inline(always)]
	fn glWindowPos2fv(&self, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glWindowPos2fv", catch_unwind(||(self.windowpos2fv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2i.xhtml>
	#[inline(always)]
	fn glWindowPos2i(&self, x: GLint, y: GLint) -> Result<()> {
		let ret = process_catch("glWindowPos2i", catch_unwind(||(self.windowpos2i)(x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2iv.xhtml>
	#[inline(always)]
	fn glWindowPos2iv(&self, v: *const GLint) -> Result<()> {
		let ret = process_catch("glWindowPos2iv", catch_unwind(||(self.windowpos2iv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2s.xhtml>
	#[inline(always)]
	fn glWindowPos2s(&self, x: GLshort, y: GLshort) -> Result<()> {
		let ret = process_catch("glWindowPos2s", catch_unwind(||(self.windowpos2s)(x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2sv.xhtml>
	#[inline(always)]
	fn glWindowPos2sv(&self, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glWindowPos2sv", catch_unwind(||(self.windowpos2sv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3d.xhtml>
	#[inline(always)]
	fn glWindowPos3d(&self, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()> {
		let ret = process_catch("glWindowPos3d", catch_unwind(||(self.windowpos3d)(x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3dv.xhtml>
	#[inline(always)]
	fn glWindowPos3dv(&self, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glWindowPos3dv", catch_unwind(||(self.windowpos3dv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3f.xhtml>
	#[inline(always)]
	fn glWindowPos3f(&self, x: GLfloat, y: GLfloat, z: GLfloat) -> Result<()> {
		let ret = process_catch("glWindowPos3f", catch_unwind(||(self.windowpos3f)(x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3fv.xhtml>
	#[inline(always)]
	fn glWindowPos3fv(&self, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glWindowPos3fv", catch_unwind(||(self.windowpos3fv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3i.xhtml>
	#[inline(always)]
	fn glWindowPos3i(&self, x: GLint, y: GLint, z: GLint) -> Result<()> {
		let ret = process_catch("glWindowPos3i", catch_unwind(||(self.windowpos3i)(x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3iv.xhtml>
	#[inline(always)]
	fn glWindowPos3iv(&self, v: *const GLint) -> Result<()> {
		let ret = process_catch("glWindowPos3iv", catch_unwind(||(self.windowpos3iv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3s.xhtml>
	#[inline(always)]
	fn glWindowPos3s(&self, x: GLshort, y: GLshort, z: GLshort) -> Result<()> {
		let ret = process_catch("glWindowPos3s", catch_unwind(||(self.windowpos3s)(x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3sv.xhtml>
	#[inline(always)]
	fn glWindowPos3sv(&self, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glWindowPos3sv", catch_unwind(||(self.windowpos3sv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendColor.xhtml>
	#[inline(always)]
	fn glBlendColor(&self, red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) -> Result<()> {
		let ret = process_catch("glBlendColor", catch_unwind(||(self.blendcolor)(red, green, blue, alpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendColor", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendEquation.xhtml>
	#[inline(always)]
	fn glBlendEquation(&self, mode: GLenum) -> Result<()> {
		let ret = process_catch("glBlendEquation", catch_unwind(||(self.blendequation)(mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendEquation", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version14 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (1, 4, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			blendfuncseparate: {let proc = get_proc_address("glBlendFuncSeparate"); if proc == null() {dummy_pfnglblendfuncseparateproc} else {unsafe{transmute(proc)}}},
			multidrawarrays: {let proc = get_proc_address("glMultiDrawArrays"); if proc == null() {dummy_pfnglmultidrawarraysproc} else {unsafe{transmute(proc)}}},
			multidrawelements: {let proc = get_proc_address("glMultiDrawElements"); if proc == null() {dummy_pfnglmultidrawelementsproc} else {unsafe{transmute(proc)}}},
			pointparameterf: {let proc = get_proc_address("glPointParameterf"); if proc == null() {dummy_pfnglpointparameterfproc} else {unsafe{transmute(proc)}}},
			pointparameterfv: {let proc = get_proc_address("glPointParameterfv"); if proc == null() {dummy_pfnglpointparameterfvproc} else {unsafe{transmute(proc)}}},
			pointparameteri: {let proc = get_proc_address("glPointParameteri"); if proc == null() {dummy_pfnglpointparameteriproc} else {unsafe{transmute(proc)}}},
			pointparameteriv: {let proc = get_proc_address("glPointParameteriv"); if proc == null() {dummy_pfnglpointparameterivproc} else {unsafe{transmute(proc)}}},
			fogcoordf: {let proc = get_proc_address("glFogCoordf"); if proc == null() {dummy_pfnglfogcoordfproc} else {unsafe{transmute(proc)}}},
			fogcoordfv: {let proc = get_proc_address("glFogCoordfv"); if proc == null() {dummy_pfnglfogcoordfvproc} else {unsafe{transmute(proc)}}},
			fogcoordd: {let proc = get_proc_address("glFogCoordd"); if proc == null() {dummy_pfnglfogcoorddproc} else {unsafe{transmute(proc)}}},
			fogcoorddv: {let proc = get_proc_address("glFogCoorddv"); if proc == null() {dummy_pfnglfogcoorddvproc} else {unsafe{transmute(proc)}}},
			fogcoordpointer: {let proc = get_proc_address("glFogCoordPointer"); if proc == null() {dummy_pfnglfogcoordpointerproc} else {unsafe{transmute(proc)}}},
			secondarycolor3b: {let proc = get_proc_address("glSecondaryColor3b"); if proc == null() {dummy_pfnglsecondarycolor3bproc} else {unsafe{transmute(proc)}}},
			secondarycolor3bv: {let proc = get_proc_address("glSecondaryColor3bv"); if proc == null() {dummy_pfnglsecondarycolor3bvproc} else {unsafe{transmute(proc)}}},
			secondarycolor3d: {let proc = get_proc_address("glSecondaryColor3d"); if proc == null() {dummy_pfnglsecondarycolor3dproc} else {unsafe{transmute(proc)}}},
			secondarycolor3dv: {let proc = get_proc_address("glSecondaryColor3dv"); if proc == null() {dummy_pfnglsecondarycolor3dvproc} else {unsafe{transmute(proc)}}},
			secondarycolor3f: {let proc = get_proc_address("glSecondaryColor3f"); if proc == null() {dummy_pfnglsecondarycolor3fproc} else {unsafe{transmute(proc)}}},
			secondarycolor3fv: {let proc = get_proc_address("glSecondaryColor3fv"); if proc == null() {dummy_pfnglsecondarycolor3fvproc} else {unsafe{transmute(proc)}}},
			secondarycolor3i: {let proc = get_proc_address("glSecondaryColor3i"); if proc == null() {dummy_pfnglsecondarycolor3iproc} else {unsafe{transmute(proc)}}},
			secondarycolor3iv: {let proc = get_proc_address("glSecondaryColor3iv"); if proc == null() {dummy_pfnglsecondarycolor3ivproc} else {unsafe{transmute(proc)}}},
			secondarycolor3s: {let proc = get_proc_address("glSecondaryColor3s"); if proc == null() {dummy_pfnglsecondarycolor3sproc} else {unsafe{transmute(proc)}}},
			secondarycolor3sv: {let proc = get_proc_address("glSecondaryColor3sv"); if proc == null() {dummy_pfnglsecondarycolor3svproc} else {unsafe{transmute(proc)}}},
			secondarycolor3ub: {let proc = get_proc_address("glSecondaryColor3ub"); if proc == null() {dummy_pfnglsecondarycolor3ubproc} else {unsafe{transmute(proc)}}},
			secondarycolor3ubv: {let proc = get_proc_address("glSecondaryColor3ubv"); if proc == null() {dummy_pfnglsecondarycolor3ubvproc} else {unsafe{transmute(proc)}}},
			secondarycolor3ui: {let proc = get_proc_address("glSecondaryColor3ui"); if proc == null() {dummy_pfnglsecondarycolor3uiproc} else {unsafe{transmute(proc)}}},
			secondarycolor3uiv: {let proc = get_proc_address("glSecondaryColor3uiv"); if proc == null() {dummy_pfnglsecondarycolor3uivproc} else {unsafe{transmute(proc)}}},
			secondarycolor3us: {let proc = get_proc_address("glSecondaryColor3us"); if proc == null() {dummy_pfnglsecondarycolor3usproc} else {unsafe{transmute(proc)}}},
			secondarycolor3usv: {let proc = get_proc_address("glSecondaryColor3usv"); if proc == null() {dummy_pfnglsecondarycolor3usvproc} else {unsafe{transmute(proc)}}},
			secondarycolorpointer: {let proc = get_proc_address("glSecondaryColorPointer"); if proc == null() {dummy_pfnglsecondarycolorpointerproc} else {unsafe{transmute(proc)}}},
			windowpos2d: {let proc = get_proc_address("glWindowPos2d"); if proc == null() {dummy_pfnglwindowpos2dproc} else {unsafe{transmute(proc)}}},
			windowpos2dv: {let proc = get_proc_address("glWindowPos2dv"); if proc == null() {dummy_pfnglwindowpos2dvproc} else {unsafe{transmute(proc)}}},
			windowpos2f: {let proc = get_proc_address("glWindowPos2f"); if proc == null() {dummy_pfnglwindowpos2fproc} else {unsafe{transmute(proc)}}},
			windowpos2fv: {let proc = get_proc_address("glWindowPos2fv"); if proc == null() {dummy_pfnglwindowpos2fvproc} else {unsafe{transmute(proc)}}},
			windowpos2i: {let proc = get_proc_address("glWindowPos2i"); if proc == null() {dummy_pfnglwindowpos2iproc} else {unsafe{transmute(proc)}}},
			windowpos2iv: {let proc = get_proc_address("glWindowPos2iv"); if proc == null() {dummy_pfnglwindowpos2ivproc} else {unsafe{transmute(proc)}}},
			windowpos2s: {let proc = get_proc_address("glWindowPos2s"); if proc == null() {dummy_pfnglwindowpos2sproc} else {unsafe{transmute(proc)}}},
			windowpos2sv: {let proc = get_proc_address("glWindowPos2sv"); if proc == null() {dummy_pfnglwindowpos2svproc} else {unsafe{transmute(proc)}}},
			windowpos3d: {let proc = get_proc_address("glWindowPos3d"); if proc == null() {dummy_pfnglwindowpos3dproc} else {unsafe{transmute(proc)}}},
			windowpos3dv: {let proc = get_proc_address("glWindowPos3dv"); if proc == null() {dummy_pfnglwindowpos3dvproc} else {unsafe{transmute(proc)}}},
			windowpos3f: {let proc = get_proc_address("glWindowPos3f"); if proc == null() {dummy_pfnglwindowpos3fproc} else {unsafe{transmute(proc)}}},
			windowpos3fv: {let proc = get_proc_address("glWindowPos3fv"); if proc == null() {dummy_pfnglwindowpos3fvproc} else {unsafe{transmute(proc)}}},
			windowpos3i: {let proc = get_proc_address("glWindowPos3i"); if proc == null() {dummy_pfnglwindowpos3iproc} else {unsafe{transmute(proc)}}},
			windowpos3iv: {let proc = get_proc_address("glWindowPos3iv"); if proc == null() {dummy_pfnglwindowpos3ivproc} else {unsafe{transmute(proc)}}},
			windowpos3s: {let proc = get_proc_address("glWindowPos3s"); if proc == null() {dummy_pfnglwindowpos3sproc} else {unsafe{transmute(proc)}}},
			windowpos3sv: {let proc = get_proc_address("glWindowPos3sv"); if proc == null() {dummy_pfnglwindowpos3svproc} else {unsafe{transmute(proc)}}},
			blendcolor: {let proc = get_proc_address("glBlendColor"); if proc == null() {dummy_pfnglblendcolorproc} else {unsafe{transmute(proc)}}},
			blendequation: {let proc = get_proc_address("glBlendEquation"); if proc == null() {dummy_pfnglblendequationproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version14 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			blendfuncseparate: dummy_pfnglblendfuncseparateproc,
			multidrawarrays: dummy_pfnglmultidrawarraysproc,
			multidrawelements: dummy_pfnglmultidrawelementsproc,
			pointparameterf: dummy_pfnglpointparameterfproc,
			pointparameterfv: dummy_pfnglpointparameterfvproc,
			pointparameteri: dummy_pfnglpointparameteriproc,
			pointparameteriv: dummy_pfnglpointparameterivproc,
			fogcoordf: dummy_pfnglfogcoordfproc,
			fogcoordfv: dummy_pfnglfogcoordfvproc,
			fogcoordd: dummy_pfnglfogcoorddproc,
			fogcoorddv: dummy_pfnglfogcoorddvproc,
			fogcoordpointer: dummy_pfnglfogcoordpointerproc,
			secondarycolor3b: dummy_pfnglsecondarycolor3bproc,
			secondarycolor3bv: dummy_pfnglsecondarycolor3bvproc,
			secondarycolor3d: dummy_pfnglsecondarycolor3dproc,
			secondarycolor3dv: dummy_pfnglsecondarycolor3dvproc,
			secondarycolor3f: dummy_pfnglsecondarycolor3fproc,
			secondarycolor3fv: dummy_pfnglsecondarycolor3fvproc,
			secondarycolor3i: dummy_pfnglsecondarycolor3iproc,
			secondarycolor3iv: dummy_pfnglsecondarycolor3ivproc,
			secondarycolor3s: dummy_pfnglsecondarycolor3sproc,
			secondarycolor3sv: dummy_pfnglsecondarycolor3svproc,
			secondarycolor3ub: dummy_pfnglsecondarycolor3ubproc,
			secondarycolor3ubv: dummy_pfnglsecondarycolor3ubvproc,
			secondarycolor3ui: dummy_pfnglsecondarycolor3uiproc,
			secondarycolor3uiv: dummy_pfnglsecondarycolor3uivproc,
			secondarycolor3us: dummy_pfnglsecondarycolor3usproc,
			secondarycolor3usv: dummy_pfnglsecondarycolor3usvproc,
			secondarycolorpointer: dummy_pfnglsecondarycolorpointerproc,
			windowpos2d: dummy_pfnglwindowpos2dproc,
			windowpos2dv: dummy_pfnglwindowpos2dvproc,
			windowpos2f: dummy_pfnglwindowpos2fproc,
			windowpos2fv: dummy_pfnglwindowpos2fvproc,
			windowpos2i: dummy_pfnglwindowpos2iproc,
			windowpos2iv: dummy_pfnglwindowpos2ivproc,
			windowpos2s: dummy_pfnglwindowpos2sproc,
			windowpos2sv: dummy_pfnglwindowpos2svproc,
			windowpos3d: dummy_pfnglwindowpos3dproc,
			windowpos3dv: dummy_pfnglwindowpos3dvproc,
			windowpos3f: dummy_pfnglwindowpos3fproc,
			windowpos3fv: dummy_pfnglwindowpos3fvproc,
			windowpos3i: dummy_pfnglwindowpos3iproc,
			windowpos3iv: dummy_pfnglwindowpos3ivproc,
			windowpos3s: dummy_pfnglwindowpos3sproc,
			windowpos3sv: dummy_pfnglwindowpos3svproc,
			blendcolor: dummy_pfnglblendcolorproc,
			blendequation: dummy_pfnglblendequationproc,
		}
	}
}
impl Debug for Version14 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version14")
			.field("available", &self.available)
			.field("blendfuncseparate", unsafe{if transmute::<_, *const c_void>(self.blendfuncseparate) == (dummy_pfnglblendfuncseparateproc as *const c_void) {&null::<PFNGLBLENDFUNCSEPARATEPROC>()} else {&self.blendfuncseparate}})
			.field("multidrawarrays", unsafe{if transmute::<_, *const c_void>(self.multidrawarrays) == (dummy_pfnglmultidrawarraysproc as *const c_void) {&null::<PFNGLMULTIDRAWARRAYSPROC>()} else {&self.multidrawarrays}})
			.field("multidrawelements", unsafe{if transmute::<_, *const c_void>(self.multidrawelements) == (dummy_pfnglmultidrawelementsproc as *const c_void) {&null::<PFNGLMULTIDRAWELEMENTSPROC>()} else {&self.multidrawelements}})
			.field("pointparameterf", unsafe{if transmute::<_, *const c_void>(self.pointparameterf) == (dummy_pfnglpointparameterfproc as *const c_void) {&null::<PFNGLPOINTPARAMETERFPROC>()} else {&self.pointparameterf}})
			.field("pointparameterfv", unsafe{if transmute::<_, *const c_void>(self.pointparameterfv) == (dummy_pfnglpointparameterfvproc as *const c_void) {&null::<PFNGLPOINTPARAMETERFVPROC>()} else {&self.pointparameterfv}})
			.field("pointparameteri", unsafe{if transmute::<_, *const c_void>(self.pointparameteri) == (dummy_pfnglpointparameteriproc as *const c_void) {&null::<PFNGLPOINTPARAMETERIPROC>()} else {&self.pointparameteri}})
			.field("pointparameteriv", unsafe{if transmute::<_, *const c_void>(self.pointparameteriv) == (dummy_pfnglpointparameterivproc as *const c_void) {&null::<PFNGLPOINTPARAMETERIVPROC>()} else {&self.pointparameteriv}})
			.field("fogcoordf", unsafe{if transmute::<_, *const c_void>(self.fogcoordf) == (dummy_pfnglfogcoordfproc as *const c_void) {&null::<PFNGLFOGCOORDFPROC>()} else {&self.fogcoordf}})
			.field("fogcoordfv", unsafe{if transmute::<_, *const c_void>(self.fogcoordfv) == (dummy_pfnglfogcoordfvproc as *const c_void) {&null::<PFNGLFOGCOORDFVPROC>()} else {&self.fogcoordfv}})
			.field("fogcoordd", unsafe{if transmute::<_, *const c_void>(self.fogcoordd) == (dummy_pfnglfogcoorddproc as *const c_void) {&null::<PFNGLFOGCOORDDPROC>()} else {&self.fogcoordd}})
			.field("fogcoorddv", unsafe{if transmute::<_, *const c_void>(self.fogcoorddv) == (dummy_pfnglfogcoorddvproc as *const c_void) {&null::<PFNGLFOGCOORDDVPROC>()} else {&self.fogcoorddv}})
			.field("fogcoordpointer", unsafe{if transmute::<_, *const c_void>(self.fogcoordpointer) == (dummy_pfnglfogcoordpointerproc as *const c_void) {&null::<PFNGLFOGCOORDPOINTERPROC>()} else {&self.fogcoordpointer}})
			.field("secondarycolor3b", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3b) == (dummy_pfnglsecondarycolor3bproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3BPROC>()} else {&self.secondarycolor3b}})
			.field("secondarycolor3bv", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3bv) == (dummy_pfnglsecondarycolor3bvproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3BVPROC>()} else {&self.secondarycolor3bv}})
			.field("secondarycolor3d", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3d) == (dummy_pfnglsecondarycolor3dproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3DPROC>()} else {&self.secondarycolor3d}})
			.field("secondarycolor3dv", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3dv) == (dummy_pfnglsecondarycolor3dvproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3DVPROC>()} else {&self.secondarycolor3dv}})
			.field("secondarycolor3f", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3f) == (dummy_pfnglsecondarycolor3fproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3FPROC>()} else {&self.secondarycolor3f}})
			.field("secondarycolor3fv", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3fv) == (dummy_pfnglsecondarycolor3fvproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3FVPROC>()} else {&self.secondarycolor3fv}})
			.field("secondarycolor3i", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3i) == (dummy_pfnglsecondarycolor3iproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3IPROC>()} else {&self.secondarycolor3i}})
			.field("secondarycolor3iv", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3iv) == (dummy_pfnglsecondarycolor3ivproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3IVPROC>()} else {&self.secondarycolor3iv}})
			.field("secondarycolor3s", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3s) == (dummy_pfnglsecondarycolor3sproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3SPROC>()} else {&self.secondarycolor3s}})
			.field("secondarycolor3sv", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3sv) == (dummy_pfnglsecondarycolor3svproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3SVPROC>()} else {&self.secondarycolor3sv}})
			.field("secondarycolor3ub", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3ub) == (dummy_pfnglsecondarycolor3ubproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3UBPROC>()} else {&self.secondarycolor3ub}})
			.field("secondarycolor3ubv", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3ubv) == (dummy_pfnglsecondarycolor3ubvproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3UBVPROC>()} else {&self.secondarycolor3ubv}})
			.field("secondarycolor3ui", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3ui) == (dummy_pfnglsecondarycolor3uiproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3UIPROC>()} else {&self.secondarycolor3ui}})
			.field("secondarycolor3uiv", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3uiv) == (dummy_pfnglsecondarycolor3uivproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3UIVPROC>()} else {&self.secondarycolor3uiv}})
			.field("secondarycolor3us", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3us) == (dummy_pfnglsecondarycolor3usproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3USPROC>()} else {&self.secondarycolor3us}})
			.field("secondarycolor3usv", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3usv) == (dummy_pfnglsecondarycolor3usvproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3USVPROC>()} else {&self.secondarycolor3usv}})
			.field("secondarycolorpointer", unsafe{if transmute::<_, *const c_void>(self.secondarycolorpointer) == (dummy_pfnglsecondarycolorpointerproc as *const c_void) {&null::<PFNGLSECONDARYCOLORPOINTERPROC>()} else {&self.secondarycolorpointer}})
			.field("windowpos2d", unsafe{if transmute::<_, *const c_void>(self.windowpos2d) == (dummy_pfnglwindowpos2dproc as *const c_void) {&null::<PFNGLWINDOWPOS2DPROC>()} else {&self.windowpos2d}})
			.field("windowpos2dv", unsafe{if transmute::<_, *const c_void>(self.windowpos2dv) == (dummy_pfnglwindowpos2dvproc as *const c_void) {&null::<PFNGLWINDOWPOS2DVPROC>()} else {&self.windowpos2dv}})
			.field("windowpos2f", unsafe{if transmute::<_, *const c_void>(self.windowpos2f) == (dummy_pfnglwindowpos2fproc as *const c_void) {&null::<PFNGLWINDOWPOS2FPROC>()} else {&self.windowpos2f}})
			.field("windowpos2fv", unsafe{if transmute::<_, *const c_void>(self.windowpos2fv) == (dummy_pfnglwindowpos2fvproc as *const c_void) {&null::<PFNGLWINDOWPOS2FVPROC>()} else {&self.windowpos2fv}})
			.field("windowpos2i", unsafe{if transmute::<_, *const c_void>(self.windowpos2i) == (dummy_pfnglwindowpos2iproc as *const c_void) {&null::<PFNGLWINDOWPOS2IPROC>()} else {&self.windowpos2i}})
			.field("windowpos2iv", unsafe{if transmute::<_, *const c_void>(self.windowpos2iv) == (dummy_pfnglwindowpos2ivproc as *const c_void) {&null::<PFNGLWINDOWPOS2IVPROC>()} else {&self.windowpos2iv}})
			.field("windowpos2s", unsafe{if transmute::<_, *const c_void>(self.windowpos2s) == (dummy_pfnglwindowpos2sproc as *const c_void) {&null::<PFNGLWINDOWPOS2SPROC>()} else {&self.windowpos2s}})
			.field("windowpos2sv", unsafe{if transmute::<_, *const c_void>(self.windowpos2sv) == (dummy_pfnglwindowpos2svproc as *const c_void) {&null::<PFNGLWINDOWPOS2SVPROC>()} else {&self.windowpos2sv}})
			.field("windowpos3d", unsafe{if transmute::<_, *const c_void>(self.windowpos3d) == (dummy_pfnglwindowpos3dproc as *const c_void) {&null::<PFNGLWINDOWPOS3DPROC>()} else {&self.windowpos3d}})
			.field("windowpos3dv", unsafe{if transmute::<_, *const c_void>(self.windowpos3dv) == (dummy_pfnglwindowpos3dvproc as *const c_void) {&null::<PFNGLWINDOWPOS3DVPROC>()} else {&self.windowpos3dv}})
			.field("windowpos3f", unsafe{if transmute::<_, *const c_void>(self.windowpos3f) == (dummy_pfnglwindowpos3fproc as *const c_void) {&null::<PFNGLWINDOWPOS3FPROC>()} else {&self.windowpos3f}})
			.field("windowpos3fv", unsafe{if transmute::<_, *const c_void>(self.windowpos3fv) == (dummy_pfnglwindowpos3fvproc as *const c_void) {&null::<PFNGLWINDOWPOS3FVPROC>()} else {&self.windowpos3fv}})
			.field("windowpos3i", unsafe{if transmute::<_, *const c_void>(self.windowpos3i) == (dummy_pfnglwindowpos3iproc as *const c_void) {&null::<PFNGLWINDOWPOS3IPROC>()} else {&self.windowpos3i}})
			.field("windowpos3iv", unsafe{if transmute::<_, *const c_void>(self.windowpos3iv) == (dummy_pfnglwindowpos3ivproc as *const c_void) {&null::<PFNGLWINDOWPOS3IVPROC>()} else {&self.windowpos3iv}})
			.field("windowpos3s", unsafe{if transmute::<_, *const c_void>(self.windowpos3s) == (dummy_pfnglwindowpos3sproc as *const c_void) {&null::<PFNGLWINDOWPOS3SPROC>()} else {&self.windowpos3s}})
			.field("windowpos3sv", unsafe{if transmute::<_, *const c_void>(self.windowpos3sv) == (dummy_pfnglwindowpos3svproc as *const c_void) {&null::<PFNGLWINDOWPOS3SVPROC>()} else {&self.windowpos3sv}})
			.field("blendcolor", unsafe{if transmute::<_, *const c_void>(self.blendcolor) == (dummy_pfnglblendcolorproc as *const c_void) {&null::<PFNGLBLENDCOLORPROC>()} else {&self.blendcolor}})
			.field("blendequation", unsafe{if transmute::<_, *const c_void>(self.blendequation) == (dummy_pfnglblendequationproc as *const c_void) {&null::<PFNGLBLENDEQUATIONPROC>()} else {&self.blendequation}})
			.finish()
		} else {
			f.debug_struct("Version14")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

/// Alias to `khronos_ssize_t`
pub type GLsizeiptr = khronos_ssize_t;

/// Alias to `khronos_intptr_t`
pub type GLintptr = khronos_intptr_t;

/// The prototype to the OpenGL function `GenQueries`
type PFNGLGENQUERIESPROC = extern "system" fn(GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `DeleteQueries`
type PFNGLDELETEQUERIESPROC = extern "system" fn(GLsizei, *const GLuint);

/// The prototype to the OpenGL function `IsQuery`
type PFNGLISQUERYPROC = extern "system" fn(GLuint) -> GLboolean;

/// The prototype to the OpenGL function `BeginQuery`
type PFNGLBEGINQUERYPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `EndQuery`
type PFNGLENDQUERYPROC = extern "system" fn(GLenum);

/// The prototype to the OpenGL function `GetQueryiv`
type PFNGLGETQUERYIVPROC = extern "system" fn(GLenum, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetQueryObjectiv`
type PFNGLGETQUERYOBJECTIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetQueryObjectuiv`
type PFNGLGETQUERYOBJECTUIVPROC = extern "system" fn(GLuint, GLenum, *mut GLuint);

/// The prototype to the OpenGL function `BindBuffer`
type PFNGLBINDBUFFERPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `DeleteBuffers`
type PFNGLDELETEBUFFERSPROC = extern "system" fn(GLsizei, *const GLuint);

/// The prototype to the OpenGL function `GenBuffers`
type PFNGLGENBUFFERSPROC = extern "system" fn(GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `IsBuffer`
type PFNGLISBUFFERPROC = extern "system" fn(GLuint) -> GLboolean;

/// The prototype to the OpenGL function `BufferData`
type PFNGLBUFFERDATAPROC = extern "system" fn(GLenum, GLsizeiptr, *const c_void, GLenum);

/// The prototype to the OpenGL function `BufferSubData`
type PFNGLBUFFERSUBDATAPROC = extern "system" fn(GLenum, GLintptr, GLsizeiptr, *const c_void);

/// The prototype to the OpenGL function `GetBufferSubData`
type PFNGLGETBUFFERSUBDATAPROC = extern "system" fn(GLenum, GLintptr, GLsizeiptr, *mut c_void);

/// The prototype to the OpenGL function `MapBuffer`
type PFNGLMAPBUFFERPROC = extern "system" fn(GLenum, GLenum) -> *mut c_void;

/// The prototype to the OpenGL function `UnmapBuffer`
type PFNGLUNMAPBUFFERPROC = extern "system" fn(GLenum) -> GLboolean;

/// The prototype to the OpenGL function `GetBufferParameteriv`
type PFNGLGETBUFFERPARAMETERIVPROC = extern "system" fn(GLenum, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetBufferPointerv`
type PFNGLGETBUFFERPOINTERVPROC = extern "system" fn(GLenum, GLenum, *mut *mut c_void);

/// The dummy function of `GenQueries()`
extern "system" fn dummy_pfnglgenqueriesproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGenQueries()` is null.")
}

/// The dummy function of `DeleteQueries()`
extern "system" fn dummy_pfngldeletequeriesproc (_: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glDeleteQueries()` is null.")
}

/// The dummy function of `IsQuery()`
extern "system" fn dummy_pfnglisqueryproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsQuery()` is null.")
}

/// The dummy function of `BeginQuery()`
extern "system" fn dummy_pfnglbeginqueryproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glBeginQuery()` is null.")
}

/// The dummy function of `EndQuery()`
extern "system" fn dummy_pfnglendqueryproc (_: GLenum) {
	panic!("OpenGL function pointer `glEndQuery()` is null.")
}

/// The dummy function of `GetQueryiv()`
extern "system" fn dummy_pfnglgetqueryivproc (_: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetQueryiv()` is null.")
}

/// The dummy function of `GetQueryObjectiv()`
extern "system" fn dummy_pfnglgetqueryobjectivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetQueryObjectiv()` is null.")
}

/// The dummy function of `GetQueryObjectuiv()`
extern "system" fn dummy_pfnglgetqueryobjectuivproc (_: GLuint, _: GLenum, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetQueryObjectuiv()` is null.")
}

/// The dummy function of `BindBuffer()`
extern "system" fn dummy_pfnglbindbufferproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glBindBuffer()` is null.")
}

/// The dummy function of `DeleteBuffers()`
extern "system" fn dummy_pfngldeletebuffersproc (_: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glDeleteBuffers()` is null.")
}

/// The dummy function of `GenBuffers()`
extern "system" fn dummy_pfnglgenbuffersproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGenBuffers()` is null.")
}

/// The dummy function of `IsBuffer()`
extern "system" fn dummy_pfnglisbufferproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsBuffer()` is null.")
}

/// The dummy function of `BufferData()`
extern "system" fn dummy_pfnglbufferdataproc (_: GLenum, _: GLsizeiptr, _: *const c_void, _: GLenum) {
	panic!("OpenGL function pointer `glBufferData()` is null.")
}

/// The dummy function of `BufferSubData()`
extern "system" fn dummy_pfnglbuffersubdataproc (_: GLenum, _: GLintptr, _: GLsizeiptr, _: *const c_void) {
	panic!("OpenGL function pointer `glBufferSubData()` is null.")
}

/// The dummy function of `GetBufferSubData()`
extern "system" fn dummy_pfnglgetbuffersubdataproc (_: GLenum, _: GLintptr, _: GLsizeiptr, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetBufferSubData()` is null.")
}

/// The dummy function of `MapBuffer()`
extern "system" fn dummy_pfnglmapbufferproc (_: GLenum, _: GLenum) -> *mut c_void {
	panic!("OpenGL function pointer `glMapBuffer()` is null.")
}

/// The dummy function of `UnmapBuffer()`
extern "system" fn dummy_pfnglunmapbufferproc (_: GLenum) -> GLboolean {
	panic!("OpenGL function pointer `glUnmapBuffer()` is null.")
}

/// The dummy function of `GetBufferParameteriv()`
extern "system" fn dummy_pfnglgetbufferparameterivproc (_: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetBufferParameteriv()` is null.")
}

/// The dummy function of `GetBufferPointerv()`
extern "system" fn dummy_pfnglgetbufferpointervproc (_: GLenum, _: GLenum, _: *mut *mut c_void) {
	panic!("OpenGL function pointer `glGetBufferPointerv()` is null.")
}
/// Constant value defined from OpenGL 1.5
pub const GL_BUFFER_SIZE: GLenum = 0x8764;

/// Constant value defined from OpenGL 1.5
pub const GL_BUFFER_USAGE: GLenum = 0x8765;

/// Constant value defined from OpenGL 1.5
pub const GL_QUERY_COUNTER_BITS: GLenum = 0x8864;

/// Constant value defined from OpenGL 1.5
pub const GL_CURRENT_QUERY: GLenum = 0x8865;

/// Constant value defined from OpenGL 1.5
pub const GL_QUERY_RESULT: GLenum = 0x8866;

/// Constant value defined from OpenGL 1.5
pub const GL_QUERY_RESULT_AVAILABLE: GLenum = 0x8867;

/// Constant value defined from OpenGL 1.5
pub const GL_ARRAY_BUFFER: GLenum = 0x8892;

/// Constant value defined from OpenGL 1.5
pub const GL_ELEMENT_ARRAY_BUFFER: GLenum = 0x8893;

/// Constant value defined from OpenGL 1.5
pub const GL_ARRAY_BUFFER_BINDING: GLenum = 0x8894;

/// Constant value defined from OpenGL 1.5
pub const GL_ELEMENT_ARRAY_BUFFER_BINDING: GLenum = 0x8895;

/// Constant value defined from OpenGL 1.5
pub const GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: GLenum = 0x889F;

/// Constant value defined from OpenGL 1.5
pub const GL_READ_ONLY: GLenum = 0x88B8;

/// Constant value defined from OpenGL 1.5
pub const GL_WRITE_ONLY: GLenum = 0x88B9;

/// Constant value defined from OpenGL 1.5
pub const GL_READ_WRITE: GLenum = 0x88BA;

/// Constant value defined from OpenGL 1.5
pub const GL_BUFFER_ACCESS: GLenum = 0x88BB;

/// Constant value defined from OpenGL 1.5
pub const GL_BUFFER_MAPPED: GLenum = 0x88BC;

/// Constant value defined from OpenGL 1.5
pub const GL_BUFFER_MAP_POINTER: GLenum = 0x88BD;

/// Constant value defined from OpenGL 1.5
pub const GL_STREAM_DRAW: GLenum = 0x88E0;

/// Constant value defined from OpenGL 1.5
pub const GL_STREAM_READ: GLenum = 0x88E1;

/// Constant value defined from OpenGL 1.5
pub const GL_STREAM_COPY: GLenum = 0x88E2;

/// Constant value defined from OpenGL 1.5
pub const GL_STATIC_DRAW: GLenum = 0x88E4;

/// Constant value defined from OpenGL 1.5
pub const GL_STATIC_READ: GLenum = 0x88E5;

/// Constant value defined from OpenGL 1.5
pub const GL_STATIC_COPY: GLenum = 0x88E6;

/// Constant value defined from OpenGL 1.5
pub const GL_DYNAMIC_DRAW: GLenum = 0x88E8;

/// Constant value defined from OpenGL 1.5
pub const GL_DYNAMIC_READ: GLenum = 0x88E9;

/// Constant value defined from OpenGL 1.5
pub const GL_DYNAMIC_COPY: GLenum = 0x88EA;

/// Constant value defined from OpenGL 1.5
pub const GL_SAMPLES_PASSED: GLenum = 0x8914;

/// Constant value defined from OpenGL 1.5
pub const GL_SRC1_ALPHA: GLenum = 0x8589;

/// Constant value defined from OpenGL 1.5
pub const GL_VERTEX_ARRAY_BUFFER_BINDING: GLenum = 0x8896;

/// Constant value defined from OpenGL 1.5
pub const GL_NORMAL_ARRAY_BUFFER_BINDING: GLenum = 0x8897;

/// Constant value defined from OpenGL 1.5
pub const GL_COLOR_ARRAY_BUFFER_BINDING: GLenum = 0x8898;

/// Constant value defined from OpenGL 1.5
pub const GL_INDEX_ARRAY_BUFFER_BINDING: GLenum = 0x8899;

/// Constant value defined from OpenGL 1.5
pub const GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING: GLenum = 0x889A;

/// Constant value defined from OpenGL 1.5
pub const GL_EDGE_FLAG_ARRAY_BUFFER_BINDING: GLenum = 0x889B;

/// Constant value defined from OpenGL 1.5
pub const GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING: GLenum = 0x889C;

/// Constant value defined from OpenGL 1.5
pub const GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING: GLenum = 0x889D;

/// Constant value defined from OpenGL 1.5
pub const GL_WEIGHT_ARRAY_BUFFER_BINDING: GLenum = 0x889E;

/// Constant value defined from OpenGL 1.5
pub const GL_FOG_COORD_SRC: GLenum = 0x8450;

/// Constant value defined from OpenGL 1.5
pub const GL_FOG_COORD: GLenum = 0x8451;

/// Constant value defined from OpenGL 1.5
pub const GL_CURRENT_FOG_COORD: GLenum = 0x8453;

/// Constant value defined from OpenGL 1.5
pub const GL_FOG_COORD_ARRAY_TYPE: GLenum = 0x8454;

/// Constant value defined from OpenGL 1.5
pub const GL_FOG_COORD_ARRAY_STRIDE: GLenum = 0x8455;

/// Constant value defined from OpenGL 1.5
pub const GL_FOG_COORD_ARRAY_POINTER: GLenum = 0x8456;

/// Constant value defined from OpenGL 1.5
pub const GL_FOG_COORD_ARRAY: GLenum = 0x8457;

/// Constant value defined from OpenGL 1.5
pub const GL_FOG_COORD_ARRAY_BUFFER_BINDING: GLenum = 0x889D;

/// Constant value defined from OpenGL 1.5
pub const GL_SRC0_RGB: GLenum = 0x8580;

/// Constant value defined from OpenGL 1.5
pub const GL_SRC1_RGB: GLenum = 0x8581;

/// Constant value defined from OpenGL 1.5
pub const GL_SRC2_RGB: GLenum = 0x8582;

/// Constant value defined from OpenGL 1.5
pub const GL_SRC0_ALPHA: GLenum = 0x8588;

/// Constant value defined from OpenGL 1.5
pub const GL_SRC2_ALPHA: GLenum = 0x858A;

/// Functions from OpenGL version 1.5
pub trait GL_1_5 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	fn glGetError(&self) -> GLenum;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenQueries.xhtml>
	fn glGenQueries(&self, n: GLsizei, ids: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteQueries.xhtml>
	fn glDeleteQueries(&self, n: GLsizei, ids: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsQuery.xhtml>
	fn glIsQuery(&self, id: GLuint) -> Result<GLboolean>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBeginQuery.xhtml>
	fn glBeginQuery(&self, target: GLenum, id: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEndQuery.xhtml>
	fn glEndQuery(&self, target: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryiv.xhtml>
	fn glGetQueryiv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryObjectiv.xhtml>
	fn glGetQueryObjectiv(&self, id: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryObjectuiv.xhtml>
	fn glGetQueryObjectuiv(&self, id: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml>
	fn glBindBuffer(&self, target: GLenum, buffer: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteBuffers.xhtml>
	fn glDeleteBuffers(&self, n: GLsizei, buffers: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml>
	fn glGenBuffers(&self, n: GLsizei, buffers: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsBuffer.xhtml>
	fn glIsBuffer(&self, buffer: GLuint) -> Result<GLboolean>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBufferData.xhtml>
	fn glBufferData(&self, target: GLenum, size: GLsizeiptr, data: *const c_void, usage: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml>
	fn glBufferSubData(&self, target: GLenum, offset: GLintptr, size: GLsizeiptr, data: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetBufferSubData.xhtml>
	fn glGetBufferSubData(&self, target: GLenum, offset: GLintptr, size: GLsizeiptr, data: *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml>
	fn glMapBuffer(&self, target: GLenum, access: GLenum) -> Result<*mut c_void>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUnmapBuffer.xhtml>
	fn glUnmapBuffer(&self, target: GLenum) -> Result<GLboolean>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetBufferParameteriv.xhtml>
	fn glGetBufferParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetBufferPointerv.xhtml>
	fn glGetBufferPointerv(&self, target: GLenum, pname: GLenum, params: *mut *mut c_void) -> Result<()>;
}
/// Functions from OpenGL version 1.5
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version15 {
	/// Is OpenGL version 1.5 available
	available: bool,

	/// The function pointer to `glGetError()`
	pub geterror: PFNGLGETERRORPROC,

	/// The function pointer to `glGenQueries()`
	pub genqueries: PFNGLGENQUERIESPROC,

	/// The function pointer to `glDeleteQueries()`
	pub deletequeries: PFNGLDELETEQUERIESPROC,

	/// The function pointer to `glIsQuery()`
	pub isquery: PFNGLISQUERYPROC,

	/// The function pointer to `glBeginQuery()`
	pub beginquery: PFNGLBEGINQUERYPROC,

	/// The function pointer to `glEndQuery()`
	pub endquery: PFNGLENDQUERYPROC,

	/// The function pointer to `glGetQueryiv()`
	pub getqueryiv: PFNGLGETQUERYIVPROC,

	/// The function pointer to `glGetQueryObjectiv()`
	pub getqueryobjectiv: PFNGLGETQUERYOBJECTIVPROC,

	/// The function pointer to `glGetQueryObjectuiv()`
	pub getqueryobjectuiv: PFNGLGETQUERYOBJECTUIVPROC,

	/// The function pointer to `glBindBuffer()`
	pub bindbuffer: PFNGLBINDBUFFERPROC,

	/// The function pointer to `glDeleteBuffers()`
	pub deletebuffers: PFNGLDELETEBUFFERSPROC,

	/// The function pointer to `glGenBuffers()`
	pub genbuffers: PFNGLGENBUFFERSPROC,

	/// The function pointer to `glIsBuffer()`
	pub isbuffer: PFNGLISBUFFERPROC,

	/// The function pointer to `glBufferData()`
	pub bufferdata: PFNGLBUFFERDATAPROC,

	/// The function pointer to `glBufferSubData()`
	pub buffersubdata: PFNGLBUFFERSUBDATAPROC,

	/// The function pointer to `glGetBufferSubData()`
	pub getbuffersubdata: PFNGLGETBUFFERSUBDATAPROC,

	/// The function pointer to `glMapBuffer()`
	pub mapbuffer: PFNGLMAPBUFFERPROC,

	/// The function pointer to `glUnmapBuffer()`
	pub unmapbuffer: PFNGLUNMAPBUFFERPROC,

	/// The function pointer to `glGetBufferParameteriv()`
	pub getbufferparameteriv: PFNGLGETBUFFERPARAMETERIVPROC,

	/// The function pointer to `glGetBufferPointerv()`
	pub getbufferpointerv: PFNGLGETBUFFERPOINTERVPROC,
}

impl GL_1_5 for Version15 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenQueries.xhtml>
	#[inline(always)]
	fn glGenQueries(&self, n: GLsizei, ids: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenQueries", catch_unwind(||(self.genqueries)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenQueries", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteQueries.xhtml>
	#[inline(always)]
	fn glDeleteQueries(&self, n: GLsizei, ids: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteQueries", catch_unwind(||(self.deletequeries)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteQueries", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsQuery.xhtml>
	#[inline(always)]
	fn glIsQuery(&self, id: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsQuery", catch_unwind(||(self.isquery)(id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsQuery", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBeginQuery.xhtml>
	#[inline(always)]
	fn glBeginQuery(&self, target: GLenum, id: GLuint) -> Result<()> {
		let ret = process_catch("glBeginQuery", catch_unwind(||(self.beginquery)(target, id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBeginQuery", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEndQuery.xhtml>
	#[inline(always)]
	fn glEndQuery(&self, target: GLenum) -> Result<()> {
		let ret = process_catch("glEndQuery", catch_unwind(||(self.endquery)(target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEndQuery", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryiv.xhtml>
	#[inline(always)]
	fn glGetQueryiv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetQueryiv", catch_unwind(||(self.getqueryiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryObjectiv.xhtml>
	#[inline(always)]
	fn glGetQueryObjectiv(&self, id: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetQueryObjectiv", catch_unwind(||(self.getqueryobjectiv)(id, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryObjectiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryObjectuiv.xhtml>
	#[inline(always)]
	fn glGetQueryObjectuiv(&self, id: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetQueryObjectuiv", catch_unwind(||(self.getqueryobjectuiv)(id, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryObjectuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml>
	#[inline(always)]
	fn glBindBuffer(&self, target: GLenum, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glBindBuffer", catch_unwind(||(self.bindbuffer)(target, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteBuffers.xhtml>
	#[inline(always)]
	fn glDeleteBuffers(&self, n: GLsizei, buffers: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteBuffers", catch_unwind(||(self.deletebuffers)(n, buffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteBuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml>
	#[inline(always)]
	fn glGenBuffers(&self, n: GLsizei, buffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenBuffers", catch_unwind(||(self.genbuffers)(n, buffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenBuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsBuffer.xhtml>
	#[inline(always)]
	fn glIsBuffer(&self, buffer: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsBuffer", catch_unwind(||(self.isbuffer)(buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBufferData.xhtml>
	#[inline(always)]
	fn glBufferData(&self, target: GLenum, size: GLsizeiptr, data: *const c_void, usage: GLenum) -> Result<()> {
		let ret = process_catch("glBufferData", catch_unwind(||(self.bufferdata)(target, size, data, usage)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBufferData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml>
	#[inline(always)]
	fn glBufferSubData(&self, target: GLenum, offset: GLintptr, size: GLsizeiptr, data: *const c_void) -> Result<()> {
		let ret = process_catch("glBufferSubData", catch_unwind(||(self.buffersubdata)(target, offset, size, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetBufferSubData.xhtml>
	#[inline(always)]
	fn glGetBufferSubData(&self, target: GLenum, offset: GLintptr, size: GLsizeiptr, data: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetBufferSubData", catch_unwind(||(self.getbuffersubdata)(target, offset, size, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml>
	#[inline(always)]
	fn glMapBuffer(&self, target: GLenum, access: GLenum) -> Result<*mut c_void> {
		let ret = process_catch("glMapBuffer", catch_unwind(||(self.mapbuffer)(target, access)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMapBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUnmapBuffer.xhtml>
	#[inline(always)]
	fn glUnmapBuffer(&self, target: GLenum) -> Result<GLboolean> {
		let ret = process_catch("glUnmapBuffer", catch_unwind(||(self.unmapbuffer)(target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUnmapBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetBufferParameteriv.xhtml>
	#[inline(always)]
	fn glGetBufferParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetBufferParameteriv", catch_unwind(||(self.getbufferparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBufferParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetBufferPointerv.xhtml>
	#[inline(always)]
	fn glGetBufferPointerv(&self, target: GLenum, pname: GLenum, params: *mut *mut c_void) -> Result<()> {
		let ret = process_catch("glGetBufferPointerv", catch_unwind(||(self.getbufferpointerv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBufferPointerv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version15 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (1, 5, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			genqueries: {let proc = get_proc_address("glGenQueries"); if proc == null() {dummy_pfnglgenqueriesproc} else {unsafe{transmute(proc)}}},
			deletequeries: {let proc = get_proc_address("glDeleteQueries"); if proc == null() {dummy_pfngldeletequeriesproc} else {unsafe{transmute(proc)}}},
			isquery: {let proc = get_proc_address("glIsQuery"); if proc == null() {dummy_pfnglisqueryproc} else {unsafe{transmute(proc)}}},
			beginquery: {let proc = get_proc_address("glBeginQuery"); if proc == null() {dummy_pfnglbeginqueryproc} else {unsafe{transmute(proc)}}},
			endquery: {let proc = get_proc_address("glEndQuery"); if proc == null() {dummy_pfnglendqueryproc} else {unsafe{transmute(proc)}}},
			getqueryiv: {let proc = get_proc_address("glGetQueryiv"); if proc == null() {dummy_pfnglgetqueryivproc} else {unsafe{transmute(proc)}}},
			getqueryobjectiv: {let proc = get_proc_address("glGetQueryObjectiv"); if proc == null() {dummy_pfnglgetqueryobjectivproc} else {unsafe{transmute(proc)}}},
			getqueryobjectuiv: {let proc = get_proc_address("glGetQueryObjectuiv"); if proc == null() {dummy_pfnglgetqueryobjectuivproc} else {unsafe{transmute(proc)}}},
			bindbuffer: {let proc = get_proc_address("glBindBuffer"); if proc == null() {dummy_pfnglbindbufferproc} else {unsafe{transmute(proc)}}},
			deletebuffers: {let proc = get_proc_address("glDeleteBuffers"); if proc == null() {dummy_pfngldeletebuffersproc} else {unsafe{transmute(proc)}}},
			genbuffers: {let proc = get_proc_address("glGenBuffers"); if proc == null() {dummy_pfnglgenbuffersproc} else {unsafe{transmute(proc)}}},
			isbuffer: {let proc = get_proc_address("glIsBuffer"); if proc == null() {dummy_pfnglisbufferproc} else {unsafe{transmute(proc)}}},
			bufferdata: {let proc = get_proc_address("glBufferData"); if proc == null() {dummy_pfnglbufferdataproc} else {unsafe{transmute(proc)}}},
			buffersubdata: {let proc = get_proc_address("glBufferSubData"); if proc == null() {dummy_pfnglbuffersubdataproc} else {unsafe{transmute(proc)}}},
			getbuffersubdata: {let proc = get_proc_address("glGetBufferSubData"); if proc == null() {dummy_pfnglgetbuffersubdataproc} else {unsafe{transmute(proc)}}},
			mapbuffer: {let proc = get_proc_address("glMapBuffer"); if proc == null() {dummy_pfnglmapbufferproc} else {unsafe{transmute(proc)}}},
			unmapbuffer: {let proc = get_proc_address("glUnmapBuffer"); if proc == null() {dummy_pfnglunmapbufferproc} else {unsafe{transmute(proc)}}},
			getbufferparameteriv: {let proc = get_proc_address("glGetBufferParameteriv"); if proc == null() {dummy_pfnglgetbufferparameterivproc} else {unsafe{transmute(proc)}}},
			getbufferpointerv: {let proc = get_proc_address("glGetBufferPointerv"); if proc == null() {dummy_pfnglgetbufferpointervproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version15 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			genqueries: dummy_pfnglgenqueriesproc,
			deletequeries: dummy_pfngldeletequeriesproc,
			isquery: dummy_pfnglisqueryproc,
			beginquery: dummy_pfnglbeginqueryproc,
			endquery: dummy_pfnglendqueryproc,
			getqueryiv: dummy_pfnglgetqueryivproc,
			getqueryobjectiv: dummy_pfnglgetqueryobjectivproc,
			getqueryobjectuiv: dummy_pfnglgetqueryobjectuivproc,
			bindbuffer: dummy_pfnglbindbufferproc,
			deletebuffers: dummy_pfngldeletebuffersproc,
			genbuffers: dummy_pfnglgenbuffersproc,
			isbuffer: dummy_pfnglisbufferproc,
			bufferdata: dummy_pfnglbufferdataproc,
			buffersubdata: dummy_pfnglbuffersubdataproc,
			getbuffersubdata: dummy_pfnglgetbuffersubdataproc,
			mapbuffer: dummy_pfnglmapbufferproc,
			unmapbuffer: dummy_pfnglunmapbufferproc,
			getbufferparameteriv: dummy_pfnglgetbufferparameterivproc,
			getbufferpointerv: dummy_pfnglgetbufferpointervproc,
		}
	}
}
impl Debug for Version15 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version15")
			.field("available", &self.available)
			.field("genqueries", unsafe{if transmute::<_, *const c_void>(self.genqueries) == (dummy_pfnglgenqueriesproc as *const c_void) {&null::<PFNGLGENQUERIESPROC>()} else {&self.genqueries}})
			.field("deletequeries", unsafe{if transmute::<_, *const c_void>(self.deletequeries) == (dummy_pfngldeletequeriesproc as *const c_void) {&null::<PFNGLDELETEQUERIESPROC>()} else {&self.deletequeries}})
			.field("isquery", unsafe{if transmute::<_, *const c_void>(self.isquery) == (dummy_pfnglisqueryproc as *const c_void) {&null::<PFNGLISQUERYPROC>()} else {&self.isquery}})
			.field("beginquery", unsafe{if transmute::<_, *const c_void>(self.beginquery) == (dummy_pfnglbeginqueryproc as *const c_void) {&null::<PFNGLBEGINQUERYPROC>()} else {&self.beginquery}})
			.field("endquery", unsafe{if transmute::<_, *const c_void>(self.endquery) == (dummy_pfnglendqueryproc as *const c_void) {&null::<PFNGLENDQUERYPROC>()} else {&self.endquery}})
			.field("getqueryiv", unsafe{if transmute::<_, *const c_void>(self.getqueryiv) == (dummy_pfnglgetqueryivproc as *const c_void) {&null::<PFNGLGETQUERYIVPROC>()} else {&self.getqueryiv}})
			.field("getqueryobjectiv", unsafe{if transmute::<_, *const c_void>(self.getqueryobjectiv) == (dummy_pfnglgetqueryobjectivproc as *const c_void) {&null::<PFNGLGETQUERYOBJECTIVPROC>()} else {&self.getqueryobjectiv}})
			.field("getqueryobjectuiv", unsafe{if transmute::<_, *const c_void>(self.getqueryobjectuiv) == (dummy_pfnglgetqueryobjectuivproc as *const c_void) {&null::<PFNGLGETQUERYOBJECTUIVPROC>()} else {&self.getqueryobjectuiv}})
			.field("bindbuffer", unsafe{if transmute::<_, *const c_void>(self.bindbuffer) == (dummy_pfnglbindbufferproc as *const c_void) {&null::<PFNGLBINDBUFFERPROC>()} else {&self.bindbuffer}})
			.field("deletebuffers", unsafe{if transmute::<_, *const c_void>(self.deletebuffers) == (dummy_pfngldeletebuffersproc as *const c_void) {&null::<PFNGLDELETEBUFFERSPROC>()} else {&self.deletebuffers}})
			.field("genbuffers", unsafe{if transmute::<_, *const c_void>(self.genbuffers) == (dummy_pfnglgenbuffersproc as *const c_void) {&null::<PFNGLGENBUFFERSPROC>()} else {&self.genbuffers}})
			.field("isbuffer", unsafe{if transmute::<_, *const c_void>(self.isbuffer) == (dummy_pfnglisbufferproc as *const c_void) {&null::<PFNGLISBUFFERPROC>()} else {&self.isbuffer}})
			.field("bufferdata", unsafe{if transmute::<_, *const c_void>(self.bufferdata) == (dummy_pfnglbufferdataproc as *const c_void) {&null::<PFNGLBUFFERDATAPROC>()} else {&self.bufferdata}})
			.field("buffersubdata", unsafe{if transmute::<_, *const c_void>(self.buffersubdata) == (dummy_pfnglbuffersubdataproc as *const c_void) {&null::<PFNGLBUFFERSUBDATAPROC>()} else {&self.buffersubdata}})
			.field("getbuffersubdata", unsafe{if transmute::<_, *const c_void>(self.getbuffersubdata) == (dummy_pfnglgetbuffersubdataproc as *const c_void) {&null::<PFNGLGETBUFFERSUBDATAPROC>()} else {&self.getbuffersubdata}})
			.field("mapbuffer", unsafe{if transmute::<_, *const c_void>(self.mapbuffer) == (dummy_pfnglmapbufferproc as *const c_void) {&null::<PFNGLMAPBUFFERPROC>()} else {&self.mapbuffer}})
			.field("unmapbuffer", unsafe{if transmute::<_, *const c_void>(self.unmapbuffer) == (dummy_pfnglunmapbufferproc as *const c_void) {&null::<PFNGLUNMAPBUFFERPROC>()} else {&self.unmapbuffer}})
			.field("getbufferparameteriv", unsafe{if transmute::<_, *const c_void>(self.getbufferparameteriv) == (dummy_pfnglgetbufferparameterivproc as *const c_void) {&null::<PFNGLGETBUFFERPARAMETERIVPROC>()} else {&self.getbufferparameteriv}})
			.field("getbufferpointerv", unsafe{if transmute::<_, *const c_void>(self.getbufferpointerv) == (dummy_pfnglgetbufferpointervproc as *const c_void) {&null::<PFNGLGETBUFFERPOINTERVPROC>()} else {&self.getbufferpointerv}})
			.finish()
		} else {
			f.debug_struct("Version15")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

/// Alias to `i8`
pub type GLchar = i8;

/// The prototype to the OpenGL function `BlendEquationSeparate`
type PFNGLBLENDEQUATIONSEPARATEPROC = extern "system" fn(GLenum, GLenum);

/// The prototype to the OpenGL function `DrawBuffers`
type PFNGLDRAWBUFFERSPROC = extern "system" fn(GLsizei, *const GLenum);

/// The prototype to the OpenGL function `StencilOpSeparate`
type PFNGLSTENCILOPSEPARATEPROC = extern "system" fn(GLenum, GLenum, GLenum, GLenum);

/// The prototype to the OpenGL function `StencilFuncSeparate`
type PFNGLSTENCILFUNCSEPARATEPROC = extern "system" fn(GLenum, GLenum, GLint, GLuint);

/// The prototype to the OpenGL function `StencilMaskSeparate`
type PFNGLSTENCILMASKSEPARATEPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `AttachShader`
type PFNGLATTACHSHADERPROC = extern "system" fn(GLuint, GLuint);

/// The prototype to the OpenGL function `BindAttribLocation`
type PFNGLBINDATTRIBLOCATIONPROC = extern "system" fn(GLuint, GLuint, *const GLchar);

/// The prototype to the OpenGL function `CompileShader`
type PFNGLCOMPILESHADERPROC = extern "system" fn(GLuint);

/// The prototype to the OpenGL function `CreateProgram`
type PFNGLCREATEPROGRAMPROC = extern "system" fn() -> GLuint;

/// The prototype to the OpenGL function `CreateShader`
type PFNGLCREATESHADERPROC = extern "system" fn(GLenum) -> GLuint;

/// The prototype to the OpenGL function `DeleteProgram`
type PFNGLDELETEPROGRAMPROC = extern "system" fn(GLuint);

/// The prototype to the OpenGL function `DeleteShader`
type PFNGLDELETESHADERPROC = extern "system" fn(GLuint);

/// The prototype to the OpenGL function `DetachShader`
type PFNGLDETACHSHADERPROC = extern "system" fn(GLuint, GLuint);

/// The prototype to the OpenGL function `DisableVertexAttribArray`
type PFNGLDISABLEVERTEXATTRIBARRAYPROC = extern "system" fn(GLuint);

/// The prototype to the OpenGL function `EnableVertexAttribArray`
type PFNGLENABLEVERTEXATTRIBARRAYPROC = extern "system" fn(GLuint);

/// The prototype to the OpenGL function `GetActiveAttrib`
type PFNGLGETACTIVEATTRIBPROC = extern "system" fn(GLuint, GLuint, GLsizei, *mut GLsizei, *mut GLint, *mut GLenum, *mut GLchar);

/// The prototype to the OpenGL function `GetActiveUniform`
type PFNGLGETACTIVEUNIFORMPROC = extern "system" fn(GLuint, GLuint, GLsizei, *mut GLsizei, *mut GLint, *mut GLenum, *mut GLchar);

/// The prototype to the OpenGL function `GetAttachedShaders`
type PFNGLGETATTACHEDSHADERSPROC = extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `GetAttribLocation`
type PFNGLGETATTRIBLOCATIONPROC = extern "system" fn(GLuint, *const GLchar) -> GLint;

/// The prototype to the OpenGL function `GetProgramiv`
type PFNGLGETPROGRAMIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetProgramInfoLog`
type PFNGLGETPROGRAMINFOLOGPROC = extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar);

/// The prototype to the OpenGL function `GetShaderiv`
type PFNGLGETSHADERIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetShaderInfoLog`
type PFNGLGETSHADERINFOLOGPROC = extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar);

/// The prototype to the OpenGL function `GetShaderSource`
type PFNGLGETSHADERSOURCEPROC = extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar);

/// The prototype to the OpenGL function `GetUniformLocation`
type PFNGLGETUNIFORMLOCATIONPROC = extern "system" fn(GLuint, *const GLchar) -> GLint;

/// The prototype to the OpenGL function `GetUniformfv`
type PFNGLGETUNIFORMFVPROC = extern "system" fn(GLuint, GLint, *mut GLfloat);

/// The prototype to the OpenGL function `GetUniformiv`
type PFNGLGETUNIFORMIVPROC = extern "system" fn(GLuint, GLint, *mut GLint);

/// The prototype to the OpenGL function `GetVertexAttribdv`
type PFNGLGETVERTEXATTRIBDVPROC = extern "system" fn(GLuint, GLenum, *mut GLdouble);

/// The prototype to the OpenGL function `GetVertexAttribfv`
type PFNGLGETVERTEXATTRIBFVPROC = extern "system" fn(GLuint, GLenum, *mut GLfloat);

/// The prototype to the OpenGL function `GetVertexAttribiv`
type PFNGLGETVERTEXATTRIBIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetVertexAttribPointerv`
type PFNGLGETVERTEXATTRIBPOINTERVPROC = extern "system" fn(GLuint, GLenum, *mut *mut c_void);

/// The prototype to the OpenGL function `IsProgram`
type PFNGLISPROGRAMPROC = extern "system" fn(GLuint) -> GLboolean;

/// The prototype to the OpenGL function `IsShader`
type PFNGLISSHADERPROC = extern "system" fn(GLuint) -> GLboolean;

/// The prototype to the OpenGL function `LinkProgram`
type PFNGLLINKPROGRAMPROC = extern "system" fn(GLuint);

/// The prototype to the OpenGL function `ShaderSource`
type PFNGLSHADERSOURCEPROC = extern "system" fn(GLuint, GLsizei, *const *const GLchar, *const GLint);

/// The prototype to the OpenGL function `UseProgram`
type PFNGLUSEPROGRAMPROC = extern "system" fn(GLuint);

/// The prototype to the OpenGL function `Uniform1f`
type PFNGLUNIFORM1FPROC = extern "system" fn(GLint, GLfloat);

/// The prototype to the OpenGL function `Uniform2f`
type PFNGLUNIFORM2FPROC = extern "system" fn(GLint, GLfloat, GLfloat);

/// The prototype to the OpenGL function `Uniform3f`
type PFNGLUNIFORM3FPROC = extern "system" fn(GLint, GLfloat, GLfloat, GLfloat);

/// The prototype to the OpenGL function `Uniform4f`
type PFNGLUNIFORM4FPROC = extern "system" fn(GLint, GLfloat, GLfloat, GLfloat, GLfloat);

/// The prototype to the OpenGL function `Uniform1i`
type PFNGLUNIFORM1IPROC = extern "system" fn(GLint, GLint);

/// The prototype to the OpenGL function `Uniform2i`
type PFNGLUNIFORM2IPROC = extern "system" fn(GLint, GLint, GLint);

/// The prototype to the OpenGL function `Uniform3i`
type PFNGLUNIFORM3IPROC = extern "system" fn(GLint, GLint, GLint, GLint);

/// The prototype to the OpenGL function `Uniform4i`
type PFNGLUNIFORM4IPROC = extern "system" fn(GLint, GLint, GLint, GLint, GLint);

/// The prototype to the OpenGL function `Uniform1fv`
type PFNGLUNIFORM1FVPROC = extern "system" fn(GLint, GLsizei, *const GLfloat);

/// The prototype to the OpenGL function `Uniform2fv`
type PFNGLUNIFORM2FVPROC = extern "system" fn(GLint, GLsizei, *const GLfloat);

/// The prototype to the OpenGL function `Uniform3fv`
type PFNGLUNIFORM3FVPROC = extern "system" fn(GLint, GLsizei, *const GLfloat);

/// The prototype to the OpenGL function `Uniform4fv`
type PFNGLUNIFORM4FVPROC = extern "system" fn(GLint, GLsizei, *const GLfloat);

/// The prototype to the OpenGL function `Uniform1iv`
type PFNGLUNIFORM1IVPROC = extern "system" fn(GLint, GLsizei, *const GLint);

/// The prototype to the OpenGL function `Uniform2iv`
type PFNGLUNIFORM2IVPROC = extern "system" fn(GLint, GLsizei, *const GLint);

/// The prototype to the OpenGL function `Uniform3iv`
type PFNGLUNIFORM3IVPROC = extern "system" fn(GLint, GLsizei, *const GLint);

/// The prototype to the OpenGL function `Uniform4iv`
type PFNGLUNIFORM4IVPROC = extern "system" fn(GLint, GLsizei, *const GLint);

/// The prototype to the OpenGL function `UniformMatrix2fv`
type PFNGLUNIFORMMATRIX2FVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat);

/// The prototype to the OpenGL function `UniformMatrix3fv`
type PFNGLUNIFORMMATRIX3FVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat);

/// The prototype to the OpenGL function `UniformMatrix4fv`
type PFNGLUNIFORMMATRIX4FVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat);

/// The prototype to the OpenGL function `ValidateProgram`
type PFNGLVALIDATEPROGRAMPROC = extern "system" fn(GLuint);

/// The prototype to the OpenGL function `VertexAttrib1d`
type PFNGLVERTEXATTRIB1DPROC = extern "system" fn(GLuint, GLdouble);

/// The prototype to the OpenGL function `VertexAttrib1dv`
type PFNGLVERTEXATTRIB1DVPROC = extern "system" fn(GLuint, *const GLdouble);

/// The prototype to the OpenGL function `VertexAttrib1f`
type PFNGLVERTEXATTRIB1FPROC = extern "system" fn(GLuint, GLfloat);

/// The prototype to the OpenGL function `VertexAttrib1fv`
type PFNGLVERTEXATTRIB1FVPROC = extern "system" fn(GLuint, *const GLfloat);

/// The prototype to the OpenGL function `VertexAttrib1s`
type PFNGLVERTEXATTRIB1SPROC = extern "system" fn(GLuint, GLshort);

/// The prototype to the OpenGL function `VertexAttrib1sv`
type PFNGLVERTEXATTRIB1SVPROC = extern "system" fn(GLuint, *const GLshort);

/// The prototype to the OpenGL function `VertexAttrib2d`
type PFNGLVERTEXATTRIB2DPROC = extern "system" fn(GLuint, GLdouble, GLdouble);

/// The prototype to the OpenGL function `VertexAttrib2dv`
type PFNGLVERTEXATTRIB2DVPROC = extern "system" fn(GLuint, *const GLdouble);

/// The prototype to the OpenGL function `VertexAttrib2f`
type PFNGLVERTEXATTRIB2FPROC = extern "system" fn(GLuint, GLfloat, GLfloat);

/// The prototype to the OpenGL function `VertexAttrib2fv`
type PFNGLVERTEXATTRIB2FVPROC = extern "system" fn(GLuint, *const GLfloat);

/// The prototype to the OpenGL function `VertexAttrib2s`
type PFNGLVERTEXATTRIB2SPROC = extern "system" fn(GLuint, GLshort, GLshort);

/// The prototype to the OpenGL function `VertexAttrib2sv`
type PFNGLVERTEXATTRIB2SVPROC = extern "system" fn(GLuint, *const GLshort);

/// The prototype to the OpenGL function `VertexAttrib3d`
type PFNGLVERTEXATTRIB3DPROC = extern "system" fn(GLuint, GLdouble, GLdouble, GLdouble);

/// The prototype to the OpenGL function `VertexAttrib3dv`
type PFNGLVERTEXATTRIB3DVPROC = extern "system" fn(GLuint, *const GLdouble);

/// The prototype to the OpenGL function `VertexAttrib3f`
type PFNGLVERTEXATTRIB3FPROC = extern "system" fn(GLuint, GLfloat, GLfloat, GLfloat);

/// The prototype to the OpenGL function `VertexAttrib3fv`
type PFNGLVERTEXATTRIB3FVPROC = extern "system" fn(GLuint, *const GLfloat);

/// The prototype to the OpenGL function `VertexAttrib3s`
type PFNGLVERTEXATTRIB3SPROC = extern "system" fn(GLuint, GLshort, GLshort, GLshort);

/// The prototype to the OpenGL function `VertexAttrib3sv`
type PFNGLVERTEXATTRIB3SVPROC = extern "system" fn(GLuint, *const GLshort);

/// The prototype to the OpenGL function `VertexAttrib4Nbv`
type PFNGLVERTEXATTRIB4NBVPROC = extern "system" fn(GLuint, *const GLbyte);

/// The prototype to the OpenGL function `VertexAttrib4Niv`
type PFNGLVERTEXATTRIB4NIVPROC = extern "system" fn(GLuint, *const GLint);

/// The prototype to the OpenGL function `VertexAttrib4Nsv`
type PFNGLVERTEXATTRIB4NSVPROC = extern "system" fn(GLuint, *const GLshort);

/// The prototype to the OpenGL function `VertexAttrib4Nub`
type PFNGLVERTEXATTRIB4NUBPROC = extern "system" fn(GLuint, GLubyte, GLubyte, GLubyte, GLubyte);

/// The prototype to the OpenGL function `VertexAttrib4Nubv`
type PFNGLVERTEXATTRIB4NUBVPROC = extern "system" fn(GLuint, *const GLubyte);

/// The prototype to the OpenGL function `VertexAttrib4Nuiv`
type PFNGLVERTEXATTRIB4NUIVPROC = extern "system" fn(GLuint, *const GLuint);

/// The prototype to the OpenGL function `VertexAttrib4Nusv`
type PFNGLVERTEXATTRIB4NUSVPROC = extern "system" fn(GLuint, *const GLushort);

/// The prototype to the OpenGL function `VertexAttrib4bv`
type PFNGLVERTEXATTRIB4BVPROC = extern "system" fn(GLuint, *const GLbyte);

/// The prototype to the OpenGL function `VertexAttrib4d`
type PFNGLVERTEXATTRIB4DPROC = extern "system" fn(GLuint, GLdouble, GLdouble, GLdouble, GLdouble);

/// The prototype to the OpenGL function `VertexAttrib4dv`
type PFNGLVERTEXATTRIB4DVPROC = extern "system" fn(GLuint, *const GLdouble);

/// The prototype to the OpenGL function `VertexAttrib4f`
type PFNGLVERTEXATTRIB4FPROC = extern "system" fn(GLuint, GLfloat, GLfloat, GLfloat, GLfloat);

/// The prototype to the OpenGL function `VertexAttrib4fv`
type PFNGLVERTEXATTRIB4FVPROC = extern "system" fn(GLuint, *const GLfloat);

/// The prototype to the OpenGL function `VertexAttrib4iv`
type PFNGLVERTEXATTRIB4IVPROC = extern "system" fn(GLuint, *const GLint);

/// The prototype to the OpenGL function `VertexAttrib4s`
type PFNGLVERTEXATTRIB4SPROC = extern "system" fn(GLuint, GLshort, GLshort, GLshort, GLshort);

/// The prototype to the OpenGL function `VertexAttrib4sv`
type PFNGLVERTEXATTRIB4SVPROC = extern "system" fn(GLuint, *const GLshort);

/// The prototype to the OpenGL function `VertexAttrib4ubv`
type PFNGLVERTEXATTRIB4UBVPROC = extern "system" fn(GLuint, *const GLubyte);

/// The prototype to the OpenGL function `VertexAttrib4uiv`
type PFNGLVERTEXATTRIB4UIVPROC = extern "system" fn(GLuint, *const GLuint);

/// The prototype to the OpenGL function `VertexAttrib4usv`
type PFNGLVERTEXATTRIB4USVPROC = extern "system" fn(GLuint, *const GLushort);

/// The prototype to the OpenGL function `VertexAttribPointer`
type PFNGLVERTEXATTRIBPOINTERPROC = extern "system" fn(GLuint, GLint, GLenum, GLboolean, GLsizei, *const c_void);

/// The dummy function of `BlendEquationSeparate()`
extern "system" fn dummy_pfnglblendequationseparateproc (_: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glBlendEquationSeparate()` is null.")
}

/// The dummy function of `DrawBuffers()`
extern "system" fn dummy_pfngldrawbuffersproc (_: GLsizei, _: *const GLenum) {
	panic!("OpenGL function pointer `glDrawBuffers()` is null.")
}

/// The dummy function of `StencilOpSeparate()`
extern "system" fn dummy_pfnglstencilopseparateproc (_: GLenum, _: GLenum, _: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glStencilOpSeparate()` is null.")
}

/// The dummy function of `StencilFuncSeparate()`
extern "system" fn dummy_pfnglstencilfuncseparateproc (_: GLenum, _: GLenum, _: GLint, _: GLuint) {
	panic!("OpenGL function pointer `glStencilFuncSeparate()` is null.")
}

/// The dummy function of `StencilMaskSeparate()`
extern "system" fn dummy_pfnglstencilmaskseparateproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glStencilMaskSeparate()` is null.")
}

/// The dummy function of `AttachShader()`
extern "system" fn dummy_pfnglattachshaderproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glAttachShader()` is null.")
}

/// The dummy function of `BindAttribLocation()`
extern "system" fn dummy_pfnglbindattriblocationproc (_: GLuint, _: GLuint, _: *const GLchar) {
	panic!("OpenGL function pointer `glBindAttribLocation()` is null.")
}

/// The dummy function of `CompileShader()`
extern "system" fn dummy_pfnglcompileshaderproc (_: GLuint) {
	panic!("OpenGL function pointer `glCompileShader()` is null.")
}

/// The dummy function of `CreateProgram()`
extern "system" fn dummy_pfnglcreateprogramproc () -> GLuint {
	panic!("OpenGL function pointer `glCreateProgram()` is null.")
}

/// The dummy function of `CreateShader()`
extern "system" fn dummy_pfnglcreateshaderproc (_: GLenum) -> GLuint {
	panic!("OpenGL function pointer `glCreateShader()` is null.")
}

/// The dummy function of `DeleteProgram()`
extern "system" fn dummy_pfngldeleteprogramproc (_: GLuint) {
	panic!("OpenGL function pointer `glDeleteProgram()` is null.")
}

/// The dummy function of `DeleteShader()`
extern "system" fn dummy_pfngldeleteshaderproc (_: GLuint) {
	panic!("OpenGL function pointer `glDeleteShader()` is null.")
}

/// The dummy function of `DetachShader()`
extern "system" fn dummy_pfngldetachshaderproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glDetachShader()` is null.")
}

/// The dummy function of `DisableVertexAttribArray()`
extern "system" fn dummy_pfngldisablevertexattribarrayproc (_: GLuint) {
	panic!("OpenGL function pointer `glDisableVertexAttribArray()` is null.")
}

/// The dummy function of `EnableVertexAttribArray()`
extern "system" fn dummy_pfnglenablevertexattribarrayproc (_: GLuint) {
	panic!("OpenGL function pointer `glEnableVertexAttribArray()` is null.")
}

/// The dummy function of `GetActiveAttrib()`
extern "system" fn dummy_pfnglgetactiveattribproc (_: GLuint, _: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLint, _: *mut GLenum, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetActiveAttrib()` is null.")
}

/// The dummy function of `GetActiveUniform()`
extern "system" fn dummy_pfnglgetactiveuniformproc (_: GLuint, _: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLint, _: *mut GLenum, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetActiveUniform()` is null.")
}

/// The dummy function of `GetAttachedShaders()`
extern "system" fn dummy_pfnglgetattachedshadersproc (_: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetAttachedShaders()` is null.")
}

/// The dummy function of `GetAttribLocation()`
extern "system" fn dummy_pfnglgetattriblocationproc (_: GLuint, _: *const GLchar) -> GLint {
	panic!("OpenGL function pointer `glGetAttribLocation()` is null.")
}

/// The dummy function of `GetProgramiv()`
extern "system" fn dummy_pfnglgetprogramivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetProgramiv()` is null.")
}

/// The dummy function of `GetProgramInfoLog()`
extern "system" fn dummy_pfnglgetprograminfologproc (_: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetProgramInfoLog()` is null.")
}

/// The dummy function of `GetShaderiv()`
extern "system" fn dummy_pfnglgetshaderivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetShaderiv()` is null.")
}

/// The dummy function of `GetShaderInfoLog()`
extern "system" fn dummy_pfnglgetshaderinfologproc (_: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetShaderInfoLog()` is null.")
}

/// The dummy function of `GetShaderSource()`
extern "system" fn dummy_pfnglgetshadersourceproc (_: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetShaderSource()` is null.")
}

/// The dummy function of `GetUniformLocation()`
extern "system" fn dummy_pfnglgetuniformlocationproc (_: GLuint, _: *const GLchar) -> GLint {
	panic!("OpenGL function pointer `glGetUniformLocation()` is null.")
}

/// The dummy function of `GetUniformfv()`
extern "system" fn dummy_pfnglgetuniformfvproc (_: GLuint, _: GLint, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetUniformfv()` is null.")
}

/// The dummy function of `GetUniformiv()`
extern "system" fn dummy_pfnglgetuniformivproc (_: GLuint, _: GLint, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetUniformiv()` is null.")
}

/// The dummy function of `GetVertexAttribdv()`
extern "system" fn dummy_pfnglgetvertexattribdvproc (_: GLuint, _: GLenum, _: *mut GLdouble) {
	panic!("OpenGL function pointer `glGetVertexAttribdv()` is null.")
}

/// The dummy function of `GetVertexAttribfv()`
extern "system" fn dummy_pfnglgetvertexattribfvproc (_: GLuint, _: GLenum, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetVertexAttribfv()` is null.")
}

/// The dummy function of `GetVertexAttribiv()`
extern "system" fn dummy_pfnglgetvertexattribivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetVertexAttribiv()` is null.")
}

/// The dummy function of `GetVertexAttribPointerv()`
extern "system" fn dummy_pfnglgetvertexattribpointervproc (_: GLuint, _: GLenum, _: *mut *mut c_void) {
	panic!("OpenGL function pointer `glGetVertexAttribPointerv()` is null.")
}

/// The dummy function of `IsProgram()`
extern "system" fn dummy_pfnglisprogramproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsProgram()` is null.")
}

/// The dummy function of `IsShader()`
extern "system" fn dummy_pfnglisshaderproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsShader()` is null.")
}

/// The dummy function of `LinkProgram()`
extern "system" fn dummy_pfngllinkprogramproc (_: GLuint) {
	panic!("OpenGL function pointer `glLinkProgram()` is null.")
}

/// The dummy function of `ShaderSource()`
extern "system" fn dummy_pfnglshadersourceproc (_: GLuint, _: GLsizei, _: *const *const GLchar, _: *const GLint) {
	panic!("OpenGL function pointer `glShaderSource()` is null.")
}

/// The dummy function of `UseProgram()`
extern "system" fn dummy_pfngluseprogramproc (_: GLuint) {
	panic!("OpenGL function pointer `glUseProgram()` is null.")
}

/// The dummy function of `Uniform1f()`
extern "system" fn dummy_pfngluniform1fproc (_: GLint, _: GLfloat) {
	panic!("OpenGL function pointer `glUniform1f()` is null.")
}

/// The dummy function of `Uniform2f()`
extern "system" fn dummy_pfngluniform2fproc (_: GLint, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glUniform2f()` is null.")
}

/// The dummy function of `Uniform3f()`
extern "system" fn dummy_pfngluniform3fproc (_: GLint, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glUniform3f()` is null.")
}

/// The dummy function of `Uniform4f()`
extern "system" fn dummy_pfngluniform4fproc (_: GLint, _: GLfloat, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glUniform4f()` is null.")
}

/// The dummy function of `Uniform1i()`
extern "system" fn dummy_pfngluniform1iproc (_: GLint, _: GLint) {
	panic!("OpenGL function pointer `glUniform1i()` is null.")
}

/// The dummy function of `Uniform2i()`
extern "system" fn dummy_pfngluniform2iproc (_: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glUniform2i()` is null.")
}

/// The dummy function of `Uniform3i()`
extern "system" fn dummy_pfngluniform3iproc (_: GLint, _: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glUniform3i()` is null.")
}

/// The dummy function of `Uniform4i()`
extern "system" fn dummy_pfngluniform4iproc (_: GLint, _: GLint, _: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glUniform4i()` is null.")
}

/// The dummy function of `Uniform1fv()`
extern "system" fn dummy_pfngluniform1fvproc (_: GLint, _: GLsizei, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniform1fv()` is null.")
}

/// The dummy function of `Uniform2fv()`
extern "system" fn dummy_pfngluniform2fvproc (_: GLint, _: GLsizei, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniform2fv()` is null.")
}

/// The dummy function of `Uniform3fv()`
extern "system" fn dummy_pfngluniform3fvproc (_: GLint, _: GLsizei, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniform3fv()` is null.")
}

/// The dummy function of `Uniform4fv()`
extern "system" fn dummy_pfngluniform4fvproc (_: GLint, _: GLsizei, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniform4fv()` is null.")
}

/// The dummy function of `Uniform1iv()`
extern "system" fn dummy_pfngluniform1ivproc (_: GLint, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glUniform1iv()` is null.")
}

/// The dummy function of `Uniform2iv()`
extern "system" fn dummy_pfngluniform2ivproc (_: GLint, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glUniform2iv()` is null.")
}

/// The dummy function of `Uniform3iv()`
extern "system" fn dummy_pfngluniform3ivproc (_: GLint, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glUniform3iv()` is null.")
}

/// The dummy function of `Uniform4iv()`
extern "system" fn dummy_pfngluniform4ivproc (_: GLint, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glUniform4iv()` is null.")
}

/// The dummy function of `UniformMatrix2fv()`
extern "system" fn dummy_pfngluniformmatrix2fvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniformMatrix2fv()` is null.")
}

/// The dummy function of `UniformMatrix3fv()`
extern "system" fn dummy_pfngluniformmatrix3fvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniformMatrix3fv()` is null.")
}

/// The dummy function of `UniformMatrix4fv()`
extern "system" fn dummy_pfngluniformmatrix4fvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniformMatrix4fv()` is null.")
}

/// The dummy function of `ValidateProgram()`
extern "system" fn dummy_pfnglvalidateprogramproc (_: GLuint) {
	panic!("OpenGL function pointer `glValidateProgram()` is null.")
}

/// The dummy function of `VertexAttrib1d()`
extern "system" fn dummy_pfnglvertexattrib1dproc (_: GLuint, _: GLdouble) {
	panic!("OpenGL function pointer `glVertexAttrib1d()` is null.")
}

/// The dummy function of `VertexAttrib1dv()`
extern "system" fn dummy_pfnglvertexattrib1dvproc (_: GLuint, _: *const GLdouble) {
	panic!("OpenGL function pointer `glVertexAttrib1dv()` is null.")
}

/// The dummy function of `VertexAttrib1f()`
extern "system" fn dummy_pfnglvertexattrib1fproc (_: GLuint, _: GLfloat) {
	panic!("OpenGL function pointer `glVertexAttrib1f()` is null.")
}

/// The dummy function of `VertexAttrib1fv()`
extern "system" fn dummy_pfnglvertexattrib1fvproc (_: GLuint, _: *const GLfloat) {
	panic!("OpenGL function pointer `glVertexAttrib1fv()` is null.")
}

/// The dummy function of `VertexAttrib1s()`
extern "system" fn dummy_pfnglvertexattrib1sproc (_: GLuint, _: GLshort) {
	panic!("OpenGL function pointer `glVertexAttrib1s()` is null.")
}

/// The dummy function of `VertexAttrib1sv()`
extern "system" fn dummy_pfnglvertexattrib1svproc (_: GLuint, _: *const GLshort) {
	panic!("OpenGL function pointer `glVertexAttrib1sv()` is null.")
}

/// The dummy function of `VertexAttrib2d()`
extern "system" fn dummy_pfnglvertexattrib2dproc (_: GLuint, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glVertexAttrib2d()` is null.")
}

/// The dummy function of `VertexAttrib2dv()`
extern "system" fn dummy_pfnglvertexattrib2dvproc (_: GLuint, _: *const GLdouble) {
	panic!("OpenGL function pointer `glVertexAttrib2dv()` is null.")
}

/// The dummy function of `VertexAttrib2f()`
extern "system" fn dummy_pfnglvertexattrib2fproc (_: GLuint, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glVertexAttrib2f()` is null.")
}

/// The dummy function of `VertexAttrib2fv()`
extern "system" fn dummy_pfnglvertexattrib2fvproc (_: GLuint, _: *const GLfloat) {
	panic!("OpenGL function pointer `glVertexAttrib2fv()` is null.")
}

/// The dummy function of `VertexAttrib2s()`
extern "system" fn dummy_pfnglvertexattrib2sproc (_: GLuint, _: GLshort, _: GLshort) {
	panic!("OpenGL function pointer `glVertexAttrib2s()` is null.")
}

/// The dummy function of `VertexAttrib2sv()`
extern "system" fn dummy_pfnglvertexattrib2svproc (_: GLuint, _: *const GLshort) {
	panic!("OpenGL function pointer `glVertexAttrib2sv()` is null.")
}

/// The dummy function of `VertexAttrib3d()`
extern "system" fn dummy_pfnglvertexattrib3dproc (_: GLuint, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glVertexAttrib3d()` is null.")
}

/// The dummy function of `VertexAttrib3dv()`
extern "system" fn dummy_pfnglvertexattrib3dvproc (_: GLuint, _: *const GLdouble) {
	panic!("OpenGL function pointer `glVertexAttrib3dv()` is null.")
}

/// The dummy function of `VertexAttrib3f()`
extern "system" fn dummy_pfnglvertexattrib3fproc (_: GLuint, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glVertexAttrib3f()` is null.")
}

/// The dummy function of `VertexAttrib3fv()`
extern "system" fn dummy_pfnglvertexattrib3fvproc (_: GLuint, _: *const GLfloat) {
	panic!("OpenGL function pointer `glVertexAttrib3fv()` is null.")
}

/// The dummy function of `VertexAttrib3s()`
extern "system" fn dummy_pfnglvertexattrib3sproc (_: GLuint, _: GLshort, _: GLshort, _: GLshort) {
	panic!("OpenGL function pointer `glVertexAttrib3s()` is null.")
}

/// The dummy function of `VertexAttrib3sv()`
extern "system" fn dummy_pfnglvertexattrib3svproc (_: GLuint, _: *const GLshort) {
	panic!("OpenGL function pointer `glVertexAttrib3sv()` is null.")
}

/// The dummy function of `VertexAttrib4Nbv()`
extern "system" fn dummy_pfnglvertexattrib4nbvproc (_: GLuint, _: *const GLbyte) {
	panic!("OpenGL function pointer `glVertexAttrib4Nbv()` is null.")
}

/// The dummy function of `VertexAttrib4Niv()`
extern "system" fn dummy_pfnglvertexattrib4nivproc (_: GLuint, _: *const GLint) {
	panic!("OpenGL function pointer `glVertexAttrib4Niv()` is null.")
}

/// The dummy function of `VertexAttrib4Nsv()`
extern "system" fn dummy_pfnglvertexattrib4nsvproc (_: GLuint, _: *const GLshort) {
	panic!("OpenGL function pointer `glVertexAttrib4Nsv()` is null.")
}

/// The dummy function of `VertexAttrib4Nub()`
extern "system" fn dummy_pfnglvertexattrib4nubproc (_: GLuint, _: GLubyte, _: GLubyte, _: GLubyte, _: GLubyte) {
	panic!("OpenGL function pointer `glVertexAttrib4Nub()` is null.")
}

/// The dummy function of `VertexAttrib4Nubv()`
extern "system" fn dummy_pfnglvertexattrib4nubvproc (_: GLuint, _: *const GLubyte) {
	panic!("OpenGL function pointer `glVertexAttrib4Nubv()` is null.")
}

/// The dummy function of `VertexAttrib4Nuiv()`
extern "system" fn dummy_pfnglvertexattrib4nuivproc (_: GLuint, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttrib4Nuiv()` is null.")
}

/// The dummy function of `VertexAttrib4Nusv()`
extern "system" fn dummy_pfnglvertexattrib4nusvproc (_: GLuint, _: *const GLushort) {
	panic!("OpenGL function pointer `glVertexAttrib4Nusv()` is null.")
}

/// The dummy function of `VertexAttrib4bv()`
extern "system" fn dummy_pfnglvertexattrib4bvproc (_: GLuint, _: *const GLbyte) {
	panic!("OpenGL function pointer `glVertexAttrib4bv()` is null.")
}

/// The dummy function of `VertexAttrib4d()`
extern "system" fn dummy_pfnglvertexattrib4dproc (_: GLuint, _: GLdouble, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glVertexAttrib4d()` is null.")
}

/// The dummy function of `VertexAttrib4dv()`
extern "system" fn dummy_pfnglvertexattrib4dvproc (_: GLuint, _: *const GLdouble) {
	panic!("OpenGL function pointer `glVertexAttrib4dv()` is null.")
}

/// The dummy function of `VertexAttrib4f()`
extern "system" fn dummy_pfnglvertexattrib4fproc (_: GLuint, _: GLfloat, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glVertexAttrib4f()` is null.")
}

/// The dummy function of `VertexAttrib4fv()`
extern "system" fn dummy_pfnglvertexattrib4fvproc (_: GLuint, _: *const GLfloat) {
	panic!("OpenGL function pointer `glVertexAttrib4fv()` is null.")
}

/// The dummy function of `VertexAttrib4iv()`
extern "system" fn dummy_pfnglvertexattrib4ivproc (_: GLuint, _: *const GLint) {
	panic!("OpenGL function pointer `glVertexAttrib4iv()` is null.")
}

/// The dummy function of `VertexAttrib4s()`
extern "system" fn dummy_pfnglvertexattrib4sproc (_: GLuint, _: GLshort, _: GLshort, _: GLshort, _: GLshort) {
	panic!("OpenGL function pointer `glVertexAttrib4s()` is null.")
}

/// The dummy function of `VertexAttrib4sv()`
extern "system" fn dummy_pfnglvertexattrib4svproc (_: GLuint, _: *const GLshort) {
	panic!("OpenGL function pointer `glVertexAttrib4sv()` is null.")
}

/// The dummy function of `VertexAttrib4ubv()`
extern "system" fn dummy_pfnglvertexattrib4ubvproc (_: GLuint, _: *const GLubyte) {
	panic!("OpenGL function pointer `glVertexAttrib4ubv()` is null.")
}

/// The dummy function of `VertexAttrib4uiv()`
extern "system" fn dummy_pfnglvertexattrib4uivproc (_: GLuint, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttrib4uiv()` is null.")
}

/// The dummy function of `VertexAttrib4usv()`
extern "system" fn dummy_pfnglvertexattrib4usvproc (_: GLuint, _: *const GLushort) {
	panic!("OpenGL function pointer `glVertexAttrib4usv()` is null.")
}

/// The dummy function of `VertexAttribPointer()`
extern "system" fn dummy_pfnglvertexattribpointerproc (_: GLuint, _: GLint, _: GLenum, _: GLboolean, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glVertexAttribPointer()` is null.")
}
/// Constant value defined from OpenGL 2.0
pub const GL_BLEND_EQUATION_RGB: GLenum = 0x8009;

/// Constant value defined from OpenGL 2.0
pub const GL_VERTEX_ATTRIB_ARRAY_ENABLED: GLenum = 0x8622;

/// Constant value defined from OpenGL 2.0
pub const GL_VERTEX_ATTRIB_ARRAY_SIZE: GLenum = 0x8623;

/// Constant value defined from OpenGL 2.0
pub const GL_VERTEX_ATTRIB_ARRAY_STRIDE: GLenum = 0x8624;

/// Constant value defined from OpenGL 2.0
pub const GL_VERTEX_ATTRIB_ARRAY_TYPE: GLenum = 0x8625;

/// Constant value defined from OpenGL 2.0
pub const GL_CURRENT_VERTEX_ATTRIB: GLenum = 0x8626;

/// Constant value defined from OpenGL 2.0
pub const GL_VERTEX_PROGRAM_POINT_SIZE: GLenum = 0x8642;

/// Constant value defined from OpenGL 2.0
pub const GL_VERTEX_ATTRIB_ARRAY_POINTER: GLenum = 0x8645;

/// Constant value defined from OpenGL 2.0
pub const GL_STENCIL_BACK_FUNC: GLenum = 0x8800;

/// Constant value defined from OpenGL 2.0
pub const GL_STENCIL_BACK_FAIL: GLenum = 0x8801;

/// Constant value defined from OpenGL 2.0
pub const GL_STENCIL_BACK_PASS_DEPTH_FAIL: GLenum = 0x8802;

/// Constant value defined from OpenGL 2.0
pub const GL_STENCIL_BACK_PASS_DEPTH_PASS: GLenum = 0x8803;

/// Constant value defined from OpenGL 2.0
pub const GL_MAX_DRAW_BUFFERS: GLenum = 0x8824;

/// Constant value defined from OpenGL 2.0
pub const GL_DRAW_BUFFER0: GLenum = 0x8825;

/// Constant value defined from OpenGL 2.0
pub const GL_DRAW_BUFFER1: GLenum = 0x8826;

/// Constant value defined from OpenGL 2.0
pub const GL_DRAW_BUFFER2: GLenum = 0x8827;

/// Constant value defined from OpenGL 2.0
pub const GL_DRAW_BUFFER3: GLenum = 0x8828;

/// Constant value defined from OpenGL 2.0
pub const GL_DRAW_BUFFER4: GLenum = 0x8829;

/// Constant value defined from OpenGL 2.0
pub const GL_DRAW_BUFFER5: GLenum = 0x882A;

/// Constant value defined from OpenGL 2.0
pub const GL_DRAW_BUFFER6: GLenum = 0x882B;

/// Constant value defined from OpenGL 2.0
pub const GL_DRAW_BUFFER7: GLenum = 0x882C;

/// Constant value defined from OpenGL 2.0
pub const GL_DRAW_BUFFER8: GLenum = 0x882D;

/// Constant value defined from OpenGL 2.0
pub const GL_DRAW_BUFFER9: GLenum = 0x882E;

/// Constant value defined from OpenGL 2.0
pub const GL_DRAW_BUFFER10: GLenum = 0x882F;

/// Constant value defined from OpenGL 2.0
pub const GL_DRAW_BUFFER11: GLenum = 0x8830;

/// Constant value defined from OpenGL 2.0
pub const GL_DRAW_BUFFER12: GLenum = 0x8831;

/// Constant value defined from OpenGL 2.0
pub const GL_DRAW_BUFFER13: GLenum = 0x8832;

/// Constant value defined from OpenGL 2.0
pub const GL_DRAW_BUFFER14: GLenum = 0x8833;

/// Constant value defined from OpenGL 2.0
pub const GL_DRAW_BUFFER15: GLenum = 0x8834;

/// Constant value defined from OpenGL 2.0
pub const GL_BLEND_EQUATION_ALPHA: GLenum = 0x883D;

/// Constant value defined from OpenGL 2.0
pub const GL_MAX_VERTEX_ATTRIBS: GLenum = 0x8869;

/// Constant value defined from OpenGL 2.0
pub const GL_VERTEX_ATTRIB_ARRAY_NORMALIZED: GLenum = 0x886A;

/// Constant value defined from OpenGL 2.0
pub const GL_MAX_TEXTURE_IMAGE_UNITS: GLenum = 0x8872;

/// Constant value defined from OpenGL 2.0
pub const GL_FRAGMENT_SHADER: GLenum = 0x8B30;

/// Constant value defined from OpenGL 2.0
pub const GL_VERTEX_SHADER: GLenum = 0x8B31;

/// Constant value defined from OpenGL 2.0
pub const GL_MAX_FRAGMENT_UNIFORM_COMPONENTS: GLenum = 0x8B49;

/// Constant value defined from OpenGL 2.0
pub const GL_MAX_VERTEX_UNIFORM_COMPONENTS: GLenum = 0x8B4A;

/// Constant value defined from OpenGL 2.0
pub const GL_MAX_VARYING_FLOATS: GLenum = 0x8B4B;

/// Constant value defined from OpenGL 2.0
pub const GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS: GLenum = 0x8B4C;

/// Constant value defined from OpenGL 2.0
pub const GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS: GLenum = 0x8B4D;

/// Constant value defined from OpenGL 2.0
pub const GL_SHADER_TYPE: GLenum = 0x8B4F;

/// Constant value defined from OpenGL 2.0
pub const GL_FLOAT_VEC2: GLenum = 0x8B50;

/// Constant value defined from OpenGL 2.0
pub const GL_FLOAT_VEC3: GLenum = 0x8B51;

/// Constant value defined from OpenGL 2.0
pub const GL_FLOAT_VEC4: GLenum = 0x8B52;

/// Constant value defined from OpenGL 2.0
pub const GL_INT_VEC2: GLenum = 0x8B53;

/// Constant value defined from OpenGL 2.0
pub const GL_INT_VEC3: GLenum = 0x8B54;

/// Constant value defined from OpenGL 2.0
pub const GL_INT_VEC4: GLenum = 0x8B55;

/// Constant value defined from OpenGL 2.0
pub const GL_BOOL: GLenum = 0x8B56;

/// Constant value defined from OpenGL 2.0
pub const GL_BOOL_VEC2: GLenum = 0x8B57;

/// Constant value defined from OpenGL 2.0
pub const GL_BOOL_VEC3: GLenum = 0x8B58;

/// Constant value defined from OpenGL 2.0
pub const GL_BOOL_VEC4: GLenum = 0x8B59;

/// Constant value defined from OpenGL 2.0
pub const GL_FLOAT_MAT2: GLenum = 0x8B5A;

/// Constant value defined from OpenGL 2.0
pub const GL_FLOAT_MAT3: GLenum = 0x8B5B;

/// Constant value defined from OpenGL 2.0
pub const GL_FLOAT_MAT4: GLenum = 0x8B5C;

/// Constant value defined from OpenGL 2.0
pub const GL_SAMPLER_1D: GLenum = 0x8B5D;

/// Constant value defined from OpenGL 2.0
pub const GL_SAMPLER_2D: GLenum = 0x8B5E;

/// Constant value defined from OpenGL 2.0
pub const GL_SAMPLER_3D: GLenum = 0x8B5F;

/// Constant value defined from OpenGL 2.0
pub const GL_SAMPLER_CUBE: GLenum = 0x8B60;

/// Constant value defined from OpenGL 2.0
pub const GL_SAMPLER_1D_SHADOW: GLenum = 0x8B61;

/// Constant value defined from OpenGL 2.0
pub const GL_SAMPLER_2D_SHADOW: GLenum = 0x8B62;

/// Constant value defined from OpenGL 2.0
pub const GL_DELETE_STATUS: GLenum = 0x8B80;

/// Constant value defined from OpenGL 2.0
pub const GL_COMPILE_STATUS: GLenum = 0x8B81;

/// Constant value defined from OpenGL 2.0
pub const GL_LINK_STATUS: GLenum = 0x8B82;

/// Constant value defined from OpenGL 2.0
pub const GL_VALIDATE_STATUS: GLenum = 0x8B83;

/// Constant value defined from OpenGL 2.0
pub const GL_INFO_LOG_LENGTH: GLenum = 0x8B84;

/// Constant value defined from OpenGL 2.0
pub const GL_ATTACHED_SHADERS: GLenum = 0x8B85;

/// Constant value defined from OpenGL 2.0
pub const GL_ACTIVE_UNIFORMS: GLenum = 0x8B86;

/// Constant value defined from OpenGL 2.0
pub const GL_ACTIVE_UNIFORM_MAX_LENGTH: GLenum = 0x8B87;

/// Constant value defined from OpenGL 2.0
pub const GL_SHADER_SOURCE_LENGTH: GLenum = 0x8B88;

/// Constant value defined from OpenGL 2.0
pub const GL_ACTIVE_ATTRIBUTES: GLenum = 0x8B89;

/// Constant value defined from OpenGL 2.0
pub const GL_ACTIVE_ATTRIBUTE_MAX_LENGTH: GLenum = 0x8B8A;

/// Constant value defined from OpenGL 2.0
pub const GL_FRAGMENT_SHADER_DERIVATIVE_HINT: GLenum = 0x8B8B;

/// Constant value defined from OpenGL 2.0
pub const GL_SHADING_LANGUAGE_VERSION: GLenum = 0x8B8C;

/// Constant value defined from OpenGL 2.0
pub const GL_CURRENT_PROGRAM: GLenum = 0x8B8D;

/// Constant value defined from OpenGL 2.0
pub const GL_POINT_SPRITE_COORD_ORIGIN: GLenum = 0x8CA0;

/// Constant value defined from OpenGL 2.0
pub const GL_LOWER_LEFT: GLenum = 0x8CA1;

/// Constant value defined from OpenGL 2.0
pub const GL_UPPER_LEFT: GLenum = 0x8CA2;

/// Constant value defined from OpenGL 2.0
pub const GL_STENCIL_BACK_REF: GLenum = 0x8CA3;

/// Constant value defined from OpenGL 2.0
pub const GL_STENCIL_BACK_VALUE_MASK: GLenum = 0x8CA4;

/// Constant value defined from OpenGL 2.0
pub const GL_STENCIL_BACK_WRITEMASK: GLenum = 0x8CA5;

/// Constant value defined from OpenGL 2.0
pub const GL_VERTEX_PROGRAM_TWO_SIDE: GLenum = 0x8643;

/// Constant value defined from OpenGL 2.0
pub const GL_POINT_SPRITE: GLenum = 0x8861;

/// Constant value defined from OpenGL 2.0
pub const GL_COORD_REPLACE: GLenum = 0x8862;

/// Constant value defined from OpenGL 2.0
pub const GL_MAX_TEXTURE_COORDS: GLenum = 0x8871;

/// Functions from OpenGL version 2.0
pub trait GL_2_0 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	fn glGetError(&self) -> GLenum;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendEquationSeparate.xhtml>
	fn glBlendEquationSeparate(&self, modeRGB: GLenum, modeAlpha: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml>
	fn glDrawBuffers(&self, n: GLsizei, bufs: *const GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilOpSeparate.xhtml>
	fn glStencilOpSeparate(&self, face: GLenum, sfail: GLenum, dpfail: GLenum, dppass: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilFuncSeparate.xhtml>
	fn glStencilFuncSeparate(&self, face: GLenum, func: GLenum, ref_: GLint, mask: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilMaskSeparate.xhtml>
	fn glStencilMaskSeparate(&self, face: GLenum, mask: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glAttachShader.xhtml>
	fn glAttachShader(&self, program: GLuint, shader: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindAttribLocation.xhtml>
	fn glBindAttribLocation(&self, program: GLuint, index: GLuint, name: *const GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompileShader.xhtml>
	fn glCompileShader(&self, shader: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateProgram.xhtml>
	fn glCreateProgram(&self) -> Result<GLuint>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateShader.xhtml>
	fn glCreateShader(&self, type_: GLenum) -> Result<GLuint>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteProgram.xhtml>
	fn glDeleteProgram(&self, program: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteShader.xhtml>
	fn glDeleteShader(&self, shader: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDetachShader.xhtml>
	fn glDetachShader(&self, program: GLuint, shader: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDisableVertexAttribArray.xhtml>
	fn glDisableVertexAttribArray(&self, index: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml>
	fn glEnableVertexAttribArray(&self, index: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveAttrib.xhtml>
	fn glGetActiveAttrib(&self, program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLint, type_: *mut GLenum, name: *mut GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveUniform.xhtml>
	fn glGetActiveUniform(&self, program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLint, type_: *mut GLenum, name: *mut GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetAttachedShaders.xhtml>
	fn glGetAttachedShaders(&self, program: GLuint, maxCount: GLsizei, count: *mut GLsizei, shaders: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetAttribLocation.xhtml>
	fn glGetAttribLocation(&self, program: GLuint, name: *const GLchar) -> Result<GLint>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramiv.xhtml>
	fn glGetProgramiv(&self, program: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramInfoLog.xhtml>
	fn glGetProgramInfoLog(&self, program: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShaderiv.xhtml>
	fn glGetShaderiv(&self, shader: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShaderInfoLog.xhtml>
	fn glGetShaderInfoLog(&self, shader: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShaderSource.xhtml>
	fn glGetShaderSource(&self, shader: GLuint, bufSize: GLsizei, length: *mut GLsizei, source: *mut GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformLocation.xhtml>
	fn glGetUniformLocation(&self, program: GLuint, name: *const GLchar) -> Result<GLint>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformfv.xhtml>
	fn glGetUniformfv(&self, program: GLuint, location: GLint, params: *mut GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformiv.xhtml>
	fn glGetUniformiv(&self, program: GLuint, location: GLint, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribdv.xhtml>
	fn glGetVertexAttribdv(&self, index: GLuint, pname: GLenum, params: *mut GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribfv.xhtml>
	fn glGetVertexAttribfv(&self, index: GLuint, pname: GLenum, params: *mut GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribiv.xhtml>
	fn glGetVertexAttribiv(&self, index: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribPointerv.xhtml>
	fn glGetVertexAttribPointerv(&self, index: GLuint, pname: GLenum, pointer: *mut *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsProgram.xhtml>
	fn glIsProgram(&self, program: GLuint) -> Result<GLboolean>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsShader.xhtml>
	fn glIsShader(&self, shader: GLuint) -> Result<GLboolean>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLinkProgram.xhtml>
	fn glLinkProgram(&self, program: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glShaderSource.xhtml>
	fn glShaderSource(&self, shader: GLuint, count: GLsizei, string_: *const *const GLchar, length: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUseProgram.xhtml>
	fn glUseProgram(&self, program: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1f.xhtml>
	fn glUniform1f(&self, location: GLint, v0: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2f.xhtml>
	fn glUniform2f(&self, location: GLint, v0: GLfloat, v1: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3f.xhtml>
	fn glUniform3f(&self, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4f.xhtml>
	fn glUniform4f(&self, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1i.xhtml>
	fn glUniform1i(&self, location: GLint, v0: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2i.xhtml>
	fn glUniform2i(&self, location: GLint, v0: GLint, v1: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3i.xhtml>
	fn glUniform3i(&self, location: GLint, v0: GLint, v1: GLint, v2: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4i.xhtml>
	fn glUniform4i(&self, location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1fv.xhtml>
	fn glUniform1fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2fv.xhtml>
	fn glUniform2fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3fv.xhtml>
	fn glUniform3fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4fv.xhtml>
	fn glUniform4fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1iv.xhtml>
	fn glUniform1iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2iv.xhtml>
	fn glUniform2iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3iv.xhtml>
	fn glUniform3iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4iv.xhtml>
	fn glUniform4iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix2fv.xhtml>
	fn glUniformMatrix2fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix3fv.xhtml>
	fn glUniformMatrix3fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix4fv.xhtml>
	fn glUniformMatrix4fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glValidateProgram.xhtml>
	fn glValidateProgram(&self, program: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib1d.xhtml>
	fn glVertexAttrib1d(&self, index: GLuint, x: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib1dv.xhtml>
	fn glVertexAttrib1dv(&self, index: GLuint, v: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib1f.xhtml>
	fn glVertexAttrib1f(&self, index: GLuint, x: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib1fv.xhtml>
	fn glVertexAttrib1fv(&self, index: GLuint, v: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib1s.xhtml>
	fn glVertexAttrib1s(&self, index: GLuint, x: GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib1sv.xhtml>
	fn glVertexAttrib1sv(&self, index: GLuint, v: *const GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib2d.xhtml>
	fn glVertexAttrib2d(&self, index: GLuint, x: GLdouble, y: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib2dv.xhtml>
	fn glVertexAttrib2dv(&self, index: GLuint, v: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib2f.xhtml>
	fn glVertexAttrib2f(&self, index: GLuint, x: GLfloat, y: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib2fv.xhtml>
	fn glVertexAttrib2fv(&self, index: GLuint, v: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib2s.xhtml>
	fn glVertexAttrib2s(&self, index: GLuint, x: GLshort, y: GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib2sv.xhtml>
	fn glVertexAttrib2sv(&self, index: GLuint, v: *const GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib3d.xhtml>
	fn glVertexAttrib3d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib3dv.xhtml>
	fn glVertexAttrib3dv(&self, index: GLuint, v: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib3f.xhtml>
	fn glVertexAttrib3f(&self, index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib3fv.xhtml>
	fn glVertexAttrib3fv(&self, index: GLuint, v: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib3s.xhtml>
	fn glVertexAttrib3s(&self, index: GLuint, x: GLshort, y: GLshort, z: GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib3sv.xhtml>
	fn glVertexAttrib3sv(&self, index: GLuint, v: *const GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Nbv.xhtml>
	fn glVertexAttrib4Nbv(&self, index: GLuint, v: *const GLbyte) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Niv.xhtml>
	fn glVertexAttrib4Niv(&self, index: GLuint, v: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Nsv.xhtml>
	fn glVertexAttrib4Nsv(&self, index: GLuint, v: *const GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Nub.xhtml>
	fn glVertexAttrib4Nub(&self, index: GLuint, x: GLubyte, y: GLubyte, z: GLubyte, w: GLubyte) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Nubv.xhtml>
	fn glVertexAttrib4Nubv(&self, index: GLuint, v: *const GLubyte) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Nuiv.xhtml>
	fn glVertexAttrib4Nuiv(&self, index: GLuint, v: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Nusv.xhtml>
	fn glVertexAttrib4Nusv(&self, index: GLuint, v: *const GLushort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4bv.xhtml>
	fn glVertexAttrib4bv(&self, index: GLuint, v: *const GLbyte) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4d.xhtml>
	fn glVertexAttrib4d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4dv.xhtml>
	fn glVertexAttrib4dv(&self, index: GLuint, v: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4f.xhtml>
	fn glVertexAttrib4f(&self, index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4fv.xhtml>
	fn glVertexAttrib4fv(&self, index: GLuint, v: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4iv.xhtml>
	fn glVertexAttrib4iv(&self, index: GLuint, v: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4s.xhtml>
	fn glVertexAttrib4s(&self, index: GLuint, x: GLshort, y: GLshort, z: GLshort, w: GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4sv.xhtml>
	fn glVertexAttrib4sv(&self, index: GLuint, v: *const GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4ubv.xhtml>
	fn glVertexAttrib4ubv(&self, index: GLuint, v: *const GLubyte) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4uiv.xhtml>
	fn glVertexAttrib4uiv(&self, index: GLuint, v: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4usv.xhtml>
	fn glVertexAttrib4usv(&self, index: GLuint, v: *const GLushort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml>
	fn glVertexAttribPointer(&self, index: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, stride: GLsizei, pointer: *const c_void) -> Result<()>;
	fn get_shading_language_version(&self) -> &'static str;
}
/// Functions from OpenGL version 2.0
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version20 {
	/// The version of the OpenGL shading language
	shading_language_version: &'static str,

	/// Is OpenGL version 2.0 available
	available: bool,

	/// The function pointer to `glGetError()`
	pub geterror: PFNGLGETERRORPROC,

	/// The function pointer to `glBlendEquationSeparate()`
	pub blendequationseparate: PFNGLBLENDEQUATIONSEPARATEPROC,

	/// The function pointer to `glDrawBuffers()`
	pub drawbuffers: PFNGLDRAWBUFFERSPROC,

	/// The function pointer to `glStencilOpSeparate()`
	pub stencilopseparate: PFNGLSTENCILOPSEPARATEPROC,

	/// The function pointer to `glStencilFuncSeparate()`
	pub stencilfuncseparate: PFNGLSTENCILFUNCSEPARATEPROC,

	/// The function pointer to `glStencilMaskSeparate()`
	pub stencilmaskseparate: PFNGLSTENCILMASKSEPARATEPROC,

	/// The function pointer to `glAttachShader()`
	pub attachshader: PFNGLATTACHSHADERPROC,

	/// The function pointer to `glBindAttribLocation()`
	pub bindattriblocation: PFNGLBINDATTRIBLOCATIONPROC,

	/// The function pointer to `glCompileShader()`
	pub compileshader: PFNGLCOMPILESHADERPROC,

	/// The function pointer to `glCreateProgram()`
	pub createprogram: PFNGLCREATEPROGRAMPROC,

	/// The function pointer to `glCreateShader()`
	pub createshader: PFNGLCREATESHADERPROC,

	/// The function pointer to `glDeleteProgram()`
	pub deleteprogram: PFNGLDELETEPROGRAMPROC,

	/// The function pointer to `glDeleteShader()`
	pub deleteshader: PFNGLDELETESHADERPROC,

	/// The function pointer to `glDetachShader()`
	pub detachshader: PFNGLDETACHSHADERPROC,

	/// The function pointer to `glDisableVertexAttribArray()`
	pub disablevertexattribarray: PFNGLDISABLEVERTEXATTRIBARRAYPROC,

	/// The function pointer to `glEnableVertexAttribArray()`
	pub enablevertexattribarray: PFNGLENABLEVERTEXATTRIBARRAYPROC,

	/// The function pointer to `glGetActiveAttrib()`
	pub getactiveattrib: PFNGLGETACTIVEATTRIBPROC,

	/// The function pointer to `glGetActiveUniform()`
	pub getactiveuniform: PFNGLGETACTIVEUNIFORMPROC,

	/// The function pointer to `glGetAttachedShaders()`
	pub getattachedshaders: PFNGLGETATTACHEDSHADERSPROC,

	/// The function pointer to `glGetAttribLocation()`
	pub getattriblocation: PFNGLGETATTRIBLOCATIONPROC,

	/// The function pointer to `glGetProgramiv()`
	pub getprogramiv: PFNGLGETPROGRAMIVPROC,

	/// The function pointer to `glGetProgramInfoLog()`
	pub getprograminfolog: PFNGLGETPROGRAMINFOLOGPROC,

	/// The function pointer to `glGetShaderiv()`
	pub getshaderiv: PFNGLGETSHADERIVPROC,

	/// The function pointer to `glGetShaderInfoLog()`
	pub getshaderinfolog: PFNGLGETSHADERINFOLOGPROC,

	/// The function pointer to `glGetShaderSource()`
	pub getshadersource: PFNGLGETSHADERSOURCEPROC,

	/// The function pointer to `glGetUniformLocation()`
	pub getuniformlocation: PFNGLGETUNIFORMLOCATIONPROC,

	/// The function pointer to `glGetUniformfv()`
	pub getuniformfv: PFNGLGETUNIFORMFVPROC,

	/// The function pointer to `glGetUniformiv()`
	pub getuniformiv: PFNGLGETUNIFORMIVPROC,

	/// The function pointer to `glGetVertexAttribdv()`
	pub getvertexattribdv: PFNGLGETVERTEXATTRIBDVPROC,

	/// The function pointer to `glGetVertexAttribfv()`
	pub getvertexattribfv: PFNGLGETVERTEXATTRIBFVPROC,

	/// The function pointer to `glGetVertexAttribiv()`
	pub getvertexattribiv: PFNGLGETVERTEXATTRIBIVPROC,

	/// The function pointer to `glGetVertexAttribPointerv()`
	pub getvertexattribpointerv: PFNGLGETVERTEXATTRIBPOINTERVPROC,

	/// The function pointer to `glIsProgram()`
	pub isprogram: PFNGLISPROGRAMPROC,

	/// The function pointer to `glIsShader()`
	pub isshader: PFNGLISSHADERPROC,

	/// The function pointer to `glLinkProgram()`
	pub linkprogram: PFNGLLINKPROGRAMPROC,

	/// The function pointer to `glShaderSource()`
	pub shadersource: PFNGLSHADERSOURCEPROC,

	/// The function pointer to `glUseProgram()`
	pub useprogram: PFNGLUSEPROGRAMPROC,

	/// The function pointer to `glUniform1f()`
	pub uniform1f: PFNGLUNIFORM1FPROC,

	/// The function pointer to `glUniform2f()`
	pub uniform2f: PFNGLUNIFORM2FPROC,

	/// The function pointer to `glUniform3f()`
	pub uniform3f: PFNGLUNIFORM3FPROC,

	/// The function pointer to `glUniform4f()`
	pub uniform4f: PFNGLUNIFORM4FPROC,

	/// The function pointer to `glUniform1i()`
	pub uniform1i: PFNGLUNIFORM1IPROC,

	/// The function pointer to `glUniform2i()`
	pub uniform2i: PFNGLUNIFORM2IPROC,

	/// The function pointer to `glUniform3i()`
	pub uniform3i: PFNGLUNIFORM3IPROC,

	/// The function pointer to `glUniform4i()`
	pub uniform4i: PFNGLUNIFORM4IPROC,

	/// The function pointer to `glUniform1fv()`
	pub uniform1fv: PFNGLUNIFORM1FVPROC,

	/// The function pointer to `glUniform2fv()`
	pub uniform2fv: PFNGLUNIFORM2FVPROC,

	/// The function pointer to `glUniform3fv()`
	pub uniform3fv: PFNGLUNIFORM3FVPROC,

	/// The function pointer to `glUniform4fv()`
	pub uniform4fv: PFNGLUNIFORM4FVPROC,

	/// The function pointer to `glUniform1iv()`
	pub uniform1iv: PFNGLUNIFORM1IVPROC,

	/// The function pointer to `glUniform2iv()`
	pub uniform2iv: PFNGLUNIFORM2IVPROC,

	/// The function pointer to `glUniform3iv()`
	pub uniform3iv: PFNGLUNIFORM3IVPROC,

	/// The function pointer to `glUniform4iv()`
	pub uniform4iv: PFNGLUNIFORM4IVPROC,

	/// The function pointer to `glUniformMatrix2fv()`
	pub uniformmatrix2fv: PFNGLUNIFORMMATRIX2FVPROC,

	/// The function pointer to `glUniformMatrix3fv()`
	pub uniformmatrix3fv: PFNGLUNIFORMMATRIX3FVPROC,

	/// The function pointer to `glUniformMatrix4fv()`
	pub uniformmatrix4fv: PFNGLUNIFORMMATRIX4FVPROC,

	/// The function pointer to `glValidateProgram()`
	pub validateprogram: PFNGLVALIDATEPROGRAMPROC,

	/// The function pointer to `glVertexAttrib1d()`
	pub vertexattrib1d: PFNGLVERTEXATTRIB1DPROC,

	/// The function pointer to `glVertexAttrib1dv()`
	pub vertexattrib1dv: PFNGLVERTEXATTRIB1DVPROC,

	/// The function pointer to `glVertexAttrib1f()`
	pub vertexattrib1f: PFNGLVERTEXATTRIB1FPROC,

	/// The function pointer to `glVertexAttrib1fv()`
	pub vertexattrib1fv: PFNGLVERTEXATTRIB1FVPROC,

	/// The function pointer to `glVertexAttrib1s()`
	pub vertexattrib1s: PFNGLVERTEXATTRIB1SPROC,

	/// The function pointer to `glVertexAttrib1sv()`
	pub vertexattrib1sv: PFNGLVERTEXATTRIB1SVPROC,

	/// The function pointer to `glVertexAttrib2d()`
	pub vertexattrib2d: PFNGLVERTEXATTRIB2DPROC,

	/// The function pointer to `glVertexAttrib2dv()`
	pub vertexattrib2dv: PFNGLVERTEXATTRIB2DVPROC,

	/// The function pointer to `glVertexAttrib2f()`
	pub vertexattrib2f: PFNGLVERTEXATTRIB2FPROC,

	/// The function pointer to `glVertexAttrib2fv()`
	pub vertexattrib2fv: PFNGLVERTEXATTRIB2FVPROC,

	/// The function pointer to `glVertexAttrib2s()`
	pub vertexattrib2s: PFNGLVERTEXATTRIB2SPROC,

	/// The function pointer to `glVertexAttrib2sv()`
	pub vertexattrib2sv: PFNGLVERTEXATTRIB2SVPROC,

	/// The function pointer to `glVertexAttrib3d()`
	pub vertexattrib3d: PFNGLVERTEXATTRIB3DPROC,

	/// The function pointer to `glVertexAttrib3dv()`
	pub vertexattrib3dv: PFNGLVERTEXATTRIB3DVPROC,

	/// The function pointer to `glVertexAttrib3f()`
	pub vertexattrib3f: PFNGLVERTEXATTRIB3FPROC,

	/// The function pointer to `glVertexAttrib3fv()`
	pub vertexattrib3fv: PFNGLVERTEXATTRIB3FVPROC,

	/// The function pointer to `glVertexAttrib3s()`
	pub vertexattrib3s: PFNGLVERTEXATTRIB3SPROC,

	/// The function pointer to `glVertexAttrib3sv()`
	pub vertexattrib3sv: PFNGLVERTEXATTRIB3SVPROC,

	/// The function pointer to `glVertexAttrib4Nbv()`
	pub vertexattrib4nbv: PFNGLVERTEXATTRIB4NBVPROC,

	/// The function pointer to `glVertexAttrib4Niv()`
	pub vertexattrib4niv: PFNGLVERTEXATTRIB4NIVPROC,

	/// The function pointer to `glVertexAttrib4Nsv()`
	pub vertexattrib4nsv: PFNGLVERTEXATTRIB4NSVPROC,

	/// The function pointer to `glVertexAttrib4Nub()`
	pub vertexattrib4nub: PFNGLVERTEXATTRIB4NUBPROC,

	/// The function pointer to `glVertexAttrib4Nubv()`
	pub vertexattrib4nubv: PFNGLVERTEXATTRIB4NUBVPROC,

	/// The function pointer to `glVertexAttrib4Nuiv()`
	pub vertexattrib4nuiv: PFNGLVERTEXATTRIB4NUIVPROC,

	/// The function pointer to `glVertexAttrib4Nusv()`
	pub vertexattrib4nusv: PFNGLVERTEXATTRIB4NUSVPROC,

	/// The function pointer to `glVertexAttrib4bv()`
	pub vertexattrib4bv: PFNGLVERTEXATTRIB4BVPROC,

	/// The function pointer to `glVertexAttrib4d()`
	pub vertexattrib4d: PFNGLVERTEXATTRIB4DPROC,

	/// The function pointer to `glVertexAttrib4dv()`
	pub vertexattrib4dv: PFNGLVERTEXATTRIB4DVPROC,

	/// The function pointer to `glVertexAttrib4f()`
	pub vertexattrib4f: PFNGLVERTEXATTRIB4FPROC,

	/// The function pointer to `glVertexAttrib4fv()`
	pub vertexattrib4fv: PFNGLVERTEXATTRIB4FVPROC,

	/// The function pointer to `glVertexAttrib4iv()`
	pub vertexattrib4iv: PFNGLVERTEXATTRIB4IVPROC,

	/// The function pointer to `glVertexAttrib4s()`
	pub vertexattrib4s: PFNGLVERTEXATTRIB4SPROC,

	/// The function pointer to `glVertexAttrib4sv()`
	pub vertexattrib4sv: PFNGLVERTEXATTRIB4SVPROC,

	/// The function pointer to `glVertexAttrib4ubv()`
	pub vertexattrib4ubv: PFNGLVERTEXATTRIB4UBVPROC,

	/// The function pointer to `glVertexAttrib4uiv()`
	pub vertexattrib4uiv: PFNGLVERTEXATTRIB4UIVPROC,

	/// The function pointer to `glVertexAttrib4usv()`
	pub vertexattrib4usv: PFNGLVERTEXATTRIB4USVPROC,

	/// The function pointer to `glVertexAttribPointer()`
	pub vertexattribpointer: PFNGLVERTEXATTRIBPOINTERPROC,
}

impl GL_2_0 for Version20 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendEquationSeparate.xhtml>
	#[inline(always)]
	fn glBlendEquationSeparate(&self, modeRGB: GLenum, modeAlpha: GLenum) -> Result<()> {
		let ret = process_catch("glBlendEquationSeparate", catch_unwind(||(self.blendequationseparate)(modeRGB, modeAlpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendEquationSeparate", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml>
	#[inline(always)]
	fn glDrawBuffers(&self, n: GLsizei, bufs: *const GLenum) -> Result<()> {
		let ret = process_catch("glDrawBuffers", catch_unwind(||(self.drawbuffers)(n, bufs)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawBuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilOpSeparate.xhtml>
	#[inline(always)]
	fn glStencilOpSeparate(&self, face: GLenum, sfail: GLenum, dpfail: GLenum, dppass: GLenum) -> Result<()> {
		let ret = process_catch("glStencilOpSeparate", catch_unwind(||(self.stencilopseparate)(face, sfail, dpfail, dppass)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilOpSeparate", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilFuncSeparate.xhtml>
	#[inline(always)]
	fn glStencilFuncSeparate(&self, face: GLenum, func: GLenum, ref_: GLint, mask: GLuint) -> Result<()> {
		let ret = process_catch("glStencilFuncSeparate", catch_unwind(||(self.stencilfuncseparate)(face, func, ref_, mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilFuncSeparate", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilMaskSeparate.xhtml>
	#[inline(always)]
	fn glStencilMaskSeparate(&self, face: GLenum, mask: GLuint) -> Result<()> {
		let ret = process_catch("glStencilMaskSeparate", catch_unwind(||(self.stencilmaskseparate)(face, mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilMaskSeparate", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glAttachShader.xhtml>
	#[inline(always)]
	fn glAttachShader(&self, program: GLuint, shader: GLuint) -> Result<()> {
		let ret = process_catch("glAttachShader", catch_unwind(||(self.attachshader)(program, shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glAttachShader", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindAttribLocation.xhtml>
	#[inline(always)]
	fn glBindAttribLocation(&self, program: GLuint, index: GLuint, name: *const GLchar) -> Result<()> {
		let ret = process_catch("glBindAttribLocation", catch_unwind(||(self.bindattriblocation)(program, index, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindAttribLocation", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompileShader.xhtml>
	#[inline(always)]
	fn glCompileShader(&self, shader: GLuint) -> Result<()> {
		let ret = process_catch("glCompileShader", catch_unwind(||(self.compileshader)(shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompileShader", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateProgram.xhtml>
	#[inline(always)]
	fn glCreateProgram(&self) -> Result<GLuint> {
		let ret = process_catch("glCreateProgram", catch_unwind(||(self.createprogram)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateProgram", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateShader.xhtml>
	#[inline(always)]
	fn glCreateShader(&self, type_: GLenum) -> Result<GLuint> {
		let ret = process_catch("glCreateShader", catch_unwind(||(self.createshader)(type_)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateShader", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteProgram.xhtml>
	#[inline(always)]
	fn glDeleteProgram(&self, program: GLuint) -> Result<()> {
		let ret = process_catch("glDeleteProgram", catch_unwind(||(self.deleteprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteProgram", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteShader.xhtml>
	#[inline(always)]
	fn glDeleteShader(&self, shader: GLuint) -> Result<()> {
		let ret = process_catch("glDeleteShader", catch_unwind(||(self.deleteshader)(shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteShader", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDetachShader.xhtml>
	#[inline(always)]
	fn glDetachShader(&self, program: GLuint, shader: GLuint) -> Result<()> {
		let ret = process_catch("glDetachShader", catch_unwind(||(self.detachshader)(program, shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDetachShader", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDisableVertexAttribArray.xhtml>
	#[inline(always)]
	fn glDisableVertexAttribArray(&self, index: GLuint) -> Result<()> {
		let ret = process_catch("glDisableVertexAttribArray", catch_unwind(||(self.disablevertexattribarray)(index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDisableVertexAttribArray", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml>
	#[inline(always)]
	fn glEnableVertexAttribArray(&self, index: GLuint) -> Result<()> {
		let ret = process_catch("glEnableVertexAttribArray", catch_unwind(||(self.enablevertexattribarray)(index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEnableVertexAttribArray", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveAttrib.xhtml>
	#[inline(always)]
	fn glGetActiveAttrib(&self, program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLint, type_: *mut GLenum, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveAttrib", catch_unwind(||(self.getactiveattrib)(program, index, bufSize, length, size, type_, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveAttrib", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveUniform.xhtml>
	#[inline(always)]
	fn glGetActiveUniform(&self, program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLint, type_: *mut GLenum, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveUniform", catch_unwind(||(self.getactiveuniform)(program, index, bufSize, length, size, type_, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniform", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetAttachedShaders.xhtml>
	#[inline(always)]
	fn glGetAttachedShaders(&self, program: GLuint, maxCount: GLsizei, count: *mut GLsizei, shaders: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetAttachedShaders", catch_unwind(||(self.getattachedshaders)(program, maxCount, count, shaders)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetAttachedShaders", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetAttribLocation.xhtml>
	#[inline(always)]
	fn glGetAttribLocation(&self, program: GLuint, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetAttribLocation", catch_unwind(||(self.getattriblocation)(program, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetAttribLocation", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramiv.xhtml>
	#[inline(always)]
	fn glGetProgramiv(&self, program: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramiv", catch_unwind(||(self.getprogramiv)(program, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramInfoLog.xhtml>
	#[inline(always)]
	fn glGetProgramInfoLog(&self, program: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetProgramInfoLog", catch_unwind(||(self.getprograminfolog)(program, bufSize, length, infoLog)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramInfoLog", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShaderiv.xhtml>
	#[inline(always)]
	fn glGetShaderiv(&self, shader: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetShaderiv", catch_unwind(||(self.getshaderiv)(shader, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetShaderiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShaderInfoLog.xhtml>
	#[inline(always)]
	fn glGetShaderInfoLog(&self, shader: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetShaderInfoLog", catch_unwind(||(self.getshaderinfolog)(shader, bufSize, length, infoLog)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetShaderInfoLog", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShaderSource.xhtml>
	#[inline(always)]
	fn glGetShaderSource(&self, shader: GLuint, bufSize: GLsizei, length: *mut GLsizei, source: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetShaderSource", catch_unwind(||(self.getshadersource)(shader, bufSize, length, source)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetShaderSource", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformLocation.xhtml>
	#[inline(always)]
	fn glGetUniformLocation(&self, program: GLuint, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetUniformLocation", catch_unwind(||(self.getuniformlocation)(program, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformLocation", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformfv.xhtml>
	#[inline(always)]
	fn glGetUniformfv(&self, program: GLuint, location: GLint, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetUniformfv", catch_unwind(||(self.getuniformfv)(program, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformiv.xhtml>
	#[inline(always)]
	fn glGetUniformiv(&self, program: GLuint, location: GLint, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetUniformiv", catch_unwind(||(self.getuniformiv)(program, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribdv.xhtml>
	#[inline(always)]
	fn glGetVertexAttribdv(&self, index: GLuint, pname: GLenum, params: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetVertexAttribdv", catch_unwind(||(self.getvertexattribdv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribdv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribfv.xhtml>
	#[inline(always)]
	fn glGetVertexAttribfv(&self, index: GLuint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetVertexAttribfv", catch_unwind(||(self.getvertexattribfv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribiv.xhtml>
	#[inline(always)]
	fn glGetVertexAttribiv(&self, index: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetVertexAttribiv", catch_unwind(||(self.getvertexattribiv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribPointerv.xhtml>
	#[inline(always)]
	fn glGetVertexAttribPointerv(&self, index: GLuint, pname: GLenum, pointer: *mut *mut c_void) -> Result<()> {
		let ret = process_catch("glGetVertexAttribPointerv", catch_unwind(||(self.getvertexattribpointerv)(index, pname, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribPointerv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsProgram.xhtml>
	#[inline(always)]
	fn glIsProgram(&self, program: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsProgram", catch_unwind(||(self.isprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsProgram", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsShader.xhtml>
	#[inline(always)]
	fn glIsShader(&self, shader: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsShader", catch_unwind(||(self.isshader)(shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsShader", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLinkProgram.xhtml>
	#[inline(always)]
	fn glLinkProgram(&self, program: GLuint) -> Result<()> {
		let ret = process_catch("glLinkProgram", catch_unwind(||(self.linkprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLinkProgram", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glShaderSource.xhtml>
	#[inline(always)]
	fn glShaderSource(&self, shader: GLuint, count: GLsizei, string_: *const *const GLchar, length: *const GLint) -> Result<()> {
		let ret = process_catch("glShaderSource", catch_unwind(||(self.shadersource)(shader, count, string_, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glShaderSource", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUseProgram.xhtml>
	#[inline(always)]
	fn glUseProgram(&self, program: GLuint) -> Result<()> {
		let ret = process_catch("glUseProgram", catch_unwind(||(self.useprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUseProgram", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1f.xhtml>
	#[inline(always)]
	fn glUniform1f(&self, location: GLint, v0: GLfloat) -> Result<()> {
		let ret = process_catch("glUniform1f", catch_unwind(||(self.uniform1f)(location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2f.xhtml>
	#[inline(always)]
	fn glUniform2f(&self, location: GLint, v0: GLfloat, v1: GLfloat) -> Result<()> {
		let ret = process_catch("glUniform2f", catch_unwind(||(self.uniform2f)(location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3f.xhtml>
	#[inline(always)]
	fn glUniform3f(&self, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat) -> Result<()> {
		let ret = process_catch("glUniform3f", catch_unwind(||(self.uniform3f)(location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4f.xhtml>
	#[inline(always)]
	fn glUniform4f(&self, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat) -> Result<()> {
		let ret = process_catch("glUniform4f", catch_unwind(||(self.uniform4f)(location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1i.xhtml>
	#[inline(always)]
	fn glUniform1i(&self, location: GLint, v0: GLint) -> Result<()> {
		let ret = process_catch("glUniform1i", catch_unwind(||(self.uniform1i)(location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2i.xhtml>
	#[inline(always)]
	fn glUniform2i(&self, location: GLint, v0: GLint, v1: GLint) -> Result<()> {
		let ret = process_catch("glUniform2i", catch_unwind(||(self.uniform2i)(location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3i.xhtml>
	#[inline(always)]
	fn glUniform3i(&self, location: GLint, v0: GLint, v1: GLint, v2: GLint) -> Result<()> {
		let ret = process_catch("glUniform3i", catch_unwind(||(self.uniform3i)(location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4i.xhtml>
	#[inline(always)]
	fn glUniform4i(&self, location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint) -> Result<()> {
		let ret = process_catch("glUniform4i", catch_unwind(||(self.uniform4i)(location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1fv.xhtml>
	#[inline(always)]
	fn glUniform1fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniform1fv", catch_unwind(||(self.uniform1fv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2fv.xhtml>
	#[inline(always)]
	fn glUniform2fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniform2fv", catch_unwind(||(self.uniform2fv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3fv.xhtml>
	#[inline(always)]
	fn glUniform3fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniform3fv", catch_unwind(||(self.uniform3fv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4fv.xhtml>
	#[inline(always)]
	fn glUniform4fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniform4fv", catch_unwind(||(self.uniform4fv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1iv.xhtml>
	#[inline(always)]
	fn glUniform1iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glUniform1iv", catch_unwind(||(self.uniform1iv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2iv.xhtml>
	#[inline(always)]
	fn glUniform2iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glUniform2iv", catch_unwind(||(self.uniform2iv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3iv.xhtml>
	#[inline(always)]
	fn glUniform3iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glUniform3iv", catch_unwind(||(self.uniform3iv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4iv.xhtml>
	#[inline(always)]
	fn glUniform4iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glUniform4iv", catch_unwind(||(self.uniform4iv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix2fv.xhtml>
	#[inline(always)]
	fn glUniformMatrix2fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix2fv", catch_unwind(||(self.uniformmatrix2fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix3fv.xhtml>
	#[inline(always)]
	fn glUniformMatrix3fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix3fv", catch_unwind(||(self.uniformmatrix3fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix4fv.xhtml>
	#[inline(always)]
	fn glUniformMatrix4fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix4fv", catch_unwind(||(self.uniformmatrix4fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glValidateProgram.xhtml>
	#[inline(always)]
	fn glValidateProgram(&self, program: GLuint) -> Result<()> {
		let ret = process_catch("glValidateProgram", catch_unwind(||(self.validateprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glValidateProgram", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib1d.xhtml>
	#[inline(always)]
	fn glVertexAttrib1d(&self, index: GLuint, x: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib1d", catch_unwind(||(self.vertexattrib1d)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib1dv.xhtml>
	#[inline(always)]
	fn glVertexAttrib1dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib1dv", catch_unwind(||(self.vertexattrib1dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib1f.xhtml>
	#[inline(always)]
	fn glVertexAttrib1f(&self, index: GLuint, x: GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib1f", catch_unwind(||(self.vertexattrib1f)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib1fv.xhtml>
	#[inline(always)]
	fn glVertexAttrib1fv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib1fv", catch_unwind(||(self.vertexattrib1fv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib1s.xhtml>
	#[inline(always)]
	fn glVertexAttrib1s(&self, index: GLuint, x: GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib1s", catch_unwind(||(self.vertexattrib1s)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib1sv.xhtml>
	#[inline(always)]
	fn glVertexAttrib1sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib1sv", catch_unwind(||(self.vertexattrib1sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib2d.xhtml>
	#[inline(always)]
	fn glVertexAttrib2d(&self, index: GLuint, x: GLdouble, y: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib2d", catch_unwind(||(self.vertexattrib2d)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib2dv.xhtml>
	#[inline(always)]
	fn glVertexAttrib2dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib2dv", catch_unwind(||(self.vertexattrib2dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib2f.xhtml>
	#[inline(always)]
	fn glVertexAttrib2f(&self, index: GLuint, x: GLfloat, y: GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib2f", catch_unwind(||(self.vertexattrib2f)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib2fv.xhtml>
	#[inline(always)]
	fn glVertexAttrib2fv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib2fv", catch_unwind(||(self.vertexattrib2fv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib2s.xhtml>
	#[inline(always)]
	fn glVertexAttrib2s(&self, index: GLuint, x: GLshort, y: GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib2s", catch_unwind(||(self.vertexattrib2s)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib2sv.xhtml>
	#[inline(always)]
	fn glVertexAttrib2sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib2sv", catch_unwind(||(self.vertexattrib2sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib3d.xhtml>
	#[inline(always)]
	fn glVertexAttrib3d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib3d", catch_unwind(||(self.vertexattrib3d)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib3dv.xhtml>
	#[inline(always)]
	fn glVertexAttrib3dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib3dv", catch_unwind(||(self.vertexattrib3dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib3f.xhtml>
	#[inline(always)]
	fn glVertexAttrib3f(&self, index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib3f", catch_unwind(||(self.vertexattrib3f)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib3fv.xhtml>
	#[inline(always)]
	fn glVertexAttrib3fv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib3fv", catch_unwind(||(self.vertexattrib3fv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib3s.xhtml>
	#[inline(always)]
	fn glVertexAttrib3s(&self, index: GLuint, x: GLshort, y: GLshort, z: GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib3s", catch_unwind(||(self.vertexattrib3s)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib3sv.xhtml>
	#[inline(always)]
	fn glVertexAttrib3sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib3sv", catch_unwind(||(self.vertexattrib3sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Nbv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4Nbv(&self, index: GLuint, v: *const GLbyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nbv", catch_unwind(||(self.vertexattrib4nbv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nbv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Niv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4Niv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Niv", catch_unwind(||(self.vertexattrib4niv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Niv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Nsv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4Nsv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nsv", catch_unwind(||(self.vertexattrib4nsv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nsv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Nub.xhtml>
	#[inline(always)]
	fn glVertexAttrib4Nub(&self, index: GLuint, x: GLubyte, y: GLubyte, z: GLubyte, w: GLubyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nub", catch_unwind(||(self.vertexattrib4nub)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nub", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Nubv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4Nubv(&self, index: GLuint, v: *const GLubyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nubv", catch_unwind(||(self.vertexattrib4nubv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nubv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Nuiv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4Nuiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nuiv", catch_unwind(||(self.vertexattrib4nuiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Nusv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4Nusv(&self, index: GLuint, v: *const GLushort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nusv", catch_unwind(||(self.vertexattrib4nusv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nusv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4bv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4bv(&self, index: GLuint, v: *const GLbyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4bv", catch_unwind(||(self.vertexattrib4bv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4bv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4d.xhtml>
	#[inline(always)]
	fn glVertexAttrib4d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib4d", catch_unwind(||(self.vertexattrib4d)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4dv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib4dv", catch_unwind(||(self.vertexattrib4dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4f.xhtml>
	#[inline(always)]
	fn glVertexAttrib4f(&self, index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib4f", catch_unwind(||(self.vertexattrib4f)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4fv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4fv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib4fv", catch_unwind(||(self.vertexattrib4fv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4iv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttrib4iv", catch_unwind(||(self.vertexattrib4iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4s.xhtml>
	#[inline(always)]
	fn glVertexAttrib4s(&self, index: GLuint, x: GLshort, y: GLshort, z: GLshort, w: GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4s", catch_unwind(||(self.vertexattrib4s)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4sv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4sv", catch_unwind(||(self.vertexattrib4sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4ubv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4ubv(&self, index: GLuint, v: *const GLubyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4ubv", catch_unwind(||(self.vertexattrib4ubv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4ubv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4uiv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttrib4uiv", catch_unwind(||(self.vertexattrib4uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4usv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4usv(&self, index: GLuint, v: *const GLushort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4usv", catch_unwind(||(self.vertexattrib4usv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4usv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml>
	#[inline(always)]
	fn glVertexAttribPointer(&self, index: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glVertexAttribPointer", catch_unwind(||(self.vertexattribpointer)(index, size, type_, normalized, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribPointer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn get_shading_language_version(&self) -> &'static str {
		self.shading_language_version
	}
}

impl Version20 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (2, 0, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			blendequationseparate: {let proc = get_proc_address("glBlendEquationSeparate"); if proc == null() {dummy_pfnglblendequationseparateproc} else {unsafe{transmute(proc)}}},
			drawbuffers: {let proc = get_proc_address("glDrawBuffers"); if proc == null() {dummy_pfngldrawbuffersproc} else {unsafe{transmute(proc)}}},
			stencilopseparate: {let proc = get_proc_address("glStencilOpSeparate"); if proc == null() {dummy_pfnglstencilopseparateproc} else {unsafe{transmute(proc)}}},
			stencilfuncseparate: {let proc = get_proc_address("glStencilFuncSeparate"); if proc == null() {dummy_pfnglstencilfuncseparateproc} else {unsafe{transmute(proc)}}},
			stencilmaskseparate: {let proc = get_proc_address("glStencilMaskSeparate"); if proc == null() {dummy_pfnglstencilmaskseparateproc} else {unsafe{transmute(proc)}}},
			attachshader: {let proc = get_proc_address("glAttachShader"); if proc == null() {dummy_pfnglattachshaderproc} else {unsafe{transmute(proc)}}},
			bindattriblocation: {let proc = get_proc_address("glBindAttribLocation"); if proc == null() {dummy_pfnglbindattriblocationproc} else {unsafe{transmute(proc)}}},
			compileshader: {let proc = get_proc_address("glCompileShader"); if proc == null() {dummy_pfnglcompileshaderproc} else {unsafe{transmute(proc)}}},
			createprogram: {let proc = get_proc_address("glCreateProgram"); if proc == null() {dummy_pfnglcreateprogramproc} else {unsafe{transmute(proc)}}},
			createshader: {let proc = get_proc_address("glCreateShader"); if proc == null() {dummy_pfnglcreateshaderproc} else {unsafe{transmute(proc)}}},
			deleteprogram: {let proc = get_proc_address("glDeleteProgram"); if proc == null() {dummy_pfngldeleteprogramproc} else {unsafe{transmute(proc)}}},
			deleteshader: {let proc = get_proc_address("glDeleteShader"); if proc == null() {dummy_pfngldeleteshaderproc} else {unsafe{transmute(proc)}}},
			detachshader: {let proc = get_proc_address("glDetachShader"); if proc == null() {dummy_pfngldetachshaderproc} else {unsafe{transmute(proc)}}},
			disablevertexattribarray: {let proc = get_proc_address("glDisableVertexAttribArray"); if proc == null() {dummy_pfngldisablevertexattribarrayproc} else {unsafe{transmute(proc)}}},
			enablevertexattribarray: {let proc = get_proc_address("glEnableVertexAttribArray"); if proc == null() {dummy_pfnglenablevertexattribarrayproc} else {unsafe{transmute(proc)}}},
			getactiveattrib: {let proc = get_proc_address("glGetActiveAttrib"); if proc == null() {dummy_pfnglgetactiveattribproc} else {unsafe{transmute(proc)}}},
			getactiveuniform: {let proc = get_proc_address("glGetActiveUniform"); if proc == null() {dummy_pfnglgetactiveuniformproc} else {unsafe{transmute(proc)}}},
			getattachedshaders: {let proc = get_proc_address("glGetAttachedShaders"); if proc == null() {dummy_pfnglgetattachedshadersproc} else {unsafe{transmute(proc)}}},
			getattriblocation: {let proc = get_proc_address("glGetAttribLocation"); if proc == null() {dummy_pfnglgetattriblocationproc} else {unsafe{transmute(proc)}}},
			getprogramiv: {let proc = get_proc_address("glGetProgramiv"); if proc == null() {dummy_pfnglgetprogramivproc} else {unsafe{transmute(proc)}}},
			getprograminfolog: {let proc = get_proc_address("glGetProgramInfoLog"); if proc == null() {dummy_pfnglgetprograminfologproc} else {unsafe{transmute(proc)}}},
			getshaderiv: {let proc = get_proc_address("glGetShaderiv"); if proc == null() {dummy_pfnglgetshaderivproc} else {unsafe{transmute(proc)}}},
			getshaderinfolog: {let proc = get_proc_address("glGetShaderInfoLog"); if proc == null() {dummy_pfnglgetshaderinfologproc} else {unsafe{transmute(proc)}}},
			getshadersource: {let proc = get_proc_address("glGetShaderSource"); if proc == null() {dummy_pfnglgetshadersourceproc} else {unsafe{transmute(proc)}}},
			getuniformlocation: {let proc = get_proc_address("glGetUniformLocation"); if proc == null() {dummy_pfnglgetuniformlocationproc} else {unsafe{transmute(proc)}}},
			getuniformfv: {let proc = get_proc_address("glGetUniformfv"); if proc == null() {dummy_pfnglgetuniformfvproc} else {unsafe{transmute(proc)}}},
			getuniformiv: {let proc = get_proc_address("glGetUniformiv"); if proc == null() {dummy_pfnglgetuniformivproc} else {unsafe{transmute(proc)}}},
			getvertexattribdv: {let proc = get_proc_address("glGetVertexAttribdv"); if proc == null() {dummy_pfnglgetvertexattribdvproc} else {unsafe{transmute(proc)}}},
			getvertexattribfv: {let proc = get_proc_address("glGetVertexAttribfv"); if proc == null() {dummy_pfnglgetvertexattribfvproc} else {unsafe{transmute(proc)}}},
			getvertexattribiv: {let proc = get_proc_address("glGetVertexAttribiv"); if proc == null() {dummy_pfnglgetvertexattribivproc} else {unsafe{transmute(proc)}}},
			getvertexattribpointerv: {let proc = get_proc_address("glGetVertexAttribPointerv"); if proc == null() {dummy_pfnglgetvertexattribpointervproc} else {unsafe{transmute(proc)}}},
			isprogram: {let proc = get_proc_address("glIsProgram"); if proc == null() {dummy_pfnglisprogramproc} else {unsafe{transmute(proc)}}},
			isshader: {let proc = get_proc_address("glIsShader"); if proc == null() {dummy_pfnglisshaderproc} else {unsafe{transmute(proc)}}},
			linkprogram: {let proc = get_proc_address("glLinkProgram"); if proc == null() {dummy_pfngllinkprogramproc} else {unsafe{transmute(proc)}}},
			shadersource: {let proc = get_proc_address("glShaderSource"); if proc == null() {dummy_pfnglshadersourceproc} else {unsafe{transmute(proc)}}},
			useprogram: {let proc = get_proc_address("glUseProgram"); if proc == null() {dummy_pfngluseprogramproc} else {unsafe{transmute(proc)}}},
			uniform1f: {let proc = get_proc_address("glUniform1f"); if proc == null() {dummy_pfngluniform1fproc} else {unsafe{transmute(proc)}}},
			uniform2f: {let proc = get_proc_address("glUniform2f"); if proc == null() {dummy_pfngluniform2fproc} else {unsafe{transmute(proc)}}},
			uniform3f: {let proc = get_proc_address("glUniform3f"); if proc == null() {dummy_pfngluniform3fproc} else {unsafe{transmute(proc)}}},
			uniform4f: {let proc = get_proc_address("glUniform4f"); if proc == null() {dummy_pfngluniform4fproc} else {unsafe{transmute(proc)}}},
			uniform1i: {let proc = get_proc_address("glUniform1i"); if proc == null() {dummy_pfngluniform1iproc} else {unsafe{transmute(proc)}}},
			uniform2i: {let proc = get_proc_address("glUniform2i"); if proc == null() {dummy_pfngluniform2iproc} else {unsafe{transmute(proc)}}},
			uniform3i: {let proc = get_proc_address("glUniform3i"); if proc == null() {dummy_pfngluniform3iproc} else {unsafe{transmute(proc)}}},
			uniform4i: {let proc = get_proc_address("glUniform4i"); if proc == null() {dummy_pfngluniform4iproc} else {unsafe{transmute(proc)}}},
			uniform1fv: {let proc = get_proc_address("glUniform1fv"); if proc == null() {dummy_pfngluniform1fvproc} else {unsafe{transmute(proc)}}},
			uniform2fv: {let proc = get_proc_address("glUniform2fv"); if proc == null() {dummy_pfngluniform2fvproc} else {unsafe{transmute(proc)}}},
			uniform3fv: {let proc = get_proc_address("glUniform3fv"); if proc == null() {dummy_pfngluniform3fvproc} else {unsafe{transmute(proc)}}},
			uniform4fv: {let proc = get_proc_address("glUniform4fv"); if proc == null() {dummy_pfngluniform4fvproc} else {unsafe{transmute(proc)}}},
			uniform1iv: {let proc = get_proc_address("glUniform1iv"); if proc == null() {dummy_pfngluniform1ivproc} else {unsafe{transmute(proc)}}},
			uniform2iv: {let proc = get_proc_address("glUniform2iv"); if proc == null() {dummy_pfngluniform2ivproc} else {unsafe{transmute(proc)}}},
			uniform3iv: {let proc = get_proc_address("glUniform3iv"); if proc == null() {dummy_pfngluniform3ivproc} else {unsafe{transmute(proc)}}},
			uniform4iv: {let proc = get_proc_address("glUniform4iv"); if proc == null() {dummy_pfngluniform4ivproc} else {unsafe{transmute(proc)}}},
			uniformmatrix2fv: {let proc = get_proc_address("glUniformMatrix2fv"); if proc == null() {dummy_pfngluniformmatrix2fvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix3fv: {let proc = get_proc_address("glUniformMatrix3fv"); if proc == null() {dummy_pfngluniformmatrix3fvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix4fv: {let proc = get_proc_address("glUniformMatrix4fv"); if proc == null() {dummy_pfngluniformmatrix4fvproc} else {unsafe{transmute(proc)}}},
			validateprogram: {let proc = get_proc_address("glValidateProgram"); if proc == null() {dummy_pfnglvalidateprogramproc} else {unsafe{transmute(proc)}}},
			vertexattrib1d: {let proc = get_proc_address("glVertexAttrib1d"); if proc == null() {dummy_pfnglvertexattrib1dproc} else {unsafe{transmute(proc)}}},
			vertexattrib1dv: {let proc = get_proc_address("glVertexAttrib1dv"); if proc == null() {dummy_pfnglvertexattrib1dvproc} else {unsafe{transmute(proc)}}},
			vertexattrib1f: {let proc = get_proc_address("glVertexAttrib1f"); if proc == null() {dummy_pfnglvertexattrib1fproc} else {unsafe{transmute(proc)}}},
			vertexattrib1fv: {let proc = get_proc_address("glVertexAttrib1fv"); if proc == null() {dummy_pfnglvertexattrib1fvproc} else {unsafe{transmute(proc)}}},
			vertexattrib1s: {let proc = get_proc_address("glVertexAttrib1s"); if proc == null() {dummy_pfnglvertexattrib1sproc} else {unsafe{transmute(proc)}}},
			vertexattrib1sv: {let proc = get_proc_address("glVertexAttrib1sv"); if proc == null() {dummy_pfnglvertexattrib1svproc} else {unsafe{transmute(proc)}}},
			vertexattrib2d: {let proc = get_proc_address("glVertexAttrib2d"); if proc == null() {dummy_pfnglvertexattrib2dproc} else {unsafe{transmute(proc)}}},
			vertexattrib2dv: {let proc = get_proc_address("glVertexAttrib2dv"); if proc == null() {dummy_pfnglvertexattrib2dvproc} else {unsafe{transmute(proc)}}},
			vertexattrib2f: {let proc = get_proc_address("glVertexAttrib2f"); if proc == null() {dummy_pfnglvertexattrib2fproc} else {unsafe{transmute(proc)}}},
			vertexattrib2fv: {let proc = get_proc_address("glVertexAttrib2fv"); if proc == null() {dummy_pfnglvertexattrib2fvproc} else {unsafe{transmute(proc)}}},
			vertexattrib2s: {let proc = get_proc_address("glVertexAttrib2s"); if proc == null() {dummy_pfnglvertexattrib2sproc} else {unsafe{transmute(proc)}}},
			vertexattrib2sv: {let proc = get_proc_address("glVertexAttrib2sv"); if proc == null() {dummy_pfnglvertexattrib2svproc} else {unsafe{transmute(proc)}}},
			vertexattrib3d: {let proc = get_proc_address("glVertexAttrib3d"); if proc == null() {dummy_pfnglvertexattrib3dproc} else {unsafe{transmute(proc)}}},
			vertexattrib3dv: {let proc = get_proc_address("glVertexAttrib3dv"); if proc == null() {dummy_pfnglvertexattrib3dvproc} else {unsafe{transmute(proc)}}},
			vertexattrib3f: {let proc = get_proc_address("glVertexAttrib3f"); if proc == null() {dummy_pfnglvertexattrib3fproc} else {unsafe{transmute(proc)}}},
			vertexattrib3fv: {let proc = get_proc_address("glVertexAttrib3fv"); if proc == null() {dummy_pfnglvertexattrib3fvproc} else {unsafe{transmute(proc)}}},
			vertexattrib3s: {let proc = get_proc_address("glVertexAttrib3s"); if proc == null() {dummy_pfnglvertexattrib3sproc} else {unsafe{transmute(proc)}}},
			vertexattrib3sv: {let proc = get_proc_address("glVertexAttrib3sv"); if proc == null() {dummy_pfnglvertexattrib3svproc} else {unsafe{transmute(proc)}}},
			vertexattrib4nbv: {let proc = get_proc_address("glVertexAttrib4Nbv"); if proc == null() {dummy_pfnglvertexattrib4nbvproc} else {unsafe{transmute(proc)}}},
			vertexattrib4niv: {let proc = get_proc_address("glVertexAttrib4Niv"); if proc == null() {dummy_pfnglvertexattrib4nivproc} else {unsafe{transmute(proc)}}},
			vertexattrib4nsv: {let proc = get_proc_address("glVertexAttrib4Nsv"); if proc == null() {dummy_pfnglvertexattrib4nsvproc} else {unsafe{transmute(proc)}}},
			vertexattrib4nub: {let proc = get_proc_address("glVertexAttrib4Nub"); if proc == null() {dummy_pfnglvertexattrib4nubproc} else {unsafe{transmute(proc)}}},
			vertexattrib4nubv: {let proc = get_proc_address("glVertexAttrib4Nubv"); if proc == null() {dummy_pfnglvertexattrib4nubvproc} else {unsafe{transmute(proc)}}},
			vertexattrib4nuiv: {let proc = get_proc_address("glVertexAttrib4Nuiv"); if proc == null() {dummy_pfnglvertexattrib4nuivproc} else {unsafe{transmute(proc)}}},
			vertexattrib4nusv: {let proc = get_proc_address("glVertexAttrib4Nusv"); if proc == null() {dummy_pfnglvertexattrib4nusvproc} else {unsafe{transmute(proc)}}},
			vertexattrib4bv: {let proc = get_proc_address("glVertexAttrib4bv"); if proc == null() {dummy_pfnglvertexattrib4bvproc} else {unsafe{transmute(proc)}}},
			vertexattrib4d: {let proc = get_proc_address("glVertexAttrib4d"); if proc == null() {dummy_pfnglvertexattrib4dproc} else {unsafe{transmute(proc)}}},
			vertexattrib4dv: {let proc = get_proc_address("glVertexAttrib4dv"); if proc == null() {dummy_pfnglvertexattrib4dvproc} else {unsafe{transmute(proc)}}},
			vertexattrib4f: {let proc = get_proc_address("glVertexAttrib4f"); if proc == null() {dummy_pfnglvertexattrib4fproc} else {unsafe{transmute(proc)}}},
			vertexattrib4fv: {let proc = get_proc_address("glVertexAttrib4fv"); if proc == null() {dummy_pfnglvertexattrib4fvproc} else {unsafe{transmute(proc)}}},
			vertexattrib4iv: {let proc = get_proc_address("glVertexAttrib4iv"); if proc == null() {dummy_pfnglvertexattrib4ivproc} else {unsafe{transmute(proc)}}},
			vertexattrib4s: {let proc = get_proc_address("glVertexAttrib4s"); if proc == null() {dummy_pfnglvertexattrib4sproc} else {unsafe{transmute(proc)}}},
			vertexattrib4sv: {let proc = get_proc_address("glVertexAttrib4sv"); if proc == null() {dummy_pfnglvertexattrib4svproc} else {unsafe{transmute(proc)}}},
			vertexattrib4ubv: {let proc = get_proc_address("glVertexAttrib4ubv"); if proc == null() {dummy_pfnglvertexattrib4ubvproc} else {unsafe{transmute(proc)}}},
			vertexattrib4uiv: {let proc = get_proc_address("glVertexAttrib4uiv"); if proc == null() {dummy_pfnglvertexattrib4uivproc} else {unsafe{transmute(proc)}}},
			vertexattrib4usv: {let proc = get_proc_address("glVertexAttrib4usv"); if proc == null() {dummy_pfnglvertexattrib4usvproc} else {unsafe{transmute(proc)}}},
			vertexattribpointer: {let proc = get_proc_address("glVertexAttribPointer"); if proc == null() {dummy_pfnglvertexattribpointerproc} else {unsafe{transmute(proc)}}},
			shading_language_version: base.glGetString(GL_SHADING_LANGUAGE_VERSION).unwrap(),
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version20 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			blendequationseparate: dummy_pfnglblendequationseparateproc,
			drawbuffers: dummy_pfngldrawbuffersproc,
			stencilopseparate: dummy_pfnglstencilopseparateproc,
			stencilfuncseparate: dummy_pfnglstencilfuncseparateproc,
			stencilmaskseparate: dummy_pfnglstencilmaskseparateproc,
			attachshader: dummy_pfnglattachshaderproc,
			bindattriblocation: dummy_pfnglbindattriblocationproc,
			compileshader: dummy_pfnglcompileshaderproc,
			createprogram: dummy_pfnglcreateprogramproc,
			createshader: dummy_pfnglcreateshaderproc,
			deleteprogram: dummy_pfngldeleteprogramproc,
			deleteshader: dummy_pfngldeleteshaderproc,
			detachshader: dummy_pfngldetachshaderproc,
			disablevertexattribarray: dummy_pfngldisablevertexattribarrayproc,
			enablevertexattribarray: dummy_pfnglenablevertexattribarrayproc,
			getactiveattrib: dummy_pfnglgetactiveattribproc,
			getactiveuniform: dummy_pfnglgetactiveuniformproc,
			getattachedshaders: dummy_pfnglgetattachedshadersproc,
			getattriblocation: dummy_pfnglgetattriblocationproc,
			getprogramiv: dummy_pfnglgetprogramivproc,
			getprograminfolog: dummy_pfnglgetprograminfologproc,
			getshaderiv: dummy_pfnglgetshaderivproc,
			getshaderinfolog: dummy_pfnglgetshaderinfologproc,
			getshadersource: dummy_pfnglgetshadersourceproc,
			getuniformlocation: dummy_pfnglgetuniformlocationproc,
			getuniformfv: dummy_pfnglgetuniformfvproc,
			getuniformiv: dummy_pfnglgetuniformivproc,
			getvertexattribdv: dummy_pfnglgetvertexattribdvproc,
			getvertexattribfv: dummy_pfnglgetvertexattribfvproc,
			getvertexattribiv: dummy_pfnglgetvertexattribivproc,
			getvertexattribpointerv: dummy_pfnglgetvertexattribpointervproc,
			isprogram: dummy_pfnglisprogramproc,
			isshader: dummy_pfnglisshaderproc,
			linkprogram: dummy_pfngllinkprogramproc,
			shadersource: dummy_pfnglshadersourceproc,
			useprogram: dummy_pfngluseprogramproc,
			uniform1f: dummy_pfngluniform1fproc,
			uniform2f: dummy_pfngluniform2fproc,
			uniform3f: dummy_pfngluniform3fproc,
			uniform4f: dummy_pfngluniform4fproc,
			uniform1i: dummy_pfngluniform1iproc,
			uniform2i: dummy_pfngluniform2iproc,
			uniform3i: dummy_pfngluniform3iproc,
			uniform4i: dummy_pfngluniform4iproc,
			uniform1fv: dummy_pfngluniform1fvproc,
			uniform2fv: dummy_pfngluniform2fvproc,
			uniform3fv: dummy_pfngluniform3fvproc,
			uniform4fv: dummy_pfngluniform4fvproc,
			uniform1iv: dummy_pfngluniform1ivproc,
			uniform2iv: dummy_pfngluniform2ivproc,
			uniform3iv: dummy_pfngluniform3ivproc,
			uniform4iv: dummy_pfngluniform4ivproc,
			uniformmatrix2fv: dummy_pfngluniformmatrix2fvproc,
			uniformmatrix3fv: dummy_pfngluniformmatrix3fvproc,
			uniformmatrix4fv: dummy_pfngluniformmatrix4fvproc,
			validateprogram: dummy_pfnglvalidateprogramproc,
			vertexattrib1d: dummy_pfnglvertexattrib1dproc,
			vertexattrib1dv: dummy_pfnglvertexattrib1dvproc,
			vertexattrib1f: dummy_pfnglvertexattrib1fproc,
			vertexattrib1fv: dummy_pfnglvertexattrib1fvproc,
			vertexattrib1s: dummy_pfnglvertexattrib1sproc,
			vertexattrib1sv: dummy_pfnglvertexattrib1svproc,
			vertexattrib2d: dummy_pfnglvertexattrib2dproc,
			vertexattrib2dv: dummy_pfnglvertexattrib2dvproc,
			vertexattrib2f: dummy_pfnglvertexattrib2fproc,
			vertexattrib2fv: dummy_pfnglvertexattrib2fvproc,
			vertexattrib2s: dummy_pfnglvertexattrib2sproc,
			vertexattrib2sv: dummy_pfnglvertexattrib2svproc,
			vertexattrib3d: dummy_pfnglvertexattrib3dproc,
			vertexattrib3dv: dummy_pfnglvertexattrib3dvproc,
			vertexattrib3f: dummy_pfnglvertexattrib3fproc,
			vertexattrib3fv: dummy_pfnglvertexattrib3fvproc,
			vertexattrib3s: dummy_pfnglvertexattrib3sproc,
			vertexattrib3sv: dummy_pfnglvertexattrib3svproc,
			vertexattrib4nbv: dummy_pfnglvertexattrib4nbvproc,
			vertexattrib4niv: dummy_pfnglvertexattrib4nivproc,
			vertexattrib4nsv: dummy_pfnglvertexattrib4nsvproc,
			vertexattrib4nub: dummy_pfnglvertexattrib4nubproc,
			vertexattrib4nubv: dummy_pfnglvertexattrib4nubvproc,
			vertexattrib4nuiv: dummy_pfnglvertexattrib4nuivproc,
			vertexattrib4nusv: dummy_pfnglvertexattrib4nusvproc,
			vertexattrib4bv: dummy_pfnglvertexattrib4bvproc,
			vertexattrib4d: dummy_pfnglvertexattrib4dproc,
			vertexattrib4dv: dummy_pfnglvertexattrib4dvproc,
			vertexattrib4f: dummy_pfnglvertexattrib4fproc,
			vertexattrib4fv: dummy_pfnglvertexattrib4fvproc,
			vertexattrib4iv: dummy_pfnglvertexattrib4ivproc,
			vertexattrib4s: dummy_pfnglvertexattrib4sproc,
			vertexattrib4sv: dummy_pfnglvertexattrib4svproc,
			vertexattrib4ubv: dummy_pfnglvertexattrib4ubvproc,
			vertexattrib4uiv: dummy_pfnglvertexattrib4uivproc,
			vertexattrib4usv: dummy_pfnglvertexattrib4usvproc,
			vertexattribpointer: dummy_pfnglvertexattribpointerproc,
			shading_language_version: "unknown",
		}
	}
}
impl Debug for Version20 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version20")
			.field("available", &self.available)
			.field("shading_language_version", &self.shading_language_version)
			.field("blendequationseparate", unsafe{if transmute::<_, *const c_void>(self.blendequationseparate) == (dummy_pfnglblendequationseparateproc as *const c_void) {&null::<PFNGLBLENDEQUATIONSEPARATEPROC>()} else {&self.blendequationseparate}})
			.field("drawbuffers", unsafe{if transmute::<_, *const c_void>(self.drawbuffers) == (dummy_pfngldrawbuffersproc as *const c_void) {&null::<PFNGLDRAWBUFFERSPROC>()} else {&self.drawbuffers}})
			.field("stencilopseparate", unsafe{if transmute::<_, *const c_void>(self.stencilopseparate) == (dummy_pfnglstencilopseparateproc as *const c_void) {&null::<PFNGLSTENCILOPSEPARATEPROC>()} else {&self.stencilopseparate}})
			.field("stencilfuncseparate", unsafe{if transmute::<_, *const c_void>(self.stencilfuncseparate) == (dummy_pfnglstencilfuncseparateproc as *const c_void) {&null::<PFNGLSTENCILFUNCSEPARATEPROC>()} else {&self.stencilfuncseparate}})
			.field("stencilmaskseparate", unsafe{if transmute::<_, *const c_void>(self.stencilmaskseparate) == (dummy_pfnglstencilmaskseparateproc as *const c_void) {&null::<PFNGLSTENCILMASKSEPARATEPROC>()} else {&self.stencilmaskseparate}})
			.field("attachshader", unsafe{if transmute::<_, *const c_void>(self.attachshader) == (dummy_pfnglattachshaderproc as *const c_void) {&null::<PFNGLATTACHSHADERPROC>()} else {&self.attachshader}})
			.field("bindattriblocation", unsafe{if transmute::<_, *const c_void>(self.bindattriblocation) == (dummy_pfnglbindattriblocationproc as *const c_void) {&null::<PFNGLBINDATTRIBLOCATIONPROC>()} else {&self.bindattriblocation}})
			.field("compileshader", unsafe{if transmute::<_, *const c_void>(self.compileshader) == (dummy_pfnglcompileshaderproc as *const c_void) {&null::<PFNGLCOMPILESHADERPROC>()} else {&self.compileshader}})
			.field("createprogram", unsafe{if transmute::<_, *const c_void>(self.createprogram) == (dummy_pfnglcreateprogramproc as *const c_void) {&null::<PFNGLCREATEPROGRAMPROC>()} else {&self.createprogram}})
			.field("createshader", unsafe{if transmute::<_, *const c_void>(self.createshader) == (dummy_pfnglcreateshaderproc as *const c_void) {&null::<PFNGLCREATESHADERPROC>()} else {&self.createshader}})
			.field("deleteprogram", unsafe{if transmute::<_, *const c_void>(self.deleteprogram) == (dummy_pfngldeleteprogramproc as *const c_void) {&null::<PFNGLDELETEPROGRAMPROC>()} else {&self.deleteprogram}})
			.field("deleteshader", unsafe{if transmute::<_, *const c_void>(self.deleteshader) == (dummy_pfngldeleteshaderproc as *const c_void) {&null::<PFNGLDELETESHADERPROC>()} else {&self.deleteshader}})
			.field("detachshader", unsafe{if transmute::<_, *const c_void>(self.detachshader) == (dummy_pfngldetachshaderproc as *const c_void) {&null::<PFNGLDETACHSHADERPROC>()} else {&self.detachshader}})
			.field("disablevertexattribarray", unsafe{if transmute::<_, *const c_void>(self.disablevertexattribarray) == (dummy_pfngldisablevertexattribarrayproc as *const c_void) {&null::<PFNGLDISABLEVERTEXATTRIBARRAYPROC>()} else {&self.disablevertexattribarray}})
			.field("enablevertexattribarray", unsafe{if transmute::<_, *const c_void>(self.enablevertexattribarray) == (dummy_pfnglenablevertexattribarrayproc as *const c_void) {&null::<PFNGLENABLEVERTEXATTRIBARRAYPROC>()} else {&self.enablevertexattribarray}})
			.field("getactiveattrib", unsafe{if transmute::<_, *const c_void>(self.getactiveattrib) == (dummy_pfnglgetactiveattribproc as *const c_void) {&null::<PFNGLGETACTIVEATTRIBPROC>()} else {&self.getactiveattrib}})
			.field("getactiveuniform", unsafe{if transmute::<_, *const c_void>(self.getactiveuniform) == (dummy_pfnglgetactiveuniformproc as *const c_void) {&null::<PFNGLGETACTIVEUNIFORMPROC>()} else {&self.getactiveuniform}})
			.field("getattachedshaders", unsafe{if transmute::<_, *const c_void>(self.getattachedshaders) == (dummy_pfnglgetattachedshadersproc as *const c_void) {&null::<PFNGLGETATTACHEDSHADERSPROC>()} else {&self.getattachedshaders}})
			.field("getattriblocation", unsafe{if transmute::<_, *const c_void>(self.getattriblocation) == (dummy_pfnglgetattriblocationproc as *const c_void) {&null::<PFNGLGETATTRIBLOCATIONPROC>()} else {&self.getattriblocation}})
			.field("getprogramiv", unsafe{if transmute::<_, *const c_void>(self.getprogramiv) == (dummy_pfnglgetprogramivproc as *const c_void) {&null::<PFNGLGETPROGRAMIVPROC>()} else {&self.getprogramiv}})
			.field("getprograminfolog", unsafe{if transmute::<_, *const c_void>(self.getprograminfolog) == (dummy_pfnglgetprograminfologproc as *const c_void) {&null::<PFNGLGETPROGRAMINFOLOGPROC>()} else {&self.getprograminfolog}})
			.field("getshaderiv", unsafe{if transmute::<_, *const c_void>(self.getshaderiv) == (dummy_pfnglgetshaderivproc as *const c_void) {&null::<PFNGLGETSHADERIVPROC>()} else {&self.getshaderiv}})
			.field("getshaderinfolog", unsafe{if transmute::<_, *const c_void>(self.getshaderinfolog) == (dummy_pfnglgetshaderinfologproc as *const c_void) {&null::<PFNGLGETSHADERINFOLOGPROC>()} else {&self.getshaderinfolog}})
			.field("getshadersource", unsafe{if transmute::<_, *const c_void>(self.getshadersource) == (dummy_pfnglgetshadersourceproc as *const c_void) {&null::<PFNGLGETSHADERSOURCEPROC>()} else {&self.getshadersource}})
			.field("getuniformlocation", unsafe{if transmute::<_, *const c_void>(self.getuniformlocation) == (dummy_pfnglgetuniformlocationproc as *const c_void) {&null::<PFNGLGETUNIFORMLOCATIONPROC>()} else {&self.getuniformlocation}})
			.field("getuniformfv", unsafe{if transmute::<_, *const c_void>(self.getuniformfv) == (dummy_pfnglgetuniformfvproc as *const c_void) {&null::<PFNGLGETUNIFORMFVPROC>()} else {&self.getuniformfv}})
			.field("getuniformiv", unsafe{if transmute::<_, *const c_void>(self.getuniformiv) == (dummy_pfnglgetuniformivproc as *const c_void) {&null::<PFNGLGETUNIFORMIVPROC>()} else {&self.getuniformiv}})
			.field("getvertexattribdv", unsafe{if transmute::<_, *const c_void>(self.getvertexattribdv) == (dummy_pfnglgetvertexattribdvproc as *const c_void) {&null::<PFNGLGETVERTEXATTRIBDVPROC>()} else {&self.getvertexattribdv}})
			.field("getvertexattribfv", unsafe{if transmute::<_, *const c_void>(self.getvertexattribfv) == (dummy_pfnglgetvertexattribfvproc as *const c_void) {&null::<PFNGLGETVERTEXATTRIBFVPROC>()} else {&self.getvertexattribfv}})
			.field("getvertexattribiv", unsafe{if transmute::<_, *const c_void>(self.getvertexattribiv) == (dummy_pfnglgetvertexattribivproc as *const c_void) {&null::<PFNGLGETVERTEXATTRIBIVPROC>()} else {&self.getvertexattribiv}})
			.field("getvertexattribpointerv", unsafe{if transmute::<_, *const c_void>(self.getvertexattribpointerv) == (dummy_pfnglgetvertexattribpointervproc as *const c_void) {&null::<PFNGLGETVERTEXATTRIBPOINTERVPROC>()} else {&self.getvertexattribpointerv}})
			.field("isprogram", unsafe{if transmute::<_, *const c_void>(self.isprogram) == (dummy_pfnglisprogramproc as *const c_void) {&null::<PFNGLISPROGRAMPROC>()} else {&self.isprogram}})
			.field("isshader", unsafe{if transmute::<_, *const c_void>(self.isshader) == (dummy_pfnglisshaderproc as *const c_void) {&null::<PFNGLISSHADERPROC>()} else {&self.isshader}})
			.field("linkprogram", unsafe{if transmute::<_, *const c_void>(self.linkprogram) == (dummy_pfngllinkprogramproc as *const c_void) {&null::<PFNGLLINKPROGRAMPROC>()} else {&self.linkprogram}})
			.field("shadersource", unsafe{if transmute::<_, *const c_void>(self.shadersource) == (dummy_pfnglshadersourceproc as *const c_void) {&null::<PFNGLSHADERSOURCEPROC>()} else {&self.shadersource}})
			.field("useprogram", unsafe{if transmute::<_, *const c_void>(self.useprogram) == (dummy_pfngluseprogramproc as *const c_void) {&null::<PFNGLUSEPROGRAMPROC>()} else {&self.useprogram}})
			.field("uniform1f", unsafe{if transmute::<_, *const c_void>(self.uniform1f) == (dummy_pfngluniform1fproc as *const c_void) {&null::<PFNGLUNIFORM1FPROC>()} else {&self.uniform1f}})
			.field("uniform2f", unsafe{if transmute::<_, *const c_void>(self.uniform2f) == (dummy_pfngluniform2fproc as *const c_void) {&null::<PFNGLUNIFORM2FPROC>()} else {&self.uniform2f}})
			.field("uniform3f", unsafe{if transmute::<_, *const c_void>(self.uniform3f) == (dummy_pfngluniform3fproc as *const c_void) {&null::<PFNGLUNIFORM3FPROC>()} else {&self.uniform3f}})
			.field("uniform4f", unsafe{if transmute::<_, *const c_void>(self.uniform4f) == (dummy_pfngluniform4fproc as *const c_void) {&null::<PFNGLUNIFORM4FPROC>()} else {&self.uniform4f}})
			.field("uniform1i", unsafe{if transmute::<_, *const c_void>(self.uniform1i) == (dummy_pfngluniform1iproc as *const c_void) {&null::<PFNGLUNIFORM1IPROC>()} else {&self.uniform1i}})
			.field("uniform2i", unsafe{if transmute::<_, *const c_void>(self.uniform2i) == (dummy_pfngluniform2iproc as *const c_void) {&null::<PFNGLUNIFORM2IPROC>()} else {&self.uniform2i}})
			.field("uniform3i", unsafe{if transmute::<_, *const c_void>(self.uniform3i) == (dummy_pfngluniform3iproc as *const c_void) {&null::<PFNGLUNIFORM3IPROC>()} else {&self.uniform3i}})
			.field("uniform4i", unsafe{if transmute::<_, *const c_void>(self.uniform4i) == (dummy_pfngluniform4iproc as *const c_void) {&null::<PFNGLUNIFORM4IPROC>()} else {&self.uniform4i}})
			.field("uniform1fv", unsafe{if transmute::<_, *const c_void>(self.uniform1fv) == (dummy_pfngluniform1fvproc as *const c_void) {&null::<PFNGLUNIFORM1FVPROC>()} else {&self.uniform1fv}})
			.field("uniform2fv", unsafe{if transmute::<_, *const c_void>(self.uniform2fv) == (dummy_pfngluniform2fvproc as *const c_void) {&null::<PFNGLUNIFORM2FVPROC>()} else {&self.uniform2fv}})
			.field("uniform3fv", unsafe{if transmute::<_, *const c_void>(self.uniform3fv) == (dummy_pfngluniform3fvproc as *const c_void) {&null::<PFNGLUNIFORM3FVPROC>()} else {&self.uniform3fv}})
			.field("uniform4fv", unsafe{if transmute::<_, *const c_void>(self.uniform4fv) == (dummy_pfngluniform4fvproc as *const c_void) {&null::<PFNGLUNIFORM4FVPROC>()} else {&self.uniform4fv}})
			.field("uniform1iv", unsafe{if transmute::<_, *const c_void>(self.uniform1iv) == (dummy_pfngluniform1ivproc as *const c_void) {&null::<PFNGLUNIFORM1IVPROC>()} else {&self.uniform1iv}})
			.field("uniform2iv", unsafe{if transmute::<_, *const c_void>(self.uniform2iv) == (dummy_pfngluniform2ivproc as *const c_void) {&null::<PFNGLUNIFORM2IVPROC>()} else {&self.uniform2iv}})
			.field("uniform3iv", unsafe{if transmute::<_, *const c_void>(self.uniform3iv) == (dummy_pfngluniform3ivproc as *const c_void) {&null::<PFNGLUNIFORM3IVPROC>()} else {&self.uniform3iv}})
			.field("uniform4iv", unsafe{if transmute::<_, *const c_void>(self.uniform4iv) == (dummy_pfngluniform4ivproc as *const c_void) {&null::<PFNGLUNIFORM4IVPROC>()} else {&self.uniform4iv}})
			.field("uniformmatrix2fv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix2fv) == (dummy_pfngluniformmatrix2fvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX2FVPROC>()} else {&self.uniformmatrix2fv}})
			.field("uniformmatrix3fv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix3fv) == (dummy_pfngluniformmatrix3fvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX3FVPROC>()} else {&self.uniformmatrix3fv}})
			.field("uniformmatrix4fv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix4fv) == (dummy_pfngluniformmatrix4fvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX4FVPROC>()} else {&self.uniformmatrix4fv}})
			.field("validateprogram", unsafe{if transmute::<_, *const c_void>(self.validateprogram) == (dummy_pfnglvalidateprogramproc as *const c_void) {&null::<PFNGLVALIDATEPROGRAMPROC>()} else {&self.validateprogram}})
			.field("vertexattrib1d", unsafe{if transmute::<_, *const c_void>(self.vertexattrib1d) == (dummy_pfnglvertexattrib1dproc as *const c_void) {&null::<PFNGLVERTEXATTRIB1DPROC>()} else {&self.vertexattrib1d}})
			.field("vertexattrib1dv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib1dv) == (dummy_pfnglvertexattrib1dvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB1DVPROC>()} else {&self.vertexattrib1dv}})
			.field("vertexattrib1f", unsafe{if transmute::<_, *const c_void>(self.vertexattrib1f) == (dummy_pfnglvertexattrib1fproc as *const c_void) {&null::<PFNGLVERTEXATTRIB1FPROC>()} else {&self.vertexattrib1f}})
			.field("vertexattrib1fv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib1fv) == (dummy_pfnglvertexattrib1fvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB1FVPROC>()} else {&self.vertexattrib1fv}})
			.field("vertexattrib1s", unsafe{if transmute::<_, *const c_void>(self.vertexattrib1s) == (dummy_pfnglvertexattrib1sproc as *const c_void) {&null::<PFNGLVERTEXATTRIB1SPROC>()} else {&self.vertexattrib1s}})
			.field("vertexattrib1sv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib1sv) == (dummy_pfnglvertexattrib1svproc as *const c_void) {&null::<PFNGLVERTEXATTRIB1SVPROC>()} else {&self.vertexattrib1sv}})
			.field("vertexattrib2d", unsafe{if transmute::<_, *const c_void>(self.vertexattrib2d) == (dummy_pfnglvertexattrib2dproc as *const c_void) {&null::<PFNGLVERTEXATTRIB2DPROC>()} else {&self.vertexattrib2d}})
			.field("vertexattrib2dv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib2dv) == (dummy_pfnglvertexattrib2dvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB2DVPROC>()} else {&self.vertexattrib2dv}})
			.field("vertexattrib2f", unsafe{if transmute::<_, *const c_void>(self.vertexattrib2f) == (dummy_pfnglvertexattrib2fproc as *const c_void) {&null::<PFNGLVERTEXATTRIB2FPROC>()} else {&self.vertexattrib2f}})
			.field("vertexattrib2fv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib2fv) == (dummy_pfnglvertexattrib2fvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB2FVPROC>()} else {&self.vertexattrib2fv}})
			.field("vertexattrib2s", unsafe{if transmute::<_, *const c_void>(self.vertexattrib2s) == (dummy_pfnglvertexattrib2sproc as *const c_void) {&null::<PFNGLVERTEXATTRIB2SPROC>()} else {&self.vertexattrib2s}})
			.field("vertexattrib2sv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib2sv) == (dummy_pfnglvertexattrib2svproc as *const c_void) {&null::<PFNGLVERTEXATTRIB2SVPROC>()} else {&self.vertexattrib2sv}})
			.field("vertexattrib3d", unsafe{if transmute::<_, *const c_void>(self.vertexattrib3d) == (dummy_pfnglvertexattrib3dproc as *const c_void) {&null::<PFNGLVERTEXATTRIB3DPROC>()} else {&self.vertexattrib3d}})
			.field("vertexattrib3dv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib3dv) == (dummy_pfnglvertexattrib3dvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB3DVPROC>()} else {&self.vertexattrib3dv}})
			.field("vertexattrib3f", unsafe{if transmute::<_, *const c_void>(self.vertexattrib3f) == (dummy_pfnglvertexattrib3fproc as *const c_void) {&null::<PFNGLVERTEXATTRIB3FPROC>()} else {&self.vertexattrib3f}})
			.field("vertexattrib3fv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib3fv) == (dummy_pfnglvertexattrib3fvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB3FVPROC>()} else {&self.vertexattrib3fv}})
			.field("vertexattrib3s", unsafe{if transmute::<_, *const c_void>(self.vertexattrib3s) == (dummy_pfnglvertexattrib3sproc as *const c_void) {&null::<PFNGLVERTEXATTRIB3SPROC>()} else {&self.vertexattrib3s}})
			.field("vertexattrib3sv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib3sv) == (dummy_pfnglvertexattrib3svproc as *const c_void) {&null::<PFNGLVERTEXATTRIB3SVPROC>()} else {&self.vertexattrib3sv}})
			.field("vertexattrib4nbv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4nbv) == (dummy_pfnglvertexattrib4nbvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4NBVPROC>()} else {&self.vertexattrib4nbv}})
			.field("vertexattrib4niv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4niv) == (dummy_pfnglvertexattrib4nivproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4NIVPROC>()} else {&self.vertexattrib4niv}})
			.field("vertexattrib4nsv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4nsv) == (dummy_pfnglvertexattrib4nsvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4NSVPROC>()} else {&self.vertexattrib4nsv}})
			.field("vertexattrib4nub", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4nub) == (dummy_pfnglvertexattrib4nubproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4NUBPROC>()} else {&self.vertexattrib4nub}})
			.field("vertexattrib4nubv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4nubv) == (dummy_pfnglvertexattrib4nubvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4NUBVPROC>()} else {&self.vertexattrib4nubv}})
			.field("vertexattrib4nuiv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4nuiv) == (dummy_pfnglvertexattrib4nuivproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4NUIVPROC>()} else {&self.vertexattrib4nuiv}})
			.field("vertexattrib4nusv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4nusv) == (dummy_pfnglvertexattrib4nusvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4NUSVPROC>()} else {&self.vertexattrib4nusv}})
			.field("vertexattrib4bv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4bv) == (dummy_pfnglvertexattrib4bvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4BVPROC>()} else {&self.vertexattrib4bv}})
			.field("vertexattrib4d", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4d) == (dummy_pfnglvertexattrib4dproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4DPROC>()} else {&self.vertexattrib4d}})
			.field("vertexattrib4dv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4dv) == (dummy_pfnglvertexattrib4dvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4DVPROC>()} else {&self.vertexattrib4dv}})
			.field("vertexattrib4f", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4f) == (dummy_pfnglvertexattrib4fproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4FPROC>()} else {&self.vertexattrib4f}})
			.field("vertexattrib4fv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4fv) == (dummy_pfnglvertexattrib4fvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4FVPROC>()} else {&self.vertexattrib4fv}})
			.field("vertexattrib4iv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4iv) == (dummy_pfnglvertexattrib4ivproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4IVPROC>()} else {&self.vertexattrib4iv}})
			.field("vertexattrib4s", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4s) == (dummy_pfnglvertexattrib4sproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4SPROC>()} else {&self.vertexattrib4s}})
			.field("vertexattrib4sv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4sv) == (dummy_pfnglvertexattrib4svproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4SVPROC>()} else {&self.vertexattrib4sv}})
			.field("vertexattrib4ubv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4ubv) == (dummy_pfnglvertexattrib4ubvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4UBVPROC>()} else {&self.vertexattrib4ubv}})
			.field("vertexattrib4uiv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4uiv) == (dummy_pfnglvertexattrib4uivproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4UIVPROC>()} else {&self.vertexattrib4uiv}})
			.field("vertexattrib4usv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4usv) == (dummy_pfnglvertexattrib4usvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4USVPROC>()} else {&self.vertexattrib4usv}})
			.field("vertexattribpointer", unsafe{if transmute::<_, *const c_void>(self.vertexattribpointer) == (dummy_pfnglvertexattribpointerproc as *const c_void) {&null::<PFNGLVERTEXATTRIBPOINTERPROC>()} else {&self.vertexattribpointer}})
			.finish()
		} else {
			f.debug_struct("Version20")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

/// The prototype to the OpenGL function `UniformMatrix2x3fv`
type PFNGLUNIFORMMATRIX2X3FVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat);

/// The prototype to the OpenGL function `UniformMatrix3x2fv`
type PFNGLUNIFORMMATRIX3X2FVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat);

/// The prototype to the OpenGL function `UniformMatrix2x4fv`
type PFNGLUNIFORMMATRIX2X4FVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat);

/// The prototype to the OpenGL function `UniformMatrix4x2fv`
type PFNGLUNIFORMMATRIX4X2FVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat);

/// The prototype to the OpenGL function `UniformMatrix3x4fv`
type PFNGLUNIFORMMATRIX3X4FVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat);

/// The prototype to the OpenGL function `UniformMatrix4x3fv`
type PFNGLUNIFORMMATRIX4X3FVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat);

/// The dummy function of `UniformMatrix2x3fv()`
extern "system" fn dummy_pfngluniformmatrix2x3fvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniformMatrix2x3fv()` is null.")
}

/// The dummy function of `UniformMatrix3x2fv()`
extern "system" fn dummy_pfngluniformmatrix3x2fvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniformMatrix3x2fv()` is null.")
}

/// The dummy function of `UniformMatrix2x4fv()`
extern "system" fn dummy_pfngluniformmatrix2x4fvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniformMatrix2x4fv()` is null.")
}

/// The dummy function of `UniformMatrix4x2fv()`
extern "system" fn dummy_pfngluniformmatrix4x2fvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniformMatrix4x2fv()` is null.")
}

/// The dummy function of `UniformMatrix3x4fv()`
extern "system" fn dummy_pfngluniformmatrix3x4fvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniformMatrix3x4fv()` is null.")
}

/// The dummy function of `UniformMatrix4x3fv()`
extern "system" fn dummy_pfngluniformmatrix4x3fvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniformMatrix4x3fv()` is null.")
}
/// Constant value defined from OpenGL 2.1
pub const GL_PIXEL_PACK_BUFFER: GLenum = 0x88EB;

/// Constant value defined from OpenGL 2.1
pub const GL_PIXEL_UNPACK_BUFFER: GLenum = 0x88EC;

/// Constant value defined from OpenGL 2.1
pub const GL_PIXEL_PACK_BUFFER_BINDING: GLenum = 0x88ED;

/// Constant value defined from OpenGL 2.1
pub const GL_PIXEL_UNPACK_BUFFER_BINDING: GLenum = 0x88EF;

/// Constant value defined from OpenGL 2.1
pub const GL_FLOAT_MAT2x3: GLenum = 0x8B65;

/// Constant value defined from OpenGL 2.1
pub const GL_FLOAT_MAT2x4: GLenum = 0x8B66;

/// Constant value defined from OpenGL 2.1
pub const GL_FLOAT_MAT3x2: GLenum = 0x8B67;

/// Constant value defined from OpenGL 2.1
pub const GL_FLOAT_MAT3x4: GLenum = 0x8B68;

/// Constant value defined from OpenGL 2.1
pub const GL_FLOAT_MAT4x2: GLenum = 0x8B69;

/// Constant value defined from OpenGL 2.1
pub const GL_FLOAT_MAT4x3: GLenum = 0x8B6A;

/// Constant value defined from OpenGL 2.1
pub const GL_SRGB: GLenum = 0x8C40;

/// Constant value defined from OpenGL 2.1
pub const GL_SRGB8: GLenum = 0x8C41;

/// Constant value defined from OpenGL 2.1
pub const GL_SRGB_ALPHA: GLenum = 0x8C42;

/// Constant value defined from OpenGL 2.1
pub const GL_SRGB8_ALPHA8: GLenum = 0x8C43;

/// Constant value defined from OpenGL 2.1
pub const GL_COMPRESSED_SRGB: GLenum = 0x8C48;

/// Constant value defined from OpenGL 2.1
pub const GL_COMPRESSED_SRGB_ALPHA: GLenum = 0x8C49;

/// Constant value defined from OpenGL 2.1
pub const GL_CURRENT_RASTER_SECONDARY_COLOR: GLenum = 0x845F;

/// Constant value defined from OpenGL 2.1
pub const GL_SLUMINANCE_ALPHA: GLenum = 0x8C44;

/// Constant value defined from OpenGL 2.1
pub const GL_SLUMINANCE8_ALPHA8: GLenum = 0x8C45;

/// Constant value defined from OpenGL 2.1
pub const GL_SLUMINANCE: GLenum = 0x8C46;

/// Constant value defined from OpenGL 2.1
pub const GL_SLUMINANCE8: GLenum = 0x8C47;

/// Constant value defined from OpenGL 2.1
pub const GL_COMPRESSED_SLUMINANCE: GLenum = 0x8C4A;

/// Constant value defined from OpenGL 2.1
pub const GL_COMPRESSED_SLUMINANCE_ALPHA: GLenum = 0x8C4B;

/// Functions from OpenGL version 2.1
pub trait GL_2_1 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	fn glGetError(&self) -> GLenum;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix2x3fv.xhtml>
	fn glUniformMatrix2x3fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix3x2fv.xhtml>
	fn glUniformMatrix3x2fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix2x4fv.xhtml>
	fn glUniformMatrix2x4fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix4x2fv.xhtml>
	fn glUniformMatrix4x2fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix3x4fv.xhtml>
	fn glUniformMatrix3x4fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix4x3fv.xhtml>
	fn glUniformMatrix4x3fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;
}
/// Functions from OpenGL version 2.1
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version21 {
	/// Is OpenGL version 2.1 available
	available: bool,

	/// The function pointer to `glGetError()`
	pub geterror: PFNGLGETERRORPROC,

	/// The function pointer to `glUniformMatrix2x3fv()`
	pub uniformmatrix2x3fv: PFNGLUNIFORMMATRIX2X3FVPROC,

	/// The function pointer to `glUniformMatrix3x2fv()`
	pub uniformmatrix3x2fv: PFNGLUNIFORMMATRIX3X2FVPROC,

	/// The function pointer to `glUniformMatrix2x4fv()`
	pub uniformmatrix2x4fv: PFNGLUNIFORMMATRIX2X4FVPROC,

	/// The function pointer to `glUniformMatrix4x2fv()`
	pub uniformmatrix4x2fv: PFNGLUNIFORMMATRIX4X2FVPROC,

	/// The function pointer to `glUniformMatrix3x4fv()`
	pub uniformmatrix3x4fv: PFNGLUNIFORMMATRIX3X4FVPROC,

	/// The function pointer to `glUniformMatrix4x3fv()`
	pub uniformmatrix4x3fv: PFNGLUNIFORMMATRIX4X3FVPROC,
}

impl GL_2_1 for Version21 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix2x3fv.xhtml>
	#[inline(always)]
	fn glUniformMatrix2x3fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix2x3fv", catch_unwind(||(self.uniformmatrix2x3fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2x3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix3x2fv.xhtml>
	#[inline(always)]
	fn glUniformMatrix3x2fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix3x2fv", catch_unwind(||(self.uniformmatrix3x2fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3x2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix2x4fv.xhtml>
	#[inline(always)]
	fn glUniformMatrix2x4fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix2x4fv", catch_unwind(||(self.uniformmatrix2x4fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2x4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix4x2fv.xhtml>
	#[inline(always)]
	fn glUniformMatrix4x2fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix4x2fv", catch_unwind(||(self.uniformmatrix4x2fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4x2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix3x4fv.xhtml>
	#[inline(always)]
	fn glUniformMatrix3x4fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix3x4fv", catch_unwind(||(self.uniformmatrix3x4fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3x4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix4x3fv.xhtml>
	#[inline(always)]
	fn glUniformMatrix4x3fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix4x3fv", catch_unwind(||(self.uniformmatrix4x3fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4x3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version21 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (2, 1, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			uniformmatrix2x3fv: {let proc = get_proc_address("glUniformMatrix2x3fv"); if proc == null() {dummy_pfngluniformmatrix2x3fvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix3x2fv: {let proc = get_proc_address("glUniformMatrix3x2fv"); if proc == null() {dummy_pfngluniformmatrix3x2fvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix2x4fv: {let proc = get_proc_address("glUniformMatrix2x4fv"); if proc == null() {dummy_pfngluniformmatrix2x4fvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix4x2fv: {let proc = get_proc_address("glUniformMatrix4x2fv"); if proc == null() {dummy_pfngluniformmatrix4x2fvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix3x4fv: {let proc = get_proc_address("glUniformMatrix3x4fv"); if proc == null() {dummy_pfngluniformmatrix3x4fvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix4x3fv: {let proc = get_proc_address("glUniformMatrix4x3fv"); if proc == null() {dummy_pfngluniformmatrix4x3fvproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version21 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			uniformmatrix2x3fv: dummy_pfngluniformmatrix2x3fvproc,
			uniformmatrix3x2fv: dummy_pfngluniformmatrix3x2fvproc,
			uniformmatrix2x4fv: dummy_pfngluniformmatrix2x4fvproc,
			uniformmatrix4x2fv: dummy_pfngluniformmatrix4x2fvproc,
			uniformmatrix3x4fv: dummy_pfngluniformmatrix3x4fvproc,
			uniformmatrix4x3fv: dummy_pfngluniformmatrix4x3fvproc,
		}
	}
}
impl Debug for Version21 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version21")
			.field("available", &self.available)
			.field("uniformmatrix2x3fv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix2x3fv) == (dummy_pfngluniformmatrix2x3fvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX2X3FVPROC>()} else {&self.uniformmatrix2x3fv}})
			.field("uniformmatrix3x2fv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix3x2fv) == (dummy_pfngluniformmatrix3x2fvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX3X2FVPROC>()} else {&self.uniformmatrix3x2fv}})
			.field("uniformmatrix2x4fv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix2x4fv) == (dummy_pfngluniformmatrix2x4fvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX2X4FVPROC>()} else {&self.uniformmatrix2x4fv}})
			.field("uniformmatrix4x2fv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix4x2fv) == (dummy_pfngluniformmatrix4x2fvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX4X2FVPROC>()} else {&self.uniformmatrix4x2fv}})
			.field("uniformmatrix3x4fv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix3x4fv) == (dummy_pfngluniformmatrix3x4fvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX3X4FVPROC>()} else {&self.uniformmatrix3x4fv}})
			.field("uniformmatrix4x3fv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix4x3fv) == (dummy_pfngluniformmatrix4x3fvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX4X3FVPROC>()} else {&self.uniformmatrix4x3fv}})
			.finish()
		} else {
			f.debug_struct("Version21")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

/// Alias to `khronos_uint16_t`
pub type GLhalf = khronos_uint16_t;

/// The prototype to the OpenGL function `ColorMaski`
type PFNGLCOLORMASKIPROC = extern "system" fn(GLuint, GLboolean, GLboolean, GLboolean, GLboolean);

/// The prototype to the OpenGL function `GetBooleani_v`
type PFNGLGETBOOLEANI_VPROC = extern "system" fn(GLenum, GLuint, *mut GLboolean);

/// The prototype to the OpenGL function `GetIntegeri_v`
type PFNGLGETINTEGERI_VPROC = extern "system" fn(GLenum, GLuint, *mut GLint);

/// The prototype to the OpenGL function `Enablei`
type PFNGLENABLEIPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `Disablei`
type PFNGLDISABLEIPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `IsEnabledi`
type PFNGLISENABLEDIPROC = extern "system" fn(GLenum, GLuint) -> GLboolean;

/// The prototype to the OpenGL function `BeginTransformFeedback`
type PFNGLBEGINTRANSFORMFEEDBACKPROC = extern "system" fn(GLenum);

/// The prototype to the OpenGL function `EndTransformFeedback`
type PFNGLENDTRANSFORMFEEDBACKPROC = extern "system" fn();

/// The prototype to the OpenGL function `BindBufferRange`
type PFNGLBINDBUFFERRANGEPROC = extern "system" fn(GLenum, GLuint, GLuint, GLintptr, GLsizeiptr);

/// The prototype to the OpenGL function `BindBufferBase`
type PFNGLBINDBUFFERBASEPROC = extern "system" fn(GLenum, GLuint, GLuint);

/// The prototype to the OpenGL function `TransformFeedbackVaryings`
type PFNGLTRANSFORMFEEDBACKVARYINGSPROC = extern "system" fn(GLuint, GLsizei, *const *const GLchar, GLenum);

/// The prototype to the OpenGL function `GetTransformFeedbackVarying`
type PFNGLGETTRANSFORMFEEDBACKVARYINGPROC = extern "system" fn(GLuint, GLuint, GLsizei, *mut GLsizei, *mut GLsizei, *mut GLenum, *mut GLchar);

/// The prototype to the OpenGL function `ClampColor`
type PFNGLCLAMPCOLORPROC = extern "system" fn(GLenum, GLenum);

/// The prototype to the OpenGL function `BeginConditionalRender`
type PFNGLBEGINCONDITIONALRENDERPROC = extern "system" fn(GLuint, GLenum);

/// The prototype to the OpenGL function `EndConditionalRender`
type PFNGLENDCONDITIONALRENDERPROC = extern "system" fn();

/// The prototype to the OpenGL function `VertexAttribIPointer`
type PFNGLVERTEXATTRIBIPOINTERPROC = extern "system" fn(GLuint, GLint, GLenum, GLsizei, *const c_void);

/// The prototype to the OpenGL function `GetVertexAttribIiv`
type PFNGLGETVERTEXATTRIBIIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetVertexAttribIuiv`
type PFNGLGETVERTEXATTRIBIUIVPROC = extern "system" fn(GLuint, GLenum, *mut GLuint);

/// The prototype to the OpenGL function `VertexAttribI1i`
type PFNGLVERTEXATTRIBI1IPROC = extern "system" fn(GLuint, GLint);

/// The prototype to the OpenGL function `VertexAttribI2i`
type PFNGLVERTEXATTRIBI2IPROC = extern "system" fn(GLuint, GLint, GLint);

/// The prototype to the OpenGL function `VertexAttribI3i`
type PFNGLVERTEXATTRIBI3IPROC = extern "system" fn(GLuint, GLint, GLint, GLint);

/// The prototype to the OpenGL function `VertexAttribI4i`
type PFNGLVERTEXATTRIBI4IPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint);

/// The prototype to the OpenGL function `VertexAttribI1ui`
type PFNGLVERTEXATTRIBI1UIPROC = extern "system" fn(GLuint, GLuint);

/// The prototype to the OpenGL function `VertexAttribI2ui`
type PFNGLVERTEXATTRIBI2UIPROC = extern "system" fn(GLuint, GLuint, GLuint);

/// The prototype to the OpenGL function `VertexAttribI3ui`
type PFNGLVERTEXATTRIBI3UIPROC = extern "system" fn(GLuint, GLuint, GLuint, GLuint);

/// The prototype to the OpenGL function `VertexAttribI4ui`
type PFNGLVERTEXATTRIBI4UIPROC = extern "system" fn(GLuint, GLuint, GLuint, GLuint, GLuint);

/// The prototype to the OpenGL function `VertexAttribI1iv`
type PFNGLVERTEXATTRIBI1IVPROC = extern "system" fn(GLuint, *const GLint);

/// The prototype to the OpenGL function `VertexAttribI2iv`
type PFNGLVERTEXATTRIBI2IVPROC = extern "system" fn(GLuint, *const GLint);

/// The prototype to the OpenGL function `VertexAttribI3iv`
type PFNGLVERTEXATTRIBI3IVPROC = extern "system" fn(GLuint, *const GLint);

/// The prototype to the OpenGL function `VertexAttribI4iv`
type PFNGLVERTEXATTRIBI4IVPROC = extern "system" fn(GLuint, *const GLint);

/// The prototype to the OpenGL function `VertexAttribI1uiv`
type PFNGLVERTEXATTRIBI1UIVPROC = extern "system" fn(GLuint, *const GLuint);

/// The prototype to the OpenGL function `VertexAttribI2uiv`
type PFNGLVERTEXATTRIBI2UIVPROC = extern "system" fn(GLuint, *const GLuint);

/// The prototype to the OpenGL function `VertexAttribI3uiv`
type PFNGLVERTEXATTRIBI3UIVPROC = extern "system" fn(GLuint, *const GLuint);

/// The prototype to the OpenGL function `VertexAttribI4uiv`
type PFNGLVERTEXATTRIBI4UIVPROC = extern "system" fn(GLuint, *const GLuint);

/// The prototype to the OpenGL function `VertexAttribI4bv`
type PFNGLVERTEXATTRIBI4BVPROC = extern "system" fn(GLuint, *const GLbyte);

/// The prototype to the OpenGL function `VertexAttribI4sv`
type PFNGLVERTEXATTRIBI4SVPROC = extern "system" fn(GLuint, *const GLshort);

/// The prototype to the OpenGL function `VertexAttribI4ubv`
type PFNGLVERTEXATTRIBI4UBVPROC = extern "system" fn(GLuint, *const GLubyte);

/// The prototype to the OpenGL function `VertexAttribI4usv`
type PFNGLVERTEXATTRIBI4USVPROC = extern "system" fn(GLuint, *const GLushort);

/// The prototype to the OpenGL function `GetUniformuiv`
type PFNGLGETUNIFORMUIVPROC = extern "system" fn(GLuint, GLint, *mut GLuint);

/// The prototype to the OpenGL function `BindFragDataLocation`
type PFNGLBINDFRAGDATALOCATIONPROC = extern "system" fn(GLuint, GLuint, *const GLchar);

/// The prototype to the OpenGL function `GetFragDataLocation`
type PFNGLGETFRAGDATALOCATIONPROC = extern "system" fn(GLuint, *const GLchar) -> GLint;

/// The prototype to the OpenGL function `Uniform1ui`
type PFNGLUNIFORM1UIPROC = extern "system" fn(GLint, GLuint);

/// The prototype to the OpenGL function `Uniform2ui`
type PFNGLUNIFORM2UIPROC = extern "system" fn(GLint, GLuint, GLuint);

/// The prototype to the OpenGL function `Uniform3ui`
type PFNGLUNIFORM3UIPROC = extern "system" fn(GLint, GLuint, GLuint, GLuint);

/// The prototype to the OpenGL function `Uniform4ui`
type PFNGLUNIFORM4UIPROC = extern "system" fn(GLint, GLuint, GLuint, GLuint, GLuint);

/// The prototype to the OpenGL function `Uniform1uiv`
type PFNGLUNIFORM1UIVPROC = extern "system" fn(GLint, GLsizei, *const GLuint);

/// The prototype to the OpenGL function `Uniform2uiv`
type PFNGLUNIFORM2UIVPROC = extern "system" fn(GLint, GLsizei, *const GLuint);

/// The prototype to the OpenGL function `Uniform3uiv`
type PFNGLUNIFORM3UIVPROC = extern "system" fn(GLint, GLsizei, *const GLuint);

/// The prototype to the OpenGL function `Uniform4uiv`
type PFNGLUNIFORM4UIVPROC = extern "system" fn(GLint, GLsizei, *const GLuint);

/// The prototype to the OpenGL function `TexParameterIiv`
type PFNGLTEXPARAMETERIIVPROC = extern "system" fn(GLenum, GLenum, *const GLint);

/// The prototype to the OpenGL function `TexParameterIuiv`
type PFNGLTEXPARAMETERIUIVPROC = extern "system" fn(GLenum, GLenum, *const GLuint);

/// The prototype to the OpenGL function `GetTexParameterIiv`
type PFNGLGETTEXPARAMETERIIVPROC = extern "system" fn(GLenum, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetTexParameterIuiv`
type PFNGLGETTEXPARAMETERIUIVPROC = extern "system" fn(GLenum, GLenum, *mut GLuint);

/// The prototype to the OpenGL function `ClearBufferiv`
type PFNGLCLEARBUFFERIVPROC = extern "system" fn(GLenum, GLint, *const GLint);

/// The prototype to the OpenGL function `ClearBufferuiv`
type PFNGLCLEARBUFFERUIVPROC = extern "system" fn(GLenum, GLint, *const GLuint);

/// The prototype to the OpenGL function `ClearBufferfv`
type PFNGLCLEARBUFFERFVPROC = extern "system" fn(GLenum, GLint, *const GLfloat);

/// The prototype to the OpenGL function `ClearBufferfi`
type PFNGLCLEARBUFFERFIPROC = extern "system" fn(GLenum, GLint, GLfloat, GLint);

/// The prototype to the OpenGL function `GetStringi`
type PFNGLGETSTRINGIPROC = extern "system" fn(GLenum, GLuint) -> *const GLubyte;

/// The prototype to the OpenGL function `IsRenderbuffer`
type PFNGLISRENDERBUFFERPROC = extern "system" fn(GLuint) -> GLboolean;

/// The prototype to the OpenGL function `BindRenderbuffer`
type PFNGLBINDRENDERBUFFERPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `DeleteRenderbuffers`
type PFNGLDELETERENDERBUFFERSPROC = extern "system" fn(GLsizei, *const GLuint);

/// The prototype to the OpenGL function `GenRenderbuffers`
type PFNGLGENRENDERBUFFERSPROC = extern "system" fn(GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `RenderbufferStorage`
type PFNGLRENDERBUFFERSTORAGEPROC = extern "system" fn(GLenum, GLenum, GLsizei, GLsizei);

/// The prototype to the OpenGL function `GetRenderbufferParameteriv`
type PFNGLGETRENDERBUFFERPARAMETERIVPROC = extern "system" fn(GLenum, GLenum, *mut GLint);

/// The prototype to the OpenGL function `IsFramebuffer`
type PFNGLISFRAMEBUFFERPROC = extern "system" fn(GLuint) -> GLboolean;

/// The prototype to the OpenGL function `BindFramebuffer`
type PFNGLBINDFRAMEBUFFERPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `DeleteFramebuffers`
type PFNGLDELETEFRAMEBUFFERSPROC = extern "system" fn(GLsizei, *const GLuint);

/// The prototype to the OpenGL function `GenFramebuffers`
type PFNGLGENFRAMEBUFFERSPROC = extern "system" fn(GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `CheckFramebufferStatus`
type PFNGLCHECKFRAMEBUFFERSTATUSPROC = extern "system" fn(GLenum) -> GLenum;

/// The prototype to the OpenGL function `FramebufferTexture1D`
type PFNGLFRAMEBUFFERTEXTURE1DPROC = extern "system" fn(GLenum, GLenum, GLenum, GLuint, GLint);

/// The prototype to the OpenGL function `FramebufferTexture2D`
type PFNGLFRAMEBUFFERTEXTURE2DPROC = extern "system" fn(GLenum, GLenum, GLenum, GLuint, GLint);

/// The prototype to the OpenGL function `FramebufferTexture3D`
type PFNGLFRAMEBUFFERTEXTURE3DPROC = extern "system" fn(GLenum, GLenum, GLenum, GLuint, GLint, GLint);

/// The prototype to the OpenGL function `FramebufferRenderbuffer`
type PFNGLFRAMEBUFFERRENDERBUFFERPROC = extern "system" fn(GLenum, GLenum, GLenum, GLuint);

/// The prototype to the OpenGL function `GetFramebufferAttachmentParameteriv`
type PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC = extern "system" fn(GLenum, GLenum, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GenerateMipmap`
type PFNGLGENERATEMIPMAPPROC = extern "system" fn(GLenum);

/// The prototype to the OpenGL function `BlitFramebuffer`
type PFNGLBLITFRAMEBUFFERPROC = extern "system" fn(GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLbitfield, GLenum);

/// The prototype to the OpenGL function `RenderbufferStorageMultisample`
type PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC = extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei);

/// The prototype to the OpenGL function `FramebufferTextureLayer`
type PFNGLFRAMEBUFFERTEXTURELAYERPROC = extern "system" fn(GLenum, GLenum, GLuint, GLint, GLint);

/// The prototype to the OpenGL function `MapBufferRange`
type PFNGLMAPBUFFERRANGEPROC = extern "system" fn(GLenum, GLintptr, GLsizeiptr, GLbitfield) -> *mut c_void;

/// The prototype to the OpenGL function `FlushMappedBufferRange`
type PFNGLFLUSHMAPPEDBUFFERRANGEPROC = extern "system" fn(GLenum, GLintptr, GLsizeiptr);

/// The prototype to the OpenGL function `BindVertexArray`
type PFNGLBINDVERTEXARRAYPROC = extern "system" fn(GLuint);

/// The prototype to the OpenGL function `DeleteVertexArrays`
type PFNGLDELETEVERTEXARRAYSPROC = extern "system" fn(GLsizei, *const GLuint);

/// The prototype to the OpenGL function `GenVertexArrays`
type PFNGLGENVERTEXARRAYSPROC = extern "system" fn(GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `IsVertexArray`
type PFNGLISVERTEXARRAYPROC = extern "system" fn(GLuint) -> GLboolean;

/// The dummy function of `ColorMaski()`
extern "system" fn dummy_pfnglcolormaskiproc (_: GLuint, _: GLboolean, _: GLboolean, _: GLboolean, _: GLboolean) {
	panic!("OpenGL function pointer `glColorMaski()` is null.")
}

/// The dummy function of `GetBooleani_v()`
extern "system" fn dummy_pfnglgetbooleani_vproc (_: GLenum, _: GLuint, _: *mut GLboolean) {
	panic!("OpenGL function pointer `glGetBooleani_v()` is null.")
}

/// The dummy function of `GetIntegeri_v()`
extern "system" fn dummy_pfnglgetintegeri_vproc (_: GLenum, _: GLuint, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetIntegeri_v()` is null.")
}

/// The dummy function of `Enablei()`
extern "system" fn dummy_pfnglenableiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glEnablei()` is null.")
}

/// The dummy function of `Disablei()`
extern "system" fn dummy_pfngldisableiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glDisablei()` is null.")
}

/// The dummy function of `IsEnabledi()`
extern "system" fn dummy_pfnglisenablediproc (_: GLenum, _: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsEnabledi()` is null.")
}

/// The dummy function of `BeginTransformFeedback()`
extern "system" fn dummy_pfnglbegintransformfeedbackproc (_: GLenum) {
	panic!("OpenGL function pointer `glBeginTransformFeedback()` is null.")
}

/// The dummy function of `EndTransformFeedback()`
extern "system" fn dummy_pfnglendtransformfeedbackproc () {
	panic!("OpenGL function pointer `glEndTransformFeedback()` is null.")
}

/// The dummy function of `BindBufferRange()`
extern "system" fn dummy_pfnglbindbufferrangeproc (_: GLenum, _: GLuint, _: GLuint, _: GLintptr, _: GLsizeiptr) {
	panic!("OpenGL function pointer `glBindBufferRange()` is null.")
}

/// The dummy function of `BindBufferBase()`
extern "system" fn dummy_pfnglbindbufferbaseproc (_: GLenum, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glBindBufferBase()` is null.")
}

/// The dummy function of `TransformFeedbackVaryings()`
extern "system" fn dummy_pfngltransformfeedbackvaryingsproc (_: GLuint, _: GLsizei, _: *const *const GLchar, _: GLenum) {
	panic!("OpenGL function pointer `glTransformFeedbackVaryings()` is null.")
}

/// The dummy function of `GetTransformFeedbackVarying()`
extern "system" fn dummy_pfnglgettransformfeedbackvaryingproc (_: GLuint, _: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLsizei, _: *mut GLenum, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetTransformFeedbackVarying()` is null.")
}

/// The dummy function of `ClampColor()`
extern "system" fn dummy_pfnglclampcolorproc (_: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glClampColor()` is null.")
}

/// The dummy function of `BeginConditionalRender()`
extern "system" fn dummy_pfnglbeginconditionalrenderproc (_: GLuint, _: GLenum) {
	panic!("OpenGL function pointer `glBeginConditionalRender()` is null.")
}

/// The dummy function of `EndConditionalRender()`
extern "system" fn dummy_pfnglendconditionalrenderproc () {
	panic!("OpenGL function pointer `glEndConditionalRender()` is null.")
}

/// The dummy function of `VertexAttribIPointer()`
extern "system" fn dummy_pfnglvertexattribipointerproc (_: GLuint, _: GLint, _: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glVertexAttribIPointer()` is null.")
}

/// The dummy function of `GetVertexAttribIiv()`
extern "system" fn dummy_pfnglgetvertexattribiivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetVertexAttribIiv()` is null.")
}

/// The dummy function of `GetVertexAttribIuiv()`
extern "system" fn dummy_pfnglgetvertexattribiuivproc (_: GLuint, _: GLenum, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetVertexAttribIuiv()` is null.")
}

/// The dummy function of `VertexAttribI1i()`
extern "system" fn dummy_pfnglvertexattribi1iproc (_: GLuint, _: GLint) {
	panic!("OpenGL function pointer `glVertexAttribI1i()` is null.")
}

/// The dummy function of `VertexAttribI2i()`
extern "system" fn dummy_pfnglvertexattribi2iproc (_: GLuint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glVertexAttribI2i()` is null.")
}

/// The dummy function of `VertexAttribI3i()`
extern "system" fn dummy_pfnglvertexattribi3iproc (_: GLuint, _: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glVertexAttribI3i()` is null.")
}

/// The dummy function of `VertexAttribI4i()`
extern "system" fn dummy_pfnglvertexattribi4iproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glVertexAttribI4i()` is null.")
}

/// The dummy function of `VertexAttribI1ui()`
extern "system" fn dummy_pfnglvertexattribi1uiproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribI1ui()` is null.")
}

/// The dummy function of `VertexAttribI2ui()`
extern "system" fn dummy_pfnglvertexattribi2uiproc (_: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribI2ui()` is null.")
}

/// The dummy function of `VertexAttribI3ui()`
extern "system" fn dummy_pfnglvertexattribi3uiproc (_: GLuint, _: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribI3ui()` is null.")
}

/// The dummy function of `VertexAttribI4ui()`
extern "system" fn dummy_pfnglvertexattribi4uiproc (_: GLuint, _: GLuint, _: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribI4ui()` is null.")
}

/// The dummy function of `VertexAttribI1iv()`
extern "system" fn dummy_pfnglvertexattribi1ivproc (_: GLuint, _: *const GLint) {
	panic!("OpenGL function pointer `glVertexAttribI1iv()` is null.")
}

/// The dummy function of `VertexAttribI2iv()`
extern "system" fn dummy_pfnglvertexattribi2ivproc (_: GLuint, _: *const GLint) {
	panic!("OpenGL function pointer `glVertexAttribI2iv()` is null.")
}

/// The dummy function of `VertexAttribI3iv()`
extern "system" fn dummy_pfnglvertexattribi3ivproc (_: GLuint, _: *const GLint) {
	panic!("OpenGL function pointer `glVertexAttribI3iv()` is null.")
}

/// The dummy function of `VertexAttribI4iv()`
extern "system" fn dummy_pfnglvertexattribi4ivproc (_: GLuint, _: *const GLint) {
	panic!("OpenGL function pointer `glVertexAttribI4iv()` is null.")
}

/// The dummy function of `VertexAttribI1uiv()`
extern "system" fn dummy_pfnglvertexattribi1uivproc (_: GLuint, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttribI1uiv()` is null.")
}

/// The dummy function of `VertexAttribI2uiv()`
extern "system" fn dummy_pfnglvertexattribi2uivproc (_: GLuint, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttribI2uiv()` is null.")
}

/// The dummy function of `VertexAttribI3uiv()`
extern "system" fn dummy_pfnglvertexattribi3uivproc (_: GLuint, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttribI3uiv()` is null.")
}

/// The dummy function of `VertexAttribI4uiv()`
extern "system" fn dummy_pfnglvertexattribi4uivproc (_: GLuint, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttribI4uiv()` is null.")
}

/// The dummy function of `VertexAttribI4bv()`
extern "system" fn dummy_pfnglvertexattribi4bvproc (_: GLuint, _: *const GLbyte) {
	panic!("OpenGL function pointer `glVertexAttribI4bv()` is null.")
}

/// The dummy function of `VertexAttribI4sv()`
extern "system" fn dummy_pfnglvertexattribi4svproc (_: GLuint, _: *const GLshort) {
	panic!("OpenGL function pointer `glVertexAttribI4sv()` is null.")
}

/// The dummy function of `VertexAttribI4ubv()`
extern "system" fn dummy_pfnglvertexattribi4ubvproc (_: GLuint, _: *const GLubyte) {
	panic!("OpenGL function pointer `glVertexAttribI4ubv()` is null.")
}

/// The dummy function of `VertexAttribI4usv()`
extern "system" fn dummy_pfnglvertexattribi4usvproc (_: GLuint, _: *const GLushort) {
	panic!("OpenGL function pointer `glVertexAttribI4usv()` is null.")
}

/// The dummy function of `GetUniformuiv()`
extern "system" fn dummy_pfnglgetuniformuivproc (_: GLuint, _: GLint, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetUniformuiv()` is null.")
}

/// The dummy function of `BindFragDataLocation()`
extern "system" fn dummy_pfnglbindfragdatalocationproc (_: GLuint, _: GLuint, _: *const GLchar) {
	panic!("OpenGL function pointer `glBindFragDataLocation()` is null.")
}

/// The dummy function of `GetFragDataLocation()`
extern "system" fn dummy_pfnglgetfragdatalocationproc (_: GLuint, _: *const GLchar) -> GLint {
	panic!("OpenGL function pointer `glGetFragDataLocation()` is null.")
}

/// The dummy function of `Uniform1ui()`
extern "system" fn dummy_pfngluniform1uiproc (_: GLint, _: GLuint) {
	panic!("OpenGL function pointer `glUniform1ui()` is null.")
}

/// The dummy function of `Uniform2ui()`
extern "system" fn dummy_pfngluniform2uiproc (_: GLint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glUniform2ui()` is null.")
}

/// The dummy function of `Uniform3ui()`
extern "system" fn dummy_pfngluniform3uiproc (_: GLint, _: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glUniform3ui()` is null.")
}

/// The dummy function of `Uniform4ui()`
extern "system" fn dummy_pfngluniform4uiproc (_: GLint, _: GLuint, _: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glUniform4ui()` is null.")
}

/// The dummy function of `Uniform1uiv()`
extern "system" fn dummy_pfngluniform1uivproc (_: GLint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glUniform1uiv()` is null.")
}

/// The dummy function of `Uniform2uiv()`
extern "system" fn dummy_pfngluniform2uivproc (_: GLint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glUniform2uiv()` is null.")
}

/// The dummy function of `Uniform3uiv()`
extern "system" fn dummy_pfngluniform3uivproc (_: GLint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glUniform3uiv()` is null.")
}

/// The dummy function of `Uniform4uiv()`
extern "system" fn dummy_pfngluniform4uivproc (_: GLint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glUniform4uiv()` is null.")
}

/// The dummy function of `TexParameterIiv()`
extern "system" fn dummy_pfngltexparameteriivproc (_: GLenum, _: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glTexParameterIiv()` is null.")
}

/// The dummy function of `TexParameterIuiv()`
extern "system" fn dummy_pfngltexparameteriuivproc (_: GLenum, _: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glTexParameterIuiv()` is null.")
}

/// The dummy function of `GetTexParameterIiv()`
extern "system" fn dummy_pfnglgettexparameteriivproc (_: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetTexParameterIiv()` is null.")
}

/// The dummy function of `GetTexParameterIuiv()`
extern "system" fn dummy_pfnglgettexparameteriuivproc (_: GLenum, _: GLenum, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetTexParameterIuiv()` is null.")
}

/// The dummy function of `ClearBufferiv()`
extern "system" fn dummy_pfnglclearbufferivproc (_: GLenum, _: GLint, _: *const GLint) {
	panic!("OpenGL function pointer `glClearBufferiv()` is null.")
}

/// The dummy function of `ClearBufferuiv()`
extern "system" fn dummy_pfnglclearbufferuivproc (_: GLenum, _: GLint, _: *const GLuint) {
	panic!("OpenGL function pointer `glClearBufferuiv()` is null.")
}

/// The dummy function of `ClearBufferfv()`
extern "system" fn dummy_pfnglclearbufferfvproc (_: GLenum, _: GLint, _: *const GLfloat) {
	panic!("OpenGL function pointer `glClearBufferfv()` is null.")
}

/// The dummy function of `ClearBufferfi()`
extern "system" fn dummy_pfnglclearbufferfiproc (_: GLenum, _: GLint, _: GLfloat, _: GLint) {
	panic!("OpenGL function pointer `glClearBufferfi()` is null.")
}

/// The dummy function of `GetStringi()`
extern "system" fn dummy_pfnglgetstringiproc (_: GLenum, _: GLuint) -> *const GLubyte {
	panic!("OpenGL function pointer `glGetStringi()` is null.")
}

/// The dummy function of `IsRenderbuffer()`
extern "system" fn dummy_pfnglisrenderbufferproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsRenderbuffer()` is null.")
}

/// The dummy function of `BindRenderbuffer()`
extern "system" fn dummy_pfnglbindrenderbufferproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glBindRenderbuffer()` is null.")
}

/// The dummy function of `DeleteRenderbuffers()`
extern "system" fn dummy_pfngldeleterenderbuffersproc (_: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glDeleteRenderbuffers()` is null.")
}

/// The dummy function of `GenRenderbuffers()`
extern "system" fn dummy_pfnglgenrenderbuffersproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGenRenderbuffers()` is null.")
}

/// The dummy function of `RenderbufferStorage()`
extern "system" fn dummy_pfnglrenderbufferstorageproc (_: GLenum, _: GLenum, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glRenderbufferStorage()` is null.")
}

/// The dummy function of `GetRenderbufferParameteriv()`
extern "system" fn dummy_pfnglgetrenderbufferparameterivproc (_: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetRenderbufferParameteriv()` is null.")
}

/// The dummy function of `IsFramebuffer()`
extern "system" fn dummy_pfnglisframebufferproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsFramebuffer()` is null.")
}

/// The dummy function of `BindFramebuffer()`
extern "system" fn dummy_pfnglbindframebufferproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glBindFramebuffer()` is null.")
}

/// The dummy function of `DeleteFramebuffers()`
extern "system" fn dummy_pfngldeleteframebuffersproc (_: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glDeleteFramebuffers()` is null.")
}

/// The dummy function of `GenFramebuffers()`
extern "system" fn dummy_pfnglgenframebuffersproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGenFramebuffers()` is null.")
}

/// The dummy function of `CheckFramebufferStatus()`
extern "system" fn dummy_pfnglcheckframebufferstatusproc (_: GLenum) -> GLenum {
	panic!("OpenGL function pointer `glCheckFramebufferStatus()` is null.")
}

/// The dummy function of `FramebufferTexture1D()`
extern "system" fn dummy_pfnglframebuffertexture1dproc (_: GLenum, _: GLenum, _: GLenum, _: GLuint, _: GLint) {
	panic!("OpenGL function pointer `glFramebufferTexture1D()` is null.")
}

/// The dummy function of `FramebufferTexture2D()`
extern "system" fn dummy_pfnglframebuffertexture2dproc (_: GLenum, _: GLenum, _: GLenum, _: GLuint, _: GLint) {
	panic!("OpenGL function pointer `glFramebufferTexture2D()` is null.")
}

/// The dummy function of `FramebufferTexture3D()`
extern "system" fn dummy_pfnglframebuffertexture3dproc (_: GLenum, _: GLenum, _: GLenum, _: GLuint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glFramebufferTexture3D()` is null.")
}

/// The dummy function of `FramebufferRenderbuffer()`
extern "system" fn dummy_pfnglframebufferrenderbufferproc (_: GLenum, _: GLenum, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glFramebufferRenderbuffer()` is null.")
}

/// The dummy function of `GetFramebufferAttachmentParameteriv()`
extern "system" fn dummy_pfnglgetframebufferattachmentparameterivproc (_: GLenum, _: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetFramebufferAttachmentParameteriv()` is null.")
}

/// The dummy function of `GenerateMipmap()`
extern "system" fn dummy_pfnglgeneratemipmapproc (_: GLenum) {
	panic!("OpenGL function pointer `glGenerateMipmap()` is null.")
}

/// The dummy function of `BlitFramebuffer()`
extern "system" fn dummy_pfnglblitframebufferproc (_: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLbitfield, _: GLenum) {
	panic!("OpenGL function pointer `glBlitFramebuffer()` is null.")
}

/// The dummy function of `RenderbufferStorageMultisample()`
extern "system" fn dummy_pfnglrenderbufferstoragemultisampleproc (_: GLenum, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glRenderbufferStorageMultisample()` is null.")
}

/// The dummy function of `FramebufferTextureLayer()`
extern "system" fn dummy_pfnglframebuffertexturelayerproc (_: GLenum, _: GLenum, _: GLuint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glFramebufferTextureLayer()` is null.")
}

/// The dummy function of `MapBufferRange()`
extern "system" fn dummy_pfnglmapbufferrangeproc (_: GLenum, _: GLintptr, _: GLsizeiptr, _: GLbitfield) -> *mut c_void {
	panic!("OpenGL function pointer `glMapBufferRange()` is null.")
}

/// The dummy function of `FlushMappedBufferRange()`
extern "system" fn dummy_pfnglflushmappedbufferrangeproc (_: GLenum, _: GLintptr, _: GLsizeiptr) {
	panic!("OpenGL function pointer `glFlushMappedBufferRange()` is null.")
}

/// The dummy function of `BindVertexArray()`
extern "system" fn dummy_pfnglbindvertexarrayproc (_: GLuint) {
	panic!("OpenGL function pointer `glBindVertexArray()` is null.")
}

/// The dummy function of `DeleteVertexArrays()`
extern "system" fn dummy_pfngldeletevertexarraysproc (_: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glDeleteVertexArrays()` is null.")
}

/// The dummy function of `GenVertexArrays()`
extern "system" fn dummy_pfnglgenvertexarraysproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGenVertexArrays()` is null.")
}

/// The dummy function of `IsVertexArray()`
extern "system" fn dummy_pfnglisvertexarrayproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsVertexArray()` is null.")
}
/// Constant value defined from OpenGL 3.0
pub const GL_COMPARE_REF_TO_TEXTURE: GLenum = 0x884E;

/// Constant value defined from OpenGL 3.0
pub const GL_CLIP_DISTANCE0: GLenum = 0x3000;

/// Constant value defined from OpenGL 3.0
pub const GL_CLIP_DISTANCE1: GLenum = 0x3001;

/// Constant value defined from OpenGL 3.0
pub const GL_CLIP_DISTANCE2: GLenum = 0x3002;

/// Constant value defined from OpenGL 3.0
pub const GL_CLIP_DISTANCE3: GLenum = 0x3003;

/// Constant value defined from OpenGL 3.0
pub const GL_CLIP_DISTANCE4: GLenum = 0x3004;

/// Constant value defined from OpenGL 3.0
pub const GL_CLIP_DISTANCE5: GLenum = 0x3005;

/// Constant value defined from OpenGL 3.0
pub const GL_CLIP_DISTANCE6: GLenum = 0x3006;

/// Constant value defined from OpenGL 3.0
pub const GL_CLIP_DISTANCE7: GLenum = 0x3007;

/// Constant value defined from OpenGL 3.0
pub const GL_MAX_CLIP_DISTANCES: GLenum = 0x0D32;

/// Constant value defined from OpenGL 3.0
pub const GL_MAJOR_VERSION: GLenum = 0x821B;

/// Constant value defined from OpenGL 3.0
pub const GL_MINOR_VERSION: GLenum = 0x821C;

/// Constant value defined from OpenGL 3.0
pub const GL_NUM_EXTENSIONS: GLenum = 0x821D;

/// Constant value defined from OpenGL 3.0
pub const GL_CONTEXT_FLAGS: GLenum = 0x821E;

/// Constant value defined from OpenGL 3.0
pub const GL_COMPRESSED_RED: GLenum = 0x8225;

/// Constant value defined from OpenGL 3.0
pub const GL_COMPRESSED_RG: GLenum = 0x8226;

/// Constant value defined from OpenGL 3.0
pub const GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT: GLbitfield = 0x00000001;

/// Constant value defined from OpenGL 3.0
pub const GL_RGBA32F: GLenum = 0x8814;

/// Constant value defined from OpenGL 3.0
pub const GL_RGB32F: GLenum = 0x8815;

/// Constant value defined from OpenGL 3.0
pub const GL_RGBA16F: GLenum = 0x881A;

/// Constant value defined from OpenGL 3.0
pub const GL_RGB16F: GLenum = 0x881B;

/// Constant value defined from OpenGL 3.0
pub const GL_VERTEX_ATTRIB_ARRAY_INTEGER: GLenum = 0x88FD;

/// Constant value defined from OpenGL 3.0
pub const GL_MAX_ARRAY_TEXTURE_LAYERS: GLenum = 0x88FF;

/// Constant value defined from OpenGL 3.0
pub const GL_MIN_PROGRAM_TEXEL_OFFSET: GLenum = 0x8904;

/// Constant value defined from OpenGL 3.0
pub const GL_MAX_PROGRAM_TEXEL_OFFSET: GLenum = 0x8905;

/// Constant value defined from OpenGL 3.0
pub const GL_CLAMP_READ_COLOR: GLenum = 0x891C;

/// Constant value defined from OpenGL 3.0
pub const GL_FIXED_ONLY: GLenum = 0x891D;

/// Constant value defined from OpenGL 3.0
pub const GL_MAX_VARYING_COMPONENTS: GLenum = 0x8B4B;

/// Constant value defined from OpenGL 3.0
pub const GL_TEXTURE_1D_ARRAY: GLenum = 0x8C18;

/// Constant value defined from OpenGL 3.0
pub const GL_PROXY_TEXTURE_1D_ARRAY: GLenum = 0x8C19;

/// Constant value defined from OpenGL 3.0
pub const GL_TEXTURE_2D_ARRAY: GLenum = 0x8C1A;

/// Constant value defined from OpenGL 3.0
pub const GL_PROXY_TEXTURE_2D_ARRAY: GLenum = 0x8C1B;

/// Constant value defined from OpenGL 3.0
pub const GL_TEXTURE_BINDING_1D_ARRAY: GLenum = 0x8C1C;

/// Constant value defined from OpenGL 3.0
pub const GL_TEXTURE_BINDING_2D_ARRAY: GLenum = 0x8C1D;

/// Constant value defined from OpenGL 3.0
pub const GL_R11F_G11F_B10F: GLenum = 0x8C3A;

/// Constant value defined from OpenGL 3.0
pub const GL_UNSIGNED_INT_10F_11F_11F_REV: GLenum = 0x8C3B;

/// Constant value defined from OpenGL 3.0
pub const GL_RGB9_E5: GLenum = 0x8C3D;

/// Constant value defined from OpenGL 3.0
pub const GL_UNSIGNED_INT_5_9_9_9_REV: GLenum = 0x8C3E;

/// Constant value defined from OpenGL 3.0
pub const GL_TEXTURE_SHARED_SIZE: GLenum = 0x8C3F;

/// Constant value defined from OpenGL 3.0
pub const GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: GLenum = 0x8C76;

/// Constant value defined from OpenGL 3.0
pub const GL_TRANSFORM_FEEDBACK_BUFFER_MODE: GLenum = 0x8C7F;

/// Constant value defined from OpenGL 3.0
pub const GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: GLenum = 0x8C80;

/// Constant value defined from OpenGL 3.0
pub const GL_TRANSFORM_FEEDBACK_VARYINGS: GLenum = 0x8C83;

/// Constant value defined from OpenGL 3.0
pub const GL_TRANSFORM_FEEDBACK_BUFFER_START: GLenum = 0x8C84;

/// Constant value defined from OpenGL 3.0
pub const GL_TRANSFORM_FEEDBACK_BUFFER_SIZE: GLenum = 0x8C85;

/// Constant value defined from OpenGL 3.0
pub const GL_PRIMITIVES_GENERATED: GLenum = 0x8C87;

/// Constant value defined from OpenGL 3.0
pub const GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: GLenum = 0x8C88;

/// Constant value defined from OpenGL 3.0
pub const GL_RASTERIZER_DISCARD: GLenum = 0x8C89;

/// Constant value defined from OpenGL 3.0
pub const GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: GLenum = 0x8C8A;

/// Constant value defined from OpenGL 3.0
pub const GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: GLenum = 0x8C8B;

/// Constant value defined from OpenGL 3.0
pub const GL_INTERLEAVED_ATTRIBS: GLenum = 0x8C8C;

/// Constant value defined from OpenGL 3.0
pub const GL_SEPARATE_ATTRIBS: GLenum = 0x8C8D;

/// Constant value defined from OpenGL 3.0
pub const GL_TRANSFORM_FEEDBACK_BUFFER: GLenum = 0x8C8E;

/// Constant value defined from OpenGL 3.0
pub const GL_TRANSFORM_FEEDBACK_BUFFER_BINDING: GLenum = 0x8C8F;

/// Constant value defined from OpenGL 3.0
pub const GL_RGBA32UI: GLenum = 0x8D70;

/// Constant value defined from OpenGL 3.0
pub const GL_RGB32UI: GLenum = 0x8D71;

/// Constant value defined from OpenGL 3.0
pub const GL_RGBA16UI: GLenum = 0x8D76;

/// Constant value defined from OpenGL 3.0
pub const GL_RGB16UI: GLenum = 0x8D77;

/// Constant value defined from OpenGL 3.0
pub const GL_RGBA8UI: GLenum = 0x8D7C;

/// Constant value defined from OpenGL 3.0
pub const GL_RGB8UI: GLenum = 0x8D7D;

/// Constant value defined from OpenGL 3.0
pub const GL_RGBA32I: GLenum = 0x8D82;

/// Constant value defined from OpenGL 3.0
pub const GL_RGB32I: GLenum = 0x8D83;

/// Constant value defined from OpenGL 3.0
pub const GL_RGBA16I: GLenum = 0x8D88;

/// Constant value defined from OpenGL 3.0
pub const GL_RGB16I: GLenum = 0x8D89;

/// Constant value defined from OpenGL 3.0
pub const GL_RGBA8I: GLenum = 0x8D8E;

/// Constant value defined from OpenGL 3.0
pub const GL_RGB8I: GLenum = 0x8D8F;

/// Constant value defined from OpenGL 3.0
pub const GL_RED_INTEGER: GLenum = 0x8D94;

/// Constant value defined from OpenGL 3.0
pub const GL_GREEN_INTEGER: GLenum = 0x8D95;

/// Constant value defined from OpenGL 3.0
pub const GL_BLUE_INTEGER: GLenum = 0x8D96;

/// Constant value defined from OpenGL 3.0
pub const GL_RGB_INTEGER: GLenum = 0x8D98;

/// Constant value defined from OpenGL 3.0
pub const GL_RGBA_INTEGER: GLenum = 0x8D99;

/// Constant value defined from OpenGL 3.0
pub const GL_BGR_INTEGER: GLenum = 0x8D9A;

/// Constant value defined from OpenGL 3.0
pub const GL_BGRA_INTEGER: GLenum = 0x8D9B;

/// Constant value defined from OpenGL 3.0
pub const GL_SAMPLER_1D_ARRAY: GLenum = 0x8DC0;

/// Constant value defined from OpenGL 3.0
pub const GL_SAMPLER_2D_ARRAY: GLenum = 0x8DC1;

/// Constant value defined from OpenGL 3.0
pub const GL_SAMPLER_1D_ARRAY_SHADOW: GLenum = 0x8DC3;

/// Constant value defined from OpenGL 3.0
pub const GL_SAMPLER_2D_ARRAY_SHADOW: GLenum = 0x8DC4;

/// Constant value defined from OpenGL 3.0
pub const GL_SAMPLER_CUBE_SHADOW: GLenum = 0x8DC5;

/// Constant value defined from OpenGL 3.0
pub const GL_UNSIGNED_INT_VEC2: GLenum = 0x8DC6;

/// Constant value defined from OpenGL 3.0
pub const GL_UNSIGNED_INT_VEC3: GLenum = 0x8DC7;

/// Constant value defined from OpenGL 3.0
pub const GL_UNSIGNED_INT_VEC4: GLenum = 0x8DC8;

/// Constant value defined from OpenGL 3.0
pub const GL_INT_SAMPLER_1D: GLenum = 0x8DC9;

/// Constant value defined from OpenGL 3.0
pub const GL_INT_SAMPLER_2D: GLenum = 0x8DCA;

/// Constant value defined from OpenGL 3.0
pub const GL_INT_SAMPLER_3D: GLenum = 0x8DCB;

/// Constant value defined from OpenGL 3.0
pub const GL_INT_SAMPLER_CUBE: GLenum = 0x8DCC;

/// Constant value defined from OpenGL 3.0
pub const GL_INT_SAMPLER_1D_ARRAY: GLenum = 0x8DCE;

/// Constant value defined from OpenGL 3.0
pub const GL_INT_SAMPLER_2D_ARRAY: GLenum = 0x8DCF;

/// Constant value defined from OpenGL 3.0
pub const GL_UNSIGNED_INT_SAMPLER_1D: GLenum = 0x8DD1;

/// Constant value defined from OpenGL 3.0
pub const GL_UNSIGNED_INT_SAMPLER_2D: GLenum = 0x8DD2;

/// Constant value defined from OpenGL 3.0
pub const GL_UNSIGNED_INT_SAMPLER_3D: GLenum = 0x8DD3;

/// Constant value defined from OpenGL 3.0
pub const GL_UNSIGNED_INT_SAMPLER_CUBE: GLenum = 0x8DD4;

/// Constant value defined from OpenGL 3.0
pub const GL_UNSIGNED_INT_SAMPLER_1D_ARRAY: GLenum = 0x8DD6;

/// Constant value defined from OpenGL 3.0
pub const GL_UNSIGNED_INT_SAMPLER_2D_ARRAY: GLenum = 0x8DD7;

/// Constant value defined from OpenGL 3.0
pub const GL_QUERY_WAIT: GLenum = 0x8E13;

/// Constant value defined from OpenGL 3.0
pub const GL_QUERY_NO_WAIT: GLenum = 0x8E14;

/// Constant value defined from OpenGL 3.0
pub const GL_QUERY_BY_REGION_WAIT: GLenum = 0x8E15;

/// Constant value defined from OpenGL 3.0
pub const GL_QUERY_BY_REGION_NO_WAIT: GLenum = 0x8E16;

/// Constant value defined from OpenGL 3.0
pub const GL_BUFFER_ACCESS_FLAGS: GLenum = 0x911F;

/// Constant value defined from OpenGL 3.0
pub const GL_BUFFER_MAP_LENGTH: GLenum = 0x9120;

/// Constant value defined from OpenGL 3.0
pub const GL_BUFFER_MAP_OFFSET: GLenum = 0x9121;

/// Constant value defined from OpenGL 3.0
pub const GL_DEPTH_COMPONENT32F: GLenum = 0x8CAC;

/// Constant value defined from OpenGL 3.0
pub const GL_DEPTH32F_STENCIL8: GLenum = 0x8CAD;

/// Constant value defined from OpenGL 3.0
pub const GL_FLOAT_32_UNSIGNED_INT_24_8_REV: GLenum = 0x8DAD;

/// Constant value defined from OpenGL 3.0
pub const GL_INVALID_FRAMEBUFFER_OPERATION: GLenum = 0x0506;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: GLenum = 0x8210;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: GLenum = 0x8211;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE: GLenum = 0x8212;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: GLenum = 0x8213;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: GLenum = 0x8214;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: GLenum = 0x8215;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: GLenum = 0x8216;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: GLenum = 0x8217;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_DEFAULT: GLenum = 0x8218;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_UNDEFINED: GLenum = 0x8219;

/// Constant value defined from OpenGL 3.0
pub const GL_DEPTH_STENCIL_ATTACHMENT: GLenum = 0x821A;

/// Constant value defined from OpenGL 3.0
pub const GL_MAX_RENDERBUFFER_SIZE: GLenum = 0x84E8;

/// Constant value defined from OpenGL 3.0
pub const GL_DEPTH_STENCIL: GLenum = 0x84F9;

/// Constant value defined from OpenGL 3.0
pub const GL_UNSIGNED_INT_24_8: GLenum = 0x84FA;

/// Constant value defined from OpenGL 3.0
pub const GL_DEPTH24_STENCIL8: GLenum = 0x88F0;

/// Constant value defined from OpenGL 3.0
pub const GL_TEXTURE_STENCIL_SIZE: GLenum = 0x88F1;

/// Constant value defined from OpenGL 3.0
pub const GL_TEXTURE_RED_TYPE: GLenum = 0x8C10;

/// Constant value defined from OpenGL 3.0
pub const GL_TEXTURE_GREEN_TYPE: GLenum = 0x8C11;

/// Constant value defined from OpenGL 3.0
pub const GL_TEXTURE_BLUE_TYPE: GLenum = 0x8C12;

/// Constant value defined from OpenGL 3.0
pub const GL_TEXTURE_ALPHA_TYPE: GLenum = 0x8C13;

/// Constant value defined from OpenGL 3.0
pub const GL_TEXTURE_DEPTH_TYPE: GLenum = 0x8C16;

/// Constant value defined from OpenGL 3.0
pub const GL_UNSIGNED_NORMALIZED: GLenum = 0x8C17;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_BINDING: GLenum = 0x8CA6;

/// Constant value defined from OpenGL 3.0
pub const GL_DRAW_FRAMEBUFFER_BINDING: GLenum = 0x8CA6;

/// Constant value defined from OpenGL 3.0
pub const GL_RENDERBUFFER_BINDING: GLenum = 0x8CA7;

/// Constant value defined from OpenGL 3.0
pub const GL_READ_FRAMEBUFFER: GLenum = 0x8CA8;

/// Constant value defined from OpenGL 3.0
pub const GL_DRAW_FRAMEBUFFER: GLenum = 0x8CA9;

/// Constant value defined from OpenGL 3.0
pub const GL_READ_FRAMEBUFFER_BINDING: GLenum = 0x8CAA;

/// Constant value defined from OpenGL 3.0
pub const GL_RENDERBUFFER_SAMPLES: GLenum = 0x8CAB;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: GLenum = 0x8CD0;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: GLenum = 0x8CD1;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: GLenum = 0x8CD2;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: GLenum = 0x8CD3;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: GLenum = 0x8CD4;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_COMPLETE: GLenum = 0x8CD5;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT: GLenum = 0x8CD6;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: GLenum = 0x8CD7;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER: GLenum = 0x8CDB;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER: GLenum = 0x8CDC;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_UNSUPPORTED: GLenum = 0x8CDD;

/// Constant value defined from OpenGL 3.0
pub const GL_MAX_COLOR_ATTACHMENTS: GLenum = 0x8CDF;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT0: GLenum = 0x8CE0;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT1: GLenum = 0x8CE1;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT2: GLenum = 0x8CE2;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT3: GLenum = 0x8CE3;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT4: GLenum = 0x8CE4;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT5: GLenum = 0x8CE5;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT6: GLenum = 0x8CE6;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT7: GLenum = 0x8CE7;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT8: GLenum = 0x8CE8;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT9: GLenum = 0x8CE9;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT10: GLenum = 0x8CEA;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT11: GLenum = 0x8CEB;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT12: GLenum = 0x8CEC;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT13: GLenum = 0x8CED;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT14: GLenum = 0x8CEE;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT15: GLenum = 0x8CEF;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT16: GLenum = 0x8CF0;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT17: GLenum = 0x8CF1;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT18: GLenum = 0x8CF2;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT19: GLenum = 0x8CF3;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT20: GLenum = 0x8CF4;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT21: GLenum = 0x8CF5;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT22: GLenum = 0x8CF6;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT23: GLenum = 0x8CF7;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT24: GLenum = 0x8CF8;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT25: GLenum = 0x8CF9;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT26: GLenum = 0x8CFA;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT27: GLenum = 0x8CFB;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT28: GLenum = 0x8CFC;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT29: GLenum = 0x8CFD;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT30: GLenum = 0x8CFE;

/// Constant value defined from OpenGL 3.0
pub const GL_COLOR_ATTACHMENT31: GLenum = 0x8CFF;

/// Constant value defined from OpenGL 3.0
pub const GL_DEPTH_ATTACHMENT: GLenum = 0x8D00;

/// Constant value defined from OpenGL 3.0
pub const GL_STENCIL_ATTACHMENT: GLenum = 0x8D20;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER: GLenum = 0x8D40;

/// Constant value defined from OpenGL 3.0
pub const GL_RENDERBUFFER: GLenum = 0x8D41;

/// Constant value defined from OpenGL 3.0
pub const GL_RENDERBUFFER_WIDTH: GLenum = 0x8D42;

/// Constant value defined from OpenGL 3.0
pub const GL_RENDERBUFFER_HEIGHT: GLenum = 0x8D43;

/// Constant value defined from OpenGL 3.0
pub const GL_RENDERBUFFER_INTERNAL_FORMAT: GLenum = 0x8D44;

/// Constant value defined from OpenGL 3.0
pub const GL_STENCIL_INDEX1: GLenum = 0x8D46;

/// Constant value defined from OpenGL 3.0
pub const GL_STENCIL_INDEX4: GLenum = 0x8D47;

/// Constant value defined from OpenGL 3.0
pub const GL_STENCIL_INDEX8: GLenum = 0x8D48;

/// Constant value defined from OpenGL 3.0
pub const GL_STENCIL_INDEX16: GLenum = 0x8D49;

/// Constant value defined from OpenGL 3.0
pub const GL_RENDERBUFFER_RED_SIZE: GLenum = 0x8D50;

/// Constant value defined from OpenGL 3.0
pub const GL_RENDERBUFFER_GREEN_SIZE: GLenum = 0x8D51;

/// Constant value defined from OpenGL 3.0
pub const GL_RENDERBUFFER_BLUE_SIZE: GLenum = 0x8D52;

/// Constant value defined from OpenGL 3.0
pub const GL_RENDERBUFFER_ALPHA_SIZE: GLenum = 0x8D53;

/// Constant value defined from OpenGL 3.0
pub const GL_RENDERBUFFER_DEPTH_SIZE: GLenum = 0x8D54;

/// Constant value defined from OpenGL 3.0
pub const GL_RENDERBUFFER_STENCIL_SIZE: GLenum = 0x8D55;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: GLenum = 0x8D56;

/// Constant value defined from OpenGL 3.0
pub const GL_MAX_SAMPLES: GLenum = 0x8D57;

/// Constant value defined from OpenGL 3.0
pub const GL_INDEX: GLenum = 0x8222;

/// Constant value defined from OpenGL 3.0
pub const GL_TEXTURE_LUMINANCE_TYPE: GLenum = 0x8C14;

/// Constant value defined from OpenGL 3.0
pub const GL_TEXTURE_INTENSITY_TYPE: GLenum = 0x8C15;

/// Constant value defined from OpenGL 3.0
pub const GL_FRAMEBUFFER_SRGB: GLenum = 0x8DB9;

/// Constant value defined from OpenGL 3.0
pub const GL_HALF_FLOAT: GLenum = 0x140B;

/// Constant value defined from OpenGL 3.0
pub const GL_MAP_READ_BIT: GLbitfield = 0x0001;

/// Constant value defined from OpenGL 3.0
pub const GL_MAP_WRITE_BIT: GLbitfield = 0x0002;

/// Constant value defined from OpenGL 3.0
pub const GL_MAP_INVALIDATE_RANGE_BIT: GLbitfield = 0x0004;

/// Constant value defined from OpenGL 3.0
pub const GL_MAP_INVALIDATE_BUFFER_BIT: GLbitfield = 0x0008;

/// Constant value defined from OpenGL 3.0
pub const GL_MAP_FLUSH_EXPLICIT_BIT: GLbitfield = 0x0010;

/// Constant value defined from OpenGL 3.0
pub const GL_MAP_UNSYNCHRONIZED_BIT: GLbitfield = 0x0020;

/// Constant value defined from OpenGL 3.0
pub const GL_COMPRESSED_RED_RGTC1: GLenum = 0x8DBB;

/// Constant value defined from OpenGL 3.0
pub const GL_COMPRESSED_SIGNED_RED_RGTC1: GLenum = 0x8DBC;

/// Constant value defined from OpenGL 3.0
pub const GL_COMPRESSED_RG_RGTC2: GLenum = 0x8DBD;

/// Constant value defined from OpenGL 3.0
pub const GL_COMPRESSED_SIGNED_RG_RGTC2: GLenum = 0x8DBE;

/// Constant value defined from OpenGL 3.0
pub const GL_RG: GLenum = 0x8227;

/// Constant value defined from OpenGL 3.0
pub const GL_RG_INTEGER: GLenum = 0x8228;

/// Constant value defined from OpenGL 3.0
pub const GL_R8: GLenum = 0x8229;

/// Constant value defined from OpenGL 3.0
pub const GL_R16: GLenum = 0x822A;

/// Constant value defined from OpenGL 3.0
pub const GL_RG8: GLenum = 0x822B;

/// Constant value defined from OpenGL 3.0
pub const GL_RG16: GLenum = 0x822C;

/// Constant value defined from OpenGL 3.0
pub const GL_R16F: GLenum = 0x822D;

/// Constant value defined from OpenGL 3.0
pub const GL_R32F: GLenum = 0x822E;

/// Constant value defined from OpenGL 3.0
pub const GL_RG16F: GLenum = 0x822F;

/// Constant value defined from OpenGL 3.0
pub const GL_RG32F: GLenum = 0x8230;

/// Constant value defined from OpenGL 3.0
pub const GL_R8I: GLenum = 0x8231;

/// Constant value defined from OpenGL 3.0
pub const GL_R8UI: GLenum = 0x8232;

/// Constant value defined from OpenGL 3.0
pub const GL_R16I: GLenum = 0x8233;

/// Constant value defined from OpenGL 3.0
pub const GL_R16UI: GLenum = 0x8234;

/// Constant value defined from OpenGL 3.0
pub const GL_R32I: GLenum = 0x8235;

/// Constant value defined from OpenGL 3.0
pub const GL_R32UI: GLenum = 0x8236;

/// Constant value defined from OpenGL 3.0
pub const GL_RG8I: GLenum = 0x8237;

/// Constant value defined from OpenGL 3.0
pub const GL_RG8UI: GLenum = 0x8238;

/// Constant value defined from OpenGL 3.0
pub const GL_RG16I: GLenum = 0x8239;

/// Constant value defined from OpenGL 3.0
pub const GL_RG16UI: GLenum = 0x823A;

/// Constant value defined from OpenGL 3.0
pub const GL_RG32I: GLenum = 0x823B;

/// Constant value defined from OpenGL 3.0
pub const GL_RG32UI: GLenum = 0x823C;

/// Constant value defined from OpenGL 3.0
pub const GL_VERTEX_ARRAY_BINDING: GLenum = 0x85B5;

/// Constant value defined from OpenGL 3.0
pub const GL_CLAMP_VERTEX_COLOR: GLenum = 0x891A;

/// Constant value defined from OpenGL 3.0
pub const GL_CLAMP_FRAGMENT_COLOR: GLenum = 0x891B;

/// Constant value defined from OpenGL 3.0
pub const GL_ALPHA_INTEGER: GLenum = 0x8D97;

/// Functions from OpenGL version 3.0
pub trait GL_3_0 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	fn glGetError(&self) -> GLenum;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glColorMaski.xhtml>
	fn glColorMaski(&self, index: GLuint, r: GLboolean, g: GLboolean, b: GLboolean, a: GLboolean) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetBooleani_v.xhtml>
	fn glGetBooleani_v(&self, target: GLenum, index: GLuint, data: *mut GLboolean) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetIntegeri_v.xhtml>
	fn glGetIntegeri_v(&self, target: GLenum, index: GLuint, data: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEnablei.xhtml>
	fn glEnablei(&self, target: GLenum, index: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDisablei.xhtml>
	fn glDisablei(&self, target: GLenum, index: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsEnabledi.xhtml>
	fn glIsEnabledi(&self, target: GLenum, index: GLuint) -> Result<GLboolean>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBeginTransformFeedback.xhtml>
	fn glBeginTransformFeedback(&self, primitiveMode: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEndTransformFeedback.xhtml>
	fn glEndTransformFeedback(&self) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindBufferRange.xhtml>
	fn glBindBufferRange(&self, target: GLenum, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindBufferBase.xhtml>
	fn glBindBufferBase(&self, target: GLenum, index: GLuint, buffer: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTransformFeedbackVaryings.xhtml>
	fn glTransformFeedbackVaryings(&self, program: GLuint, count: GLsizei, varyings: *const *const GLchar, bufferMode: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTransformFeedbackVarying.xhtml>
	fn glGetTransformFeedbackVarying(&self, program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLsizei, type_: *mut GLenum, name: *mut GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClampColor.xhtml>
	fn glClampColor(&self, target: GLenum, clamp: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBeginConditionalRender.xhtml>
	fn glBeginConditionalRender(&self, id: GLuint, mode: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEndConditionalRender.xhtml>
	fn glEndConditionalRender(&self) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribIPointer.xhtml>
	fn glVertexAttribIPointer(&self, index: GLuint, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribIiv.xhtml>
	fn glGetVertexAttribIiv(&self, index: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribIuiv.xhtml>
	fn glGetVertexAttribIuiv(&self, index: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI1i.xhtml>
	fn glVertexAttribI1i(&self, index: GLuint, x: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI2i.xhtml>
	fn glVertexAttribI2i(&self, index: GLuint, x: GLint, y: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI3i.xhtml>
	fn glVertexAttribI3i(&self, index: GLuint, x: GLint, y: GLint, z: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4i.xhtml>
	fn glVertexAttribI4i(&self, index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI1ui.xhtml>
	fn glVertexAttribI1ui(&self, index: GLuint, x: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI2ui.xhtml>
	fn glVertexAttribI2ui(&self, index: GLuint, x: GLuint, y: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI3ui.xhtml>
	fn glVertexAttribI3ui(&self, index: GLuint, x: GLuint, y: GLuint, z: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4ui.xhtml>
	fn glVertexAttribI4ui(&self, index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI1iv.xhtml>
	fn glVertexAttribI1iv(&self, index: GLuint, v: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI2iv.xhtml>
	fn glVertexAttribI2iv(&self, index: GLuint, v: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI3iv.xhtml>
	fn glVertexAttribI3iv(&self, index: GLuint, v: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4iv.xhtml>
	fn glVertexAttribI4iv(&self, index: GLuint, v: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI1uiv.xhtml>
	fn glVertexAttribI1uiv(&self, index: GLuint, v: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI2uiv.xhtml>
	fn glVertexAttribI2uiv(&self, index: GLuint, v: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI3uiv.xhtml>
	fn glVertexAttribI3uiv(&self, index: GLuint, v: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4uiv.xhtml>
	fn glVertexAttribI4uiv(&self, index: GLuint, v: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4bv.xhtml>
	fn glVertexAttribI4bv(&self, index: GLuint, v: *const GLbyte) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4sv.xhtml>
	fn glVertexAttribI4sv(&self, index: GLuint, v: *const GLshort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4ubv.xhtml>
	fn glVertexAttribI4ubv(&self, index: GLuint, v: *const GLubyte) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4usv.xhtml>
	fn glVertexAttribI4usv(&self, index: GLuint, v: *const GLushort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformuiv.xhtml>
	fn glGetUniformuiv(&self, program: GLuint, location: GLint, params: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindFragDataLocation.xhtml>
	fn glBindFragDataLocation(&self, program: GLuint, color: GLuint, name: *const GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetFragDataLocation.xhtml>
	fn glGetFragDataLocation(&self, program: GLuint, name: *const GLchar) -> Result<GLint>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1ui.xhtml>
	fn glUniform1ui(&self, location: GLint, v0: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2ui.xhtml>
	fn glUniform2ui(&self, location: GLint, v0: GLuint, v1: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3ui.xhtml>
	fn glUniform3ui(&self, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4ui.xhtml>
	fn glUniform4ui(&self, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1uiv.xhtml>
	fn glUniform1uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2uiv.xhtml>
	fn glUniform2uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3uiv.xhtml>
	fn glUniform3uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4uiv.xhtml>
	fn glUniform4uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameterIiv.xhtml>
	fn glTexParameterIiv(&self, target: GLenum, pname: GLenum, params: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameterIuiv.xhtml>
	fn glTexParameterIuiv(&self, target: GLenum, pname: GLenum, params: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexParameterIiv.xhtml>
	fn glGetTexParameterIiv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexParameterIuiv.xhtml>
	fn glGetTexParameterIuiv(&self, target: GLenum, pname: GLenum, params: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearBufferiv.xhtml>
	fn glClearBufferiv(&self, buffer: GLenum, drawbuffer: GLint, value: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearBufferuiv.xhtml>
	fn glClearBufferuiv(&self, buffer: GLenum, drawbuffer: GLint, value: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearBufferfv.xhtml>
	fn glClearBufferfv(&self, buffer: GLenum, drawbuffer: GLint, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearBufferfi.xhtml>
	fn glClearBufferfi(&self, buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetStringi.xhtml>
	fn glGetStringi(&self, name: GLenum, index: GLuint) -> Result<&'static str>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsRenderbuffer.xhtml>
	fn glIsRenderbuffer(&self, renderbuffer: GLuint) -> Result<GLboolean>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindRenderbuffer.xhtml>
	fn glBindRenderbuffer(&self, target: GLenum, renderbuffer: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteRenderbuffers.xhtml>
	fn glDeleteRenderbuffers(&self, n: GLsizei, renderbuffers: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenRenderbuffers.xhtml>
	fn glGenRenderbuffers(&self, n: GLsizei, renderbuffers: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml>
	fn glRenderbufferStorage(&self, target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetRenderbufferParameteriv.xhtml>
	fn glGetRenderbufferParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsFramebuffer.xhtml>
	fn glIsFramebuffer(&self, framebuffer: GLuint) -> Result<GLboolean>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindFramebuffer.xhtml>
	fn glBindFramebuffer(&self, target: GLenum, framebuffer: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteFramebuffers.xhtml>
	fn glDeleteFramebuffers(&self, n: GLsizei, framebuffers: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenFramebuffers.xhtml>
	fn glGenFramebuffers(&self, n: GLsizei, framebuffers: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml>
	fn glCheckFramebufferStatus(&self, target: GLenum) -> Result<GLenum>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferTexture1D.xhtml>
	fn glFramebufferTexture1D(&self, target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferTexture2D.xhtml>
	fn glFramebufferTexture2D(&self, target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferTexture3D.xhtml>
	fn glFramebufferTexture3D(&self, target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint, zoffset: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml>
	fn glFramebufferRenderbuffer(&self, target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameteriv.xhtml>
	fn glGetFramebufferAttachmentParameteriv(&self, target: GLenum, attachment: GLenum, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml>
	fn glGenerateMipmap(&self, target: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml>
	fn glBlitFramebuffer(&self, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml>
	fn glRenderbufferStorageMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml>
	fn glFramebufferTextureLayer(&self, target: GLenum, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml>
	fn glMapBufferRange(&self, target: GLenum, offset: GLintptr, length: GLsizeiptr, access: GLbitfield) -> Result<*mut c_void>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml>
	fn glFlushMappedBufferRange(&self, target: GLenum, offset: GLintptr, length: GLsizeiptr) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml>
	fn glBindVertexArray(&self, array: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteVertexArrays.xhtml>
	fn glDeleteVertexArrays(&self, n: GLsizei, arrays: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml>
	fn glGenVertexArrays(&self, n: GLsizei, arrays: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsVertexArray.xhtml>
	fn glIsVertexArray(&self, array: GLuint) -> Result<GLboolean>;
}
/// Functions from OpenGL version 3.0
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version30 {
	/// Is OpenGL version 3.0 available
	available: bool,

	/// The function pointer to `glGetError()`
	pub geterror: PFNGLGETERRORPROC,

	/// The function pointer to `glColorMaski()`
	pub colormaski: PFNGLCOLORMASKIPROC,

	/// The function pointer to `glGetBooleani_v()`
	pub getbooleani_v: PFNGLGETBOOLEANI_VPROC,

	/// The function pointer to `glGetIntegeri_v()`
	pub getintegeri_v: PFNGLGETINTEGERI_VPROC,

	/// The function pointer to `glEnablei()`
	pub enablei: PFNGLENABLEIPROC,

	/// The function pointer to `glDisablei()`
	pub disablei: PFNGLDISABLEIPROC,

	/// The function pointer to `glIsEnabledi()`
	pub isenabledi: PFNGLISENABLEDIPROC,

	/// The function pointer to `glBeginTransformFeedback()`
	pub begintransformfeedback: PFNGLBEGINTRANSFORMFEEDBACKPROC,

	/// The function pointer to `glEndTransformFeedback()`
	pub endtransformfeedback: PFNGLENDTRANSFORMFEEDBACKPROC,

	/// The function pointer to `glBindBufferRange()`
	pub bindbufferrange: PFNGLBINDBUFFERRANGEPROC,

	/// The function pointer to `glBindBufferBase()`
	pub bindbufferbase: PFNGLBINDBUFFERBASEPROC,

	/// The function pointer to `glTransformFeedbackVaryings()`
	pub transformfeedbackvaryings: PFNGLTRANSFORMFEEDBACKVARYINGSPROC,

	/// The function pointer to `glGetTransformFeedbackVarying()`
	pub gettransformfeedbackvarying: PFNGLGETTRANSFORMFEEDBACKVARYINGPROC,

	/// The function pointer to `glClampColor()`
	pub clampcolor: PFNGLCLAMPCOLORPROC,

	/// The function pointer to `glBeginConditionalRender()`
	pub beginconditionalrender: PFNGLBEGINCONDITIONALRENDERPROC,

	/// The function pointer to `glEndConditionalRender()`
	pub endconditionalrender: PFNGLENDCONDITIONALRENDERPROC,

	/// The function pointer to `glVertexAttribIPointer()`
	pub vertexattribipointer: PFNGLVERTEXATTRIBIPOINTERPROC,

	/// The function pointer to `glGetVertexAttribIiv()`
	pub getvertexattribiiv: PFNGLGETVERTEXATTRIBIIVPROC,

	/// The function pointer to `glGetVertexAttribIuiv()`
	pub getvertexattribiuiv: PFNGLGETVERTEXATTRIBIUIVPROC,

	/// The function pointer to `glVertexAttribI1i()`
	pub vertexattribi1i: PFNGLVERTEXATTRIBI1IPROC,

	/// The function pointer to `glVertexAttribI2i()`
	pub vertexattribi2i: PFNGLVERTEXATTRIBI2IPROC,

	/// The function pointer to `glVertexAttribI3i()`
	pub vertexattribi3i: PFNGLVERTEXATTRIBI3IPROC,

	/// The function pointer to `glVertexAttribI4i()`
	pub vertexattribi4i: PFNGLVERTEXATTRIBI4IPROC,

	/// The function pointer to `glVertexAttribI1ui()`
	pub vertexattribi1ui: PFNGLVERTEXATTRIBI1UIPROC,

	/// The function pointer to `glVertexAttribI2ui()`
	pub vertexattribi2ui: PFNGLVERTEXATTRIBI2UIPROC,

	/// The function pointer to `glVertexAttribI3ui()`
	pub vertexattribi3ui: PFNGLVERTEXATTRIBI3UIPROC,

	/// The function pointer to `glVertexAttribI4ui()`
	pub vertexattribi4ui: PFNGLVERTEXATTRIBI4UIPROC,

	/// The function pointer to `glVertexAttribI1iv()`
	pub vertexattribi1iv: PFNGLVERTEXATTRIBI1IVPROC,

	/// The function pointer to `glVertexAttribI2iv()`
	pub vertexattribi2iv: PFNGLVERTEXATTRIBI2IVPROC,

	/// The function pointer to `glVertexAttribI3iv()`
	pub vertexattribi3iv: PFNGLVERTEXATTRIBI3IVPROC,

	/// The function pointer to `glVertexAttribI4iv()`
	pub vertexattribi4iv: PFNGLVERTEXATTRIBI4IVPROC,

	/// The function pointer to `glVertexAttribI1uiv()`
	pub vertexattribi1uiv: PFNGLVERTEXATTRIBI1UIVPROC,

	/// The function pointer to `glVertexAttribI2uiv()`
	pub vertexattribi2uiv: PFNGLVERTEXATTRIBI2UIVPROC,

	/// The function pointer to `glVertexAttribI3uiv()`
	pub vertexattribi3uiv: PFNGLVERTEXATTRIBI3UIVPROC,

	/// The function pointer to `glVertexAttribI4uiv()`
	pub vertexattribi4uiv: PFNGLVERTEXATTRIBI4UIVPROC,

	/// The function pointer to `glVertexAttribI4bv()`
	pub vertexattribi4bv: PFNGLVERTEXATTRIBI4BVPROC,

	/// The function pointer to `glVertexAttribI4sv()`
	pub vertexattribi4sv: PFNGLVERTEXATTRIBI4SVPROC,

	/// The function pointer to `glVertexAttribI4ubv()`
	pub vertexattribi4ubv: PFNGLVERTEXATTRIBI4UBVPROC,

	/// The function pointer to `glVertexAttribI4usv()`
	pub vertexattribi4usv: PFNGLVERTEXATTRIBI4USVPROC,

	/// The function pointer to `glGetUniformuiv()`
	pub getuniformuiv: PFNGLGETUNIFORMUIVPROC,

	/// The function pointer to `glBindFragDataLocation()`
	pub bindfragdatalocation: PFNGLBINDFRAGDATALOCATIONPROC,

	/// The function pointer to `glGetFragDataLocation()`
	pub getfragdatalocation: PFNGLGETFRAGDATALOCATIONPROC,

	/// The function pointer to `glUniform1ui()`
	pub uniform1ui: PFNGLUNIFORM1UIPROC,

	/// The function pointer to `glUniform2ui()`
	pub uniform2ui: PFNGLUNIFORM2UIPROC,

	/// The function pointer to `glUniform3ui()`
	pub uniform3ui: PFNGLUNIFORM3UIPROC,

	/// The function pointer to `glUniform4ui()`
	pub uniform4ui: PFNGLUNIFORM4UIPROC,

	/// The function pointer to `glUniform1uiv()`
	pub uniform1uiv: PFNGLUNIFORM1UIVPROC,

	/// The function pointer to `glUniform2uiv()`
	pub uniform2uiv: PFNGLUNIFORM2UIVPROC,

	/// The function pointer to `glUniform3uiv()`
	pub uniform3uiv: PFNGLUNIFORM3UIVPROC,

	/// The function pointer to `glUniform4uiv()`
	pub uniform4uiv: PFNGLUNIFORM4UIVPROC,

	/// The function pointer to `glTexParameterIiv()`
	pub texparameteriiv: PFNGLTEXPARAMETERIIVPROC,

	/// The function pointer to `glTexParameterIuiv()`
	pub texparameteriuiv: PFNGLTEXPARAMETERIUIVPROC,

	/// The function pointer to `glGetTexParameterIiv()`
	pub gettexparameteriiv: PFNGLGETTEXPARAMETERIIVPROC,

	/// The function pointer to `glGetTexParameterIuiv()`
	pub gettexparameteriuiv: PFNGLGETTEXPARAMETERIUIVPROC,

	/// The function pointer to `glClearBufferiv()`
	pub clearbufferiv: PFNGLCLEARBUFFERIVPROC,

	/// The function pointer to `glClearBufferuiv()`
	pub clearbufferuiv: PFNGLCLEARBUFFERUIVPROC,

	/// The function pointer to `glClearBufferfv()`
	pub clearbufferfv: PFNGLCLEARBUFFERFVPROC,

	/// The function pointer to `glClearBufferfi()`
	pub clearbufferfi: PFNGLCLEARBUFFERFIPROC,

	/// The function pointer to `glGetStringi()`
	pub getstringi: PFNGLGETSTRINGIPROC,

	/// The function pointer to `glIsRenderbuffer()`
	pub isrenderbuffer: PFNGLISRENDERBUFFERPROC,

	/// The function pointer to `glBindRenderbuffer()`
	pub bindrenderbuffer: PFNGLBINDRENDERBUFFERPROC,

	/// The function pointer to `glDeleteRenderbuffers()`
	pub deleterenderbuffers: PFNGLDELETERENDERBUFFERSPROC,

	/// The function pointer to `glGenRenderbuffers()`
	pub genrenderbuffers: PFNGLGENRENDERBUFFERSPROC,

	/// The function pointer to `glRenderbufferStorage()`
	pub renderbufferstorage: PFNGLRENDERBUFFERSTORAGEPROC,

	/// The function pointer to `glGetRenderbufferParameteriv()`
	pub getrenderbufferparameteriv: PFNGLGETRENDERBUFFERPARAMETERIVPROC,

	/// The function pointer to `glIsFramebuffer()`
	pub isframebuffer: PFNGLISFRAMEBUFFERPROC,

	/// The function pointer to `glBindFramebuffer()`
	pub bindframebuffer: PFNGLBINDFRAMEBUFFERPROC,

	/// The function pointer to `glDeleteFramebuffers()`
	pub deleteframebuffers: PFNGLDELETEFRAMEBUFFERSPROC,

	/// The function pointer to `glGenFramebuffers()`
	pub genframebuffers: PFNGLGENFRAMEBUFFERSPROC,

	/// The function pointer to `glCheckFramebufferStatus()`
	pub checkframebufferstatus: PFNGLCHECKFRAMEBUFFERSTATUSPROC,

	/// The function pointer to `glFramebufferTexture1D()`
	pub framebuffertexture1d: PFNGLFRAMEBUFFERTEXTURE1DPROC,

	/// The function pointer to `glFramebufferTexture2D()`
	pub framebuffertexture2d: PFNGLFRAMEBUFFERTEXTURE2DPROC,

	/// The function pointer to `glFramebufferTexture3D()`
	pub framebuffertexture3d: PFNGLFRAMEBUFFERTEXTURE3DPROC,

	/// The function pointer to `glFramebufferRenderbuffer()`
	pub framebufferrenderbuffer: PFNGLFRAMEBUFFERRENDERBUFFERPROC,

	/// The function pointer to `glGetFramebufferAttachmentParameteriv()`
	pub getframebufferattachmentparameteriv: PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC,

	/// The function pointer to `glGenerateMipmap()`
	pub generatemipmap: PFNGLGENERATEMIPMAPPROC,

	/// The function pointer to `glBlitFramebuffer()`
	pub blitframebuffer: PFNGLBLITFRAMEBUFFERPROC,

	/// The function pointer to `glRenderbufferStorageMultisample()`
	pub renderbufferstoragemultisample: PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC,

	/// The function pointer to `glFramebufferTextureLayer()`
	pub framebuffertexturelayer: PFNGLFRAMEBUFFERTEXTURELAYERPROC,

	/// The function pointer to `glMapBufferRange()`
	pub mapbufferrange: PFNGLMAPBUFFERRANGEPROC,

	/// The function pointer to `glFlushMappedBufferRange()`
	pub flushmappedbufferrange: PFNGLFLUSHMAPPEDBUFFERRANGEPROC,

	/// The function pointer to `glBindVertexArray()`
	pub bindvertexarray: PFNGLBINDVERTEXARRAYPROC,

	/// The function pointer to `glDeleteVertexArrays()`
	pub deletevertexarrays: PFNGLDELETEVERTEXARRAYSPROC,

	/// The function pointer to `glGenVertexArrays()`
	pub genvertexarrays: PFNGLGENVERTEXARRAYSPROC,

	/// The function pointer to `glIsVertexArray()`
	pub isvertexarray: PFNGLISVERTEXARRAYPROC,
}

impl GL_3_0 for Version30 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glColorMaski.xhtml>
	#[inline(always)]
	fn glColorMaski(&self, index: GLuint, r: GLboolean, g: GLboolean, b: GLboolean, a: GLboolean) -> Result<()> {
		let ret = process_catch("glColorMaski", catch_unwind(||(self.colormaski)(index, r, g, b, a)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorMaski", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetBooleani_v.xhtml>
	#[inline(always)]
	fn glGetBooleani_v(&self, target: GLenum, index: GLuint, data: *mut GLboolean) -> Result<()> {
		let ret = process_catch("glGetBooleani_v", catch_unwind(||(self.getbooleani_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBooleani_v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetIntegeri_v.xhtml>
	#[inline(always)]
	fn glGetIntegeri_v(&self, target: GLenum, index: GLuint, data: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetIntegeri_v", catch_unwind(||(self.getintegeri_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetIntegeri_v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEnablei.xhtml>
	#[inline(always)]
	fn glEnablei(&self, target: GLenum, index: GLuint) -> Result<()> {
		let ret = process_catch("glEnablei", catch_unwind(||(self.enablei)(target, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEnablei", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDisablei.xhtml>
	#[inline(always)]
	fn glDisablei(&self, target: GLenum, index: GLuint) -> Result<()> {
		let ret = process_catch("glDisablei", catch_unwind(||(self.disablei)(target, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDisablei", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsEnabledi.xhtml>
	#[inline(always)]
	fn glIsEnabledi(&self, target: GLenum, index: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsEnabledi", catch_unwind(||(self.isenabledi)(target, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsEnabledi", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBeginTransformFeedback.xhtml>
	#[inline(always)]
	fn glBeginTransformFeedback(&self, primitiveMode: GLenum) -> Result<()> {
		let ret = process_catch("glBeginTransformFeedback", catch_unwind(||(self.begintransformfeedback)(primitiveMode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBeginTransformFeedback", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEndTransformFeedback.xhtml>
	#[inline(always)]
	fn glEndTransformFeedback(&self) -> Result<()> {
		let ret = process_catch("glEndTransformFeedback", catch_unwind(||(self.endtransformfeedback)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEndTransformFeedback", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindBufferRange.xhtml>
	#[inline(always)]
	fn glBindBufferRange(&self, target: GLenum, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glBindBufferRange", catch_unwind(||(self.bindbufferrange)(target, index, buffer, offset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBufferRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindBufferBase.xhtml>
	#[inline(always)]
	fn glBindBufferBase(&self, target: GLenum, index: GLuint, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glBindBufferBase", catch_unwind(||(self.bindbufferbase)(target, index, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBufferBase", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTransformFeedbackVaryings.xhtml>
	#[inline(always)]
	fn glTransformFeedbackVaryings(&self, program: GLuint, count: GLsizei, varyings: *const *const GLchar, bufferMode: GLenum) -> Result<()> {
		let ret = process_catch("glTransformFeedbackVaryings", catch_unwind(||(self.transformfeedbackvaryings)(program, count, varyings, bufferMode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTransformFeedbackVaryings", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTransformFeedbackVarying.xhtml>
	#[inline(always)]
	fn glGetTransformFeedbackVarying(&self, program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLsizei, type_: *mut GLenum, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetTransformFeedbackVarying", catch_unwind(||(self.gettransformfeedbackvarying)(program, index, bufSize, length, size, type_, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTransformFeedbackVarying", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClampColor.xhtml>
	#[inline(always)]
	fn glClampColor(&self, target: GLenum, clamp: GLenum) -> Result<()> {
		let ret = process_catch("glClampColor", catch_unwind(||(self.clampcolor)(target, clamp)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClampColor", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBeginConditionalRender.xhtml>
	#[inline(always)]
	fn glBeginConditionalRender(&self, id: GLuint, mode: GLenum) -> Result<()> {
		let ret = process_catch("glBeginConditionalRender", catch_unwind(||(self.beginconditionalrender)(id, mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBeginConditionalRender", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEndConditionalRender.xhtml>
	#[inline(always)]
	fn glEndConditionalRender(&self) -> Result<()> {
		let ret = process_catch("glEndConditionalRender", catch_unwind(||(self.endconditionalrender)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEndConditionalRender", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribIPointer.xhtml>
	#[inline(always)]
	fn glVertexAttribIPointer(&self, index: GLuint, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glVertexAttribIPointer", catch_unwind(||(self.vertexattribipointer)(index, size, type_, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribIPointer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribIiv.xhtml>
	#[inline(always)]
	fn glGetVertexAttribIiv(&self, index: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetVertexAttribIiv", catch_unwind(||(self.getvertexattribiiv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribIiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribIuiv.xhtml>
	#[inline(always)]
	fn glGetVertexAttribIuiv(&self, index: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetVertexAttribIuiv", catch_unwind(||(self.getvertexattribiuiv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribIuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI1i.xhtml>
	#[inline(always)]
	fn glVertexAttribI1i(&self, index: GLuint, x: GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI1i", catch_unwind(||(self.vertexattribi1i)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI1i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI2i.xhtml>
	#[inline(always)]
	fn glVertexAttribI2i(&self, index: GLuint, x: GLint, y: GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI2i", catch_unwind(||(self.vertexattribi2i)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI2i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI3i.xhtml>
	#[inline(always)]
	fn glVertexAttribI3i(&self, index: GLuint, x: GLint, y: GLint, z: GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI3i", catch_unwind(||(self.vertexattribi3i)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI3i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4i.xhtml>
	#[inline(always)]
	fn glVertexAttribI4i(&self, index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI4i", catch_unwind(||(self.vertexattribi4i)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI1ui.xhtml>
	#[inline(always)]
	fn glVertexAttribI1ui(&self, index: GLuint, x: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI1ui", catch_unwind(||(self.vertexattribi1ui)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI1ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI2ui.xhtml>
	#[inline(always)]
	fn glVertexAttribI2ui(&self, index: GLuint, x: GLuint, y: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI2ui", catch_unwind(||(self.vertexattribi2ui)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI2ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI3ui.xhtml>
	#[inline(always)]
	fn glVertexAttribI3ui(&self, index: GLuint, x: GLuint, y: GLuint, z: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI3ui", catch_unwind(||(self.vertexattribi3ui)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4ui.xhtml>
	#[inline(always)]
	fn glVertexAttribI4ui(&self, index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI4ui", catch_unwind(||(self.vertexattribi4ui)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI1iv.xhtml>
	#[inline(always)]
	fn glVertexAttribI1iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI1iv", catch_unwind(||(self.vertexattribi1iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI1iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI2iv.xhtml>
	#[inline(always)]
	fn glVertexAttribI2iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI2iv", catch_unwind(||(self.vertexattribi2iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI2iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI3iv.xhtml>
	#[inline(always)]
	fn glVertexAttribI3iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI3iv", catch_unwind(||(self.vertexattribi3iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI3iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4iv.xhtml>
	#[inline(always)]
	fn glVertexAttribI4iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI4iv", catch_unwind(||(self.vertexattribi4iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI1uiv.xhtml>
	#[inline(always)]
	fn glVertexAttribI1uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI1uiv", catch_unwind(||(self.vertexattribi1uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI1uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI2uiv.xhtml>
	#[inline(always)]
	fn glVertexAttribI2uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI2uiv", catch_unwind(||(self.vertexattribi2uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI2uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI3uiv.xhtml>
	#[inline(always)]
	fn glVertexAttribI3uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI3uiv", catch_unwind(||(self.vertexattribi3uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4uiv.xhtml>
	#[inline(always)]
	fn glVertexAttribI4uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI4uiv", catch_unwind(||(self.vertexattribi4uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4bv.xhtml>
	#[inline(always)]
	fn glVertexAttribI4bv(&self, index: GLuint, v: *const GLbyte) -> Result<()> {
		let ret = process_catch("glVertexAttribI4bv", catch_unwind(||(self.vertexattribi4bv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4bv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4sv.xhtml>
	#[inline(always)]
	fn glVertexAttribI4sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttribI4sv", catch_unwind(||(self.vertexattribi4sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4ubv.xhtml>
	#[inline(always)]
	fn glVertexAttribI4ubv(&self, index: GLuint, v: *const GLubyte) -> Result<()> {
		let ret = process_catch("glVertexAttribI4ubv", catch_unwind(||(self.vertexattribi4ubv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4ubv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4usv.xhtml>
	#[inline(always)]
	fn glVertexAttribI4usv(&self, index: GLuint, v: *const GLushort) -> Result<()> {
		let ret = process_catch("glVertexAttribI4usv", catch_unwind(||(self.vertexattribi4usv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4usv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformuiv.xhtml>
	#[inline(always)]
	fn glGetUniformuiv(&self, program: GLuint, location: GLint, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetUniformuiv", catch_unwind(||(self.getuniformuiv)(program, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindFragDataLocation.xhtml>
	#[inline(always)]
	fn glBindFragDataLocation(&self, program: GLuint, color: GLuint, name: *const GLchar) -> Result<()> {
		let ret = process_catch("glBindFragDataLocation", catch_unwind(||(self.bindfragdatalocation)(program, color, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindFragDataLocation", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetFragDataLocation.xhtml>
	#[inline(always)]
	fn glGetFragDataLocation(&self, program: GLuint, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetFragDataLocation", catch_unwind(||(self.getfragdatalocation)(program, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFragDataLocation", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1ui.xhtml>
	#[inline(always)]
	fn glUniform1ui(&self, location: GLint, v0: GLuint) -> Result<()> {
		let ret = process_catch("glUniform1ui", catch_unwind(||(self.uniform1ui)(location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2ui.xhtml>
	#[inline(always)]
	fn glUniform2ui(&self, location: GLint, v0: GLuint, v1: GLuint) -> Result<()> {
		let ret = process_catch("glUniform2ui", catch_unwind(||(self.uniform2ui)(location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3ui.xhtml>
	#[inline(always)]
	fn glUniform3ui(&self, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint) -> Result<()> {
		let ret = process_catch("glUniform3ui", catch_unwind(||(self.uniform3ui)(location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4ui.xhtml>
	#[inline(always)]
	fn glUniform4ui(&self, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint) -> Result<()> {
		let ret = process_catch("glUniform4ui", catch_unwind(||(self.uniform4ui)(location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1uiv.xhtml>
	#[inline(always)]
	fn glUniform1uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniform1uiv", catch_unwind(||(self.uniform1uiv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2uiv.xhtml>
	#[inline(always)]
	fn glUniform2uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniform2uiv", catch_unwind(||(self.uniform2uiv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3uiv.xhtml>
	#[inline(always)]
	fn glUniform3uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniform3uiv", catch_unwind(||(self.uniform3uiv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4uiv.xhtml>
	#[inline(always)]
	fn glUniform4uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniform4uiv", catch_unwind(||(self.uniform4uiv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameterIiv.xhtml>
	#[inline(always)]
	fn glTexParameterIiv(&self, target: GLenum, pname: GLenum, params: *const GLint) -> Result<()> {
		let ret = process_catch("glTexParameterIiv", catch_unwind(||(self.texparameteriiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameterIiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameterIuiv.xhtml>
	#[inline(always)]
	fn glTexParameterIuiv(&self, target: GLenum, pname: GLenum, params: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexParameterIuiv", catch_unwind(||(self.texparameteriuiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameterIuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexParameterIiv.xhtml>
	#[inline(always)]
	fn glGetTexParameterIiv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTexParameterIiv", catch_unwind(||(self.gettexparameteriiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexParameterIiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexParameterIuiv.xhtml>
	#[inline(always)]
	fn glGetTexParameterIuiv(&self, target: GLenum, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetTexParameterIuiv", catch_unwind(||(self.gettexparameteriuiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexParameterIuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearBufferiv.xhtml>
	#[inline(always)]
	fn glClearBufferiv(&self, buffer: GLenum, drawbuffer: GLint, value: *const GLint) -> Result<()> {
		let ret = process_catch("glClearBufferiv", catch_unwind(||(self.clearbufferiv)(buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearBufferuiv.xhtml>
	#[inline(always)]
	fn glClearBufferuiv(&self, buffer: GLenum, drawbuffer: GLint, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glClearBufferuiv", catch_unwind(||(self.clearbufferuiv)(buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearBufferfv.xhtml>
	#[inline(always)]
	fn glClearBufferfv(&self, buffer: GLenum, drawbuffer: GLint, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glClearBufferfv", catch_unwind(||(self.clearbufferfv)(buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearBufferfi.xhtml>
	#[inline(always)]
	fn glClearBufferfi(&self, buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint) -> Result<()> {
		let ret = process_catch("glClearBufferfi", catch_unwind(||(self.clearbufferfi)(buffer, drawbuffer, depth, stencil)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferfi", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetStringi.xhtml>
	#[inline(always)]
	fn glGetStringi(&self, name: GLenum, index: GLuint) -> Result<&'static str> {
		let ret = process_catch("glGetStringi", catch_unwind(||unsafe{CStr::from_ptr((self.getstringi)(name, index) as *const i8)}.to_str().unwrap()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetStringi", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsRenderbuffer.xhtml>
	#[inline(always)]
	fn glIsRenderbuffer(&self, renderbuffer: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsRenderbuffer", catch_unwind(||(self.isrenderbuffer)(renderbuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsRenderbuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindRenderbuffer.xhtml>
	#[inline(always)]
	fn glBindRenderbuffer(&self, target: GLenum, renderbuffer: GLuint) -> Result<()> {
		let ret = process_catch("glBindRenderbuffer", catch_unwind(||(self.bindrenderbuffer)(target, renderbuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindRenderbuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteRenderbuffers.xhtml>
	#[inline(always)]
	fn glDeleteRenderbuffers(&self, n: GLsizei, renderbuffers: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteRenderbuffers", catch_unwind(||(self.deleterenderbuffers)(n, renderbuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteRenderbuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenRenderbuffers.xhtml>
	#[inline(always)]
	fn glGenRenderbuffers(&self, n: GLsizei, renderbuffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenRenderbuffers", catch_unwind(||(self.genrenderbuffers)(n, renderbuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenRenderbuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml>
	#[inline(always)]
	fn glRenderbufferStorage(&self, target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glRenderbufferStorage", catch_unwind(||(self.renderbufferstorage)(target, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glRenderbufferStorage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetRenderbufferParameteriv.xhtml>
	#[inline(always)]
	fn glGetRenderbufferParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetRenderbufferParameteriv", catch_unwind(||(self.getrenderbufferparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetRenderbufferParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsFramebuffer.xhtml>
	#[inline(always)]
	fn glIsFramebuffer(&self, framebuffer: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsFramebuffer", catch_unwind(||(self.isframebuffer)(framebuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsFramebuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindFramebuffer.xhtml>
	#[inline(always)]
	fn glBindFramebuffer(&self, target: GLenum, framebuffer: GLuint) -> Result<()> {
		let ret = process_catch("glBindFramebuffer", catch_unwind(||(self.bindframebuffer)(target, framebuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindFramebuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteFramebuffers.xhtml>
	#[inline(always)]
	fn glDeleteFramebuffers(&self, n: GLsizei, framebuffers: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteFramebuffers", catch_unwind(||(self.deleteframebuffers)(n, framebuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteFramebuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenFramebuffers.xhtml>
	#[inline(always)]
	fn glGenFramebuffers(&self, n: GLsizei, framebuffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenFramebuffers", catch_unwind(||(self.genframebuffers)(n, framebuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenFramebuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml>
	#[inline(always)]
	fn glCheckFramebufferStatus(&self, target: GLenum) -> Result<GLenum> {
		let ret = process_catch("glCheckFramebufferStatus", catch_unwind(||(self.checkframebufferstatus)(target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCheckFramebufferStatus", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferTexture1D.xhtml>
	#[inline(always)]
	fn glFramebufferTexture1D(&self, target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTexture1D", catch_unwind(||(self.framebuffertexture1d)(target, attachment, textarget, texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTexture1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferTexture2D.xhtml>
	#[inline(always)]
	fn glFramebufferTexture2D(&self, target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTexture2D", catch_unwind(||(self.framebuffertexture2d)(target, attachment, textarget, texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTexture2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferTexture3D.xhtml>
	#[inline(always)]
	fn glFramebufferTexture3D(&self, target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint, zoffset: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTexture3D", catch_unwind(||(self.framebuffertexture3d)(target, attachment, textarget, texture, level, zoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTexture3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml>
	#[inline(always)]
	fn glFramebufferRenderbuffer(&self, target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint) -> Result<()> {
		let ret = process_catch("glFramebufferRenderbuffer", catch_unwind(||(self.framebufferrenderbuffer)(target, attachment, renderbuffertarget, renderbuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferRenderbuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameteriv.xhtml>
	#[inline(always)]
	fn glGetFramebufferAttachmentParameteriv(&self, target: GLenum, attachment: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetFramebufferAttachmentParameteriv", catch_unwind(||(self.getframebufferattachmentparameteriv)(target, attachment, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFramebufferAttachmentParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml>
	#[inline(always)]
	fn glGenerateMipmap(&self, target: GLenum) -> Result<()> {
		let ret = process_catch("glGenerateMipmap", catch_unwind(||(self.generatemipmap)(target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenerateMipmap", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml>
	#[inline(always)]
	fn glBlitFramebuffer(&self, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum) -> Result<()> {
		let ret = process_catch("glBlitFramebuffer", catch_unwind(||(self.blitframebuffer)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlitFramebuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml>
	#[inline(always)]
	fn glRenderbufferStorageMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glRenderbufferStorageMultisample", catch_unwind(||(self.renderbufferstoragemultisample)(target, samples, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glRenderbufferStorageMultisample", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml>
	#[inline(always)]
	fn glFramebufferTextureLayer(&self, target: GLenum, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTextureLayer", catch_unwind(||(self.framebuffertexturelayer)(target, attachment, texture, level, layer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTextureLayer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml>
	#[inline(always)]
	fn glMapBufferRange(&self, target: GLenum, offset: GLintptr, length: GLsizeiptr, access: GLbitfield) -> Result<*mut c_void> {
		let ret = process_catch("glMapBufferRange", catch_unwind(||(self.mapbufferrange)(target, offset, length, access)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMapBufferRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml>
	#[inline(always)]
	fn glFlushMappedBufferRange(&self, target: GLenum, offset: GLintptr, length: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glFlushMappedBufferRange", catch_unwind(||(self.flushmappedbufferrange)(target, offset, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFlushMappedBufferRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml>
	#[inline(always)]
	fn glBindVertexArray(&self, array: GLuint) -> Result<()> {
		let ret = process_catch("glBindVertexArray", catch_unwind(||(self.bindvertexarray)(array)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindVertexArray", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteVertexArrays.xhtml>
	#[inline(always)]
	fn glDeleteVertexArrays(&self, n: GLsizei, arrays: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteVertexArrays", catch_unwind(||(self.deletevertexarrays)(n, arrays)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteVertexArrays", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml>
	#[inline(always)]
	fn glGenVertexArrays(&self, n: GLsizei, arrays: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenVertexArrays", catch_unwind(||(self.genvertexarrays)(n, arrays)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenVertexArrays", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsVertexArray.xhtml>
	#[inline(always)]
	fn glIsVertexArray(&self, array: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsVertexArray", catch_unwind(||(self.isvertexarray)(array)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsVertexArray", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version30 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (3, 0, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			colormaski: {let proc = get_proc_address("glColorMaski"); if proc == null() {dummy_pfnglcolormaskiproc} else {unsafe{transmute(proc)}}},
			getbooleani_v: {let proc = get_proc_address("glGetBooleani_v"); if proc == null() {dummy_pfnglgetbooleani_vproc} else {unsafe{transmute(proc)}}},
			getintegeri_v: {let proc = get_proc_address("glGetIntegeri_v"); if proc == null() {dummy_pfnglgetintegeri_vproc} else {unsafe{transmute(proc)}}},
			enablei: {let proc = get_proc_address("glEnablei"); if proc == null() {dummy_pfnglenableiproc} else {unsafe{transmute(proc)}}},
			disablei: {let proc = get_proc_address("glDisablei"); if proc == null() {dummy_pfngldisableiproc} else {unsafe{transmute(proc)}}},
			isenabledi: {let proc = get_proc_address("glIsEnabledi"); if proc == null() {dummy_pfnglisenablediproc} else {unsafe{transmute(proc)}}},
			begintransformfeedback: {let proc = get_proc_address("glBeginTransformFeedback"); if proc == null() {dummy_pfnglbegintransformfeedbackproc} else {unsafe{transmute(proc)}}},
			endtransformfeedback: {let proc = get_proc_address("glEndTransformFeedback"); if proc == null() {dummy_pfnglendtransformfeedbackproc} else {unsafe{transmute(proc)}}},
			bindbufferrange: {let proc = get_proc_address("glBindBufferRange"); if proc == null() {dummy_pfnglbindbufferrangeproc} else {unsafe{transmute(proc)}}},
			bindbufferbase: {let proc = get_proc_address("glBindBufferBase"); if proc == null() {dummy_pfnglbindbufferbaseproc} else {unsafe{transmute(proc)}}},
			transformfeedbackvaryings: {let proc = get_proc_address("glTransformFeedbackVaryings"); if proc == null() {dummy_pfngltransformfeedbackvaryingsproc} else {unsafe{transmute(proc)}}},
			gettransformfeedbackvarying: {let proc = get_proc_address("glGetTransformFeedbackVarying"); if proc == null() {dummy_pfnglgettransformfeedbackvaryingproc} else {unsafe{transmute(proc)}}},
			clampcolor: {let proc = get_proc_address("glClampColor"); if proc == null() {dummy_pfnglclampcolorproc} else {unsafe{transmute(proc)}}},
			beginconditionalrender: {let proc = get_proc_address("glBeginConditionalRender"); if proc == null() {dummy_pfnglbeginconditionalrenderproc} else {unsafe{transmute(proc)}}},
			endconditionalrender: {let proc = get_proc_address("glEndConditionalRender"); if proc == null() {dummy_pfnglendconditionalrenderproc} else {unsafe{transmute(proc)}}},
			vertexattribipointer: {let proc = get_proc_address("glVertexAttribIPointer"); if proc == null() {dummy_pfnglvertexattribipointerproc} else {unsafe{transmute(proc)}}},
			getvertexattribiiv: {let proc = get_proc_address("glGetVertexAttribIiv"); if proc == null() {dummy_pfnglgetvertexattribiivproc} else {unsafe{transmute(proc)}}},
			getvertexattribiuiv: {let proc = get_proc_address("glGetVertexAttribIuiv"); if proc == null() {dummy_pfnglgetvertexattribiuivproc} else {unsafe{transmute(proc)}}},
			vertexattribi1i: {let proc = get_proc_address("glVertexAttribI1i"); if proc == null() {dummy_pfnglvertexattribi1iproc} else {unsafe{transmute(proc)}}},
			vertexattribi2i: {let proc = get_proc_address("glVertexAttribI2i"); if proc == null() {dummy_pfnglvertexattribi2iproc} else {unsafe{transmute(proc)}}},
			vertexattribi3i: {let proc = get_proc_address("glVertexAttribI3i"); if proc == null() {dummy_pfnglvertexattribi3iproc} else {unsafe{transmute(proc)}}},
			vertexattribi4i: {let proc = get_proc_address("glVertexAttribI4i"); if proc == null() {dummy_pfnglvertexattribi4iproc} else {unsafe{transmute(proc)}}},
			vertexattribi1ui: {let proc = get_proc_address("glVertexAttribI1ui"); if proc == null() {dummy_pfnglvertexattribi1uiproc} else {unsafe{transmute(proc)}}},
			vertexattribi2ui: {let proc = get_proc_address("glVertexAttribI2ui"); if proc == null() {dummy_pfnglvertexattribi2uiproc} else {unsafe{transmute(proc)}}},
			vertexattribi3ui: {let proc = get_proc_address("glVertexAttribI3ui"); if proc == null() {dummy_pfnglvertexattribi3uiproc} else {unsafe{transmute(proc)}}},
			vertexattribi4ui: {let proc = get_proc_address("glVertexAttribI4ui"); if proc == null() {dummy_pfnglvertexattribi4uiproc} else {unsafe{transmute(proc)}}},
			vertexattribi1iv: {let proc = get_proc_address("glVertexAttribI1iv"); if proc == null() {dummy_pfnglvertexattribi1ivproc} else {unsafe{transmute(proc)}}},
			vertexattribi2iv: {let proc = get_proc_address("glVertexAttribI2iv"); if proc == null() {dummy_pfnglvertexattribi2ivproc} else {unsafe{transmute(proc)}}},
			vertexattribi3iv: {let proc = get_proc_address("glVertexAttribI3iv"); if proc == null() {dummy_pfnglvertexattribi3ivproc} else {unsafe{transmute(proc)}}},
			vertexattribi4iv: {let proc = get_proc_address("glVertexAttribI4iv"); if proc == null() {dummy_pfnglvertexattribi4ivproc} else {unsafe{transmute(proc)}}},
			vertexattribi1uiv: {let proc = get_proc_address("glVertexAttribI1uiv"); if proc == null() {dummy_pfnglvertexattribi1uivproc} else {unsafe{transmute(proc)}}},
			vertexattribi2uiv: {let proc = get_proc_address("glVertexAttribI2uiv"); if proc == null() {dummy_pfnglvertexattribi2uivproc} else {unsafe{transmute(proc)}}},
			vertexattribi3uiv: {let proc = get_proc_address("glVertexAttribI3uiv"); if proc == null() {dummy_pfnglvertexattribi3uivproc} else {unsafe{transmute(proc)}}},
			vertexattribi4uiv: {let proc = get_proc_address("glVertexAttribI4uiv"); if proc == null() {dummy_pfnglvertexattribi4uivproc} else {unsafe{transmute(proc)}}},
			vertexattribi4bv: {let proc = get_proc_address("glVertexAttribI4bv"); if proc == null() {dummy_pfnglvertexattribi4bvproc} else {unsafe{transmute(proc)}}},
			vertexattribi4sv: {let proc = get_proc_address("glVertexAttribI4sv"); if proc == null() {dummy_pfnglvertexattribi4svproc} else {unsafe{transmute(proc)}}},
			vertexattribi4ubv: {let proc = get_proc_address("glVertexAttribI4ubv"); if proc == null() {dummy_pfnglvertexattribi4ubvproc} else {unsafe{transmute(proc)}}},
			vertexattribi4usv: {let proc = get_proc_address("glVertexAttribI4usv"); if proc == null() {dummy_pfnglvertexattribi4usvproc} else {unsafe{transmute(proc)}}},
			getuniformuiv: {let proc = get_proc_address("glGetUniformuiv"); if proc == null() {dummy_pfnglgetuniformuivproc} else {unsafe{transmute(proc)}}},
			bindfragdatalocation: {let proc = get_proc_address("glBindFragDataLocation"); if proc == null() {dummy_pfnglbindfragdatalocationproc} else {unsafe{transmute(proc)}}},
			getfragdatalocation: {let proc = get_proc_address("glGetFragDataLocation"); if proc == null() {dummy_pfnglgetfragdatalocationproc} else {unsafe{transmute(proc)}}},
			uniform1ui: {let proc = get_proc_address("glUniform1ui"); if proc == null() {dummy_pfngluniform1uiproc} else {unsafe{transmute(proc)}}},
			uniform2ui: {let proc = get_proc_address("glUniform2ui"); if proc == null() {dummy_pfngluniform2uiproc} else {unsafe{transmute(proc)}}},
			uniform3ui: {let proc = get_proc_address("glUniform3ui"); if proc == null() {dummy_pfngluniform3uiproc} else {unsafe{transmute(proc)}}},
			uniform4ui: {let proc = get_proc_address("glUniform4ui"); if proc == null() {dummy_pfngluniform4uiproc} else {unsafe{transmute(proc)}}},
			uniform1uiv: {let proc = get_proc_address("glUniform1uiv"); if proc == null() {dummy_pfngluniform1uivproc} else {unsafe{transmute(proc)}}},
			uniform2uiv: {let proc = get_proc_address("glUniform2uiv"); if proc == null() {dummy_pfngluniform2uivproc} else {unsafe{transmute(proc)}}},
			uniform3uiv: {let proc = get_proc_address("glUniform3uiv"); if proc == null() {dummy_pfngluniform3uivproc} else {unsafe{transmute(proc)}}},
			uniform4uiv: {let proc = get_proc_address("glUniform4uiv"); if proc == null() {dummy_pfngluniform4uivproc} else {unsafe{transmute(proc)}}},
			texparameteriiv: {let proc = get_proc_address("glTexParameterIiv"); if proc == null() {dummy_pfngltexparameteriivproc} else {unsafe{transmute(proc)}}},
			texparameteriuiv: {let proc = get_proc_address("glTexParameterIuiv"); if proc == null() {dummy_pfngltexparameteriuivproc} else {unsafe{transmute(proc)}}},
			gettexparameteriiv: {let proc = get_proc_address("glGetTexParameterIiv"); if proc == null() {dummy_pfnglgettexparameteriivproc} else {unsafe{transmute(proc)}}},
			gettexparameteriuiv: {let proc = get_proc_address("glGetTexParameterIuiv"); if proc == null() {dummy_pfnglgettexparameteriuivproc} else {unsafe{transmute(proc)}}},
			clearbufferiv: {let proc = get_proc_address("glClearBufferiv"); if proc == null() {dummy_pfnglclearbufferivproc} else {unsafe{transmute(proc)}}},
			clearbufferuiv: {let proc = get_proc_address("glClearBufferuiv"); if proc == null() {dummy_pfnglclearbufferuivproc} else {unsafe{transmute(proc)}}},
			clearbufferfv: {let proc = get_proc_address("glClearBufferfv"); if proc == null() {dummy_pfnglclearbufferfvproc} else {unsafe{transmute(proc)}}},
			clearbufferfi: {let proc = get_proc_address("glClearBufferfi"); if proc == null() {dummy_pfnglclearbufferfiproc} else {unsafe{transmute(proc)}}},
			getstringi: {let proc = get_proc_address("glGetStringi"); if proc == null() {dummy_pfnglgetstringiproc} else {unsafe{transmute(proc)}}},
			isrenderbuffer: {let proc = get_proc_address("glIsRenderbuffer"); if proc == null() {dummy_pfnglisrenderbufferproc} else {unsafe{transmute(proc)}}},
			bindrenderbuffer: {let proc = get_proc_address("glBindRenderbuffer"); if proc == null() {dummy_pfnglbindrenderbufferproc} else {unsafe{transmute(proc)}}},
			deleterenderbuffers: {let proc = get_proc_address("glDeleteRenderbuffers"); if proc == null() {dummy_pfngldeleterenderbuffersproc} else {unsafe{transmute(proc)}}},
			genrenderbuffers: {let proc = get_proc_address("glGenRenderbuffers"); if proc == null() {dummy_pfnglgenrenderbuffersproc} else {unsafe{transmute(proc)}}},
			renderbufferstorage: {let proc = get_proc_address("glRenderbufferStorage"); if proc == null() {dummy_pfnglrenderbufferstorageproc} else {unsafe{transmute(proc)}}},
			getrenderbufferparameteriv: {let proc = get_proc_address("glGetRenderbufferParameteriv"); if proc == null() {dummy_pfnglgetrenderbufferparameterivproc} else {unsafe{transmute(proc)}}},
			isframebuffer: {let proc = get_proc_address("glIsFramebuffer"); if proc == null() {dummy_pfnglisframebufferproc} else {unsafe{transmute(proc)}}},
			bindframebuffer: {let proc = get_proc_address("glBindFramebuffer"); if proc == null() {dummy_pfnglbindframebufferproc} else {unsafe{transmute(proc)}}},
			deleteframebuffers: {let proc = get_proc_address("glDeleteFramebuffers"); if proc == null() {dummy_pfngldeleteframebuffersproc} else {unsafe{transmute(proc)}}},
			genframebuffers: {let proc = get_proc_address("glGenFramebuffers"); if proc == null() {dummy_pfnglgenframebuffersproc} else {unsafe{transmute(proc)}}},
			checkframebufferstatus: {let proc = get_proc_address("glCheckFramebufferStatus"); if proc == null() {dummy_pfnglcheckframebufferstatusproc} else {unsafe{transmute(proc)}}},
			framebuffertexture1d: {let proc = get_proc_address("glFramebufferTexture1D"); if proc == null() {dummy_pfnglframebuffertexture1dproc} else {unsafe{transmute(proc)}}},
			framebuffertexture2d: {let proc = get_proc_address("glFramebufferTexture2D"); if proc == null() {dummy_pfnglframebuffertexture2dproc} else {unsafe{transmute(proc)}}},
			framebuffertexture3d: {let proc = get_proc_address("glFramebufferTexture3D"); if proc == null() {dummy_pfnglframebuffertexture3dproc} else {unsafe{transmute(proc)}}},
			framebufferrenderbuffer: {let proc = get_proc_address("glFramebufferRenderbuffer"); if proc == null() {dummy_pfnglframebufferrenderbufferproc} else {unsafe{transmute(proc)}}},
			getframebufferattachmentparameteriv: {let proc = get_proc_address("glGetFramebufferAttachmentParameteriv"); if proc == null() {dummy_pfnglgetframebufferattachmentparameterivproc} else {unsafe{transmute(proc)}}},
			generatemipmap: {let proc = get_proc_address("glGenerateMipmap"); if proc == null() {dummy_pfnglgeneratemipmapproc} else {unsafe{transmute(proc)}}},
			blitframebuffer: {let proc = get_proc_address("glBlitFramebuffer"); if proc == null() {dummy_pfnglblitframebufferproc} else {unsafe{transmute(proc)}}},
			renderbufferstoragemultisample: {let proc = get_proc_address("glRenderbufferStorageMultisample"); if proc == null() {dummy_pfnglrenderbufferstoragemultisampleproc} else {unsafe{transmute(proc)}}},
			framebuffertexturelayer: {let proc = get_proc_address("glFramebufferTextureLayer"); if proc == null() {dummy_pfnglframebuffertexturelayerproc} else {unsafe{transmute(proc)}}},
			mapbufferrange: {let proc = get_proc_address("glMapBufferRange"); if proc == null() {dummy_pfnglmapbufferrangeproc} else {unsafe{transmute(proc)}}},
			flushmappedbufferrange: {let proc = get_proc_address("glFlushMappedBufferRange"); if proc == null() {dummy_pfnglflushmappedbufferrangeproc} else {unsafe{transmute(proc)}}},
			bindvertexarray: {let proc = get_proc_address("glBindVertexArray"); if proc == null() {dummy_pfnglbindvertexarrayproc} else {unsafe{transmute(proc)}}},
			deletevertexarrays: {let proc = get_proc_address("glDeleteVertexArrays"); if proc == null() {dummy_pfngldeletevertexarraysproc} else {unsafe{transmute(proc)}}},
			genvertexarrays: {let proc = get_proc_address("glGenVertexArrays"); if proc == null() {dummy_pfnglgenvertexarraysproc} else {unsafe{transmute(proc)}}},
			isvertexarray: {let proc = get_proc_address("glIsVertexArray"); if proc == null() {dummy_pfnglisvertexarrayproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version30 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			colormaski: dummy_pfnglcolormaskiproc,
			getbooleani_v: dummy_pfnglgetbooleani_vproc,
			getintegeri_v: dummy_pfnglgetintegeri_vproc,
			enablei: dummy_pfnglenableiproc,
			disablei: dummy_pfngldisableiproc,
			isenabledi: dummy_pfnglisenablediproc,
			begintransformfeedback: dummy_pfnglbegintransformfeedbackproc,
			endtransformfeedback: dummy_pfnglendtransformfeedbackproc,
			bindbufferrange: dummy_pfnglbindbufferrangeproc,
			bindbufferbase: dummy_pfnglbindbufferbaseproc,
			transformfeedbackvaryings: dummy_pfngltransformfeedbackvaryingsproc,
			gettransformfeedbackvarying: dummy_pfnglgettransformfeedbackvaryingproc,
			clampcolor: dummy_pfnglclampcolorproc,
			beginconditionalrender: dummy_pfnglbeginconditionalrenderproc,
			endconditionalrender: dummy_pfnglendconditionalrenderproc,
			vertexattribipointer: dummy_pfnglvertexattribipointerproc,
			getvertexattribiiv: dummy_pfnglgetvertexattribiivproc,
			getvertexattribiuiv: dummy_pfnglgetvertexattribiuivproc,
			vertexattribi1i: dummy_pfnglvertexattribi1iproc,
			vertexattribi2i: dummy_pfnglvertexattribi2iproc,
			vertexattribi3i: dummy_pfnglvertexattribi3iproc,
			vertexattribi4i: dummy_pfnglvertexattribi4iproc,
			vertexattribi1ui: dummy_pfnglvertexattribi1uiproc,
			vertexattribi2ui: dummy_pfnglvertexattribi2uiproc,
			vertexattribi3ui: dummy_pfnglvertexattribi3uiproc,
			vertexattribi4ui: dummy_pfnglvertexattribi4uiproc,
			vertexattribi1iv: dummy_pfnglvertexattribi1ivproc,
			vertexattribi2iv: dummy_pfnglvertexattribi2ivproc,
			vertexattribi3iv: dummy_pfnglvertexattribi3ivproc,
			vertexattribi4iv: dummy_pfnglvertexattribi4ivproc,
			vertexattribi1uiv: dummy_pfnglvertexattribi1uivproc,
			vertexattribi2uiv: dummy_pfnglvertexattribi2uivproc,
			vertexattribi3uiv: dummy_pfnglvertexattribi3uivproc,
			vertexattribi4uiv: dummy_pfnglvertexattribi4uivproc,
			vertexattribi4bv: dummy_pfnglvertexattribi4bvproc,
			vertexattribi4sv: dummy_pfnglvertexattribi4svproc,
			vertexattribi4ubv: dummy_pfnglvertexattribi4ubvproc,
			vertexattribi4usv: dummy_pfnglvertexattribi4usvproc,
			getuniformuiv: dummy_pfnglgetuniformuivproc,
			bindfragdatalocation: dummy_pfnglbindfragdatalocationproc,
			getfragdatalocation: dummy_pfnglgetfragdatalocationproc,
			uniform1ui: dummy_pfngluniform1uiproc,
			uniform2ui: dummy_pfngluniform2uiproc,
			uniform3ui: dummy_pfngluniform3uiproc,
			uniform4ui: dummy_pfngluniform4uiproc,
			uniform1uiv: dummy_pfngluniform1uivproc,
			uniform2uiv: dummy_pfngluniform2uivproc,
			uniform3uiv: dummy_pfngluniform3uivproc,
			uniform4uiv: dummy_pfngluniform4uivproc,
			texparameteriiv: dummy_pfngltexparameteriivproc,
			texparameteriuiv: dummy_pfngltexparameteriuivproc,
			gettexparameteriiv: dummy_pfnglgettexparameteriivproc,
			gettexparameteriuiv: dummy_pfnglgettexparameteriuivproc,
			clearbufferiv: dummy_pfnglclearbufferivproc,
			clearbufferuiv: dummy_pfnglclearbufferuivproc,
			clearbufferfv: dummy_pfnglclearbufferfvproc,
			clearbufferfi: dummy_pfnglclearbufferfiproc,
			getstringi: dummy_pfnglgetstringiproc,
			isrenderbuffer: dummy_pfnglisrenderbufferproc,
			bindrenderbuffer: dummy_pfnglbindrenderbufferproc,
			deleterenderbuffers: dummy_pfngldeleterenderbuffersproc,
			genrenderbuffers: dummy_pfnglgenrenderbuffersproc,
			renderbufferstorage: dummy_pfnglrenderbufferstorageproc,
			getrenderbufferparameteriv: dummy_pfnglgetrenderbufferparameterivproc,
			isframebuffer: dummy_pfnglisframebufferproc,
			bindframebuffer: dummy_pfnglbindframebufferproc,
			deleteframebuffers: dummy_pfngldeleteframebuffersproc,
			genframebuffers: dummy_pfnglgenframebuffersproc,
			checkframebufferstatus: dummy_pfnglcheckframebufferstatusproc,
			framebuffertexture1d: dummy_pfnglframebuffertexture1dproc,
			framebuffertexture2d: dummy_pfnglframebuffertexture2dproc,
			framebuffertexture3d: dummy_pfnglframebuffertexture3dproc,
			framebufferrenderbuffer: dummy_pfnglframebufferrenderbufferproc,
			getframebufferattachmentparameteriv: dummy_pfnglgetframebufferattachmentparameterivproc,
			generatemipmap: dummy_pfnglgeneratemipmapproc,
			blitframebuffer: dummy_pfnglblitframebufferproc,
			renderbufferstoragemultisample: dummy_pfnglrenderbufferstoragemultisampleproc,
			framebuffertexturelayer: dummy_pfnglframebuffertexturelayerproc,
			mapbufferrange: dummy_pfnglmapbufferrangeproc,
			flushmappedbufferrange: dummy_pfnglflushmappedbufferrangeproc,
			bindvertexarray: dummy_pfnglbindvertexarrayproc,
			deletevertexarrays: dummy_pfngldeletevertexarraysproc,
			genvertexarrays: dummy_pfnglgenvertexarraysproc,
			isvertexarray: dummy_pfnglisvertexarrayproc,
		}
	}
}
impl Debug for Version30 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version30")
			.field("available", &self.available)
			.field("colormaski", unsafe{if transmute::<_, *const c_void>(self.colormaski) == (dummy_pfnglcolormaskiproc as *const c_void) {&null::<PFNGLCOLORMASKIPROC>()} else {&self.colormaski}})
			.field("getbooleani_v", unsafe{if transmute::<_, *const c_void>(self.getbooleani_v) == (dummy_pfnglgetbooleani_vproc as *const c_void) {&null::<PFNGLGETBOOLEANI_VPROC>()} else {&self.getbooleani_v}})
			.field("getintegeri_v", unsafe{if transmute::<_, *const c_void>(self.getintegeri_v) == (dummy_pfnglgetintegeri_vproc as *const c_void) {&null::<PFNGLGETINTEGERI_VPROC>()} else {&self.getintegeri_v}})
			.field("enablei", unsafe{if transmute::<_, *const c_void>(self.enablei) == (dummy_pfnglenableiproc as *const c_void) {&null::<PFNGLENABLEIPROC>()} else {&self.enablei}})
			.field("disablei", unsafe{if transmute::<_, *const c_void>(self.disablei) == (dummy_pfngldisableiproc as *const c_void) {&null::<PFNGLDISABLEIPROC>()} else {&self.disablei}})
			.field("isenabledi", unsafe{if transmute::<_, *const c_void>(self.isenabledi) == (dummy_pfnglisenablediproc as *const c_void) {&null::<PFNGLISENABLEDIPROC>()} else {&self.isenabledi}})
			.field("begintransformfeedback", unsafe{if transmute::<_, *const c_void>(self.begintransformfeedback) == (dummy_pfnglbegintransformfeedbackproc as *const c_void) {&null::<PFNGLBEGINTRANSFORMFEEDBACKPROC>()} else {&self.begintransformfeedback}})
			.field("endtransformfeedback", unsafe{if transmute::<_, *const c_void>(self.endtransformfeedback) == (dummy_pfnglendtransformfeedbackproc as *const c_void) {&null::<PFNGLENDTRANSFORMFEEDBACKPROC>()} else {&self.endtransformfeedback}})
			.field("bindbufferrange", unsafe{if transmute::<_, *const c_void>(self.bindbufferrange) == (dummy_pfnglbindbufferrangeproc as *const c_void) {&null::<PFNGLBINDBUFFERRANGEPROC>()} else {&self.bindbufferrange}})
			.field("bindbufferbase", unsafe{if transmute::<_, *const c_void>(self.bindbufferbase) == (dummy_pfnglbindbufferbaseproc as *const c_void) {&null::<PFNGLBINDBUFFERBASEPROC>()} else {&self.bindbufferbase}})
			.field("transformfeedbackvaryings", unsafe{if transmute::<_, *const c_void>(self.transformfeedbackvaryings) == (dummy_pfngltransformfeedbackvaryingsproc as *const c_void) {&null::<PFNGLTRANSFORMFEEDBACKVARYINGSPROC>()} else {&self.transformfeedbackvaryings}})
			.field("gettransformfeedbackvarying", unsafe{if transmute::<_, *const c_void>(self.gettransformfeedbackvarying) == (dummy_pfnglgettransformfeedbackvaryingproc as *const c_void) {&null::<PFNGLGETTRANSFORMFEEDBACKVARYINGPROC>()} else {&self.gettransformfeedbackvarying}})
			.field("clampcolor", unsafe{if transmute::<_, *const c_void>(self.clampcolor) == (dummy_pfnglclampcolorproc as *const c_void) {&null::<PFNGLCLAMPCOLORPROC>()} else {&self.clampcolor}})
			.field("beginconditionalrender", unsafe{if transmute::<_, *const c_void>(self.beginconditionalrender) == (dummy_pfnglbeginconditionalrenderproc as *const c_void) {&null::<PFNGLBEGINCONDITIONALRENDERPROC>()} else {&self.beginconditionalrender}})
			.field("endconditionalrender", unsafe{if transmute::<_, *const c_void>(self.endconditionalrender) == (dummy_pfnglendconditionalrenderproc as *const c_void) {&null::<PFNGLENDCONDITIONALRENDERPROC>()} else {&self.endconditionalrender}})
			.field("vertexattribipointer", unsafe{if transmute::<_, *const c_void>(self.vertexattribipointer) == (dummy_pfnglvertexattribipointerproc as *const c_void) {&null::<PFNGLVERTEXATTRIBIPOINTERPROC>()} else {&self.vertexattribipointer}})
			.field("getvertexattribiiv", unsafe{if transmute::<_, *const c_void>(self.getvertexattribiiv) == (dummy_pfnglgetvertexattribiivproc as *const c_void) {&null::<PFNGLGETVERTEXATTRIBIIVPROC>()} else {&self.getvertexattribiiv}})
			.field("getvertexattribiuiv", unsafe{if transmute::<_, *const c_void>(self.getvertexattribiuiv) == (dummy_pfnglgetvertexattribiuivproc as *const c_void) {&null::<PFNGLGETVERTEXATTRIBIUIVPROC>()} else {&self.getvertexattribiuiv}})
			.field("vertexattribi1i", unsafe{if transmute::<_, *const c_void>(self.vertexattribi1i) == (dummy_pfnglvertexattribi1iproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI1IPROC>()} else {&self.vertexattribi1i}})
			.field("vertexattribi2i", unsafe{if transmute::<_, *const c_void>(self.vertexattribi2i) == (dummy_pfnglvertexattribi2iproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI2IPROC>()} else {&self.vertexattribi2i}})
			.field("vertexattribi3i", unsafe{if transmute::<_, *const c_void>(self.vertexattribi3i) == (dummy_pfnglvertexattribi3iproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI3IPROC>()} else {&self.vertexattribi3i}})
			.field("vertexattribi4i", unsafe{if transmute::<_, *const c_void>(self.vertexattribi4i) == (dummy_pfnglvertexattribi4iproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI4IPROC>()} else {&self.vertexattribi4i}})
			.field("vertexattribi1ui", unsafe{if transmute::<_, *const c_void>(self.vertexattribi1ui) == (dummy_pfnglvertexattribi1uiproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI1UIPROC>()} else {&self.vertexattribi1ui}})
			.field("vertexattribi2ui", unsafe{if transmute::<_, *const c_void>(self.vertexattribi2ui) == (dummy_pfnglvertexattribi2uiproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI2UIPROC>()} else {&self.vertexattribi2ui}})
			.field("vertexattribi3ui", unsafe{if transmute::<_, *const c_void>(self.vertexattribi3ui) == (dummy_pfnglvertexattribi3uiproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI3UIPROC>()} else {&self.vertexattribi3ui}})
			.field("vertexattribi4ui", unsafe{if transmute::<_, *const c_void>(self.vertexattribi4ui) == (dummy_pfnglvertexattribi4uiproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI4UIPROC>()} else {&self.vertexattribi4ui}})
			.field("vertexattribi1iv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi1iv) == (dummy_pfnglvertexattribi1ivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI1IVPROC>()} else {&self.vertexattribi1iv}})
			.field("vertexattribi2iv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi2iv) == (dummy_pfnglvertexattribi2ivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI2IVPROC>()} else {&self.vertexattribi2iv}})
			.field("vertexattribi3iv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi3iv) == (dummy_pfnglvertexattribi3ivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI3IVPROC>()} else {&self.vertexattribi3iv}})
			.field("vertexattribi4iv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi4iv) == (dummy_pfnglvertexattribi4ivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI4IVPROC>()} else {&self.vertexattribi4iv}})
			.field("vertexattribi1uiv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi1uiv) == (dummy_pfnglvertexattribi1uivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI1UIVPROC>()} else {&self.vertexattribi1uiv}})
			.field("vertexattribi2uiv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi2uiv) == (dummy_pfnglvertexattribi2uivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI2UIVPROC>()} else {&self.vertexattribi2uiv}})
			.field("vertexattribi3uiv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi3uiv) == (dummy_pfnglvertexattribi3uivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI3UIVPROC>()} else {&self.vertexattribi3uiv}})
			.field("vertexattribi4uiv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi4uiv) == (dummy_pfnglvertexattribi4uivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI4UIVPROC>()} else {&self.vertexattribi4uiv}})
			.field("vertexattribi4bv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi4bv) == (dummy_pfnglvertexattribi4bvproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI4BVPROC>()} else {&self.vertexattribi4bv}})
			.field("vertexattribi4sv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi4sv) == (dummy_pfnglvertexattribi4svproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI4SVPROC>()} else {&self.vertexattribi4sv}})
			.field("vertexattribi4ubv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi4ubv) == (dummy_pfnglvertexattribi4ubvproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI4UBVPROC>()} else {&self.vertexattribi4ubv}})
			.field("vertexattribi4usv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi4usv) == (dummy_pfnglvertexattribi4usvproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI4USVPROC>()} else {&self.vertexattribi4usv}})
			.field("getuniformuiv", unsafe{if transmute::<_, *const c_void>(self.getuniformuiv) == (dummy_pfnglgetuniformuivproc as *const c_void) {&null::<PFNGLGETUNIFORMUIVPROC>()} else {&self.getuniformuiv}})
			.field("bindfragdatalocation", unsafe{if transmute::<_, *const c_void>(self.bindfragdatalocation) == (dummy_pfnglbindfragdatalocationproc as *const c_void) {&null::<PFNGLBINDFRAGDATALOCATIONPROC>()} else {&self.bindfragdatalocation}})
			.field("getfragdatalocation", unsafe{if transmute::<_, *const c_void>(self.getfragdatalocation) == (dummy_pfnglgetfragdatalocationproc as *const c_void) {&null::<PFNGLGETFRAGDATALOCATIONPROC>()} else {&self.getfragdatalocation}})
			.field("uniform1ui", unsafe{if transmute::<_, *const c_void>(self.uniform1ui) == (dummy_pfngluniform1uiproc as *const c_void) {&null::<PFNGLUNIFORM1UIPROC>()} else {&self.uniform1ui}})
			.field("uniform2ui", unsafe{if transmute::<_, *const c_void>(self.uniform2ui) == (dummy_pfngluniform2uiproc as *const c_void) {&null::<PFNGLUNIFORM2UIPROC>()} else {&self.uniform2ui}})
			.field("uniform3ui", unsafe{if transmute::<_, *const c_void>(self.uniform3ui) == (dummy_pfngluniform3uiproc as *const c_void) {&null::<PFNGLUNIFORM3UIPROC>()} else {&self.uniform3ui}})
			.field("uniform4ui", unsafe{if transmute::<_, *const c_void>(self.uniform4ui) == (dummy_pfngluniform4uiproc as *const c_void) {&null::<PFNGLUNIFORM4UIPROC>()} else {&self.uniform4ui}})
			.field("uniform1uiv", unsafe{if transmute::<_, *const c_void>(self.uniform1uiv) == (dummy_pfngluniform1uivproc as *const c_void) {&null::<PFNGLUNIFORM1UIVPROC>()} else {&self.uniform1uiv}})
			.field("uniform2uiv", unsafe{if transmute::<_, *const c_void>(self.uniform2uiv) == (dummy_pfngluniform2uivproc as *const c_void) {&null::<PFNGLUNIFORM2UIVPROC>()} else {&self.uniform2uiv}})
			.field("uniform3uiv", unsafe{if transmute::<_, *const c_void>(self.uniform3uiv) == (dummy_pfngluniform3uivproc as *const c_void) {&null::<PFNGLUNIFORM3UIVPROC>()} else {&self.uniform3uiv}})
			.field("uniform4uiv", unsafe{if transmute::<_, *const c_void>(self.uniform4uiv) == (dummy_pfngluniform4uivproc as *const c_void) {&null::<PFNGLUNIFORM4UIVPROC>()} else {&self.uniform4uiv}})
			.field("texparameteriiv", unsafe{if transmute::<_, *const c_void>(self.texparameteriiv) == (dummy_pfngltexparameteriivproc as *const c_void) {&null::<PFNGLTEXPARAMETERIIVPROC>()} else {&self.texparameteriiv}})
			.field("texparameteriuiv", unsafe{if transmute::<_, *const c_void>(self.texparameteriuiv) == (dummy_pfngltexparameteriuivproc as *const c_void) {&null::<PFNGLTEXPARAMETERIUIVPROC>()} else {&self.texparameteriuiv}})
			.field("gettexparameteriiv", unsafe{if transmute::<_, *const c_void>(self.gettexparameteriiv) == (dummy_pfnglgettexparameteriivproc as *const c_void) {&null::<PFNGLGETTEXPARAMETERIIVPROC>()} else {&self.gettexparameteriiv}})
			.field("gettexparameteriuiv", unsafe{if transmute::<_, *const c_void>(self.gettexparameteriuiv) == (dummy_pfnglgettexparameteriuivproc as *const c_void) {&null::<PFNGLGETTEXPARAMETERIUIVPROC>()} else {&self.gettexparameteriuiv}})
			.field("clearbufferiv", unsafe{if transmute::<_, *const c_void>(self.clearbufferiv) == (dummy_pfnglclearbufferivproc as *const c_void) {&null::<PFNGLCLEARBUFFERIVPROC>()} else {&self.clearbufferiv}})
			.field("clearbufferuiv", unsafe{if transmute::<_, *const c_void>(self.clearbufferuiv) == (dummy_pfnglclearbufferuivproc as *const c_void) {&null::<PFNGLCLEARBUFFERUIVPROC>()} else {&self.clearbufferuiv}})
			.field("clearbufferfv", unsafe{if transmute::<_, *const c_void>(self.clearbufferfv) == (dummy_pfnglclearbufferfvproc as *const c_void) {&null::<PFNGLCLEARBUFFERFVPROC>()} else {&self.clearbufferfv}})
			.field("clearbufferfi", unsafe{if transmute::<_, *const c_void>(self.clearbufferfi) == (dummy_pfnglclearbufferfiproc as *const c_void) {&null::<PFNGLCLEARBUFFERFIPROC>()} else {&self.clearbufferfi}})
			.field("getstringi", unsafe{if transmute::<_, *const c_void>(self.getstringi) == (dummy_pfnglgetstringiproc as *const c_void) {&null::<PFNGLGETSTRINGIPROC>()} else {&self.getstringi}})
			.field("isrenderbuffer", unsafe{if transmute::<_, *const c_void>(self.isrenderbuffer) == (dummy_pfnglisrenderbufferproc as *const c_void) {&null::<PFNGLISRENDERBUFFERPROC>()} else {&self.isrenderbuffer}})
			.field("bindrenderbuffer", unsafe{if transmute::<_, *const c_void>(self.bindrenderbuffer) == (dummy_pfnglbindrenderbufferproc as *const c_void) {&null::<PFNGLBINDRENDERBUFFERPROC>()} else {&self.bindrenderbuffer}})
			.field("deleterenderbuffers", unsafe{if transmute::<_, *const c_void>(self.deleterenderbuffers) == (dummy_pfngldeleterenderbuffersproc as *const c_void) {&null::<PFNGLDELETERENDERBUFFERSPROC>()} else {&self.deleterenderbuffers}})
			.field("genrenderbuffers", unsafe{if transmute::<_, *const c_void>(self.genrenderbuffers) == (dummy_pfnglgenrenderbuffersproc as *const c_void) {&null::<PFNGLGENRENDERBUFFERSPROC>()} else {&self.genrenderbuffers}})
			.field("renderbufferstorage", unsafe{if transmute::<_, *const c_void>(self.renderbufferstorage) == (dummy_pfnglrenderbufferstorageproc as *const c_void) {&null::<PFNGLRENDERBUFFERSTORAGEPROC>()} else {&self.renderbufferstorage}})
			.field("getrenderbufferparameteriv", unsafe{if transmute::<_, *const c_void>(self.getrenderbufferparameteriv) == (dummy_pfnglgetrenderbufferparameterivproc as *const c_void) {&null::<PFNGLGETRENDERBUFFERPARAMETERIVPROC>()} else {&self.getrenderbufferparameteriv}})
			.field("isframebuffer", unsafe{if transmute::<_, *const c_void>(self.isframebuffer) == (dummy_pfnglisframebufferproc as *const c_void) {&null::<PFNGLISFRAMEBUFFERPROC>()} else {&self.isframebuffer}})
			.field("bindframebuffer", unsafe{if transmute::<_, *const c_void>(self.bindframebuffer) == (dummy_pfnglbindframebufferproc as *const c_void) {&null::<PFNGLBINDFRAMEBUFFERPROC>()} else {&self.bindframebuffer}})
			.field("deleteframebuffers", unsafe{if transmute::<_, *const c_void>(self.deleteframebuffers) == (dummy_pfngldeleteframebuffersproc as *const c_void) {&null::<PFNGLDELETEFRAMEBUFFERSPROC>()} else {&self.deleteframebuffers}})
			.field("genframebuffers", unsafe{if transmute::<_, *const c_void>(self.genframebuffers) == (dummy_pfnglgenframebuffersproc as *const c_void) {&null::<PFNGLGENFRAMEBUFFERSPROC>()} else {&self.genframebuffers}})
			.field("checkframebufferstatus", unsafe{if transmute::<_, *const c_void>(self.checkframebufferstatus) == (dummy_pfnglcheckframebufferstatusproc as *const c_void) {&null::<PFNGLCHECKFRAMEBUFFERSTATUSPROC>()} else {&self.checkframebufferstatus}})
			.field("framebuffertexture1d", unsafe{if transmute::<_, *const c_void>(self.framebuffertexture1d) == (dummy_pfnglframebuffertexture1dproc as *const c_void) {&null::<PFNGLFRAMEBUFFERTEXTURE1DPROC>()} else {&self.framebuffertexture1d}})
			.field("framebuffertexture2d", unsafe{if transmute::<_, *const c_void>(self.framebuffertexture2d) == (dummy_pfnglframebuffertexture2dproc as *const c_void) {&null::<PFNGLFRAMEBUFFERTEXTURE2DPROC>()} else {&self.framebuffertexture2d}})
			.field("framebuffertexture3d", unsafe{if transmute::<_, *const c_void>(self.framebuffertexture3d) == (dummy_pfnglframebuffertexture3dproc as *const c_void) {&null::<PFNGLFRAMEBUFFERTEXTURE3DPROC>()} else {&self.framebuffertexture3d}})
			.field("framebufferrenderbuffer", unsafe{if transmute::<_, *const c_void>(self.framebufferrenderbuffer) == (dummy_pfnglframebufferrenderbufferproc as *const c_void) {&null::<PFNGLFRAMEBUFFERRENDERBUFFERPROC>()} else {&self.framebufferrenderbuffer}})
			.field("getframebufferattachmentparameteriv", unsafe{if transmute::<_, *const c_void>(self.getframebufferattachmentparameteriv) == (dummy_pfnglgetframebufferattachmentparameterivproc as *const c_void) {&null::<PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC>()} else {&self.getframebufferattachmentparameteriv}})
			.field("generatemipmap", unsafe{if transmute::<_, *const c_void>(self.generatemipmap) == (dummy_pfnglgeneratemipmapproc as *const c_void) {&null::<PFNGLGENERATEMIPMAPPROC>()} else {&self.generatemipmap}})
			.field("blitframebuffer", unsafe{if transmute::<_, *const c_void>(self.blitframebuffer) == (dummy_pfnglblitframebufferproc as *const c_void) {&null::<PFNGLBLITFRAMEBUFFERPROC>()} else {&self.blitframebuffer}})
			.field("renderbufferstoragemultisample", unsafe{if transmute::<_, *const c_void>(self.renderbufferstoragemultisample) == (dummy_pfnglrenderbufferstoragemultisampleproc as *const c_void) {&null::<PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC>()} else {&self.renderbufferstoragemultisample}})
			.field("framebuffertexturelayer", unsafe{if transmute::<_, *const c_void>(self.framebuffertexturelayer) == (dummy_pfnglframebuffertexturelayerproc as *const c_void) {&null::<PFNGLFRAMEBUFFERTEXTURELAYERPROC>()} else {&self.framebuffertexturelayer}})
			.field("mapbufferrange", unsafe{if transmute::<_, *const c_void>(self.mapbufferrange) == (dummy_pfnglmapbufferrangeproc as *const c_void) {&null::<PFNGLMAPBUFFERRANGEPROC>()} else {&self.mapbufferrange}})
			.field("flushmappedbufferrange", unsafe{if transmute::<_, *const c_void>(self.flushmappedbufferrange) == (dummy_pfnglflushmappedbufferrangeproc as *const c_void) {&null::<PFNGLFLUSHMAPPEDBUFFERRANGEPROC>()} else {&self.flushmappedbufferrange}})
			.field("bindvertexarray", unsafe{if transmute::<_, *const c_void>(self.bindvertexarray) == (dummy_pfnglbindvertexarrayproc as *const c_void) {&null::<PFNGLBINDVERTEXARRAYPROC>()} else {&self.bindvertexarray}})
			.field("deletevertexarrays", unsafe{if transmute::<_, *const c_void>(self.deletevertexarrays) == (dummy_pfngldeletevertexarraysproc as *const c_void) {&null::<PFNGLDELETEVERTEXARRAYSPROC>()} else {&self.deletevertexarrays}})
			.field("genvertexarrays", unsafe{if transmute::<_, *const c_void>(self.genvertexarrays) == (dummy_pfnglgenvertexarraysproc as *const c_void) {&null::<PFNGLGENVERTEXARRAYSPROC>()} else {&self.genvertexarrays}})
			.field("isvertexarray", unsafe{if transmute::<_, *const c_void>(self.isvertexarray) == (dummy_pfnglisvertexarrayproc as *const c_void) {&null::<PFNGLISVERTEXARRAYPROC>()} else {&self.isvertexarray}})
			.finish()
		} else {
			f.debug_struct("Version30")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

/// The prototype to the OpenGL function `DrawArraysInstanced`
type PFNGLDRAWARRAYSINSTANCEDPROC = extern "system" fn(GLenum, GLint, GLsizei, GLsizei);

/// The prototype to the OpenGL function `DrawElementsInstanced`
type PFNGLDRAWELEMENTSINSTANCEDPROC = extern "system" fn(GLenum, GLsizei, GLenum, *const c_void, GLsizei);

/// The prototype to the OpenGL function `TexBuffer`
type PFNGLTEXBUFFERPROC = extern "system" fn(GLenum, GLenum, GLuint);

/// The prototype to the OpenGL function `PrimitiveRestartIndex`
type PFNGLPRIMITIVERESTARTINDEXPROC = extern "system" fn(GLuint);

/// The prototype to the OpenGL function `CopyBufferSubData`
type PFNGLCOPYBUFFERSUBDATAPROC = extern "system" fn(GLenum, GLenum, GLintptr, GLintptr, GLsizeiptr);

/// The prototype to the OpenGL function `GetUniformIndices`
type PFNGLGETUNIFORMINDICESPROC = extern "system" fn(GLuint, GLsizei, *const *const GLchar, *mut GLuint);

/// The prototype to the OpenGL function `GetActiveUniformsiv`
type PFNGLGETACTIVEUNIFORMSIVPROC = extern "system" fn(GLuint, GLsizei, *const GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetActiveUniformName`
type PFNGLGETACTIVEUNIFORMNAMEPROC = extern "system" fn(GLuint, GLuint, GLsizei, *mut GLsizei, *mut GLchar);

/// The prototype to the OpenGL function `GetUniformBlockIndex`
type PFNGLGETUNIFORMBLOCKINDEXPROC = extern "system" fn(GLuint, *const GLchar) -> GLuint;

/// The prototype to the OpenGL function `GetActiveUniformBlockiv`
type PFNGLGETACTIVEUNIFORMBLOCKIVPROC = extern "system" fn(GLuint, GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetActiveUniformBlockName`
type PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC = extern "system" fn(GLuint, GLuint, GLsizei, *mut GLsizei, *mut GLchar);

/// The prototype to the OpenGL function `UniformBlockBinding`
type PFNGLUNIFORMBLOCKBINDINGPROC = extern "system" fn(GLuint, GLuint, GLuint);

/// The dummy function of `DrawArraysInstanced()`
extern "system" fn dummy_pfngldrawarraysinstancedproc (_: GLenum, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glDrawArraysInstanced()` is null.")
}

/// The dummy function of `DrawElementsInstanced()`
extern "system" fn dummy_pfngldrawelementsinstancedproc (_: GLenum, _: GLsizei, _: GLenum, _: *const c_void, _: GLsizei) {
	panic!("OpenGL function pointer `glDrawElementsInstanced()` is null.")
}

/// The dummy function of `TexBuffer()`
extern "system" fn dummy_pfngltexbufferproc (_: GLenum, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glTexBuffer()` is null.")
}

/// The dummy function of `PrimitiveRestartIndex()`
extern "system" fn dummy_pfnglprimitiverestartindexproc (_: GLuint) {
	panic!("OpenGL function pointer `glPrimitiveRestartIndex()` is null.")
}

/// The dummy function of `CopyBufferSubData()`
extern "system" fn dummy_pfnglcopybuffersubdataproc (_: GLenum, _: GLenum, _: GLintptr, _: GLintptr, _: GLsizeiptr) {
	panic!("OpenGL function pointer `glCopyBufferSubData()` is null.")
}

/// The dummy function of `GetUniformIndices()`
extern "system" fn dummy_pfnglgetuniformindicesproc (_: GLuint, _: GLsizei, _: *const *const GLchar, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetUniformIndices()` is null.")
}

/// The dummy function of `GetActiveUniformsiv()`
extern "system" fn dummy_pfnglgetactiveuniformsivproc (_: GLuint, _: GLsizei, _: *const GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetActiveUniformsiv()` is null.")
}

/// The dummy function of `GetActiveUniformName()`
extern "system" fn dummy_pfnglgetactiveuniformnameproc (_: GLuint, _: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetActiveUniformName()` is null.")
}

/// The dummy function of `GetUniformBlockIndex()`
extern "system" fn dummy_pfnglgetuniformblockindexproc (_: GLuint, _: *const GLchar) -> GLuint {
	panic!("OpenGL function pointer `glGetUniformBlockIndex()` is null.")
}

/// The dummy function of `GetActiveUniformBlockiv()`
extern "system" fn dummy_pfnglgetactiveuniformblockivproc (_: GLuint, _: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetActiveUniformBlockiv()` is null.")
}

/// The dummy function of `GetActiveUniformBlockName()`
extern "system" fn dummy_pfnglgetactiveuniformblocknameproc (_: GLuint, _: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetActiveUniformBlockName()` is null.")
}

/// The dummy function of `UniformBlockBinding()`
extern "system" fn dummy_pfngluniformblockbindingproc (_: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glUniformBlockBinding()` is null.")
}
/// Constant value defined from OpenGL 3.1
pub const GL_SAMPLER_2D_RECT: GLenum = 0x8B63;

/// Constant value defined from OpenGL 3.1
pub const GL_SAMPLER_2D_RECT_SHADOW: GLenum = 0x8B64;

/// Constant value defined from OpenGL 3.1
pub const GL_SAMPLER_BUFFER: GLenum = 0x8DC2;

/// Constant value defined from OpenGL 3.1
pub const GL_INT_SAMPLER_2D_RECT: GLenum = 0x8DCD;

/// Constant value defined from OpenGL 3.1
pub const GL_INT_SAMPLER_BUFFER: GLenum = 0x8DD0;

/// Constant value defined from OpenGL 3.1
pub const GL_UNSIGNED_INT_SAMPLER_2D_RECT: GLenum = 0x8DD5;

/// Constant value defined from OpenGL 3.1
pub const GL_UNSIGNED_INT_SAMPLER_BUFFER: GLenum = 0x8DD8;

/// Constant value defined from OpenGL 3.1
pub const GL_TEXTURE_BUFFER: GLenum = 0x8C2A;

/// Constant value defined from OpenGL 3.1
pub const GL_MAX_TEXTURE_BUFFER_SIZE: GLenum = 0x8C2B;

/// Constant value defined from OpenGL 3.1
pub const GL_TEXTURE_BINDING_BUFFER: GLenum = 0x8C2C;

/// Constant value defined from OpenGL 3.1
pub const GL_TEXTURE_BUFFER_DATA_STORE_BINDING: GLenum = 0x8C2D;

/// Constant value defined from OpenGL 3.1
pub const GL_TEXTURE_RECTANGLE: GLenum = 0x84F5;

/// Constant value defined from OpenGL 3.1
pub const GL_TEXTURE_BINDING_RECTANGLE: GLenum = 0x84F6;

/// Constant value defined from OpenGL 3.1
pub const GL_PROXY_TEXTURE_RECTANGLE: GLenum = 0x84F7;

/// Constant value defined from OpenGL 3.1
pub const GL_MAX_RECTANGLE_TEXTURE_SIZE: GLenum = 0x84F8;

/// Constant value defined from OpenGL 3.1
pub const GL_R8_SNORM: GLenum = 0x8F94;

/// Constant value defined from OpenGL 3.1
pub const GL_RG8_SNORM: GLenum = 0x8F95;

/// Constant value defined from OpenGL 3.1
pub const GL_RGB8_SNORM: GLenum = 0x8F96;

/// Constant value defined from OpenGL 3.1
pub const GL_RGBA8_SNORM: GLenum = 0x8F97;

/// Constant value defined from OpenGL 3.1
pub const GL_R16_SNORM: GLenum = 0x8F98;

/// Constant value defined from OpenGL 3.1
pub const GL_RG16_SNORM: GLenum = 0x8F99;

/// Constant value defined from OpenGL 3.1
pub const GL_RGB16_SNORM: GLenum = 0x8F9A;

/// Constant value defined from OpenGL 3.1
pub const GL_RGBA16_SNORM: GLenum = 0x8F9B;

/// Constant value defined from OpenGL 3.1
pub const GL_SIGNED_NORMALIZED: GLenum = 0x8F9C;

/// Constant value defined from OpenGL 3.1
pub const GL_PRIMITIVE_RESTART: GLenum = 0x8F9D;

/// Constant value defined from OpenGL 3.1
pub const GL_PRIMITIVE_RESTART_INDEX: GLenum = 0x8F9E;

/// Constant value defined from OpenGL 3.1
pub const GL_COPY_READ_BUFFER: GLenum = 0x8F36;

/// Constant value defined from OpenGL 3.1
pub const GL_COPY_WRITE_BUFFER: GLenum = 0x8F37;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_BUFFER: GLenum = 0x8A11;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_BUFFER_BINDING: GLenum = 0x8A28;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_BUFFER_START: GLenum = 0x8A29;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_BUFFER_SIZE: GLenum = 0x8A2A;

/// Constant value defined from OpenGL 3.1
pub const GL_MAX_VERTEX_UNIFORM_BLOCKS: GLenum = 0x8A2B;

/// Constant value defined from OpenGL 3.1
pub const GL_MAX_GEOMETRY_UNIFORM_BLOCKS: GLenum = 0x8A2C;

/// Constant value defined from OpenGL 3.1
pub const GL_MAX_FRAGMENT_UNIFORM_BLOCKS: GLenum = 0x8A2D;

/// Constant value defined from OpenGL 3.1
pub const GL_MAX_COMBINED_UNIFORM_BLOCKS: GLenum = 0x8A2E;

/// Constant value defined from OpenGL 3.1
pub const GL_MAX_UNIFORM_BUFFER_BINDINGS: GLenum = 0x8A2F;

/// Constant value defined from OpenGL 3.1
pub const GL_MAX_UNIFORM_BLOCK_SIZE: GLenum = 0x8A30;

/// Constant value defined from OpenGL 3.1
pub const GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: GLenum = 0x8A31;

/// Constant value defined from OpenGL 3.1
pub const GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS: GLenum = 0x8A32;

/// Constant value defined from OpenGL 3.1
pub const GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: GLenum = 0x8A33;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT: GLenum = 0x8A34;

/// Constant value defined from OpenGL 3.1
pub const GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH: GLenum = 0x8A35;

/// Constant value defined from OpenGL 3.1
pub const GL_ACTIVE_UNIFORM_BLOCKS: GLenum = 0x8A36;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_TYPE: GLenum = 0x8A37;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_SIZE: GLenum = 0x8A38;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_NAME_LENGTH: GLenum = 0x8A39;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_BLOCK_INDEX: GLenum = 0x8A3A;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_OFFSET: GLenum = 0x8A3B;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_ARRAY_STRIDE: GLenum = 0x8A3C;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_MATRIX_STRIDE: GLenum = 0x8A3D;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_IS_ROW_MAJOR: GLenum = 0x8A3E;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_BLOCK_BINDING: GLenum = 0x8A3F;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_BLOCK_DATA_SIZE: GLenum = 0x8A40;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_BLOCK_NAME_LENGTH: GLenum = 0x8A41;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS: GLenum = 0x8A42;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: GLenum = 0x8A43;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: GLenum = 0x8A44;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER: GLenum = 0x8A45;

/// Constant value defined from OpenGL 3.1
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: GLenum = 0x8A46;

/// Constant value defined from OpenGL 3.1
pub const GL_INVALID_INDEX: GLuint = 0xFFFFFFFFu32;

/// Functions from OpenGL version 3.1
pub trait GL_3_1 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	fn glGetError(&self) -> GLenum;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawArraysInstanced.xhtml>
	fn glDrawArraysInstanced(&self, mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsInstanced.xhtml>
	fn glDrawElementsInstanced(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexBuffer.xhtml>
	fn glTexBuffer(&self, target: GLenum, internalformat: GLenum, buffer: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPrimitiveRestartIndex.xhtml>
	fn glPrimitiveRestartIndex(&self, index: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml>
	fn glCopyBufferSubData(&self, readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformIndices.xhtml>
	fn glGetUniformIndices(&self, program: GLuint, uniformCount: GLsizei, uniformNames: *const *const GLchar, uniformIndices: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveUniformsiv.xhtml>
	fn glGetActiveUniformsiv(&self, program: GLuint, uniformCount: GLsizei, uniformIndices: *const GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveUniformName.xhtml>
	fn glGetActiveUniformName(&self, program: GLuint, uniformIndex: GLuint, bufSize: GLsizei, length: *mut GLsizei, uniformName: *mut GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformBlockIndex.xhtml>
	fn glGetUniformBlockIndex(&self, program: GLuint, uniformBlockName: *const GLchar) -> Result<GLuint>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveUniformBlockiv.xhtml>
	fn glGetActiveUniformBlockiv(&self, program: GLuint, uniformBlockIndex: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveUniformBlockName.xhtml>
	fn glGetActiveUniformBlockName(&self, program: GLuint, uniformBlockIndex: GLuint, bufSize: GLsizei, length: *mut GLsizei, uniformBlockName: *mut GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformBlockBinding.xhtml>
	fn glUniformBlockBinding(&self, program: GLuint, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint) -> Result<()>;
}
/// Functions from OpenGL version 3.1
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version31 {
	/// Is OpenGL version 3.1 available
	available: bool,

	/// The function pointer to `glGetError()`
	pub geterror: PFNGLGETERRORPROC,

	/// The function pointer to `glDrawArraysInstanced()`
	pub drawarraysinstanced: PFNGLDRAWARRAYSINSTANCEDPROC,

	/// The function pointer to `glDrawElementsInstanced()`
	pub drawelementsinstanced: PFNGLDRAWELEMENTSINSTANCEDPROC,

	/// The function pointer to `glTexBuffer()`
	pub texbuffer: PFNGLTEXBUFFERPROC,

	/// The function pointer to `glPrimitiveRestartIndex()`
	pub primitiverestartindex: PFNGLPRIMITIVERESTARTINDEXPROC,

	/// The function pointer to `glCopyBufferSubData()`
	pub copybuffersubdata: PFNGLCOPYBUFFERSUBDATAPROC,

	/// The function pointer to `glGetUniformIndices()`
	pub getuniformindices: PFNGLGETUNIFORMINDICESPROC,

	/// The function pointer to `glGetActiveUniformsiv()`
	pub getactiveuniformsiv: PFNGLGETACTIVEUNIFORMSIVPROC,

	/// The function pointer to `glGetActiveUniformName()`
	pub getactiveuniformname: PFNGLGETACTIVEUNIFORMNAMEPROC,

	/// The function pointer to `glGetUniformBlockIndex()`
	pub getuniformblockindex: PFNGLGETUNIFORMBLOCKINDEXPROC,

	/// The function pointer to `glGetActiveUniformBlockiv()`
	pub getactiveuniformblockiv: PFNGLGETACTIVEUNIFORMBLOCKIVPROC,

	/// The function pointer to `glGetActiveUniformBlockName()`
	pub getactiveuniformblockname: PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC,

	/// The function pointer to `glUniformBlockBinding()`
	pub uniformblockbinding: PFNGLUNIFORMBLOCKBINDINGPROC,
}

impl GL_3_1 for Version31 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawArraysInstanced.xhtml>
	#[inline(always)]
	fn glDrawArraysInstanced(&self, mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawArraysInstanced", catch_unwind(||(self.drawarraysinstanced)(mode, first, count, instancecount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawArraysInstanced", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsInstanced.xhtml>
	#[inline(always)]
	fn glDrawElementsInstanced(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawElementsInstanced", catch_unwind(||(self.drawelementsinstanced)(mode, count, type_, indices, instancecount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsInstanced", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexBuffer.xhtml>
	#[inline(always)]
	fn glTexBuffer(&self, target: GLenum, internalformat: GLenum, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glTexBuffer", catch_unwind(||(self.texbuffer)(target, internalformat, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPrimitiveRestartIndex.xhtml>
	#[inline(always)]
	fn glPrimitiveRestartIndex(&self, index: GLuint) -> Result<()> {
		let ret = process_catch("glPrimitiveRestartIndex", catch_unwind(||(self.primitiverestartindex)(index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPrimitiveRestartIndex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml>
	#[inline(always)]
	fn glCopyBufferSubData(&self, readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glCopyBufferSubData", catch_unwind(||(self.copybuffersubdata)(readTarget, writeTarget, readOffset, writeOffset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyBufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformIndices.xhtml>
	#[inline(always)]
	fn glGetUniformIndices(&self, program: GLuint, uniformCount: GLsizei, uniformNames: *const *const GLchar, uniformIndices: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetUniformIndices", catch_unwind(||(self.getuniformindices)(program, uniformCount, uniformNames, uniformIndices)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformIndices", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveUniformsiv.xhtml>
	#[inline(always)]
	fn glGetActiveUniformsiv(&self, program: GLuint, uniformCount: GLsizei, uniformIndices: *const GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetActiveUniformsiv", catch_unwind(||(self.getactiveuniformsiv)(program, uniformCount, uniformIndices, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniformsiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveUniformName.xhtml>
	#[inline(always)]
	fn glGetActiveUniformName(&self, program: GLuint, uniformIndex: GLuint, bufSize: GLsizei, length: *mut GLsizei, uniformName: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveUniformName", catch_unwind(||(self.getactiveuniformname)(program, uniformIndex, bufSize, length, uniformName)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniformName", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformBlockIndex.xhtml>
	#[inline(always)]
	fn glGetUniformBlockIndex(&self, program: GLuint, uniformBlockName: *const GLchar) -> Result<GLuint> {
		let ret = process_catch("glGetUniformBlockIndex", catch_unwind(||(self.getuniformblockindex)(program, uniformBlockName)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformBlockIndex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveUniformBlockiv.xhtml>
	#[inline(always)]
	fn glGetActiveUniformBlockiv(&self, program: GLuint, uniformBlockIndex: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetActiveUniformBlockiv", catch_unwind(||(self.getactiveuniformblockiv)(program, uniformBlockIndex, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniformBlockiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveUniformBlockName.xhtml>
	#[inline(always)]
	fn glGetActiveUniformBlockName(&self, program: GLuint, uniformBlockIndex: GLuint, bufSize: GLsizei, length: *mut GLsizei, uniformBlockName: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveUniformBlockName", catch_unwind(||(self.getactiveuniformblockname)(program, uniformBlockIndex, bufSize, length, uniformBlockName)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniformBlockName", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformBlockBinding.xhtml>
	#[inline(always)]
	fn glUniformBlockBinding(&self, program: GLuint, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint) -> Result<()> {
		let ret = process_catch("glUniformBlockBinding", catch_unwind(||(self.uniformblockbinding)(program, uniformBlockIndex, uniformBlockBinding)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformBlockBinding", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version31 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (3, 1, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			drawarraysinstanced: {let proc = get_proc_address("glDrawArraysInstanced"); if proc == null() {dummy_pfngldrawarraysinstancedproc} else {unsafe{transmute(proc)}}},
			drawelementsinstanced: {let proc = get_proc_address("glDrawElementsInstanced"); if proc == null() {dummy_pfngldrawelementsinstancedproc} else {unsafe{transmute(proc)}}},
			texbuffer: {let proc = get_proc_address("glTexBuffer"); if proc == null() {dummy_pfngltexbufferproc} else {unsafe{transmute(proc)}}},
			primitiverestartindex: {let proc = get_proc_address("glPrimitiveRestartIndex"); if proc == null() {dummy_pfnglprimitiverestartindexproc} else {unsafe{transmute(proc)}}},
			copybuffersubdata: {let proc = get_proc_address("glCopyBufferSubData"); if proc == null() {dummy_pfnglcopybuffersubdataproc} else {unsafe{transmute(proc)}}},
			getuniformindices: {let proc = get_proc_address("glGetUniformIndices"); if proc == null() {dummy_pfnglgetuniformindicesproc} else {unsafe{transmute(proc)}}},
			getactiveuniformsiv: {let proc = get_proc_address("glGetActiveUniformsiv"); if proc == null() {dummy_pfnglgetactiveuniformsivproc} else {unsafe{transmute(proc)}}},
			getactiveuniformname: {let proc = get_proc_address("glGetActiveUniformName"); if proc == null() {dummy_pfnglgetactiveuniformnameproc} else {unsafe{transmute(proc)}}},
			getuniformblockindex: {let proc = get_proc_address("glGetUniformBlockIndex"); if proc == null() {dummy_pfnglgetuniformblockindexproc} else {unsafe{transmute(proc)}}},
			getactiveuniformblockiv: {let proc = get_proc_address("glGetActiveUniformBlockiv"); if proc == null() {dummy_pfnglgetactiveuniformblockivproc} else {unsafe{transmute(proc)}}},
			getactiveuniformblockname: {let proc = get_proc_address("glGetActiveUniformBlockName"); if proc == null() {dummy_pfnglgetactiveuniformblocknameproc} else {unsafe{transmute(proc)}}},
			uniformblockbinding: {let proc = get_proc_address("glUniformBlockBinding"); if proc == null() {dummy_pfngluniformblockbindingproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version31 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			drawarraysinstanced: dummy_pfngldrawarraysinstancedproc,
			drawelementsinstanced: dummy_pfngldrawelementsinstancedproc,
			texbuffer: dummy_pfngltexbufferproc,
			primitiverestartindex: dummy_pfnglprimitiverestartindexproc,
			copybuffersubdata: dummy_pfnglcopybuffersubdataproc,
			getuniformindices: dummy_pfnglgetuniformindicesproc,
			getactiveuniformsiv: dummy_pfnglgetactiveuniformsivproc,
			getactiveuniformname: dummy_pfnglgetactiveuniformnameproc,
			getuniformblockindex: dummy_pfnglgetuniformblockindexproc,
			getactiveuniformblockiv: dummy_pfnglgetactiveuniformblockivproc,
			getactiveuniformblockname: dummy_pfnglgetactiveuniformblocknameproc,
			uniformblockbinding: dummy_pfngluniformblockbindingproc,
		}
	}
}
impl Debug for Version31 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version31")
			.field("available", &self.available)
			.field("drawarraysinstanced", unsafe{if transmute::<_, *const c_void>(self.drawarraysinstanced) == (dummy_pfngldrawarraysinstancedproc as *const c_void) {&null::<PFNGLDRAWARRAYSINSTANCEDPROC>()} else {&self.drawarraysinstanced}})
			.field("drawelementsinstanced", unsafe{if transmute::<_, *const c_void>(self.drawelementsinstanced) == (dummy_pfngldrawelementsinstancedproc as *const c_void) {&null::<PFNGLDRAWELEMENTSINSTANCEDPROC>()} else {&self.drawelementsinstanced}})
			.field("texbuffer", unsafe{if transmute::<_, *const c_void>(self.texbuffer) == (dummy_pfngltexbufferproc as *const c_void) {&null::<PFNGLTEXBUFFERPROC>()} else {&self.texbuffer}})
			.field("primitiverestartindex", unsafe{if transmute::<_, *const c_void>(self.primitiverestartindex) == (dummy_pfnglprimitiverestartindexproc as *const c_void) {&null::<PFNGLPRIMITIVERESTARTINDEXPROC>()} else {&self.primitiverestartindex}})
			.field("copybuffersubdata", unsafe{if transmute::<_, *const c_void>(self.copybuffersubdata) == (dummy_pfnglcopybuffersubdataproc as *const c_void) {&null::<PFNGLCOPYBUFFERSUBDATAPROC>()} else {&self.copybuffersubdata}})
			.field("getuniformindices", unsafe{if transmute::<_, *const c_void>(self.getuniformindices) == (dummy_pfnglgetuniformindicesproc as *const c_void) {&null::<PFNGLGETUNIFORMINDICESPROC>()} else {&self.getuniformindices}})
			.field("getactiveuniformsiv", unsafe{if transmute::<_, *const c_void>(self.getactiveuniformsiv) == (dummy_pfnglgetactiveuniformsivproc as *const c_void) {&null::<PFNGLGETACTIVEUNIFORMSIVPROC>()} else {&self.getactiveuniformsiv}})
			.field("getactiveuniformname", unsafe{if transmute::<_, *const c_void>(self.getactiveuniformname) == (dummy_pfnglgetactiveuniformnameproc as *const c_void) {&null::<PFNGLGETACTIVEUNIFORMNAMEPROC>()} else {&self.getactiveuniformname}})
			.field("getuniformblockindex", unsafe{if transmute::<_, *const c_void>(self.getuniformblockindex) == (dummy_pfnglgetuniformblockindexproc as *const c_void) {&null::<PFNGLGETUNIFORMBLOCKINDEXPROC>()} else {&self.getuniformblockindex}})
			.field("getactiveuniformblockiv", unsafe{if transmute::<_, *const c_void>(self.getactiveuniformblockiv) == (dummy_pfnglgetactiveuniformblockivproc as *const c_void) {&null::<PFNGLGETACTIVEUNIFORMBLOCKIVPROC>()} else {&self.getactiveuniformblockiv}})
			.field("getactiveuniformblockname", unsafe{if transmute::<_, *const c_void>(self.getactiveuniformblockname) == (dummy_pfnglgetactiveuniformblocknameproc as *const c_void) {&null::<PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC>()} else {&self.getactiveuniformblockname}})
			.field("uniformblockbinding", unsafe{if transmute::<_, *const c_void>(self.uniformblockbinding) == (dummy_pfngluniformblockbindingproc as *const c_void) {&null::<PFNGLUNIFORMBLOCKBINDINGPROC>()} else {&self.uniformblockbinding}})
			.finish()
		} else {
			f.debug_struct("Version31")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

/// Alias to `*mut c_void`
pub type GLsync = *mut c_void;

/// Alias to `khronos_uint64_t`
pub type GLuint64 = khronos_uint64_t;

/// Alias to `khronos_int64_t`
pub type GLint64 = khronos_int64_t;

/// The prototype to the OpenGL function `DrawElementsBaseVertex`
type PFNGLDRAWELEMENTSBASEVERTEXPROC = extern "system" fn(GLenum, GLsizei, GLenum, *const c_void, GLint);

/// The prototype to the OpenGL function `DrawRangeElementsBaseVertex`
type PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC = extern "system" fn(GLenum, GLuint, GLuint, GLsizei, GLenum, *const c_void, GLint);

/// The prototype to the OpenGL function `DrawElementsInstancedBaseVertex`
type PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC = extern "system" fn(GLenum, GLsizei, GLenum, *const c_void, GLsizei, GLint);

/// The prototype to the OpenGL function `MultiDrawElementsBaseVertex`
type PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC = extern "system" fn(GLenum, *const GLsizei, GLenum, *const *const c_void, GLsizei, *const GLint);

/// The prototype to the OpenGL function `ProvokingVertex`
type PFNGLPROVOKINGVERTEXPROC = extern "system" fn(GLenum);

/// The prototype to the OpenGL function `FenceSync`
type PFNGLFENCESYNCPROC = extern "system" fn(GLenum, GLbitfield) -> GLsync;

/// The prototype to the OpenGL function `IsSync`
type PFNGLISSYNCPROC = extern "system" fn(GLsync) -> GLboolean;

/// The prototype to the OpenGL function `DeleteSync`
type PFNGLDELETESYNCPROC = extern "system" fn(GLsync);

/// The prototype to the OpenGL function `ClientWaitSync`
type PFNGLCLIENTWAITSYNCPROC = extern "system" fn(GLsync, GLbitfield, GLuint64) -> GLenum;

/// The prototype to the OpenGL function `WaitSync`
type PFNGLWAITSYNCPROC = extern "system" fn(GLsync, GLbitfield, GLuint64);

/// The prototype to the OpenGL function `GetInteger64v`
type PFNGLGETINTEGER64VPROC = extern "system" fn(GLenum, *mut GLint64);

/// The prototype to the OpenGL function `GetSynciv`
type PFNGLGETSYNCIVPROC = extern "system" fn(GLsync, GLenum, GLsizei, *mut GLsizei, *mut GLint);

/// The prototype to the OpenGL function `GetInteger64i_v`
type PFNGLGETINTEGER64I_VPROC = extern "system" fn(GLenum, GLuint, *mut GLint64);

/// The prototype to the OpenGL function `GetBufferParameteri64v`
type PFNGLGETBUFFERPARAMETERI64VPROC = extern "system" fn(GLenum, GLenum, *mut GLint64);

/// The prototype to the OpenGL function `FramebufferTexture`
type PFNGLFRAMEBUFFERTEXTUREPROC = extern "system" fn(GLenum, GLenum, GLuint, GLint);

/// The prototype to the OpenGL function `TexImage2DMultisample`
type PFNGLTEXIMAGE2DMULTISAMPLEPROC = extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLboolean);

/// The prototype to the OpenGL function `TexImage3DMultisample`
type PFNGLTEXIMAGE3DMULTISAMPLEPROC = extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei, GLboolean);

/// The prototype to the OpenGL function `GetMultisamplefv`
type PFNGLGETMULTISAMPLEFVPROC = extern "system" fn(GLenum, GLuint, *mut GLfloat);

/// The prototype to the OpenGL function `SampleMaski`
type PFNGLSAMPLEMASKIPROC = extern "system" fn(GLuint, GLbitfield);

/// The dummy function of `DrawElementsBaseVertex()`
extern "system" fn dummy_pfngldrawelementsbasevertexproc (_: GLenum, _: GLsizei, _: GLenum, _: *const c_void, _: GLint) {
	panic!("OpenGL function pointer `glDrawElementsBaseVertex()` is null.")
}

/// The dummy function of `DrawRangeElementsBaseVertex()`
extern "system" fn dummy_pfngldrawrangeelementsbasevertexproc (_: GLenum, _: GLuint, _: GLuint, _: GLsizei, _: GLenum, _: *const c_void, _: GLint) {
	panic!("OpenGL function pointer `glDrawRangeElementsBaseVertex()` is null.")
}

/// The dummy function of `DrawElementsInstancedBaseVertex()`
extern "system" fn dummy_pfngldrawelementsinstancedbasevertexproc (_: GLenum, _: GLsizei, _: GLenum, _: *const c_void, _: GLsizei, _: GLint) {
	panic!("OpenGL function pointer `glDrawElementsInstancedBaseVertex()` is null.")
}

/// The dummy function of `MultiDrawElementsBaseVertex()`
extern "system" fn dummy_pfnglmultidrawelementsbasevertexproc (_: GLenum, _: *const GLsizei, _: GLenum, _: *const *const c_void, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glMultiDrawElementsBaseVertex()` is null.")
}

/// The dummy function of `ProvokingVertex()`
extern "system" fn dummy_pfnglprovokingvertexproc (_: GLenum) {
	panic!("OpenGL function pointer `glProvokingVertex()` is null.")
}

/// The dummy function of `FenceSync()`
extern "system" fn dummy_pfnglfencesyncproc (_: GLenum, _: GLbitfield) -> GLsync {
	panic!("OpenGL function pointer `glFenceSync()` is null.")
}

/// The dummy function of `IsSync()`
extern "system" fn dummy_pfnglissyncproc (_: GLsync) -> GLboolean {
	panic!("OpenGL function pointer `glIsSync()` is null.")
}

/// The dummy function of `DeleteSync()`
extern "system" fn dummy_pfngldeletesyncproc (_: GLsync) {
	panic!("OpenGL function pointer `glDeleteSync()` is null.")
}

/// The dummy function of `ClientWaitSync()`
extern "system" fn dummy_pfnglclientwaitsyncproc (_: GLsync, _: GLbitfield, _: GLuint64) -> GLenum {
	panic!("OpenGL function pointer `glClientWaitSync()` is null.")
}

/// The dummy function of `WaitSync()`
extern "system" fn dummy_pfnglwaitsyncproc (_: GLsync, _: GLbitfield, _: GLuint64) {
	panic!("OpenGL function pointer `glWaitSync()` is null.")
}

/// The dummy function of `GetInteger64v()`
extern "system" fn dummy_pfnglgetinteger64vproc (_: GLenum, _: *mut GLint64) {
	panic!("OpenGL function pointer `glGetInteger64v()` is null.")
}

/// The dummy function of `GetSynciv()`
extern "system" fn dummy_pfnglgetsyncivproc (_: GLsync, _: GLenum, _: GLsizei, _: *mut GLsizei, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetSynciv()` is null.")
}

/// The dummy function of `GetInteger64i_v()`
extern "system" fn dummy_pfnglgetinteger64i_vproc (_: GLenum, _: GLuint, _: *mut GLint64) {
	panic!("OpenGL function pointer `glGetInteger64i_v()` is null.")
}

/// The dummy function of `GetBufferParameteri64v()`
extern "system" fn dummy_pfnglgetbufferparameteri64vproc (_: GLenum, _: GLenum, _: *mut GLint64) {
	panic!("OpenGL function pointer `glGetBufferParameteri64v()` is null.")
}

/// The dummy function of `FramebufferTexture()`
extern "system" fn dummy_pfnglframebuffertextureproc (_: GLenum, _: GLenum, _: GLuint, _: GLint) {
	panic!("OpenGL function pointer `glFramebufferTexture()` is null.")
}

/// The dummy function of `TexImage2DMultisample()`
extern "system" fn dummy_pfnglteximage2dmultisampleproc (_: GLenum, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei, _: GLboolean) {
	panic!("OpenGL function pointer `glTexImage2DMultisample()` is null.")
}

/// The dummy function of `TexImage3DMultisample()`
extern "system" fn dummy_pfnglteximage3dmultisampleproc (_: GLenum, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei, _: GLsizei, _: GLboolean) {
	panic!("OpenGL function pointer `glTexImage3DMultisample()` is null.")
}

/// The dummy function of `GetMultisamplefv()`
extern "system" fn dummy_pfnglgetmultisamplefvproc (_: GLenum, _: GLuint, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetMultisamplefv()` is null.")
}

/// The dummy function of `SampleMaski()`
extern "system" fn dummy_pfnglsamplemaskiproc (_: GLuint, _: GLbitfield) {
	panic!("OpenGL function pointer `glSampleMaski()` is null.")
}
/// Constant value defined from OpenGL 3.2
pub const GL_CONTEXT_CORE_PROFILE_BIT: GLbitfield = 0x00000001;

/// Constant value defined from OpenGL 3.2
pub const GL_CONTEXT_COMPATIBILITY_PROFILE_BIT: GLbitfield = 0x00000002;

/// Constant value defined from OpenGL 3.2
pub const GL_LINES_ADJACENCY: GLenum = 0x000A;

/// Constant value defined from OpenGL 3.2
pub const GL_LINE_STRIP_ADJACENCY: GLenum = 0x000B;

/// Constant value defined from OpenGL 3.2
pub const GL_TRIANGLES_ADJACENCY: GLenum = 0x000C;

/// Constant value defined from OpenGL 3.2
pub const GL_TRIANGLE_STRIP_ADJACENCY: GLenum = 0x000D;

/// Constant value defined from OpenGL 3.2
pub const GL_PROGRAM_POINT_SIZE: GLenum = 0x8642;

/// Constant value defined from OpenGL 3.2
pub const GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS: GLenum = 0x8C29;

/// Constant value defined from OpenGL 3.2
pub const GL_FRAMEBUFFER_ATTACHMENT_LAYERED: GLenum = 0x8DA7;

/// Constant value defined from OpenGL 3.2
pub const GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS: GLenum = 0x8DA8;

/// Constant value defined from OpenGL 3.2
pub const GL_GEOMETRY_SHADER: GLenum = 0x8DD9;

/// Constant value defined from OpenGL 3.2
pub const GL_GEOMETRY_VERTICES_OUT: GLenum = 0x8916;

/// Constant value defined from OpenGL 3.2
pub const GL_GEOMETRY_INPUT_TYPE: GLenum = 0x8917;

/// Constant value defined from OpenGL 3.2
pub const GL_GEOMETRY_OUTPUT_TYPE: GLenum = 0x8918;

/// Constant value defined from OpenGL 3.2
pub const GL_MAX_GEOMETRY_UNIFORM_COMPONENTS: GLenum = 0x8DDF;

/// Constant value defined from OpenGL 3.2
pub const GL_MAX_GEOMETRY_OUTPUT_VERTICES: GLenum = 0x8DE0;

/// Constant value defined from OpenGL 3.2
pub const GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS: GLenum = 0x8DE1;

/// Constant value defined from OpenGL 3.2
pub const GL_MAX_VERTEX_OUTPUT_COMPONENTS: GLenum = 0x9122;

/// Constant value defined from OpenGL 3.2
pub const GL_MAX_GEOMETRY_INPUT_COMPONENTS: GLenum = 0x9123;

/// Constant value defined from OpenGL 3.2
pub const GL_MAX_GEOMETRY_OUTPUT_COMPONENTS: GLenum = 0x9124;

/// Constant value defined from OpenGL 3.2
pub const GL_MAX_FRAGMENT_INPUT_COMPONENTS: GLenum = 0x9125;

/// Constant value defined from OpenGL 3.2
pub const GL_CONTEXT_PROFILE_MASK: GLenum = 0x9126;

/// Constant value defined from OpenGL 3.2
pub const GL_DEPTH_CLAMP: GLenum = 0x864F;

/// Constant value defined from OpenGL 3.2
pub const GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION: GLenum = 0x8E4C;

/// Constant value defined from OpenGL 3.2
pub const GL_FIRST_VERTEX_CONVENTION: GLenum = 0x8E4D;

/// Constant value defined from OpenGL 3.2
pub const GL_LAST_VERTEX_CONVENTION: GLenum = 0x8E4E;

/// Constant value defined from OpenGL 3.2
pub const GL_PROVOKING_VERTEX: GLenum = 0x8E4F;

/// Constant value defined from OpenGL 3.2
pub const GL_TEXTURE_CUBE_MAP_SEAMLESS: GLenum = 0x884F;

/// Constant value defined from OpenGL 3.2
pub const GL_MAX_SERVER_WAIT_TIMEOUT: GLenum = 0x9111;

/// Constant value defined from OpenGL 3.2
pub const GL_OBJECT_TYPE: GLenum = 0x9112;

/// Constant value defined from OpenGL 3.2
pub const GL_SYNC_CONDITION: GLenum = 0x9113;

/// Constant value defined from OpenGL 3.2
pub const GL_SYNC_STATUS: GLenum = 0x9114;

/// Constant value defined from OpenGL 3.2
pub const GL_SYNC_FLAGS: GLenum = 0x9115;

/// Constant value defined from OpenGL 3.2
pub const GL_SYNC_FENCE: GLenum = 0x9116;

/// Constant value defined from OpenGL 3.2
pub const GL_SYNC_GPU_COMMANDS_COMPLETE: GLenum = 0x9117;

/// Constant value defined from OpenGL 3.2
pub const GL_UNSIGNALED: GLenum = 0x9118;

/// Constant value defined from OpenGL 3.2
pub const GL_SIGNALED: GLenum = 0x9119;

/// Constant value defined from OpenGL 3.2
pub const GL_ALREADY_SIGNALED: GLenum = 0x911A;

/// Constant value defined from OpenGL 3.2
pub const GL_TIMEOUT_EXPIRED: GLenum = 0x911B;

/// Constant value defined from OpenGL 3.2
pub const GL_CONDITION_SATISFIED: GLenum = 0x911C;

/// Constant value defined from OpenGL 3.2
pub const GL_WAIT_FAILED: GLenum = 0x911D;

/// Constant value defined from OpenGL 3.2
pub const GL_TIMEOUT_IGNORED: GLuint64 = 0xFFFFFFFFFFFFFFFFu64;

/// Constant value defined from OpenGL 3.2
pub const GL_SYNC_FLUSH_COMMANDS_BIT: GLbitfield = 0x00000001;

/// Constant value defined from OpenGL 3.2
pub const GL_SAMPLE_POSITION: GLenum = 0x8E50;

/// Constant value defined from OpenGL 3.2
pub const GL_SAMPLE_MASK: GLenum = 0x8E51;

/// Constant value defined from OpenGL 3.2
pub const GL_SAMPLE_MASK_VALUE: GLenum = 0x8E52;

/// Constant value defined from OpenGL 3.2
pub const GL_MAX_SAMPLE_MASK_WORDS: GLenum = 0x8E59;

/// Constant value defined from OpenGL 3.2
pub const GL_TEXTURE_2D_MULTISAMPLE: GLenum = 0x9100;

/// Constant value defined from OpenGL 3.2
pub const GL_PROXY_TEXTURE_2D_MULTISAMPLE: GLenum = 0x9101;

/// Constant value defined from OpenGL 3.2
pub const GL_TEXTURE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9102;

/// Constant value defined from OpenGL 3.2
pub const GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9103;

/// Constant value defined from OpenGL 3.2
pub const GL_TEXTURE_BINDING_2D_MULTISAMPLE: GLenum = 0x9104;

/// Constant value defined from OpenGL 3.2
pub const GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY: GLenum = 0x9105;

/// Constant value defined from OpenGL 3.2
pub const GL_TEXTURE_SAMPLES: GLenum = 0x9106;

/// Constant value defined from OpenGL 3.2
pub const GL_TEXTURE_FIXED_SAMPLE_LOCATIONS: GLenum = 0x9107;

/// Constant value defined from OpenGL 3.2
pub const GL_SAMPLER_2D_MULTISAMPLE: GLenum = 0x9108;

/// Constant value defined from OpenGL 3.2
pub const GL_INT_SAMPLER_2D_MULTISAMPLE: GLenum = 0x9109;

/// Constant value defined from OpenGL 3.2
pub const GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE: GLenum = 0x910A;

/// Constant value defined from OpenGL 3.2
pub const GL_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910B;

/// Constant value defined from OpenGL 3.2
pub const GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910C;

/// Constant value defined from OpenGL 3.2
pub const GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910D;

/// Constant value defined from OpenGL 3.2
pub const GL_MAX_COLOR_TEXTURE_SAMPLES: GLenum = 0x910E;

/// Constant value defined from OpenGL 3.2
pub const GL_MAX_DEPTH_TEXTURE_SAMPLES: GLenum = 0x910F;

/// Constant value defined from OpenGL 3.2
pub const GL_MAX_INTEGER_SAMPLES: GLenum = 0x9110;

/// Functions from OpenGL version 3.2
pub trait GL_3_2 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	fn glGetError(&self) -> GLenum;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsBaseVertex.xhtml>
	fn glDrawElementsBaseVertex(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, basevertex: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawRangeElementsBaseVertex.xhtml>
	fn glDrawRangeElementsBaseVertex(&self, mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type_: GLenum, indices: *const c_void, basevertex: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertex.xhtml>
	fn glDrawElementsInstancedBaseVertex(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei, basevertex: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawElementsBaseVertex.xhtml>
	fn glMultiDrawElementsBaseVertex(&self, mode: GLenum, count: *const GLsizei, type_: GLenum, indices: *const *const c_void, drawcount: GLsizei, basevertex: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProvokingVertex.xhtml>
	fn glProvokingVertex(&self, mode: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFenceSync.xhtml>
	fn glFenceSync(&self, condition: GLenum, flags: GLbitfield) -> Result<GLsync>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsSync.xhtml>
	fn glIsSync(&self, sync: GLsync) -> Result<GLboolean>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteSync.xhtml>
	fn glDeleteSync(&self, sync: GLsync) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClientWaitSync.xhtml>
	fn glClientWaitSync(&self, sync: GLsync, flags: GLbitfield, timeout: GLuint64) -> Result<GLenum>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWaitSync.xhtml>
	fn glWaitSync(&self, sync: GLsync, flags: GLbitfield, timeout: GLuint64) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetInteger64v.xhtml>
	fn glGetInteger64v(&self, pname: GLenum, data: *mut GLint64) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSynciv.xhtml>
	fn glGetSynciv(&self, sync: GLsync, pname: GLenum, count: GLsizei, length: *mut GLsizei, values: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetInteger64i_v.xhtml>
	fn glGetInteger64i_v(&self, target: GLenum, index: GLuint, data: *mut GLint64) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetBufferParameteri64v.xhtml>
	fn glGetBufferParameteri64v(&self, target: GLenum, pname: GLenum, params: *mut GLint64) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml>
	fn glFramebufferTexture(&self, target: GLenum, attachment: GLenum, texture: GLuint, level: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexImage2DMultisample.xhtml>
	fn glTexImage2DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexImage3DMultisample.xhtml>
	fn glTexImage3DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetMultisamplefv.xhtml>
	fn glGetMultisamplefv(&self, pname: GLenum, index: GLuint, val: *mut GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSampleMaski.xhtml>
	fn glSampleMaski(&self, maskNumber: GLuint, mask: GLbitfield) -> Result<()>;
}
/// Functions from OpenGL version 3.2
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version32 {
	/// Is OpenGL version 3.2 available
	available: bool,

	/// The function pointer to `glGetError()`
	pub geterror: PFNGLGETERRORPROC,

	/// The function pointer to `glDrawElementsBaseVertex()`
	pub drawelementsbasevertex: PFNGLDRAWELEMENTSBASEVERTEXPROC,

	/// The function pointer to `glDrawRangeElementsBaseVertex()`
	pub drawrangeelementsbasevertex: PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC,

	/// The function pointer to `glDrawElementsInstancedBaseVertex()`
	pub drawelementsinstancedbasevertex: PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC,

	/// The function pointer to `glMultiDrawElementsBaseVertex()`
	pub multidrawelementsbasevertex: PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC,

	/// The function pointer to `glProvokingVertex()`
	pub provokingvertex: PFNGLPROVOKINGVERTEXPROC,

	/// The function pointer to `glFenceSync()`
	pub fencesync: PFNGLFENCESYNCPROC,

	/// The function pointer to `glIsSync()`
	pub issync: PFNGLISSYNCPROC,

	/// The function pointer to `glDeleteSync()`
	pub deletesync: PFNGLDELETESYNCPROC,

	/// The function pointer to `glClientWaitSync()`
	pub clientwaitsync: PFNGLCLIENTWAITSYNCPROC,

	/// The function pointer to `glWaitSync()`
	pub waitsync: PFNGLWAITSYNCPROC,

	/// The function pointer to `glGetInteger64v()`
	pub getinteger64v: PFNGLGETINTEGER64VPROC,

	/// The function pointer to `glGetSynciv()`
	pub getsynciv: PFNGLGETSYNCIVPROC,

	/// The function pointer to `glGetInteger64i_v()`
	pub getinteger64i_v: PFNGLGETINTEGER64I_VPROC,

	/// The function pointer to `glGetBufferParameteri64v()`
	pub getbufferparameteri64v: PFNGLGETBUFFERPARAMETERI64VPROC,

	/// The function pointer to `glFramebufferTexture()`
	pub framebuffertexture: PFNGLFRAMEBUFFERTEXTUREPROC,

	/// The function pointer to `glTexImage2DMultisample()`
	pub teximage2dmultisample: PFNGLTEXIMAGE2DMULTISAMPLEPROC,

	/// The function pointer to `glTexImage3DMultisample()`
	pub teximage3dmultisample: PFNGLTEXIMAGE3DMULTISAMPLEPROC,

	/// The function pointer to `glGetMultisamplefv()`
	pub getmultisamplefv: PFNGLGETMULTISAMPLEFVPROC,

	/// The function pointer to `glSampleMaski()`
	pub samplemaski: PFNGLSAMPLEMASKIPROC,
}

impl GL_3_2 for Version32 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsBaseVertex.xhtml>
	#[inline(always)]
	fn glDrawElementsBaseVertex(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, basevertex: GLint) -> Result<()> {
		let ret = process_catch("glDrawElementsBaseVertex", catch_unwind(||(self.drawelementsbasevertex)(mode, count, type_, indices, basevertex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsBaseVertex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawRangeElementsBaseVertex.xhtml>
	#[inline(always)]
	fn glDrawRangeElementsBaseVertex(&self, mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type_: GLenum, indices: *const c_void, basevertex: GLint) -> Result<()> {
		let ret = process_catch("glDrawRangeElementsBaseVertex", catch_unwind(||(self.drawrangeelementsbasevertex)(mode, start, end, count, type_, indices, basevertex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawRangeElementsBaseVertex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertex.xhtml>
	#[inline(always)]
	fn glDrawElementsInstancedBaseVertex(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei, basevertex: GLint) -> Result<()> {
		let ret = process_catch("glDrawElementsInstancedBaseVertex", catch_unwind(||(self.drawelementsinstancedbasevertex)(mode, count, type_, indices, instancecount, basevertex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsInstancedBaseVertex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawElementsBaseVertex.xhtml>
	#[inline(always)]
	fn glMultiDrawElementsBaseVertex(&self, mode: GLenum, count: *const GLsizei, type_: GLenum, indices: *const *const c_void, drawcount: GLsizei, basevertex: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiDrawElementsBaseVertex", catch_unwind(||(self.multidrawelementsbasevertex)(mode, count, type_, indices, drawcount, basevertex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawElementsBaseVertex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProvokingVertex.xhtml>
	#[inline(always)]
	fn glProvokingVertex(&self, mode: GLenum) -> Result<()> {
		let ret = process_catch("glProvokingVertex", catch_unwind(||(self.provokingvertex)(mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProvokingVertex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFenceSync.xhtml>
	#[inline(always)]
	fn glFenceSync(&self, condition: GLenum, flags: GLbitfield) -> Result<GLsync> {
		let ret = process_catch("glFenceSync", catch_unwind(||(self.fencesync)(condition, flags)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFenceSync", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsSync.xhtml>
	#[inline(always)]
	fn glIsSync(&self, sync: GLsync) -> Result<GLboolean> {
		let ret = process_catch("glIsSync", catch_unwind(||(self.issync)(sync)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsSync", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteSync.xhtml>
	#[inline(always)]
	fn glDeleteSync(&self, sync: GLsync) -> Result<()> {
		let ret = process_catch("glDeleteSync", catch_unwind(||(self.deletesync)(sync)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteSync", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClientWaitSync.xhtml>
	#[inline(always)]
	fn glClientWaitSync(&self, sync: GLsync, flags: GLbitfield, timeout: GLuint64) -> Result<GLenum> {
		let ret = process_catch("glClientWaitSync", catch_unwind(||(self.clientwaitsync)(sync, flags, timeout)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClientWaitSync", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWaitSync.xhtml>
	#[inline(always)]
	fn glWaitSync(&self, sync: GLsync, flags: GLbitfield, timeout: GLuint64) -> Result<()> {
		let ret = process_catch("glWaitSync", catch_unwind(||(self.waitsync)(sync, flags, timeout)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWaitSync", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetInteger64v.xhtml>
	#[inline(always)]
	fn glGetInteger64v(&self, pname: GLenum, data: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetInteger64v", catch_unwind(||(self.getinteger64v)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetInteger64v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSynciv.xhtml>
	#[inline(always)]
	fn glGetSynciv(&self, sync: GLsync, pname: GLenum, count: GLsizei, length: *mut GLsizei, values: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetSynciv", catch_unwind(||(self.getsynciv)(sync, pname, count, length, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSynciv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetInteger64i_v.xhtml>
	#[inline(always)]
	fn glGetInteger64i_v(&self, target: GLenum, index: GLuint, data: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetInteger64i_v", catch_unwind(||(self.getinteger64i_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetInteger64i_v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetBufferParameteri64v.xhtml>
	#[inline(always)]
	fn glGetBufferParameteri64v(&self, target: GLenum, pname: GLenum, params: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetBufferParameteri64v", catch_unwind(||(self.getbufferparameteri64v)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBufferParameteri64v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml>
	#[inline(always)]
	fn glFramebufferTexture(&self, target: GLenum, attachment: GLenum, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTexture", catch_unwind(||(self.framebuffertexture)(target, attachment, texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTexture", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexImage2DMultisample.xhtml>
	#[inline(always)]
	fn glTexImage2DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTexImage2DMultisample", catch_unwind(||(self.teximage2dmultisample)(target, samples, internalformat, width, height, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage2DMultisample", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexImage3DMultisample.xhtml>
	#[inline(always)]
	fn glTexImage3DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTexImage3DMultisample", catch_unwind(||(self.teximage3dmultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage3DMultisample", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetMultisamplefv.xhtml>
	#[inline(always)]
	fn glGetMultisamplefv(&self, pname: GLenum, index: GLuint, val: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetMultisamplefv", catch_unwind(||(self.getmultisamplefv)(pname, index, val)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetMultisamplefv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSampleMaski.xhtml>
	#[inline(always)]
	fn glSampleMaski(&self, maskNumber: GLuint, mask: GLbitfield) -> Result<()> {
		let ret = process_catch("glSampleMaski", catch_unwind(||(self.samplemaski)(maskNumber, mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSampleMaski", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version32 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (3, 2, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			drawelementsbasevertex: {let proc = get_proc_address("glDrawElementsBaseVertex"); if proc == null() {dummy_pfngldrawelementsbasevertexproc} else {unsafe{transmute(proc)}}},
			drawrangeelementsbasevertex: {let proc = get_proc_address("glDrawRangeElementsBaseVertex"); if proc == null() {dummy_pfngldrawrangeelementsbasevertexproc} else {unsafe{transmute(proc)}}},
			drawelementsinstancedbasevertex: {let proc = get_proc_address("glDrawElementsInstancedBaseVertex"); if proc == null() {dummy_pfngldrawelementsinstancedbasevertexproc} else {unsafe{transmute(proc)}}},
			multidrawelementsbasevertex: {let proc = get_proc_address("glMultiDrawElementsBaseVertex"); if proc == null() {dummy_pfnglmultidrawelementsbasevertexproc} else {unsafe{transmute(proc)}}},
			provokingvertex: {let proc = get_proc_address("glProvokingVertex"); if proc == null() {dummy_pfnglprovokingvertexproc} else {unsafe{transmute(proc)}}},
			fencesync: {let proc = get_proc_address("glFenceSync"); if proc == null() {dummy_pfnglfencesyncproc} else {unsafe{transmute(proc)}}},
			issync: {let proc = get_proc_address("glIsSync"); if proc == null() {dummy_pfnglissyncproc} else {unsafe{transmute(proc)}}},
			deletesync: {let proc = get_proc_address("glDeleteSync"); if proc == null() {dummy_pfngldeletesyncproc} else {unsafe{transmute(proc)}}},
			clientwaitsync: {let proc = get_proc_address("glClientWaitSync"); if proc == null() {dummy_pfnglclientwaitsyncproc} else {unsafe{transmute(proc)}}},
			waitsync: {let proc = get_proc_address("glWaitSync"); if proc == null() {dummy_pfnglwaitsyncproc} else {unsafe{transmute(proc)}}},
			getinteger64v: {let proc = get_proc_address("glGetInteger64v"); if proc == null() {dummy_pfnglgetinteger64vproc} else {unsafe{transmute(proc)}}},
			getsynciv: {let proc = get_proc_address("glGetSynciv"); if proc == null() {dummy_pfnglgetsyncivproc} else {unsafe{transmute(proc)}}},
			getinteger64i_v: {let proc = get_proc_address("glGetInteger64i_v"); if proc == null() {dummy_pfnglgetinteger64i_vproc} else {unsafe{transmute(proc)}}},
			getbufferparameteri64v: {let proc = get_proc_address("glGetBufferParameteri64v"); if proc == null() {dummy_pfnglgetbufferparameteri64vproc} else {unsafe{transmute(proc)}}},
			framebuffertexture: {let proc = get_proc_address("glFramebufferTexture"); if proc == null() {dummy_pfnglframebuffertextureproc} else {unsafe{transmute(proc)}}},
			teximage2dmultisample: {let proc = get_proc_address("glTexImage2DMultisample"); if proc == null() {dummy_pfnglteximage2dmultisampleproc} else {unsafe{transmute(proc)}}},
			teximage3dmultisample: {let proc = get_proc_address("glTexImage3DMultisample"); if proc == null() {dummy_pfnglteximage3dmultisampleproc} else {unsafe{transmute(proc)}}},
			getmultisamplefv: {let proc = get_proc_address("glGetMultisamplefv"); if proc == null() {dummy_pfnglgetmultisamplefvproc} else {unsafe{transmute(proc)}}},
			samplemaski: {let proc = get_proc_address("glSampleMaski"); if proc == null() {dummy_pfnglsamplemaskiproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version32 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			drawelementsbasevertex: dummy_pfngldrawelementsbasevertexproc,
			drawrangeelementsbasevertex: dummy_pfngldrawrangeelementsbasevertexproc,
			drawelementsinstancedbasevertex: dummy_pfngldrawelementsinstancedbasevertexproc,
			multidrawelementsbasevertex: dummy_pfnglmultidrawelementsbasevertexproc,
			provokingvertex: dummy_pfnglprovokingvertexproc,
			fencesync: dummy_pfnglfencesyncproc,
			issync: dummy_pfnglissyncproc,
			deletesync: dummy_pfngldeletesyncproc,
			clientwaitsync: dummy_pfnglclientwaitsyncproc,
			waitsync: dummy_pfnglwaitsyncproc,
			getinteger64v: dummy_pfnglgetinteger64vproc,
			getsynciv: dummy_pfnglgetsyncivproc,
			getinteger64i_v: dummy_pfnglgetinteger64i_vproc,
			getbufferparameteri64v: dummy_pfnglgetbufferparameteri64vproc,
			framebuffertexture: dummy_pfnglframebuffertextureproc,
			teximage2dmultisample: dummy_pfnglteximage2dmultisampleproc,
			teximage3dmultisample: dummy_pfnglteximage3dmultisampleproc,
			getmultisamplefv: dummy_pfnglgetmultisamplefvproc,
			samplemaski: dummy_pfnglsamplemaskiproc,
		}
	}
}
impl Debug for Version32 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version32")
			.field("available", &self.available)
			.field("drawelementsbasevertex", unsafe{if transmute::<_, *const c_void>(self.drawelementsbasevertex) == (dummy_pfngldrawelementsbasevertexproc as *const c_void) {&null::<PFNGLDRAWELEMENTSBASEVERTEXPROC>()} else {&self.drawelementsbasevertex}})
			.field("drawrangeelementsbasevertex", unsafe{if transmute::<_, *const c_void>(self.drawrangeelementsbasevertex) == (dummy_pfngldrawrangeelementsbasevertexproc as *const c_void) {&null::<PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC>()} else {&self.drawrangeelementsbasevertex}})
			.field("drawelementsinstancedbasevertex", unsafe{if transmute::<_, *const c_void>(self.drawelementsinstancedbasevertex) == (dummy_pfngldrawelementsinstancedbasevertexproc as *const c_void) {&null::<PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC>()} else {&self.drawelementsinstancedbasevertex}})
			.field("multidrawelementsbasevertex", unsafe{if transmute::<_, *const c_void>(self.multidrawelementsbasevertex) == (dummy_pfnglmultidrawelementsbasevertexproc as *const c_void) {&null::<PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC>()} else {&self.multidrawelementsbasevertex}})
			.field("provokingvertex", unsafe{if transmute::<_, *const c_void>(self.provokingvertex) == (dummy_pfnglprovokingvertexproc as *const c_void) {&null::<PFNGLPROVOKINGVERTEXPROC>()} else {&self.provokingvertex}})
			.field("fencesync", unsafe{if transmute::<_, *const c_void>(self.fencesync) == (dummy_pfnglfencesyncproc as *const c_void) {&null::<PFNGLFENCESYNCPROC>()} else {&self.fencesync}})
			.field("issync", unsafe{if transmute::<_, *const c_void>(self.issync) == (dummy_pfnglissyncproc as *const c_void) {&null::<PFNGLISSYNCPROC>()} else {&self.issync}})
			.field("deletesync", unsafe{if transmute::<_, *const c_void>(self.deletesync) == (dummy_pfngldeletesyncproc as *const c_void) {&null::<PFNGLDELETESYNCPROC>()} else {&self.deletesync}})
			.field("clientwaitsync", unsafe{if transmute::<_, *const c_void>(self.clientwaitsync) == (dummy_pfnglclientwaitsyncproc as *const c_void) {&null::<PFNGLCLIENTWAITSYNCPROC>()} else {&self.clientwaitsync}})
			.field("waitsync", unsafe{if transmute::<_, *const c_void>(self.waitsync) == (dummy_pfnglwaitsyncproc as *const c_void) {&null::<PFNGLWAITSYNCPROC>()} else {&self.waitsync}})
			.field("getinteger64v", unsafe{if transmute::<_, *const c_void>(self.getinteger64v) == (dummy_pfnglgetinteger64vproc as *const c_void) {&null::<PFNGLGETINTEGER64VPROC>()} else {&self.getinteger64v}})
			.field("getsynciv", unsafe{if transmute::<_, *const c_void>(self.getsynciv) == (dummy_pfnglgetsyncivproc as *const c_void) {&null::<PFNGLGETSYNCIVPROC>()} else {&self.getsynciv}})
			.field("getinteger64i_v", unsafe{if transmute::<_, *const c_void>(self.getinteger64i_v) == (dummy_pfnglgetinteger64i_vproc as *const c_void) {&null::<PFNGLGETINTEGER64I_VPROC>()} else {&self.getinteger64i_v}})
			.field("getbufferparameteri64v", unsafe{if transmute::<_, *const c_void>(self.getbufferparameteri64v) == (dummy_pfnglgetbufferparameteri64vproc as *const c_void) {&null::<PFNGLGETBUFFERPARAMETERI64VPROC>()} else {&self.getbufferparameteri64v}})
			.field("framebuffertexture", unsafe{if transmute::<_, *const c_void>(self.framebuffertexture) == (dummy_pfnglframebuffertextureproc as *const c_void) {&null::<PFNGLFRAMEBUFFERTEXTUREPROC>()} else {&self.framebuffertexture}})
			.field("teximage2dmultisample", unsafe{if transmute::<_, *const c_void>(self.teximage2dmultisample) == (dummy_pfnglteximage2dmultisampleproc as *const c_void) {&null::<PFNGLTEXIMAGE2DMULTISAMPLEPROC>()} else {&self.teximage2dmultisample}})
			.field("teximage3dmultisample", unsafe{if transmute::<_, *const c_void>(self.teximage3dmultisample) == (dummy_pfnglteximage3dmultisampleproc as *const c_void) {&null::<PFNGLTEXIMAGE3DMULTISAMPLEPROC>()} else {&self.teximage3dmultisample}})
			.field("getmultisamplefv", unsafe{if transmute::<_, *const c_void>(self.getmultisamplefv) == (dummy_pfnglgetmultisamplefvproc as *const c_void) {&null::<PFNGLGETMULTISAMPLEFVPROC>()} else {&self.getmultisamplefv}})
			.field("samplemaski", unsafe{if transmute::<_, *const c_void>(self.samplemaski) == (dummy_pfnglsamplemaskiproc as *const c_void) {&null::<PFNGLSAMPLEMASKIPROC>()} else {&self.samplemaski}})
			.finish()
		} else {
			f.debug_struct("Version32")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

/// The prototype to the OpenGL function `BindFragDataLocationIndexed`
type PFNGLBINDFRAGDATALOCATIONINDEXEDPROC = extern "system" fn(GLuint, GLuint, GLuint, *const GLchar);

/// The prototype to the OpenGL function `GetFragDataIndex`
type PFNGLGETFRAGDATAINDEXPROC = extern "system" fn(GLuint, *const GLchar) -> GLint;

/// The prototype to the OpenGL function `GenSamplers`
type PFNGLGENSAMPLERSPROC = extern "system" fn(GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `DeleteSamplers`
type PFNGLDELETESAMPLERSPROC = extern "system" fn(GLsizei, *const GLuint);

/// The prototype to the OpenGL function `IsSampler`
type PFNGLISSAMPLERPROC = extern "system" fn(GLuint) -> GLboolean;

/// The prototype to the OpenGL function `BindSampler`
type PFNGLBINDSAMPLERPROC = extern "system" fn(GLuint, GLuint);

/// The prototype to the OpenGL function `SamplerParameteri`
type PFNGLSAMPLERPARAMETERIPROC = extern "system" fn(GLuint, GLenum, GLint);

/// The prototype to the OpenGL function `SamplerParameteriv`
type PFNGLSAMPLERPARAMETERIVPROC = extern "system" fn(GLuint, GLenum, *const GLint);

/// The prototype to the OpenGL function `SamplerParameterf`
type PFNGLSAMPLERPARAMETERFPROC = extern "system" fn(GLuint, GLenum, GLfloat);

/// The prototype to the OpenGL function `SamplerParameterfv`
type PFNGLSAMPLERPARAMETERFVPROC = extern "system" fn(GLuint, GLenum, *const GLfloat);

/// The prototype to the OpenGL function `SamplerParameterIiv`
type PFNGLSAMPLERPARAMETERIIVPROC = extern "system" fn(GLuint, GLenum, *const GLint);

/// The prototype to the OpenGL function `SamplerParameterIuiv`
type PFNGLSAMPLERPARAMETERIUIVPROC = extern "system" fn(GLuint, GLenum, *const GLuint);

/// The prototype to the OpenGL function `GetSamplerParameteriv`
type PFNGLGETSAMPLERPARAMETERIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetSamplerParameterIiv`
type PFNGLGETSAMPLERPARAMETERIIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetSamplerParameterfv`
type PFNGLGETSAMPLERPARAMETERFVPROC = extern "system" fn(GLuint, GLenum, *mut GLfloat);

/// The prototype to the OpenGL function `GetSamplerParameterIuiv`
type PFNGLGETSAMPLERPARAMETERIUIVPROC = extern "system" fn(GLuint, GLenum, *mut GLuint);

/// The prototype to the OpenGL function `QueryCounter`
type PFNGLQUERYCOUNTERPROC = extern "system" fn(GLuint, GLenum);

/// The prototype to the OpenGL function `GetQueryObjecti64v`
type PFNGLGETQUERYOBJECTI64VPROC = extern "system" fn(GLuint, GLenum, *mut GLint64);

/// The prototype to the OpenGL function `GetQueryObjectui64v`
type PFNGLGETQUERYOBJECTUI64VPROC = extern "system" fn(GLuint, GLenum, *mut GLuint64);

/// The prototype to the OpenGL function `VertexAttribDivisor`
type PFNGLVERTEXATTRIBDIVISORPROC = extern "system" fn(GLuint, GLuint);

/// The prototype to the OpenGL function `VertexAttribP1ui`
type PFNGLVERTEXATTRIBP1UIPROC = extern "system" fn(GLuint, GLenum, GLboolean, GLuint);

/// The prototype to the OpenGL function `VertexAttribP1uiv`
type PFNGLVERTEXATTRIBP1UIVPROC = extern "system" fn(GLuint, GLenum, GLboolean, *const GLuint);

/// The prototype to the OpenGL function `VertexAttribP2ui`
type PFNGLVERTEXATTRIBP2UIPROC = extern "system" fn(GLuint, GLenum, GLboolean, GLuint);

/// The prototype to the OpenGL function `VertexAttribP2uiv`
type PFNGLVERTEXATTRIBP2UIVPROC = extern "system" fn(GLuint, GLenum, GLboolean, *const GLuint);

/// The prototype to the OpenGL function `VertexAttribP3ui`
type PFNGLVERTEXATTRIBP3UIPROC = extern "system" fn(GLuint, GLenum, GLboolean, GLuint);

/// The prototype to the OpenGL function `VertexAttribP3uiv`
type PFNGLVERTEXATTRIBP3UIVPROC = extern "system" fn(GLuint, GLenum, GLboolean, *const GLuint);

/// The prototype to the OpenGL function `VertexAttribP4ui`
type PFNGLVERTEXATTRIBP4UIPROC = extern "system" fn(GLuint, GLenum, GLboolean, GLuint);

/// The prototype to the OpenGL function `VertexAttribP4uiv`
type PFNGLVERTEXATTRIBP4UIVPROC = extern "system" fn(GLuint, GLenum, GLboolean, *const GLuint);

/// The prototype to the OpenGL function `VertexP2ui`
type PFNGLVERTEXP2UIPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `VertexP2uiv`
type PFNGLVERTEXP2UIVPROC = extern "system" fn(GLenum, *const GLuint);

/// The prototype to the OpenGL function `VertexP3ui`
type PFNGLVERTEXP3UIPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `VertexP3uiv`
type PFNGLVERTEXP3UIVPROC = extern "system" fn(GLenum, *const GLuint);

/// The prototype to the OpenGL function `VertexP4ui`
type PFNGLVERTEXP4UIPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `VertexP4uiv`
type PFNGLVERTEXP4UIVPROC = extern "system" fn(GLenum, *const GLuint);

/// The prototype to the OpenGL function `TexCoordP1ui`
type PFNGLTEXCOORDP1UIPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `TexCoordP1uiv`
type PFNGLTEXCOORDP1UIVPROC = extern "system" fn(GLenum, *const GLuint);

/// The prototype to the OpenGL function `TexCoordP2ui`
type PFNGLTEXCOORDP2UIPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `TexCoordP2uiv`
type PFNGLTEXCOORDP2UIVPROC = extern "system" fn(GLenum, *const GLuint);

/// The prototype to the OpenGL function `TexCoordP3ui`
type PFNGLTEXCOORDP3UIPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `TexCoordP3uiv`
type PFNGLTEXCOORDP3UIVPROC = extern "system" fn(GLenum, *const GLuint);

/// The prototype to the OpenGL function `TexCoordP4ui`
type PFNGLTEXCOORDP4UIPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `TexCoordP4uiv`
type PFNGLTEXCOORDP4UIVPROC = extern "system" fn(GLenum, *const GLuint);

/// The prototype to the OpenGL function `MultiTexCoordP1ui`
type PFNGLMULTITEXCOORDP1UIPROC = extern "system" fn(GLenum, GLenum, GLuint);

/// The prototype to the OpenGL function `MultiTexCoordP1uiv`
type PFNGLMULTITEXCOORDP1UIVPROC = extern "system" fn(GLenum, GLenum, *const GLuint);

/// The prototype to the OpenGL function `MultiTexCoordP2ui`
type PFNGLMULTITEXCOORDP2UIPROC = extern "system" fn(GLenum, GLenum, GLuint);

/// The prototype to the OpenGL function `MultiTexCoordP2uiv`
type PFNGLMULTITEXCOORDP2UIVPROC = extern "system" fn(GLenum, GLenum, *const GLuint);

/// The prototype to the OpenGL function `MultiTexCoordP3ui`
type PFNGLMULTITEXCOORDP3UIPROC = extern "system" fn(GLenum, GLenum, GLuint);

/// The prototype to the OpenGL function `MultiTexCoordP3uiv`
type PFNGLMULTITEXCOORDP3UIVPROC = extern "system" fn(GLenum, GLenum, *const GLuint);

/// The prototype to the OpenGL function `MultiTexCoordP4ui`
type PFNGLMULTITEXCOORDP4UIPROC = extern "system" fn(GLenum, GLenum, GLuint);

/// The prototype to the OpenGL function `MultiTexCoordP4uiv`
type PFNGLMULTITEXCOORDP4UIVPROC = extern "system" fn(GLenum, GLenum, *const GLuint);

/// The prototype to the OpenGL function `NormalP3ui`
type PFNGLNORMALP3UIPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `NormalP3uiv`
type PFNGLNORMALP3UIVPROC = extern "system" fn(GLenum, *const GLuint);

/// The prototype to the OpenGL function `ColorP3ui`
type PFNGLCOLORP3UIPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `ColorP3uiv`
type PFNGLCOLORP3UIVPROC = extern "system" fn(GLenum, *const GLuint);

/// The prototype to the OpenGL function `ColorP4ui`
type PFNGLCOLORP4UIPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `ColorP4uiv`
type PFNGLCOLORP4UIVPROC = extern "system" fn(GLenum, *const GLuint);

/// The prototype to the OpenGL function `SecondaryColorP3ui`
type PFNGLSECONDARYCOLORP3UIPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `SecondaryColorP3uiv`
type PFNGLSECONDARYCOLORP3UIVPROC = extern "system" fn(GLenum, *const GLuint);

/// The dummy function of `BindFragDataLocationIndexed()`
extern "system" fn dummy_pfnglbindfragdatalocationindexedproc (_: GLuint, _: GLuint, _: GLuint, _: *const GLchar) {
	panic!("OpenGL function pointer `glBindFragDataLocationIndexed()` is null.")
}

/// The dummy function of `GetFragDataIndex()`
extern "system" fn dummy_pfnglgetfragdataindexproc (_: GLuint, _: *const GLchar) -> GLint {
	panic!("OpenGL function pointer `glGetFragDataIndex()` is null.")
}

/// The dummy function of `GenSamplers()`
extern "system" fn dummy_pfnglgensamplersproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGenSamplers()` is null.")
}

/// The dummy function of `DeleteSamplers()`
extern "system" fn dummy_pfngldeletesamplersproc (_: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glDeleteSamplers()` is null.")
}

/// The dummy function of `IsSampler()`
extern "system" fn dummy_pfnglissamplerproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsSampler()` is null.")
}

/// The dummy function of `BindSampler()`
extern "system" fn dummy_pfnglbindsamplerproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glBindSampler()` is null.")
}

/// The dummy function of `SamplerParameteri()`
extern "system" fn dummy_pfnglsamplerparameteriproc (_: GLuint, _: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glSamplerParameteri()` is null.")
}

/// The dummy function of `SamplerParameteriv()`
extern "system" fn dummy_pfnglsamplerparameterivproc (_: GLuint, _: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glSamplerParameteriv()` is null.")
}

/// The dummy function of `SamplerParameterf()`
extern "system" fn dummy_pfnglsamplerparameterfproc (_: GLuint, _: GLenum, _: GLfloat) {
	panic!("OpenGL function pointer `glSamplerParameterf()` is null.")
}

/// The dummy function of `SamplerParameterfv()`
extern "system" fn dummy_pfnglsamplerparameterfvproc (_: GLuint, _: GLenum, _: *const GLfloat) {
	panic!("OpenGL function pointer `glSamplerParameterfv()` is null.")
}

/// The dummy function of `SamplerParameterIiv()`
extern "system" fn dummy_pfnglsamplerparameteriivproc (_: GLuint, _: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glSamplerParameterIiv()` is null.")
}

/// The dummy function of `SamplerParameterIuiv()`
extern "system" fn dummy_pfnglsamplerparameteriuivproc (_: GLuint, _: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glSamplerParameterIuiv()` is null.")
}

/// The dummy function of `GetSamplerParameteriv()`
extern "system" fn dummy_pfnglgetsamplerparameterivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetSamplerParameteriv()` is null.")
}

/// The dummy function of `GetSamplerParameterIiv()`
extern "system" fn dummy_pfnglgetsamplerparameteriivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetSamplerParameterIiv()` is null.")
}

/// The dummy function of `GetSamplerParameterfv()`
extern "system" fn dummy_pfnglgetsamplerparameterfvproc (_: GLuint, _: GLenum, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetSamplerParameterfv()` is null.")
}

/// The dummy function of `GetSamplerParameterIuiv()`
extern "system" fn dummy_pfnglgetsamplerparameteriuivproc (_: GLuint, _: GLenum, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetSamplerParameterIuiv()` is null.")
}

/// The dummy function of `QueryCounter()`
extern "system" fn dummy_pfnglquerycounterproc (_: GLuint, _: GLenum) {
	panic!("OpenGL function pointer `glQueryCounter()` is null.")
}

/// The dummy function of `GetQueryObjecti64v()`
extern "system" fn dummy_pfnglgetqueryobjecti64vproc (_: GLuint, _: GLenum, _: *mut GLint64) {
	panic!("OpenGL function pointer `glGetQueryObjecti64v()` is null.")
}

/// The dummy function of `GetQueryObjectui64v()`
extern "system" fn dummy_pfnglgetqueryobjectui64vproc (_: GLuint, _: GLenum, _: *mut GLuint64) {
	panic!("OpenGL function pointer `glGetQueryObjectui64v()` is null.")
}

/// The dummy function of `VertexAttribDivisor()`
extern "system" fn dummy_pfnglvertexattribdivisorproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribDivisor()` is null.")
}

/// The dummy function of `VertexAttribP1ui()`
extern "system" fn dummy_pfnglvertexattribp1uiproc (_: GLuint, _: GLenum, _: GLboolean, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribP1ui()` is null.")
}

/// The dummy function of `VertexAttribP1uiv()`
extern "system" fn dummy_pfnglvertexattribp1uivproc (_: GLuint, _: GLenum, _: GLboolean, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttribP1uiv()` is null.")
}

/// The dummy function of `VertexAttribP2ui()`
extern "system" fn dummy_pfnglvertexattribp2uiproc (_: GLuint, _: GLenum, _: GLboolean, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribP2ui()` is null.")
}

/// The dummy function of `VertexAttribP2uiv()`
extern "system" fn dummy_pfnglvertexattribp2uivproc (_: GLuint, _: GLenum, _: GLboolean, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttribP2uiv()` is null.")
}

/// The dummy function of `VertexAttribP3ui()`
extern "system" fn dummy_pfnglvertexattribp3uiproc (_: GLuint, _: GLenum, _: GLboolean, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribP3ui()` is null.")
}

/// The dummy function of `VertexAttribP3uiv()`
extern "system" fn dummy_pfnglvertexattribp3uivproc (_: GLuint, _: GLenum, _: GLboolean, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttribP3uiv()` is null.")
}

/// The dummy function of `VertexAttribP4ui()`
extern "system" fn dummy_pfnglvertexattribp4uiproc (_: GLuint, _: GLenum, _: GLboolean, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribP4ui()` is null.")
}

/// The dummy function of `VertexAttribP4uiv()`
extern "system" fn dummy_pfnglvertexattribp4uivproc (_: GLuint, _: GLenum, _: GLboolean, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttribP4uiv()` is null.")
}

/// The dummy function of `VertexP2ui()`
extern "system" fn dummy_pfnglvertexp2uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glVertexP2ui()` is null.")
}

/// The dummy function of `VertexP2uiv()`
extern "system" fn dummy_pfnglvertexp2uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexP2uiv()` is null.")
}

/// The dummy function of `VertexP3ui()`
extern "system" fn dummy_pfnglvertexp3uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glVertexP3ui()` is null.")
}

/// The dummy function of `VertexP3uiv()`
extern "system" fn dummy_pfnglvertexp3uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexP3uiv()` is null.")
}

/// The dummy function of `VertexP4ui()`
extern "system" fn dummy_pfnglvertexp4uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glVertexP4ui()` is null.")
}

/// The dummy function of `VertexP4uiv()`
extern "system" fn dummy_pfnglvertexp4uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexP4uiv()` is null.")
}

/// The dummy function of `TexCoordP1ui()`
extern "system" fn dummy_pfngltexcoordp1uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glTexCoordP1ui()` is null.")
}

/// The dummy function of `TexCoordP1uiv()`
extern "system" fn dummy_pfngltexcoordp1uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glTexCoordP1uiv()` is null.")
}

/// The dummy function of `TexCoordP2ui()`
extern "system" fn dummy_pfngltexcoordp2uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glTexCoordP2ui()` is null.")
}

/// The dummy function of `TexCoordP2uiv()`
extern "system" fn dummy_pfngltexcoordp2uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glTexCoordP2uiv()` is null.")
}

/// The dummy function of `TexCoordP3ui()`
extern "system" fn dummy_pfngltexcoordp3uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glTexCoordP3ui()` is null.")
}

/// The dummy function of `TexCoordP3uiv()`
extern "system" fn dummy_pfngltexcoordp3uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glTexCoordP3uiv()` is null.")
}

/// The dummy function of `TexCoordP4ui()`
extern "system" fn dummy_pfngltexcoordp4uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glTexCoordP4ui()` is null.")
}

/// The dummy function of `TexCoordP4uiv()`
extern "system" fn dummy_pfngltexcoordp4uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glTexCoordP4uiv()` is null.")
}

/// The dummy function of `MultiTexCoordP1ui()`
extern "system" fn dummy_pfnglmultitexcoordp1uiproc (_: GLenum, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glMultiTexCoordP1ui()` is null.")
}

/// The dummy function of `MultiTexCoordP1uiv()`
extern "system" fn dummy_pfnglmultitexcoordp1uivproc (_: GLenum, _: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glMultiTexCoordP1uiv()` is null.")
}

/// The dummy function of `MultiTexCoordP2ui()`
extern "system" fn dummy_pfnglmultitexcoordp2uiproc (_: GLenum, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glMultiTexCoordP2ui()` is null.")
}

/// The dummy function of `MultiTexCoordP2uiv()`
extern "system" fn dummy_pfnglmultitexcoordp2uivproc (_: GLenum, _: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glMultiTexCoordP2uiv()` is null.")
}

/// The dummy function of `MultiTexCoordP3ui()`
extern "system" fn dummy_pfnglmultitexcoordp3uiproc (_: GLenum, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glMultiTexCoordP3ui()` is null.")
}

/// The dummy function of `MultiTexCoordP3uiv()`
extern "system" fn dummy_pfnglmultitexcoordp3uivproc (_: GLenum, _: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glMultiTexCoordP3uiv()` is null.")
}

/// The dummy function of `MultiTexCoordP4ui()`
extern "system" fn dummy_pfnglmultitexcoordp4uiproc (_: GLenum, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glMultiTexCoordP4ui()` is null.")
}

/// The dummy function of `MultiTexCoordP4uiv()`
extern "system" fn dummy_pfnglmultitexcoordp4uivproc (_: GLenum, _: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glMultiTexCoordP4uiv()` is null.")
}

/// The dummy function of `NormalP3ui()`
extern "system" fn dummy_pfnglnormalp3uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glNormalP3ui()` is null.")
}

/// The dummy function of `NormalP3uiv()`
extern "system" fn dummy_pfnglnormalp3uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glNormalP3uiv()` is null.")
}

/// The dummy function of `ColorP3ui()`
extern "system" fn dummy_pfnglcolorp3uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glColorP3ui()` is null.")
}

/// The dummy function of `ColorP3uiv()`
extern "system" fn dummy_pfnglcolorp3uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glColorP3uiv()` is null.")
}

/// The dummy function of `ColorP4ui()`
extern "system" fn dummy_pfnglcolorp4uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glColorP4ui()` is null.")
}

/// The dummy function of `ColorP4uiv()`
extern "system" fn dummy_pfnglcolorp4uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glColorP4uiv()` is null.")
}

/// The dummy function of `SecondaryColorP3ui()`
extern "system" fn dummy_pfnglsecondarycolorp3uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glSecondaryColorP3ui()` is null.")
}

/// The dummy function of `SecondaryColorP3uiv()`
extern "system" fn dummy_pfnglsecondarycolorp3uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glSecondaryColorP3uiv()` is null.")
}
/// Constant value defined from OpenGL 3.3
pub const GL_VERTEX_ATTRIB_ARRAY_DIVISOR: GLenum = 0x88FE;

/// Constant value defined from OpenGL 3.3
pub const GL_SRC1_COLOR: GLenum = 0x88F9;

/// Constant value defined from OpenGL 3.3
pub const GL_ONE_MINUS_SRC1_COLOR: GLenum = 0x88FA;

/// Constant value defined from OpenGL 3.3
pub const GL_ONE_MINUS_SRC1_ALPHA: GLenum = 0x88FB;

/// Constant value defined from OpenGL 3.3
pub const GL_MAX_DUAL_SOURCE_DRAW_BUFFERS: GLenum = 0x88FC;

/// Constant value defined from OpenGL 3.3
pub const GL_ANY_SAMPLES_PASSED: GLenum = 0x8C2F;

/// Constant value defined from OpenGL 3.3
pub const GL_SAMPLER_BINDING: GLenum = 0x8919;

/// Constant value defined from OpenGL 3.3
pub const GL_RGB10_A2UI: GLenum = 0x906F;

/// Constant value defined from OpenGL 3.3
pub const GL_TEXTURE_SWIZZLE_R: GLenum = 0x8E42;

/// Constant value defined from OpenGL 3.3
pub const GL_TEXTURE_SWIZZLE_G: GLenum = 0x8E43;

/// Constant value defined from OpenGL 3.3
pub const GL_TEXTURE_SWIZZLE_B: GLenum = 0x8E44;

/// Constant value defined from OpenGL 3.3
pub const GL_TEXTURE_SWIZZLE_A: GLenum = 0x8E45;

/// Constant value defined from OpenGL 3.3
pub const GL_TEXTURE_SWIZZLE_RGBA: GLenum = 0x8E46;

/// Constant value defined from OpenGL 3.3
pub const GL_TIME_ELAPSED: GLenum = 0x88BF;

/// Constant value defined from OpenGL 3.3
pub const GL_TIMESTAMP: GLenum = 0x8E28;

/// Constant value defined from OpenGL 3.3
pub const GL_INT_2_10_10_10_REV: GLenum = 0x8D9F;

/// Functions from OpenGL version 3.3
pub trait GL_3_3 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	fn glGetError(&self) -> GLenum;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindFragDataLocationIndexed.xhtml>
	fn glBindFragDataLocationIndexed(&self, program: GLuint, colorNumber: GLuint, index: GLuint, name: *const GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetFragDataIndex.xhtml>
	fn glGetFragDataIndex(&self, program: GLuint, name: *const GLchar) -> Result<GLint>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenSamplers.xhtml>
	fn glGenSamplers(&self, count: GLsizei, samplers: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteSamplers.xhtml>
	fn glDeleteSamplers(&self, count: GLsizei, samplers: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsSampler.xhtml>
	fn glIsSampler(&self, sampler: GLuint) -> Result<GLboolean>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindSampler.xhtml>
	fn glBindSampler(&self, unit: GLuint, sampler: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSamplerParameteri.xhtml>
	fn glSamplerParameteri(&self, sampler: GLuint, pname: GLenum, param: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSamplerParameteriv.xhtml>
	fn glSamplerParameteriv(&self, sampler: GLuint, pname: GLenum, param: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSamplerParameterf.xhtml>
	fn glSamplerParameterf(&self, sampler: GLuint, pname: GLenum, param: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSamplerParameterfv.xhtml>
	fn glSamplerParameterfv(&self, sampler: GLuint, pname: GLenum, param: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSamplerParameterIiv.xhtml>
	fn glSamplerParameterIiv(&self, sampler: GLuint, pname: GLenum, param: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSamplerParameterIuiv.xhtml>
	fn glSamplerParameterIuiv(&self, sampler: GLuint, pname: GLenum, param: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSamplerParameteriv.xhtml>
	fn glGetSamplerParameteriv(&self, sampler: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSamplerParameterIiv.xhtml>
	fn glGetSamplerParameterIiv(&self, sampler: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSamplerParameterfv.xhtml>
	fn glGetSamplerParameterfv(&self, sampler: GLuint, pname: GLenum, params: *mut GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSamplerParameterIuiv.xhtml>
	fn glGetSamplerParameterIuiv(&self, sampler: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glQueryCounter.xhtml>
	fn glQueryCounter(&self, id: GLuint, target: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryObjecti64v.xhtml>
	fn glGetQueryObjecti64v(&self, id: GLuint, pname: GLenum, params: *mut GLint64) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryObjectui64v.xhtml>
	fn glGetQueryObjectui64v(&self, id: GLuint, pname: GLenum, params: *mut GLuint64) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribDivisor.xhtml>
	fn glVertexAttribDivisor(&self, index: GLuint, divisor: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP1ui.xhtml>
	fn glVertexAttribP1ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP1uiv.xhtml>
	fn glVertexAttribP1uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP2ui.xhtml>
	fn glVertexAttribP2ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP2uiv.xhtml>
	fn glVertexAttribP2uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP3ui.xhtml>
	fn glVertexAttribP3ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP3uiv.xhtml>
	fn glVertexAttribP3uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP4ui.xhtml>
	fn glVertexAttribP4ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP4uiv.xhtml>
	fn glVertexAttribP4uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexP2ui.xhtml>
	fn glVertexP2ui(&self, type_: GLenum, value: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexP2uiv.xhtml>
	fn glVertexP2uiv(&self, type_: GLenum, value: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexP3ui.xhtml>
	fn glVertexP3ui(&self, type_: GLenum, value: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexP3uiv.xhtml>
	fn glVertexP3uiv(&self, type_: GLenum, value: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexP4ui.xhtml>
	fn glVertexP4ui(&self, type_: GLenum, value: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexP4uiv.xhtml>
	fn glVertexP4uiv(&self, type_: GLenum, value: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP1ui.xhtml>
	fn glTexCoordP1ui(&self, type_: GLenum, coords: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP1uiv.xhtml>
	fn glTexCoordP1uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP2ui.xhtml>
	fn glTexCoordP2ui(&self, type_: GLenum, coords: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP2uiv.xhtml>
	fn glTexCoordP2uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP3ui.xhtml>
	fn glTexCoordP3ui(&self, type_: GLenum, coords: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP3uiv.xhtml>
	fn glTexCoordP3uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP4ui.xhtml>
	fn glTexCoordP4ui(&self, type_: GLenum, coords: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP4uiv.xhtml>
	fn glTexCoordP4uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP1ui.xhtml>
	fn glMultiTexCoordP1ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP1uiv.xhtml>
	fn glMultiTexCoordP1uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP2ui.xhtml>
	fn glMultiTexCoordP2ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP2uiv.xhtml>
	fn glMultiTexCoordP2uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP3ui.xhtml>
	fn glMultiTexCoordP3ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP3uiv.xhtml>
	fn glMultiTexCoordP3uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP4ui.xhtml>
	fn glMultiTexCoordP4ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP4uiv.xhtml>
	fn glMultiTexCoordP4uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNormalP3ui.xhtml>
	fn glNormalP3ui(&self, type_: GLenum, coords: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNormalP3uiv.xhtml>
	fn glNormalP3uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glColorP3ui.xhtml>
	fn glColorP3ui(&self, type_: GLenum, color: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glColorP3uiv.xhtml>
	fn glColorP3uiv(&self, type_: GLenum, color: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glColorP4ui.xhtml>
	fn glColorP4ui(&self, type_: GLenum, color: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glColorP4uiv.xhtml>
	fn glColorP4uiv(&self, type_: GLenum, color: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColorP3ui.xhtml>
	fn glSecondaryColorP3ui(&self, type_: GLenum, color: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColorP3uiv.xhtml>
	fn glSecondaryColorP3uiv(&self, type_: GLenum, color: *const GLuint) -> Result<()>;
}
/// Functions from OpenGL version 3.3
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version33 {
	/// Is OpenGL version 3.3 available
	available: bool,

	/// The function pointer to `glGetError()`
	pub geterror: PFNGLGETERRORPROC,

	/// The function pointer to `glBindFragDataLocationIndexed()`
	pub bindfragdatalocationindexed: PFNGLBINDFRAGDATALOCATIONINDEXEDPROC,

	/// The function pointer to `glGetFragDataIndex()`
	pub getfragdataindex: PFNGLGETFRAGDATAINDEXPROC,

	/// The function pointer to `glGenSamplers()`
	pub gensamplers: PFNGLGENSAMPLERSPROC,

	/// The function pointer to `glDeleteSamplers()`
	pub deletesamplers: PFNGLDELETESAMPLERSPROC,

	/// The function pointer to `glIsSampler()`
	pub issampler: PFNGLISSAMPLERPROC,

	/// The function pointer to `glBindSampler()`
	pub bindsampler: PFNGLBINDSAMPLERPROC,

	/// The function pointer to `glSamplerParameteri()`
	pub samplerparameteri: PFNGLSAMPLERPARAMETERIPROC,

	/// The function pointer to `glSamplerParameteriv()`
	pub samplerparameteriv: PFNGLSAMPLERPARAMETERIVPROC,

	/// The function pointer to `glSamplerParameterf()`
	pub samplerparameterf: PFNGLSAMPLERPARAMETERFPROC,

	/// The function pointer to `glSamplerParameterfv()`
	pub samplerparameterfv: PFNGLSAMPLERPARAMETERFVPROC,

	/// The function pointer to `glSamplerParameterIiv()`
	pub samplerparameteriiv: PFNGLSAMPLERPARAMETERIIVPROC,

	/// The function pointer to `glSamplerParameterIuiv()`
	pub samplerparameteriuiv: PFNGLSAMPLERPARAMETERIUIVPROC,

	/// The function pointer to `glGetSamplerParameteriv()`
	pub getsamplerparameteriv: PFNGLGETSAMPLERPARAMETERIVPROC,

	/// The function pointer to `glGetSamplerParameterIiv()`
	pub getsamplerparameteriiv: PFNGLGETSAMPLERPARAMETERIIVPROC,

	/// The function pointer to `glGetSamplerParameterfv()`
	pub getsamplerparameterfv: PFNGLGETSAMPLERPARAMETERFVPROC,

	/// The function pointer to `glGetSamplerParameterIuiv()`
	pub getsamplerparameteriuiv: PFNGLGETSAMPLERPARAMETERIUIVPROC,

	/// The function pointer to `glQueryCounter()`
	pub querycounter: PFNGLQUERYCOUNTERPROC,

	/// The function pointer to `glGetQueryObjecti64v()`
	pub getqueryobjecti64v: PFNGLGETQUERYOBJECTI64VPROC,

	/// The function pointer to `glGetQueryObjectui64v()`
	pub getqueryobjectui64v: PFNGLGETQUERYOBJECTUI64VPROC,

	/// The function pointer to `glVertexAttribDivisor()`
	pub vertexattribdivisor: PFNGLVERTEXATTRIBDIVISORPROC,

	/// The function pointer to `glVertexAttribP1ui()`
	pub vertexattribp1ui: PFNGLVERTEXATTRIBP1UIPROC,

	/// The function pointer to `glVertexAttribP1uiv()`
	pub vertexattribp1uiv: PFNGLVERTEXATTRIBP1UIVPROC,

	/// The function pointer to `glVertexAttribP2ui()`
	pub vertexattribp2ui: PFNGLVERTEXATTRIBP2UIPROC,

	/// The function pointer to `glVertexAttribP2uiv()`
	pub vertexattribp2uiv: PFNGLVERTEXATTRIBP2UIVPROC,

	/// The function pointer to `glVertexAttribP3ui()`
	pub vertexattribp3ui: PFNGLVERTEXATTRIBP3UIPROC,

	/// The function pointer to `glVertexAttribP3uiv()`
	pub vertexattribp3uiv: PFNGLVERTEXATTRIBP3UIVPROC,

	/// The function pointer to `glVertexAttribP4ui()`
	pub vertexattribp4ui: PFNGLVERTEXATTRIBP4UIPROC,

	/// The function pointer to `glVertexAttribP4uiv()`
	pub vertexattribp4uiv: PFNGLVERTEXATTRIBP4UIVPROC,

	/// The function pointer to `glVertexP2ui()`
	pub vertexp2ui: PFNGLVERTEXP2UIPROC,

	/// The function pointer to `glVertexP2uiv()`
	pub vertexp2uiv: PFNGLVERTEXP2UIVPROC,

	/// The function pointer to `glVertexP3ui()`
	pub vertexp3ui: PFNGLVERTEXP3UIPROC,

	/// The function pointer to `glVertexP3uiv()`
	pub vertexp3uiv: PFNGLVERTEXP3UIVPROC,

	/// The function pointer to `glVertexP4ui()`
	pub vertexp4ui: PFNGLVERTEXP4UIPROC,

	/// The function pointer to `glVertexP4uiv()`
	pub vertexp4uiv: PFNGLVERTEXP4UIVPROC,

	/// The function pointer to `glTexCoordP1ui()`
	pub texcoordp1ui: PFNGLTEXCOORDP1UIPROC,

	/// The function pointer to `glTexCoordP1uiv()`
	pub texcoordp1uiv: PFNGLTEXCOORDP1UIVPROC,

	/// The function pointer to `glTexCoordP2ui()`
	pub texcoordp2ui: PFNGLTEXCOORDP2UIPROC,

	/// The function pointer to `glTexCoordP2uiv()`
	pub texcoordp2uiv: PFNGLTEXCOORDP2UIVPROC,

	/// The function pointer to `glTexCoordP3ui()`
	pub texcoordp3ui: PFNGLTEXCOORDP3UIPROC,

	/// The function pointer to `glTexCoordP3uiv()`
	pub texcoordp3uiv: PFNGLTEXCOORDP3UIVPROC,

	/// The function pointer to `glTexCoordP4ui()`
	pub texcoordp4ui: PFNGLTEXCOORDP4UIPROC,

	/// The function pointer to `glTexCoordP4uiv()`
	pub texcoordp4uiv: PFNGLTEXCOORDP4UIVPROC,

	/// The function pointer to `glMultiTexCoordP1ui()`
	pub multitexcoordp1ui: PFNGLMULTITEXCOORDP1UIPROC,

	/// The function pointer to `glMultiTexCoordP1uiv()`
	pub multitexcoordp1uiv: PFNGLMULTITEXCOORDP1UIVPROC,

	/// The function pointer to `glMultiTexCoordP2ui()`
	pub multitexcoordp2ui: PFNGLMULTITEXCOORDP2UIPROC,

	/// The function pointer to `glMultiTexCoordP2uiv()`
	pub multitexcoordp2uiv: PFNGLMULTITEXCOORDP2UIVPROC,

	/// The function pointer to `glMultiTexCoordP3ui()`
	pub multitexcoordp3ui: PFNGLMULTITEXCOORDP3UIPROC,

	/// The function pointer to `glMultiTexCoordP3uiv()`
	pub multitexcoordp3uiv: PFNGLMULTITEXCOORDP3UIVPROC,

	/// The function pointer to `glMultiTexCoordP4ui()`
	pub multitexcoordp4ui: PFNGLMULTITEXCOORDP4UIPROC,

	/// The function pointer to `glMultiTexCoordP4uiv()`
	pub multitexcoordp4uiv: PFNGLMULTITEXCOORDP4UIVPROC,

	/// The function pointer to `glNormalP3ui()`
	pub normalp3ui: PFNGLNORMALP3UIPROC,

	/// The function pointer to `glNormalP3uiv()`
	pub normalp3uiv: PFNGLNORMALP3UIVPROC,

	/// The function pointer to `glColorP3ui()`
	pub colorp3ui: PFNGLCOLORP3UIPROC,

	/// The function pointer to `glColorP3uiv()`
	pub colorp3uiv: PFNGLCOLORP3UIVPROC,

	/// The function pointer to `glColorP4ui()`
	pub colorp4ui: PFNGLCOLORP4UIPROC,

	/// The function pointer to `glColorP4uiv()`
	pub colorp4uiv: PFNGLCOLORP4UIVPROC,

	/// The function pointer to `glSecondaryColorP3ui()`
	pub secondarycolorp3ui: PFNGLSECONDARYCOLORP3UIPROC,

	/// The function pointer to `glSecondaryColorP3uiv()`
	pub secondarycolorp3uiv: PFNGLSECONDARYCOLORP3UIVPROC,
}

impl GL_3_3 for Version33 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindFragDataLocationIndexed.xhtml>
	#[inline(always)]
	fn glBindFragDataLocationIndexed(&self, program: GLuint, colorNumber: GLuint, index: GLuint, name: *const GLchar) -> Result<()> {
		let ret = process_catch("glBindFragDataLocationIndexed", catch_unwind(||(self.bindfragdatalocationindexed)(program, colorNumber, index, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindFragDataLocationIndexed", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetFragDataIndex.xhtml>
	#[inline(always)]
	fn glGetFragDataIndex(&self, program: GLuint, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetFragDataIndex", catch_unwind(||(self.getfragdataindex)(program, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFragDataIndex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenSamplers.xhtml>
	#[inline(always)]
	fn glGenSamplers(&self, count: GLsizei, samplers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenSamplers", catch_unwind(||(self.gensamplers)(count, samplers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenSamplers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteSamplers.xhtml>
	#[inline(always)]
	fn glDeleteSamplers(&self, count: GLsizei, samplers: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteSamplers", catch_unwind(||(self.deletesamplers)(count, samplers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteSamplers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsSampler.xhtml>
	#[inline(always)]
	fn glIsSampler(&self, sampler: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsSampler", catch_unwind(||(self.issampler)(sampler)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsSampler", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindSampler.xhtml>
	#[inline(always)]
	fn glBindSampler(&self, unit: GLuint, sampler: GLuint) -> Result<()> {
		let ret = process_catch("glBindSampler", catch_unwind(||(self.bindsampler)(unit, sampler)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindSampler", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSamplerParameteri.xhtml>
	#[inline(always)]
	fn glSamplerParameteri(&self, sampler: GLuint, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glSamplerParameteri", catch_unwind(||(self.samplerparameteri)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameteri", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSamplerParameteriv.xhtml>
	#[inline(always)]
	fn glSamplerParameteriv(&self, sampler: GLuint, pname: GLenum, param: *const GLint) -> Result<()> {
		let ret = process_catch("glSamplerParameteriv", catch_unwind(||(self.samplerparameteriv)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSamplerParameterf.xhtml>
	#[inline(always)]
	fn glSamplerParameterf(&self, sampler: GLuint, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glSamplerParameterf", catch_unwind(||(self.samplerparameterf)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameterf", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSamplerParameterfv.xhtml>
	#[inline(always)]
	fn glSamplerParameterfv(&self, sampler: GLuint, pname: GLenum, param: *const GLfloat) -> Result<()> {
		let ret = process_catch("glSamplerParameterfv", catch_unwind(||(self.samplerparameterfv)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSamplerParameterIiv.xhtml>
	#[inline(always)]
	fn glSamplerParameterIiv(&self, sampler: GLuint, pname: GLenum, param: *const GLint) -> Result<()> {
		let ret = process_catch("glSamplerParameterIiv", catch_unwind(||(self.samplerparameteriiv)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameterIiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSamplerParameterIuiv.xhtml>
	#[inline(always)]
	fn glSamplerParameterIuiv(&self, sampler: GLuint, pname: GLenum, param: *const GLuint) -> Result<()> {
		let ret = process_catch("glSamplerParameterIuiv", catch_unwind(||(self.samplerparameteriuiv)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameterIuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSamplerParameteriv.xhtml>
	#[inline(always)]
	fn glGetSamplerParameteriv(&self, sampler: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetSamplerParameteriv", catch_unwind(||(self.getsamplerparameteriv)(sampler, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSamplerParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSamplerParameterIiv.xhtml>
	#[inline(always)]
	fn glGetSamplerParameterIiv(&self, sampler: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetSamplerParameterIiv", catch_unwind(||(self.getsamplerparameteriiv)(sampler, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSamplerParameterIiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSamplerParameterfv.xhtml>
	#[inline(always)]
	fn glGetSamplerParameterfv(&self, sampler: GLuint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetSamplerParameterfv", catch_unwind(||(self.getsamplerparameterfv)(sampler, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSamplerParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSamplerParameterIuiv.xhtml>
	#[inline(always)]
	fn glGetSamplerParameterIuiv(&self, sampler: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetSamplerParameterIuiv", catch_unwind(||(self.getsamplerparameteriuiv)(sampler, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSamplerParameterIuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glQueryCounter.xhtml>
	#[inline(always)]
	fn glQueryCounter(&self, id: GLuint, target: GLenum) -> Result<()> {
		let ret = process_catch("glQueryCounter", catch_unwind(||(self.querycounter)(id, target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glQueryCounter", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryObjecti64v.xhtml>
	#[inline(always)]
	fn glGetQueryObjecti64v(&self, id: GLuint, pname: GLenum, params: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetQueryObjecti64v", catch_unwind(||(self.getqueryobjecti64v)(id, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryObjecti64v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryObjectui64v.xhtml>
	#[inline(always)]
	fn glGetQueryObjectui64v(&self, id: GLuint, pname: GLenum, params: *mut GLuint64) -> Result<()> {
		let ret = process_catch("glGetQueryObjectui64v", catch_unwind(||(self.getqueryobjectui64v)(id, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryObjectui64v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribDivisor.xhtml>
	#[inline(always)]
	fn glVertexAttribDivisor(&self, index: GLuint, divisor: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribDivisor", catch_unwind(||(self.vertexattribdivisor)(index, divisor)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribDivisor", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP1ui.xhtml>
	#[inline(always)]
	fn glVertexAttribP1ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP1ui", catch_unwind(||(self.vertexattribp1ui)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP1ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP1uiv.xhtml>
	#[inline(always)]
	fn glVertexAttribP1uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP1uiv", catch_unwind(||(self.vertexattribp1uiv)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP1uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP2ui.xhtml>
	#[inline(always)]
	fn glVertexAttribP2ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP2ui", catch_unwind(||(self.vertexattribp2ui)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP2ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP2uiv.xhtml>
	#[inline(always)]
	fn glVertexAttribP2uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP2uiv", catch_unwind(||(self.vertexattribp2uiv)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP2uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP3ui.xhtml>
	#[inline(always)]
	fn glVertexAttribP3ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP3ui", catch_unwind(||(self.vertexattribp3ui)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP3uiv.xhtml>
	#[inline(always)]
	fn glVertexAttribP3uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP3uiv", catch_unwind(||(self.vertexattribp3uiv)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP4ui.xhtml>
	#[inline(always)]
	fn glVertexAttribP4ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP4ui", catch_unwind(||(self.vertexattribp4ui)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP4ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP4uiv.xhtml>
	#[inline(always)]
	fn glVertexAttribP4uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP4uiv", catch_unwind(||(self.vertexattribp4uiv)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP4uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexP2ui.xhtml>
	#[inline(always)]
	fn glVertexP2ui(&self, type_: GLenum, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexP2ui", catch_unwind(||(self.vertexp2ui)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP2ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexP2uiv.xhtml>
	#[inline(always)]
	fn glVertexP2uiv(&self, type_: GLenum, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexP2uiv", catch_unwind(||(self.vertexp2uiv)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP2uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexP3ui.xhtml>
	#[inline(always)]
	fn glVertexP3ui(&self, type_: GLenum, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexP3ui", catch_unwind(||(self.vertexp3ui)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexP3uiv.xhtml>
	#[inline(always)]
	fn glVertexP3uiv(&self, type_: GLenum, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexP3uiv", catch_unwind(||(self.vertexp3uiv)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexP4ui.xhtml>
	#[inline(always)]
	fn glVertexP4ui(&self, type_: GLenum, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexP4ui", catch_unwind(||(self.vertexp4ui)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP4ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexP4uiv.xhtml>
	#[inline(always)]
	fn glVertexP4uiv(&self, type_: GLenum, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexP4uiv", catch_unwind(||(self.vertexp4uiv)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP4uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP1ui.xhtml>
	#[inline(always)]
	fn glTexCoordP1ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP1ui", catch_unwind(||(self.texcoordp1ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP1ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP1uiv.xhtml>
	#[inline(always)]
	fn glTexCoordP1uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP1uiv", catch_unwind(||(self.texcoordp1uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP1uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP2ui.xhtml>
	#[inline(always)]
	fn glTexCoordP2ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP2ui", catch_unwind(||(self.texcoordp2ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP2ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP2uiv.xhtml>
	#[inline(always)]
	fn glTexCoordP2uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP2uiv", catch_unwind(||(self.texcoordp2uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP2uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP3ui.xhtml>
	#[inline(always)]
	fn glTexCoordP3ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP3ui", catch_unwind(||(self.texcoordp3ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP3uiv.xhtml>
	#[inline(always)]
	fn glTexCoordP3uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP3uiv", catch_unwind(||(self.texcoordp3uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP4ui.xhtml>
	#[inline(always)]
	fn glTexCoordP4ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP4ui", catch_unwind(||(self.texcoordp4ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP4ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP4uiv.xhtml>
	#[inline(always)]
	fn glTexCoordP4uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP4uiv", catch_unwind(||(self.texcoordp4uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP4uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP1ui.xhtml>
	#[inline(always)]
	fn glMultiTexCoordP1ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP1ui", catch_unwind(||(self.multitexcoordp1ui)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP1ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP1uiv.xhtml>
	#[inline(always)]
	fn glMultiTexCoordP1uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP1uiv", catch_unwind(||(self.multitexcoordp1uiv)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP1uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP2ui.xhtml>
	#[inline(always)]
	fn glMultiTexCoordP2ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP2ui", catch_unwind(||(self.multitexcoordp2ui)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP2ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP2uiv.xhtml>
	#[inline(always)]
	fn glMultiTexCoordP2uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP2uiv", catch_unwind(||(self.multitexcoordp2uiv)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP2uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP3ui.xhtml>
	#[inline(always)]
	fn glMultiTexCoordP3ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP3ui", catch_unwind(||(self.multitexcoordp3ui)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP3uiv.xhtml>
	#[inline(always)]
	fn glMultiTexCoordP3uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP3uiv", catch_unwind(||(self.multitexcoordp3uiv)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP4ui.xhtml>
	#[inline(always)]
	fn glMultiTexCoordP4ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP4ui", catch_unwind(||(self.multitexcoordp4ui)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP4ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP4uiv.xhtml>
	#[inline(always)]
	fn glMultiTexCoordP4uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP4uiv", catch_unwind(||(self.multitexcoordp4uiv)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP4uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNormalP3ui.xhtml>
	#[inline(always)]
	fn glNormalP3ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glNormalP3ui", catch_unwind(||(self.normalp3ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNormalP3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNormalP3uiv.xhtml>
	#[inline(always)]
	fn glNormalP3uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glNormalP3uiv", catch_unwind(||(self.normalp3uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNormalP3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glColorP3ui.xhtml>
	#[inline(always)]
	fn glColorP3ui(&self, type_: GLenum, color: GLuint) -> Result<()> {
		let ret = process_catch("glColorP3ui", catch_unwind(||(self.colorp3ui)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorP3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glColorP3uiv.xhtml>
	#[inline(always)]
	fn glColorP3uiv(&self, type_: GLenum, color: *const GLuint) -> Result<()> {
		let ret = process_catch("glColorP3uiv", catch_unwind(||(self.colorp3uiv)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorP3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glColorP4ui.xhtml>
	#[inline(always)]
	fn glColorP4ui(&self, type_: GLenum, color: GLuint) -> Result<()> {
		let ret = process_catch("glColorP4ui", catch_unwind(||(self.colorp4ui)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorP4ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glColorP4uiv.xhtml>
	#[inline(always)]
	fn glColorP4uiv(&self, type_: GLenum, color: *const GLuint) -> Result<()> {
		let ret = process_catch("glColorP4uiv", catch_unwind(||(self.colorp4uiv)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorP4uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColorP3ui.xhtml>
	#[inline(always)]
	fn glSecondaryColorP3ui(&self, type_: GLenum, color: GLuint) -> Result<()> {
		let ret = process_catch("glSecondaryColorP3ui", catch_unwind(||(self.secondarycolorp3ui)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColorP3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColorP3uiv.xhtml>
	#[inline(always)]
	fn glSecondaryColorP3uiv(&self, type_: GLenum, color: *const GLuint) -> Result<()> {
		let ret = process_catch("glSecondaryColorP3uiv", catch_unwind(||(self.secondarycolorp3uiv)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColorP3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version33 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (3, 3, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			bindfragdatalocationindexed: {let proc = get_proc_address("glBindFragDataLocationIndexed"); if proc == null() {dummy_pfnglbindfragdatalocationindexedproc} else {unsafe{transmute(proc)}}},
			getfragdataindex: {let proc = get_proc_address("glGetFragDataIndex"); if proc == null() {dummy_pfnglgetfragdataindexproc} else {unsafe{transmute(proc)}}},
			gensamplers: {let proc = get_proc_address("glGenSamplers"); if proc == null() {dummy_pfnglgensamplersproc} else {unsafe{transmute(proc)}}},
			deletesamplers: {let proc = get_proc_address("glDeleteSamplers"); if proc == null() {dummy_pfngldeletesamplersproc} else {unsafe{transmute(proc)}}},
			issampler: {let proc = get_proc_address("glIsSampler"); if proc == null() {dummy_pfnglissamplerproc} else {unsafe{transmute(proc)}}},
			bindsampler: {let proc = get_proc_address("glBindSampler"); if proc == null() {dummy_pfnglbindsamplerproc} else {unsafe{transmute(proc)}}},
			samplerparameteri: {let proc = get_proc_address("glSamplerParameteri"); if proc == null() {dummy_pfnglsamplerparameteriproc} else {unsafe{transmute(proc)}}},
			samplerparameteriv: {let proc = get_proc_address("glSamplerParameteriv"); if proc == null() {dummy_pfnglsamplerparameterivproc} else {unsafe{transmute(proc)}}},
			samplerparameterf: {let proc = get_proc_address("glSamplerParameterf"); if proc == null() {dummy_pfnglsamplerparameterfproc} else {unsafe{transmute(proc)}}},
			samplerparameterfv: {let proc = get_proc_address("glSamplerParameterfv"); if proc == null() {dummy_pfnglsamplerparameterfvproc} else {unsafe{transmute(proc)}}},
			samplerparameteriiv: {let proc = get_proc_address("glSamplerParameterIiv"); if proc == null() {dummy_pfnglsamplerparameteriivproc} else {unsafe{transmute(proc)}}},
			samplerparameteriuiv: {let proc = get_proc_address("glSamplerParameterIuiv"); if proc == null() {dummy_pfnglsamplerparameteriuivproc} else {unsafe{transmute(proc)}}},
			getsamplerparameteriv: {let proc = get_proc_address("glGetSamplerParameteriv"); if proc == null() {dummy_pfnglgetsamplerparameterivproc} else {unsafe{transmute(proc)}}},
			getsamplerparameteriiv: {let proc = get_proc_address("glGetSamplerParameterIiv"); if proc == null() {dummy_pfnglgetsamplerparameteriivproc} else {unsafe{transmute(proc)}}},
			getsamplerparameterfv: {let proc = get_proc_address("glGetSamplerParameterfv"); if proc == null() {dummy_pfnglgetsamplerparameterfvproc} else {unsafe{transmute(proc)}}},
			getsamplerparameteriuiv: {let proc = get_proc_address("glGetSamplerParameterIuiv"); if proc == null() {dummy_pfnglgetsamplerparameteriuivproc} else {unsafe{transmute(proc)}}},
			querycounter: {let proc = get_proc_address("glQueryCounter"); if proc == null() {dummy_pfnglquerycounterproc} else {unsafe{transmute(proc)}}},
			getqueryobjecti64v: {let proc = get_proc_address("glGetQueryObjecti64v"); if proc == null() {dummy_pfnglgetqueryobjecti64vproc} else {unsafe{transmute(proc)}}},
			getqueryobjectui64v: {let proc = get_proc_address("glGetQueryObjectui64v"); if proc == null() {dummy_pfnglgetqueryobjectui64vproc} else {unsafe{transmute(proc)}}},
			vertexattribdivisor: {let proc = get_proc_address("glVertexAttribDivisor"); if proc == null() {dummy_pfnglvertexattribdivisorproc} else {unsafe{transmute(proc)}}},
			vertexattribp1ui: {let proc = get_proc_address("glVertexAttribP1ui"); if proc == null() {dummy_pfnglvertexattribp1uiproc} else {unsafe{transmute(proc)}}},
			vertexattribp1uiv: {let proc = get_proc_address("glVertexAttribP1uiv"); if proc == null() {dummy_pfnglvertexattribp1uivproc} else {unsafe{transmute(proc)}}},
			vertexattribp2ui: {let proc = get_proc_address("glVertexAttribP2ui"); if proc == null() {dummy_pfnglvertexattribp2uiproc} else {unsafe{transmute(proc)}}},
			vertexattribp2uiv: {let proc = get_proc_address("glVertexAttribP2uiv"); if proc == null() {dummy_pfnglvertexattribp2uivproc} else {unsafe{transmute(proc)}}},
			vertexattribp3ui: {let proc = get_proc_address("glVertexAttribP3ui"); if proc == null() {dummy_pfnglvertexattribp3uiproc} else {unsafe{transmute(proc)}}},
			vertexattribp3uiv: {let proc = get_proc_address("glVertexAttribP3uiv"); if proc == null() {dummy_pfnglvertexattribp3uivproc} else {unsafe{transmute(proc)}}},
			vertexattribp4ui: {let proc = get_proc_address("glVertexAttribP4ui"); if proc == null() {dummy_pfnglvertexattribp4uiproc} else {unsafe{transmute(proc)}}},
			vertexattribp4uiv: {let proc = get_proc_address("glVertexAttribP4uiv"); if proc == null() {dummy_pfnglvertexattribp4uivproc} else {unsafe{transmute(proc)}}},
			vertexp2ui: {let proc = get_proc_address("glVertexP2ui"); if proc == null() {dummy_pfnglvertexp2uiproc} else {unsafe{transmute(proc)}}},
			vertexp2uiv: {let proc = get_proc_address("glVertexP2uiv"); if proc == null() {dummy_pfnglvertexp2uivproc} else {unsafe{transmute(proc)}}},
			vertexp3ui: {let proc = get_proc_address("glVertexP3ui"); if proc == null() {dummy_pfnglvertexp3uiproc} else {unsafe{transmute(proc)}}},
			vertexp3uiv: {let proc = get_proc_address("glVertexP3uiv"); if proc == null() {dummy_pfnglvertexp3uivproc} else {unsafe{transmute(proc)}}},
			vertexp4ui: {let proc = get_proc_address("glVertexP4ui"); if proc == null() {dummy_pfnglvertexp4uiproc} else {unsafe{transmute(proc)}}},
			vertexp4uiv: {let proc = get_proc_address("glVertexP4uiv"); if proc == null() {dummy_pfnglvertexp4uivproc} else {unsafe{transmute(proc)}}},
			texcoordp1ui: {let proc = get_proc_address("glTexCoordP1ui"); if proc == null() {dummy_pfngltexcoordp1uiproc} else {unsafe{transmute(proc)}}},
			texcoordp1uiv: {let proc = get_proc_address("glTexCoordP1uiv"); if proc == null() {dummy_pfngltexcoordp1uivproc} else {unsafe{transmute(proc)}}},
			texcoordp2ui: {let proc = get_proc_address("glTexCoordP2ui"); if proc == null() {dummy_pfngltexcoordp2uiproc} else {unsafe{transmute(proc)}}},
			texcoordp2uiv: {let proc = get_proc_address("glTexCoordP2uiv"); if proc == null() {dummy_pfngltexcoordp2uivproc} else {unsafe{transmute(proc)}}},
			texcoordp3ui: {let proc = get_proc_address("glTexCoordP3ui"); if proc == null() {dummy_pfngltexcoordp3uiproc} else {unsafe{transmute(proc)}}},
			texcoordp3uiv: {let proc = get_proc_address("glTexCoordP3uiv"); if proc == null() {dummy_pfngltexcoordp3uivproc} else {unsafe{transmute(proc)}}},
			texcoordp4ui: {let proc = get_proc_address("glTexCoordP4ui"); if proc == null() {dummy_pfngltexcoordp4uiproc} else {unsafe{transmute(proc)}}},
			texcoordp4uiv: {let proc = get_proc_address("glTexCoordP4uiv"); if proc == null() {dummy_pfngltexcoordp4uivproc} else {unsafe{transmute(proc)}}},
			multitexcoordp1ui: {let proc = get_proc_address("glMultiTexCoordP1ui"); if proc == null() {dummy_pfnglmultitexcoordp1uiproc} else {unsafe{transmute(proc)}}},
			multitexcoordp1uiv: {let proc = get_proc_address("glMultiTexCoordP1uiv"); if proc == null() {dummy_pfnglmultitexcoordp1uivproc} else {unsafe{transmute(proc)}}},
			multitexcoordp2ui: {let proc = get_proc_address("glMultiTexCoordP2ui"); if proc == null() {dummy_pfnglmultitexcoordp2uiproc} else {unsafe{transmute(proc)}}},
			multitexcoordp2uiv: {let proc = get_proc_address("glMultiTexCoordP2uiv"); if proc == null() {dummy_pfnglmultitexcoordp2uivproc} else {unsafe{transmute(proc)}}},
			multitexcoordp3ui: {let proc = get_proc_address("glMultiTexCoordP3ui"); if proc == null() {dummy_pfnglmultitexcoordp3uiproc} else {unsafe{transmute(proc)}}},
			multitexcoordp3uiv: {let proc = get_proc_address("glMultiTexCoordP3uiv"); if proc == null() {dummy_pfnglmultitexcoordp3uivproc} else {unsafe{transmute(proc)}}},
			multitexcoordp4ui: {let proc = get_proc_address("glMultiTexCoordP4ui"); if proc == null() {dummy_pfnglmultitexcoordp4uiproc} else {unsafe{transmute(proc)}}},
			multitexcoordp4uiv: {let proc = get_proc_address("glMultiTexCoordP4uiv"); if proc == null() {dummy_pfnglmultitexcoordp4uivproc} else {unsafe{transmute(proc)}}},
			normalp3ui: {let proc = get_proc_address("glNormalP3ui"); if proc == null() {dummy_pfnglnormalp3uiproc} else {unsafe{transmute(proc)}}},
			normalp3uiv: {let proc = get_proc_address("glNormalP3uiv"); if proc == null() {dummy_pfnglnormalp3uivproc} else {unsafe{transmute(proc)}}},
			colorp3ui: {let proc = get_proc_address("glColorP3ui"); if proc == null() {dummy_pfnglcolorp3uiproc} else {unsafe{transmute(proc)}}},
			colorp3uiv: {let proc = get_proc_address("glColorP3uiv"); if proc == null() {dummy_pfnglcolorp3uivproc} else {unsafe{transmute(proc)}}},
			colorp4ui: {let proc = get_proc_address("glColorP4ui"); if proc == null() {dummy_pfnglcolorp4uiproc} else {unsafe{transmute(proc)}}},
			colorp4uiv: {let proc = get_proc_address("glColorP4uiv"); if proc == null() {dummy_pfnglcolorp4uivproc} else {unsafe{transmute(proc)}}},
			secondarycolorp3ui: {let proc = get_proc_address("glSecondaryColorP3ui"); if proc == null() {dummy_pfnglsecondarycolorp3uiproc} else {unsafe{transmute(proc)}}},
			secondarycolorp3uiv: {let proc = get_proc_address("glSecondaryColorP3uiv"); if proc == null() {dummy_pfnglsecondarycolorp3uivproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version33 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			bindfragdatalocationindexed: dummy_pfnglbindfragdatalocationindexedproc,
			getfragdataindex: dummy_pfnglgetfragdataindexproc,
			gensamplers: dummy_pfnglgensamplersproc,
			deletesamplers: dummy_pfngldeletesamplersproc,
			issampler: dummy_pfnglissamplerproc,
			bindsampler: dummy_pfnglbindsamplerproc,
			samplerparameteri: dummy_pfnglsamplerparameteriproc,
			samplerparameteriv: dummy_pfnglsamplerparameterivproc,
			samplerparameterf: dummy_pfnglsamplerparameterfproc,
			samplerparameterfv: dummy_pfnglsamplerparameterfvproc,
			samplerparameteriiv: dummy_pfnglsamplerparameteriivproc,
			samplerparameteriuiv: dummy_pfnglsamplerparameteriuivproc,
			getsamplerparameteriv: dummy_pfnglgetsamplerparameterivproc,
			getsamplerparameteriiv: dummy_pfnglgetsamplerparameteriivproc,
			getsamplerparameterfv: dummy_pfnglgetsamplerparameterfvproc,
			getsamplerparameteriuiv: dummy_pfnglgetsamplerparameteriuivproc,
			querycounter: dummy_pfnglquerycounterproc,
			getqueryobjecti64v: dummy_pfnglgetqueryobjecti64vproc,
			getqueryobjectui64v: dummy_pfnglgetqueryobjectui64vproc,
			vertexattribdivisor: dummy_pfnglvertexattribdivisorproc,
			vertexattribp1ui: dummy_pfnglvertexattribp1uiproc,
			vertexattribp1uiv: dummy_pfnglvertexattribp1uivproc,
			vertexattribp2ui: dummy_pfnglvertexattribp2uiproc,
			vertexattribp2uiv: dummy_pfnglvertexattribp2uivproc,
			vertexattribp3ui: dummy_pfnglvertexattribp3uiproc,
			vertexattribp3uiv: dummy_pfnglvertexattribp3uivproc,
			vertexattribp4ui: dummy_pfnglvertexattribp4uiproc,
			vertexattribp4uiv: dummy_pfnglvertexattribp4uivproc,
			vertexp2ui: dummy_pfnglvertexp2uiproc,
			vertexp2uiv: dummy_pfnglvertexp2uivproc,
			vertexp3ui: dummy_pfnglvertexp3uiproc,
			vertexp3uiv: dummy_pfnglvertexp3uivproc,
			vertexp4ui: dummy_pfnglvertexp4uiproc,
			vertexp4uiv: dummy_pfnglvertexp4uivproc,
			texcoordp1ui: dummy_pfngltexcoordp1uiproc,
			texcoordp1uiv: dummy_pfngltexcoordp1uivproc,
			texcoordp2ui: dummy_pfngltexcoordp2uiproc,
			texcoordp2uiv: dummy_pfngltexcoordp2uivproc,
			texcoordp3ui: dummy_pfngltexcoordp3uiproc,
			texcoordp3uiv: dummy_pfngltexcoordp3uivproc,
			texcoordp4ui: dummy_pfngltexcoordp4uiproc,
			texcoordp4uiv: dummy_pfngltexcoordp4uivproc,
			multitexcoordp1ui: dummy_pfnglmultitexcoordp1uiproc,
			multitexcoordp1uiv: dummy_pfnglmultitexcoordp1uivproc,
			multitexcoordp2ui: dummy_pfnglmultitexcoordp2uiproc,
			multitexcoordp2uiv: dummy_pfnglmultitexcoordp2uivproc,
			multitexcoordp3ui: dummy_pfnglmultitexcoordp3uiproc,
			multitexcoordp3uiv: dummy_pfnglmultitexcoordp3uivproc,
			multitexcoordp4ui: dummy_pfnglmultitexcoordp4uiproc,
			multitexcoordp4uiv: dummy_pfnglmultitexcoordp4uivproc,
			normalp3ui: dummy_pfnglnormalp3uiproc,
			normalp3uiv: dummy_pfnglnormalp3uivproc,
			colorp3ui: dummy_pfnglcolorp3uiproc,
			colorp3uiv: dummy_pfnglcolorp3uivproc,
			colorp4ui: dummy_pfnglcolorp4uiproc,
			colorp4uiv: dummy_pfnglcolorp4uivproc,
			secondarycolorp3ui: dummy_pfnglsecondarycolorp3uiproc,
			secondarycolorp3uiv: dummy_pfnglsecondarycolorp3uivproc,
		}
	}
}
impl Debug for Version33 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version33")
			.field("available", &self.available)
			.field("bindfragdatalocationindexed", unsafe{if transmute::<_, *const c_void>(self.bindfragdatalocationindexed) == (dummy_pfnglbindfragdatalocationindexedproc as *const c_void) {&null::<PFNGLBINDFRAGDATALOCATIONINDEXEDPROC>()} else {&self.bindfragdatalocationindexed}})
			.field("getfragdataindex", unsafe{if transmute::<_, *const c_void>(self.getfragdataindex) == (dummy_pfnglgetfragdataindexproc as *const c_void) {&null::<PFNGLGETFRAGDATAINDEXPROC>()} else {&self.getfragdataindex}})
			.field("gensamplers", unsafe{if transmute::<_, *const c_void>(self.gensamplers) == (dummy_pfnglgensamplersproc as *const c_void) {&null::<PFNGLGENSAMPLERSPROC>()} else {&self.gensamplers}})
			.field("deletesamplers", unsafe{if transmute::<_, *const c_void>(self.deletesamplers) == (dummy_pfngldeletesamplersproc as *const c_void) {&null::<PFNGLDELETESAMPLERSPROC>()} else {&self.deletesamplers}})
			.field("issampler", unsafe{if transmute::<_, *const c_void>(self.issampler) == (dummy_pfnglissamplerproc as *const c_void) {&null::<PFNGLISSAMPLERPROC>()} else {&self.issampler}})
			.field("bindsampler", unsafe{if transmute::<_, *const c_void>(self.bindsampler) == (dummy_pfnglbindsamplerproc as *const c_void) {&null::<PFNGLBINDSAMPLERPROC>()} else {&self.bindsampler}})
			.field("samplerparameteri", unsafe{if transmute::<_, *const c_void>(self.samplerparameteri) == (dummy_pfnglsamplerparameteriproc as *const c_void) {&null::<PFNGLSAMPLERPARAMETERIPROC>()} else {&self.samplerparameteri}})
			.field("samplerparameteriv", unsafe{if transmute::<_, *const c_void>(self.samplerparameteriv) == (dummy_pfnglsamplerparameterivproc as *const c_void) {&null::<PFNGLSAMPLERPARAMETERIVPROC>()} else {&self.samplerparameteriv}})
			.field("samplerparameterf", unsafe{if transmute::<_, *const c_void>(self.samplerparameterf) == (dummy_pfnglsamplerparameterfproc as *const c_void) {&null::<PFNGLSAMPLERPARAMETERFPROC>()} else {&self.samplerparameterf}})
			.field("samplerparameterfv", unsafe{if transmute::<_, *const c_void>(self.samplerparameterfv) == (dummy_pfnglsamplerparameterfvproc as *const c_void) {&null::<PFNGLSAMPLERPARAMETERFVPROC>()} else {&self.samplerparameterfv}})
			.field("samplerparameteriiv", unsafe{if transmute::<_, *const c_void>(self.samplerparameteriiv) == (dummy_pfnglsamplerparameteriivproc as *const c_void) {&null::<PFNGLSAMPLERPARAMETERIIVPROC>()} else {&self.samplerparameteriiv}})
			.field("samplerparameteriuiv", unsafe{if transmute::<_, *const c_void>(self.samplerparameteriuiv) == (dummy_pfnglsamplerparameteriuivproc as *const c_void) {&null::<PFNGLSAMPLERPARAMETERIUIVPROC>()} else {&self.samplerparameteriuiv}})
			.field("getsamplerparameteriv", unsafe{if transmute::<_, *const c_void>(self.getsamplerparameteriv) == (dummy_pfnglgetsamplerparameterivproc as *const c_void) {&null::<PFNGLGETSAMPLERPARAMETERIVPROC>()} else {&self.getsamplerparameteriv}})
			.field("getsamplerparameteriiv", unsafe{if transmute::<_, *const c_void>(self.getsamplerparameteriiv) == (dummy_pfnglgetsamplerparameteriivproc as *const c_void) {&null::<PFNGLGETSAMPLERPARAMETERIIVPROC>()} else {&self.getsamplerparameteriiv}})
			.field("getsamplerparameterfv", unsafe{if transmute::<_, *const c_void>(self.getsamplerparameterfv) == (dummy_pfnglgetsamplerparameterfvproc as *const c_void) {&null::<PFNGLGETSAMPLERPARAMETERFVPROC>()} else {&self.getsamplerparameterfv}})
			.field("getsamplerparameteriuiv", unsafe{if transmute::<_, *const c_void>(self.getsamplerparameteriuiv) == (dummy_pfnglgetsamplerparameteriuivproc as *const c_void) {&null::<PFNGLGETSAMPLERPARAMETERIUIVPROC>()} else {&self.getsamplerparameteriuiv}})
			.field("querycounter", unsafe{if transmute::<_, *const c_void>(self.querycounter) == (dummy_pfnglquerycounterproc as *const c_void) {&null::<PFNGLQUERYCOUNTERPROC>()} else {&self.querycounter}})
			.field("getqueryobjecti64v", unsafe{if transmute::<_, *const c_void>(self.getqueryobjecti64v) == (dummy_pfnglgetqueryobjecti64vproc as *const c_void) {&null::<PFNGLGETQUERYOBJECTI64VPROC>()} else {&self.getqueryobjecti64v}})
			.field("getqueryobjectui64v", unsafe{if transmute::<_, *const c_void>(self.getqueryobjectui64v) == (dummy_pfnglgetqueryobjectui64vproc as *const c_void) {&null::<PFNGLGETQUERYOBJECTUI64VPROC>()} else {&self.getqueryobjectui64v}})
			.field("vertexattribdivisor", unsafe{if transmute::<_, *const c_void>(self.vertexattribdivisor) == (dummy_pfnglvertexattribdivisorproc as *const c_void) {&null::<PFNGLVERTEXATTRIBDIVISORPROC>()} else {&self.vertexattribdivisor}})
			.field("vertexattribp1ui", unsafe{if transmute::<_, *const c_void>(self.vertexattribp1ui) == (dummy_pfnglvertexattribp1uiproc as *const c_void) {&null::<PFNGLVERTEXATTRIBP1UIPROC>()} else {&self.vertexattribp1ui}})
			.field("vertexattribp1uiv", unsafe{if transmute::<_, *const c_void>(self.vertexattribp1uiv) == (dummy_pfnglvertexattribp1uivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBP1UIVPROC>()} else {&self.vertexattribp1uiv}})
			.field("vertexattribp2ui", unsafe{if transmute::<_, *const c_void>(self.vertexattribp2ui) == (dummy_pfnglvertexattribp2uiproc as *const c_void) {&null::<PFNGLVERTEXATTRIBP2UIPROC>()} else {&self.vertexattribp2ui}})
			.field("vertexattribp2uiv", unsafe{if transmute::<_, *const c_void>(self.vertexattribp2uiv) == (dummy_pfnglvertexattribp2uivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBP2UIVPROC>()} else {&self.vertexattribp2uiv}})
			.field("vertexattribp3ui", unsafe{if transmute::<_, *const c_void>(self.vertexattribp3ui) == (dummy_pfnglvertexattribp3uiproc as *const c_void) {&null::<PFNGLVERTEXATTRIBP3UIPROC>()} else {&self.vertexattribp3ui}})
			.field("vertexattribp3uiv", unsafe{if transmute::<_, *const c_void>(self.vertexattribp3uiv) == (dummy_pfnglvertexattribp3uivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBP3UIVPROC>()} else {&self.vertexattribp3uiv}})
			.field("vertexattribp4ui", unsafe{if transmute::<_, *const c_void>(self.vertexattribp4ui) == (dummy_pfnglvertexattribp4uiproc as *const c_void) {&null::<PFNGLVERTEXATTRIBP4UIPROC>()} else {&self.vertexattribp4ui}})
			.field("vertexattribp4uiv", unsafe{if transmute::<_, *const c_void>(self.vertexattribp4uiv) == (dummy_pfnglvertexattribp4uivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBP4UIVPROC>()} else {&self.vertexattribp4uiv}})
			.field("vertexp2ui", unsafe{if transmute::<_, *const c_void>(self.vertexp2ui) == (dummy_pfnglvertexp2uiproc as *const c_void) {&null::<PFNGLVERTEXP2UIPROC>()} else {&self.vertexp2ui}})
			.field("vertexp2uiv", unsafe{if transmute::<_, *const c_void>(self.vertexp2uiv) == (dummy_pfnglvertexp2uivproc as *const c_void) {&null::<PFNGLVERTEXP2UIVPROC>()} else {&self.vertexp2uiv}})
			.field("vertexp3ui", unsafe{if transmute::<_, *const c_void>(self.vertexp3ui) == (dummy_pfnglvertexp3uiproc as *const c_void) {&null::<PFNGLVERTEXP3UIPROC>()} else {&self.vertexp3ui}})
			.field("vertexp3uiv", unsafe{if transmute::<_, *const c_void>(self.vertexp3uiv) == (dummy_pfnglvertexp3uivproc as *const c_void) {&null::<PFNGLVERTEXP3UIVPROC>()} else {&self.vertexp3uiv}})
			.field("vertexp4ui", unsafe{if transmute::<_, *const c_void>(self.vertexp4ui) == (dummy_pfnglvertexp4uiproc as *const c_void) {&null::<PFNGLVERTEXP4UIPROC>()} else {&self.vertexp4ui}})
			.field("vertexp4uiv", unsafe{if transmute::<_, *const c_void>(self.vertexp4uiv) == (dummy_pfnglvertexp4uivproc as *const c_void) {&null::<PFNGLVERTEXP4UIVPROC>()} else {&self.vertexp4uiv}})
			.field("texcoordp1ui", unsafe{if transmute::<_, *const c_void>(self.texcoordp1ui) == (dummy_pfngltexcoordp1uiproc as *const c_void) {&null::<PFNGLTEXCOORDP1UIPROC>()} else {&self.texcoordp1ui}})
			.field("texcoordp1uiv", unsafe{if transmute::<_, *const c_void>(self.texcoordp1uiv) == (dummy_pfngltexcoordp1uivproc as *const c_void) {&null::<PFNGLTEXCOORDP1UIVPROC>()} else {&self.texcoordp1uiv}})
			.field("texcoordp2ui", unsafe{if transmute::<_, *const c_void>(self.texcoordp2ui) == (dummy_pfngltexcoordp2uiproc as *const c_void) {&null::<PFNGLTEXCOORDP2UIPROC>()} else {&self.texcoordp2ui}})
			.field("texcoordp2uiv", unsafe{if transmute::<_, *const c_void>(self.texcoordp2uiv) == (dummy_pfngltexcoordp2uivproc as *const c_void) {&null::<PFNGLTEXCOORDP2UIVPROC>()} else {&self.texcoordp2uiv}})
			.field("texcoordp3ui", unsafe{if transmute::<_, *const c_void>(self.texcoordp3ui) == (dummy_pfngltexcoordp3uiproc as *const c_void) {&null::<PFNGLTEXCOORDP3UIPROC>()} else {&self.texcoordp3ui}})
			.field("texcoordp3uiv", unsafe{if transmute::<_, *const c_void>(self.texcoordp3uiv) == (dummy_pfngltexcoordp3uivproc as *const c_void) {&null::<PFNGLTEXCOORDP3UIVPROC>()} else {&self.texcoordp3uiv}})
			.field("texcoordp4ui", unsafe{if transmute::<_, *const c_void>(self.texcoordp4ui) == (dummy_pfngltexcoordp4uiproc as *const c_void) {&null::<PFNGLTEXCOORDP4UIPROC>()} else {&self.texcoordp4ui}})
			.field("texcoordp4uiv", unsafe{if transmute::<_, *const c_void>(self.texcoordp4uiv) == (dummy_pfngltexcoordp4uivproc as *const c_void) {&null::<PFNGLTEXCOORDP4UIVPROC>()} else {&self.texcoordp4uiv}})
			.field("multitexcoordp1ui", unsafe{if transmute::<_, *const c_void>(self.multitexcoordp1ui) == (dummy_pfnglmultitexcoordp1uiproc as *const c_void) {&null::<PFNGLMULTITEXCOORDP1UIPROC>()} else {&self.multitexcoordp1ui}})
			.field("multitexcoordp1uiv", unsafe{if transmute::<_, *const c_void>(self.multitexcoordp1uiv) == (dummy_pfnglmultitexcoordp1uivproc as *const c_void) {&null::<PFNGLMULTITEXCOORDP1UIVPROC>()} else {&self.multitexcoordp1uiv}})
			.field("multitexcoordp2ui", unsafe{if transmute::<_, *const c_void>(self.multitexcoordp2ui) == (dummy_pfnglmultitexcoordp2uiproc as *const c_void) {&null::<PFNGLMULTITEXCOORDP2UIPROC>()} else {&self.multitexcoordp2ui}})
			.field("multitexcoordp2uiv", unsafe{if transmute::<_, *const c_void>(self.multitexcoordp2uiv) == (dummy_pfnglmultitexcoordp2uivproc as *const c_void) {&null::<PFNGLMULTITEXCOORDP2UIVPROC>()} else {&self.multitexcoordp2uiv}})
			.field("multitexcoordp3ui", unsafe{if transmute::<_, *const c_void>(self.multitexcoordp3ui) == (dummy_pfnglmultitexcoordp3uiproc as *const c_void) {&null::<PFNGLMULTITEXCOORDP3UIPROC>()} else {&self.multitexcoordp3ui}})
			.field("multitexcoordp3uiv", unsafe{if transmute::<_, *const c_void>(self.multitexcoordp3uiv) == (dummy_pfnglmultitexcoordp3uivproc as *const c_void) {&null::<PFNGLMULTITEXCOORDP3UIVPROC>()} else {&self.multitexcoordp3uiv}})
			.field("multitexcoordp4ui", unsafe{if transmute::<_, *const c_void>(self.multitexcoordp4ui) == (dummy_pfnglmultitexcoordp4uiproc as *const c_void) {&null::<PFNGLMULTITEXCOORDP4UIPROC>()} else {&self.multitexcoordp4ui}})
			.field("multitexcoordp4uiv", unsafe{if transmute::<_, *const c_void>(self.multitexcoordp4uiv) == (dummy_pfnglmultitexcoordp4uivproc as *const c_void) {&null::<PFNGLMULTITEXCOORDP4UIVPROC>()} else {&self.multitexcoordp4uiv}})
			.field("normalp3ui", unsafe{if transmute::<_, *const c_void>(self.normalp3ui) == (dummy_pfnglnormalp3uiproc as *const c_void) {&null::<PFNGLNORMALP3UIPROC>()} else {&self.normalp3ui}})
			.field("normalp3uiv", unsafe{if transmute::<_, *const c_void>(self.normalp3uiv) == (dummy_pfnglnormalp3uivproc as *const c_void) {&null::<PFNGLNORMALP3UIVPROC>()} else {&self.normalp3uiv}})
			.field("colorp3ui", unsafe{if transmute::<_, *const c_void>(self.colorp3ui) == (dummy_pfnglcolorp3uiproc as *const c_void) {&null::<PFNGLCOLORP3UIPROC>()} else {&self.colorp3ui}})
			.field("colorp3uiv", unsafe{if transmute::<_, *const c_void>(self.colorp3uiv) == (dummy_pfnglcolorp3uivproc as *const c_void) {&null::<PFNGLCOLORP3UIVPROC>()} else {&self.colorp3uiv}})
			.field("colorp4ui", unsafe{if transmute::<_, *const c_void>(self.colorp4ui) == (dummy_pfnglcolorp4uiproc as *const c_void) {&null::<PFNGLCOLORP4UIPROC>()} else {&self.colorp4ui}})
			.field("colorp4uiv", unsafe{if transmute::<_, *const c_void>(self.colorp4uiv) == (dummy_pfnglcolorp4uivproc as *const c_void) {&null::<PFNGLCOLORP4UIVPROC>()} else {&self.colorp4uiv}})
			.field("secondarycolorp3ui", unsafe{if transmute::<_, *const c_void>(self.secondarycolorp3ui) == (dummy_pfnglsecondarycolorp3uiproc as *const c_void) {&null::<PFNGLSECONDARYCOLORP3UIPROC>()} else {&self.secondarycolorp3ui}})
			.field("secondarycolorp3uiv", unsafe{if transmute::<_, *const c_void>(self.secondarycolorp3uiv) == (dummy_pfnglsecondarycolorp3uivproc as *const c_void) {&null::<PFNGLSECONDARYCOLORP3UIVPROC>()} else {&self.secondarycolorp3uiv}})
			.finish()
		} else {
			f.debug_struct("Version33")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

/// The prototype to the OpenGL function `MinSampleShading`
type PFNGLMINSAMPLESHADINGPROC = extern "system" fn(GLfloat);

/// The prototype to the OpenGL function `BlendEquationi`
type PFNGLBLENDEQUATIONIPROC = extern "system" fn(GLuint, GLenum);

/// The prototype to the OpenGL function `BlendEquationSeparatei`
type PFNGLBLENDEQUATIONSEPARATEIPROC = extern "system" fn(GLuint, GLenum, GLenum);

/// The prototype to the OpenGL function `BlendFunci`
type PFNGLBLENDFUNCIPROC = extern "system" fn(GLuint, GLenum, GLenum);

/// The prototype to the OpenGL function `BlendFuncSeparatei`
type PFNGLBLENDFUNCSEPARATEIPROC = extern "system" fn(GLuint, GLenum, GLenum, GLenum, GLenum);

/// The prototype to the OpenGL function `DrawArraysIndirect`
type PFNGLDRAWARRAYSINDIRECTPROC = extern "system" fn(GLenum, *const c_void);

/// The prototype to the OpenGL function `DrawElementsIndirect`
type PFNGLDRAWELEMENTSINDIRECTPROC = extern "system" fn(GLenum, GLenum, *const c_void);

/// The prototype to the OpenGL function `Uniform1d`
type PFNGLUNIFORM1DPROC = extern "system" fn(GLint, GLdouble);

/// The prototype to the OpenGL function `Uniform2d`
type PFNGLUNIFORM2DPROC = extern "system" fn(GLint, GLdouble, GLdouble);

/// The prototype to the OpenGL function `Uniform3d`
type PFNGLUNIFORM3DPROC = extern "system" fn(GLint, GLdouble, GLdouble, GLdouble);

/// The prototype to the OpenGL function `Uniform4d`
type PFNGLUNIFORM4DPROC = extern "system" fn(GLint, GLdouble, GLdouble, GLdouble, GLdouble);

/// The prototype to the OpenGL function `Uniform1dv`
type PFNGLUNIFORM1DVPROC = extern "system" fn(GLint, GLsizei, *const GLdouble);

/// The prototype to the OpenGL function `Uniform2dv`
type PFNGLUNIFORM2DVPROC = extern "system" fn(GLint, GLsizei, *const GLdouble);

/// The prototype to the OpenGL function `Uniform3dv`
type PFNGLUNIFORM3DVPROC = extern "system" fn(GLint, GLsizei, *const GLdouble);

/// The prototype to the OpenGL function `Uniform4dv`
type PFNGLUNIFORM4DVPROC = extern "system" fn(GLint, GLsizei, *const GLdouble);

/// The prototype to the OpenGL function `UniformMatrix2dv`
type PFNGLUNIFORMMATRIX2DVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble);

/// The prototype to the OpenGL function `UniformMatrix3dv`
type PFNGLUNIFORMMATRIX3DVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble);

/// The prototype to the OpenGL function `UniformMatrix4dv`
type PFNGLUNIFORMMATRIX4DVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble);

/// The prototype to the OpenGL function `UniformMatrix2x3dv`
type PFNGLUNIFORMMATRIX2X3DVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble);

/// The prototype to the OpenGL function `UniformMatrix2x4dv`
type PFNGLUNIFORMMATRIX2X4DVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble);

/// The prototype to the OpenGL function `UniformMatrix3x2dv`
type PFNGLUNIFORMMATRIX3X2DVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble);

/// The prototype to the OpenGL function `UniformMatrix3x4dv`
type PFNGLUNIFORMMATRIX3X4DVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble);

/// The prototype to the OpenGL function `UniformMatrix4x2dv`
type PFNGLUNIFORMMATRIX4X2DVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble);

/// The prototype to the OpenGL function `UniformMatrix4x3dv`
type PFNGLUNIFORMMATRIX4X3DVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble);

/// The prototype to the OpenGL function `GetUniformdv`
type PFNGLGETUNIFORMDVPROC = extern "system" fn(GLuint, GLint, *mut GLdouble);

/// The prototype to the OpenGL function `GetSubroutineUniformLocation`
type PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC = extern "system" fn(GLuint, GLenum, *const GLchar) -> GLint;

/// The prototype to the OpenGL function `GetSubroutineIndex`
type PFNGLGETSUBROUTINEINDEXPROC = extern "system" fn(GLuint, GLenum, *const GLchar) -> GLuint;

/// The prototype to the OpenGL function `GetActiveSubroutineUniformiv`
type PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC = extern "system" fn(GLuint, GLenum, GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetActiveSubroutineUniformName`
type PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC = extern "system" fn(GLuint, GLenum, GLuint, GLsizei, *mut GLsizei, *mut GLchar);

/// The prototype to the OpenGL function `GetActiveSubroutineName`
type PFNGLGETACTIVESUBROUTINENAMEPROC = extern "system" fn(GLuint, GLenum, GLuint, GLsizei, *mut GLsizei, *mut GLchar);

/// The prototype to the OpenGL function `UniformSubroutinesuiv`
type PFNGLUNIFORMSUBROUTINESUIVPROC = extern "system" fn(GLenum, GLsizei, *const GLuint);

/// The prototype to the OpenGL function `GetUniformSubroutineuiv`
type PFNGLGETUNIFORMSUBROUTINEUIVPROC = extern "system" fn(GLenum, GLint, *mut GLuint);

/// The prototype to the OpenGL function `GetProgramStageiv`
type PFNGLGETPROGRAMSTAGEIVPROC = extern "system" fn(GLuint, GLenum, GLenum, *mut GLint);

/// The prototype to the OpenGL function `PatchParameteri`
type PFNGLPATCHPARAMETERIPROC = extern "system" fn(GLenum, GLint);

/// The prototype to the OpenGL function `PatchParameterfv`
type PFNGLPATCHPARAMETERFVPROC = extern "system" fn(GLenum, *const GLfloat);

/// The prototype to the OpenGL function `BindTransformFeedback`
type PFNGLBINDTRANSFORMFEEDBACKPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `DeleteTransformFeedbacks`
type PFNGLDELETETRANSFORMFEEDBACKSPROC = extern "system" fn(GLsizei, *const GLuint);

/// The prototype to the OpenGL function `GenTransformFeedbacks`
type PFNGLGENTRANSFORMFEEDBACKSPROC = extern "system" fn(GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `IsTransformFeedback`
type PFNGLISTRANSFORMFEEDBACKPROC = extern "system" fn(GLuint) -> GLboolean;

/// The prototype to the OpenGL function `PauseTransformFeedback`
type PFNGLPAUSETRANSFORMFEEDBACKPROC = extern "system" fn();

/// The prototype to the OpenGL function `ResumeTransformFeedback`
type PFNGLRESUMETRANSFORMFEEDBACKPROC = extern "system" fn();

/// The prototype to the OpenGL function `DrawTransformFeedback`
type PFNGLDRAWTRANSFORMFEEDBACKPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `DrawTransformFeedbackStream`
type PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC = extern "system" fn(GLenum, GLuint, GLuint);

/// The prototype to the OpenGL function `BeginQueryIndexed`
type PFNGLBEGINQUERYINDEXEDPROC = extern "system" fn(GLenum, GLuint, GLuint);

/// The prototype to the OpenGL function `EndQueryIndexed`
type PFNGLENDQUERYINDEXEDPROC = extern "system" fn(GLenum, GLuint);

/// The prototype to the OpenGL function `GetQueryIndexediv`
type PFNGLGETQUERYINDEXEDIVPROC = extern "system" fn(GLenum, GLuint, GLenum, *mut GLint);

/// The dummy function of `MinSampleShading()`
extern "system" fn dummy_pfnglminsampleshadingproc (_: GLfloat) {
	panic!("OpenGL function pointer `glMinSampleShading()` is null.")
}

/// The dummy function of `BlendEquationi()`
extern "system" fn dummy_pfnglblendequationiproc (_: GLuint, _: GLenum) {
	panic!("OpenGL function pointer `glBlendEquationi()` is null.")
}

/// The dummy function of `BlendEquationSeparatei()`
extern "system" fn dummy_pfnglblendequationseparateiproc (_: GLuint, _: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glBlendEquationSeparatei()` is null.")
}

/// The dummy function of `BlendFunci()`
extern "system" fn dummy_pfnglblendfunciproc (_: GLuint, _: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glBlendFunci()` is null.")
}

/// The dummy function of `BlendFuncSeparatei()`
extern "system" fn dummy_pfnglblendfuncseparateiproc (_: GLuint, _: GLenum, _: GLenum, _: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glBlendFuncSeparatei()` is null.")
}

/// The dummy function of `DrawArraysIndirect()`
extern "system" fn dummy_pfngldrawarraysindirectproc (_: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glDrawArraysIndirect()` is null.")
}

/// The dummy function of `DrawElementsIndirect()`
extern "system" fn dummy_pfngldrawelementsindirectproc (_: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glDrawElementsIndirect()` is null.")
}

/// The dummy function of `Uniform1d()`
extern "system" fn dummy_pfngluniform1dproc (_: GLint, _: GLdouble) {
	panic!("OpenGL function pointer `glUniform1d()` is null.")
}

/// The dummy function of `Uniform2d()`
extern "system" fn dummy_pfngluniform2dproc (_: GLint, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glUniform2d()` is null.")
}

/// The dummy function of `Uniform3d()`
extern "system" fn dummy_pfngluniform3dproc (_: GLint, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glUniform3d()` is null.")
}

/// The dummy function of `Uniform4d()`
extern "system" fn dummy_pfngluniform4dproc (_: GLint, _: GLdouble, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glUniform4d()` is null.")
}

/// The dummy function of `Uniform1dv()`
extern "system" fn dummy_pfngluniform1dvproc (_: GLint, _: GLsizei, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniform1dv()` is null.")
}

/// The dummy function of `Uniform2dv()`
extern "system" fn dummy_pfngluniform2dvproc (_: GLint, _: GLsizei, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniform2dv()` is null.")
}

/// The dummy function of `Uniform3dv()`
extern "system" fn dummy_pfngluniform3dvproc (_: GLint, _: GLsizei, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniform3dv()` is null.")
}

/// The dummy function of `Uniform4dv()`
extern "system" fn dummy_pfngluniform4dvproc (_: GLint, _: GLsizei, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniform4dv()` is null.")
}

/// The dummy function of `UniformMatrix2dv()`
extern "system" fn dummy_pfngluniformmatrix2dvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniformMatrix2dv()` is null.")
}

/// The dummy function of `UniformMatrix3dv()`
extern "system" fn dummy_pfngluniformmatrix3dvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniformMatrix3dv()` is null.")
}

/// The dummy function of `UniformMatrix4dv()`
extern "system" fn dummy_pfngluniformmatrix4dvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniformMatrix4dv()` is null.")
}

/// The dummy function of `UniformMatrix2x3dv()`
extern "system" fn dummy_pfngluniformmatrix2x3dvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniformMatrix2x3dv()` is null.")
}

/// The dummy function of `UniformMatrix2x4dv()`
extern "system" fn dummy_pfngluniformmatrix2x4dvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniformMatrix2x4dv()` is null.")
}

/// The dummy function of `UniformMatrix3x2dv()`
extern "system" fn dummy_pfngluniformmatrix3x2dvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniformMatrix3x2dv()` is null.")
}

/// The dummy function of `UniformMatrix3x4dv()`
extern "system" fn dummy_pfngluniformmatrix3x4dvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniformMatrix3x4dv()` is null.")
}

/// The dummy function of `UniformMatrix4x2dv()`
extern "system" fn dummy_pfngluniformmatrix4x2dvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniformMatrix4x2dv()` is null.")
}

/// The dummy function of `UniformMatrix4x3dv()`
extern "system" fn dummy_pfngluniformmatrix4x3dvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniformMatrix4x3dv()` is null.")
}

/// The dummy function of `GetUniformdv()`
extern "system" fn dummy_pfnglgetuniformdvproc (_: GLuint, _: GLint, _: *mut GLdouble) {
	panic!("OpenGL function pointer `glGetUniformdv()` is null.")
}

/// The dummy function of `GetSubroutineUniformLocation()`
extern "system" fn dummy_pfnglgetsubroutineuniformlocationproc (_: GLuint, _: GLenum, _: *const GLchar) -> GLint {
	panic!("OpenGL function pointer `glGetSubroutineUniformLocation()` is null.")
}

/// The dummy function of `GetSubroutineIndex()`
extern "system" fn dummy_pfnglgetsubroutineindexproc (_: GLuint, _: GLenum, _: *const GLchar) -> GLuint {
	panic!("OpenGL function pointer `glGetSubroutineIndex()` is null.")
}

/// The dummy function of `GetActiveSubroutineUniformiv()`
extern "system" fn dummy_pfnglgetactivesubroutineuniformivproc (_: GLuint, _: GLenum, _: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetActiveSubroutineUniformiv()` is null.")
}

/// The dummy function of `GetActiveSubroutineUniformName()`
extern "system" fn dummy_pfnglgetactivesubroutineuniformnameproc (_: GLuint, _: GLenum, _: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetActiveSubroutineUniformName()` is null.")
}

/// The dummy function of `GetActiveSubroutineName()`
extern "system" fn dummy_pfnglgetactivesubroutinenameproc (_: GLuint, _: GLenum, _: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetActiveSubroutineName()` is null.")
}

/// The dummy function of `UniformSubroutinesuiv()`
extern "system" fn dummy_pfngluniformsubroutinesuivproc (_: GLenum, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glUniformSubroutinesuiv()` is null.")
}

/// The dummy function of `GetUniformSubroutineuiv()`
extern "system" fn dummy_pfnglgetuniformsubroutineuivproc (_: GLenum, _: GLint, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetUniformSubroutineuiv()` is null.")
}

/// The dummy function of `GetProgramStageiv()`
extern "system" fn dummy_pfnglgetprogramstageivproc (_: GLuint, _: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetProgramStageiv()` is null.")
}

/// The dummy function of `PatchParameteri()`
extern "system" fn dummy_pfnglpatchparameteriproc (_: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glPatchParameteri()` is null.")
}

/// The dummy function of `PatchParameterfv()`
extern "system" fn dummy_pfnglpatchparameterfvproc (_: GLenum, _: *const GLfloat) {
	panic!("OpenGL function pointer `glPatchParameterfv()` is null.")
}

/// The dummy function of `BindTransformFeedback()`
extern "system" fn dummy_pfnglbindtransformfeedbackproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glBindTransformFeedback()` is null.")
}

/// The dummy function of `DeleteTransformFeedbacks()`
extern "system" fn dummy_pfngldeletetransformfeedbacksproc (_: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glDeleteTransformFeedbacks()` is null.")
}

/// The dummy function of `GenTransformFeedbacks()`
extern "system" fn dummy_pfnglgentransformfeedbacksproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGenTransformFeedbacks()` is null.")
}

/// The dummy function of `IsTransformFeedback()`
extern "system" fn dummy_pfnglistransformfeedbackproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsTransformFeedback()` is null.")
}

/// The dummy function of `PauseTransformFeedback()`
extern "system" fn dummy_pfnglpausetransformfeedbackproc () {
	panic!("OpenGL function pointer `glPauseTransformFeedback()` is null.")
}

/// The dummy function of `ResumeTransformFeedback()`
extern "system" fn dummy_pfnglresumetransformfeedbackproc () {
	panic!("OpenGL function pointer `glResumeTransformFeedback()` is null.")
}

/// The dummy function of `DrawTransformFeedback()`
extern "system" fn dummy_pfngldrawtransformfeedbackproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glDrawTransformFeedback()` is null.")
}

/// The dummy function of `DrawTransformFeedbackStream()`
extern "system" fn dummy_pfngldrawtransformfeedbackstreamproc (_: GLenum, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glDrawTransformFeedbackStream()` is null.")
}

/// The dummy function of `BeginQueryIndexed()`
extern "system" fn dummy_pfnglbeginqueryindexedproc (_: GLenum, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glBeginQueryIndexed()` is null.")
}

/// The dummy function of `EndQueryIndexed()`
extern "system" fn dummy_pfnglendqueryindexedproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glEndQueryIndexed()` is null.")
}

/// The dummy function of `GetQueryIndexediv()`
extern "system" fn dummy_pfnglgetqueryindexedivproc (_: GLenum, _: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetQueryIndexediv()` is null.")
}
/// Constant value defined from OpenGL 4.0
pub const GL_SAMPLE_SHADING: GLenum = 0x8C36;

/// Constant value defined from OpenGL 4.0
pub const GL_MIN_SAMPLE_SHADING_VALUE: GLenum = 0x8C37;

/// Constant value defined from OpenGL 4.0
pub const GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET: GLenum = 0x8E5E;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET: GLenum = 0x8E5F;

/// Constant value defined from OpenGL 4.0
pub const GL_TEXTURE_CUBE_MAP_ARRAY: GLenum = 0x9009;

/// Constant value defined from OpenGL 4.0
pub const GL_TEXTURE_BINDING_CUBE_MAP_ARRAY: GLenum = 0x900A;

/// Constant value defined from OpenGL 4.0
pub const GL_PROXY_TEXTURE_CUBE_MAP_ARRAY: GLenum = 0x900B;

/// Constant value defined from OpenGL 4.0
pub const GL_SAMPLER_CUBE_MAP_ARRAY: GLenum = 0x900C;

/// Constant value defined from OpenGL 4.0
pub const GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW: GLenum = 0x900D;

/// Constant value defined from OpenGL 4.0
pub const GL_INT_SAMPLER_CUBE_MAP_ARRAY: GLenum = 0x900E;

/// Constant value defined from OpenGL 4.0
pub const GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY: GLenum = 0x900F;

/// Constant value defined from OpenGL 4.0
pub const GL_DRAW_INDIRECT_BUFFER: GLenum = 0x8F3F;

/// Constant value defined from OpenGL 4.0
pub const GL_DRAW_INDIRECT_BUFFER_BINDING: GLenum = 0x8F43;

/// Constant value defined from OpenGL 4.0
pub const GL_GEOMETRY_SHADER_INVOCATIONS: GLenum = 0x887F;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_GEOMETRY_SHADER_INVOCATIONS: GLenum = 0x8E5A;

/// Constant value defined from OpenGL 4.0
pub const GL_MIN_FRAGMENT_INTERPOLATION_OFFSET: GLenum = 0x8E5B;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_FRAGMENT_INTERPOLATION_OFFSET: GLenum = 0x8E5C;

/// Constant value defined from OpenGL 4.0
pub const GL_FRAGMENT_INTERPOLATION_OFFSET_BITS: GLenum = 0x8E5D;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_VERTEX_STREAMS: GLenum = 0x8E71;

/// Constant value defined from OpenGL 4.0
pub const GL_DOUBLE_VEC2: GLenum = 0x8FFC;

/// Constant value defined from OpenGL 4.0
pub const GL_DOUBLE_VEC3: GLenum = 0x8FFD;

/// Constant value defined from OpenGL 4.0
pub const GL_DOUBLE_VEC4: GLenum = 0x8FFE;

/// Constant value defined from OpenGL 4.0
pub const GL_DOUBLE_MAT2: GLenum = 0x8F46;

/// Constant value defined from OpenGL 4.0
pub const GL_DOUBLE_MAT3: GLenum = 0x8F47;

/// Constant value defined from OpenGL 4.0
pub const GL_DOUBLE_MAT4: GLenum = 0x8F48;

/// Constant value defined from OpenGL 4.0
pub const GL_DOUBLE_MAT2x3: GLenum = 0x8F49;

/// Constant value defined from OpenGL 4.0
pub const GL_DOUBLE_MAT2x4: GLenum = 0x8F4A;

/// Constant value defined from OpenGL 4.0
pub const GL_DOUBLE_MAT3x2: GLenum = 0x8F4B;

/// Constant value defined from OpenGL 4.0
pub const GL_DOUBLE_MAT3x4: GLenum = 0x8F4C;

/// Constant value defined from OpenGL 4.0
pub const GL_DOUBLE_MAT4x2: GLenum = 0x8F4D;

/// Constant value defined from OpenGL 4.0
pub const GL_DOUBLE_MAT4x3: GLenum = 0x8F4E;

/// Constant value defined from OpenGL 4.0
pub const GL_ACTIVE_SUBROUTINES: GLenum = 0x8DE5;

/// Constant value defined from OpenGL 4.0
pub const GL_ACTIVE_SUBROUTINE_UNIFORMS: GLenum = 0x8DE6;

/// Constant value defined from OpenGL 4.0
pub const GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS: GLenum = 0x8E47;

/// Constant value defined from OpenGL 4.0
pub const GL_ACTIVE_SUBROUTINE_MAX_LENGTH: GLenum = 0x8E48;

/// Constant value defined from OpenGL 4.0
pub const GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH: GLenum = 0x8E49;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_SUBROUTINES: GLenum = 0x8DE7;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS: GLenum = 0x8DE8;

/// Constant value defined from OpenGL 4.0
pub const GL_NUM_COMPATIBLE_SUBROUTINES: GLenum = 0x8E4A;

/// Constant value defined from OpenGL 4.0
pub const GL_COMPATIBLE_SUBROUTINES: GLenum = 0x8E4B;

/// Constant value defined from OpenGL 4.0
pub const GL_PATCHES: GLenum = 0x000E;

/// Constant value defined from OpenGL 4.0
pub const GL_PATCH_VERTICES: GLenum = 0x8E72;

/// Constant value defined from OpenGL 4.0
pub const GL_PATCH_DEFAULT_INNER_LEVEL: GLenum = 0x8E73;

/// Constant value defined from OpenGL 4.0
pub const GL_PATCH_DEFAULT_OUTER_LEVEL: GLenum = 0x8E74;

/// Constant value defined from OpenGL 4.0
pub const GL_TESS_CONTROL_OUTPUT_VERTICES: GLenum = 0x8E75;

/// Constant value defined from OpenGL 4.0
pub const GL_TESS_GEN_MODE: GLenum = 0x8E76;

/// Constant value defined from OpenGL 4.0
pub const GL_TESS_GEN_SPACING: GLenum = 0x8E77;

/// Constant value defined from OpenGL 4.0
pub const GL_TESS_GEN_VERTEX_ORDER: GLenum = 0x8E78;

/// Constant value defined from OpenGL 4.0
pub const GL_TESS_GEN_POINT_MODE: GLenum = 0x8E79;

/// Constant value defined from OpenGL 4.0
pub const GL_ISOLINES: GLenum = 0x8E7A;

/// Constant value defined from OpenGL 4.0
pub const GL_FRACTIONAL_ODD: GLenum = 0x8E7B;

/// Constant value defined from OpenGL 4.0
pub const GL_FRACTIONAL_EVEN: GLenum = 0x8E7C;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_PATCH_VERTICES: GLenum = 0x8E7D;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_TESS_GEN_LEVEL: GLenum = 0x8E7E;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS: GLenum = 0x8E7F;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS: GLenum = 0x8E80;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS: GLenum = 0x8E81;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS: GLenum = 0x8E82;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS: GLenum = 0x8E83;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_TESS_PATCH_COMPONENTS: GLenum = 0x8E84;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS: GLenum = 0x8E85;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS: GLenum = 0x8E86;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS: GLenum = 0x8E89;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS: GLenum = 0x8E8A;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_TESS_CONTROL_INPUT_COMPONENTS: GLenum = 0x886C;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS: GLenum = 0x886D;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS: GLenum = 0x8E1E;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS: GLenum = 0x8E1F;

/// Constant value defined from OpenGL 4.0
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER: GLenum = 0x84F0;

/// Constant value defined from OpenGL 4.0
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER: GLenum = 0x84F1;

/// Constant value defined from OpenGL 4.0
pub const GL_TESS_EVALUATION_SHADER: GLenum = 0x8E87;

/// Constant value defined from OpenGL 4.0
pub const GL_TESS_CONTROL_SHADER: GLenum = 0x8E88;

/// Constant value defined from OpenGL 4.0
pub const GL_TRANSFORM_FEEDBACK: GLenum = 0x8E22;

/// Constant value defined from OpenGL 4.0
pub const GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED: GLenum = 0x8E23;

/// Constant value defined from OpenGL 4.0
pub const GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE: GLenum = 0x8E24;

/// Constant value defined from OpenGL 4.0
pub const GL_TRANSFORM_FEEDBACK_BINDING: GLenum = 0x8E25;

/// Constant value defined from OpenGL 4.0
pub const GL_MAX_TRANSFORM_FEEDBACK_BUFFERS: GLenum = 0x8E70;

/// Functions from OpenGL version 4.0
pub trait GL_4_0 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	fn glGetError(&self) -> GLenum;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMinSampleShading.xhtml>
	fn glMinSampleShading(&self, value: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendEquationi.xhtml>
	fn glBlendEquationi(&self, buf: GLuint, mode: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendEquationSeparatei.xhtml>
	fn glBlendEquationSeparatei(&self, buf: GLuint, modeRGB: GLenum, modeAlpha: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendFunci.xhtml>
	fn glBlendFunci(&self, buf: GLuint, src: GLenum, dst: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendFuncSeparatei.xhtml>
	fn glBlendFuncSeparatei(&self, buf: GLuint, srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawArraysIndirect.xhtml>
	fn glDrawArraysIndirect(&self, mode: GLenum, indirect: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsIndirect.xhtml>
	fn glDrawElementsIndirect(&self, mode: GLenum, type_: GLenum, indirect: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1d.xhtml>
	fn glUniform1d(&self, location: GLint, x: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2d.xhtml>
	fn glUniform2d(&self, location: GLint, x: GLdouble, y: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3d.xhtml>
	fn glUniform3d(&self, location: GLint, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4d.xhtml>
	fn glUniform4d(&self, location: GLint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1dv.xhtml>
	fn glUniform1dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2dv.xhtml>
	fn glUniform2dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3dv.xhtml>
	fn glUniform3dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4dv.xhtml>
	fn glUniform4dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix2dv.xhtml>
	fn glUniformMatrix2dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix3dv.xhtml>
	fn glUniformMatrix3dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix4dv.xhtml>
	fn glUniformMatrix4dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix2x3dv.xhtml>
	fn glUniformMatrix2x3dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix2x4dv.xhtml>
	fn glUniformMatrix2x4dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix3x2dv.xhtml>
	fn glUniformMatrix3x2dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix3x4dv.xhtml>
	fn glUniformMatrix3x4dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix4x2dv.xhtml>
	fn glUniformMatrix4x2dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix4x3dv.xhtml>
	fn glUniformMatrix4x3dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformdv.xhtml>
	fn glGetUniformdv(&self, program: GLuint, location: GLint, params: *mut GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSubroutineUniformLocation.xhtml>
	fn glGetSubroutineUniformLocation(&self, program: GLuint, shadertype: GLenum, name: *const GLchar) -> Result<GLint>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSubroutineIndex.xhtml>
	fn glGetSubroutineIndex(&self, program: GLuint, shadertype: GLenum, name: *const GLchar) -> Result<GLuint>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniformiv.xhtml>
	fn glGetActiveSubroutineUniformiv(&self, program: GLuint, shadertype: GLenum, index: GLuint, pname: GLenum, values: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniformName.xhtml>
	fn glGetActiveSubroutineUniformName(&self, program: GLuint, shadertype: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveSubroutineName.xhtml>
	fn glGetActiveSubroutineName(&self, program: GLuint, shadertype: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformSubroutinesuiv.xhtml>
	fn glUniformSubroutinesuiv(&self, shadertype: GLenum, count: GLsizei, indices: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformSubroutineuiv.xhtml>
	fn glGetUniformSubroutineuiv(&self, shadertype: GLenum, location: GLint, params: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramStageiv.xhtml>
	fn glGetProgramStageiv(&self, program: GLuint, shadertype: GLenum, pname: GLenum, values: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPatchParameteri.xhtml>
	fn glPatchParameteri(&self, pname: GLenum, value: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPatchParameterfv.xhtml>
	fn glPatchParameterfv(&self, pname: GLenum, values: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindTransformFeedback.xhtml>
	fn glBindTransformFeedback(&self, target: GLenum, id: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteTransformFeedbacks.xhtml>
	fn glDeleteTransformFeedbacks(&self, n: GLsizei, ids: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenTransformFeedbacks.xhtml>
	fn glGenTransformFeedbacks(&self, n: GLsizei, ids: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsTransformFeedback.xhtml>
	fn glIsTransformFeedback(&self, id: GLuint) -> Result<GLboolean>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPauseTransformFeedback.xhtml>
	fn glPauseTransformFeedback(&self) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glResumeTransformFeedback.xhtml>
	fn glResumeTransformFeedback(&self) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawTransformFeedback.xhtml>
	fn glDrawTransformFeedback(&self, mode: GLenum, id: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStream.xhtml>
	fn glDrawTransformFeedbackStream(&self, mode: GLenum, id: GLuint, stream: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml>
	fn glBeginQueryIndexed(&self, target: GLenum, index: GLuint, id: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEndQueryIndexed.xhtml>
	fn glEndQueryIndexed(&self, target: GLenum, index: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryIndexediv.xhtml>
	fn glGetQueryIndexediv(&self, target: GLenum, index: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;
}
/// Functions from OpenGL version 4.0
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version40 {
	/// Is OpenGL version 4.0 available
	available: bool,

	/// The function pointer to `glGetError()`
	pub geterror: PFNGLGETERRORPROC,

	/// The function pointer to `glMinSampleShading()`
	pub minsampleshading: PFNGLMINSAMPLESHADINGPROC,

	/// The function pointer to `glBlendEquationi()`
	pub blendequationi: PFNGLBLENDEQUATIONIPROC,

	/// The function pointer to `glBlendEquationSeparatei()`
	pub blendequationseparatei: PFNGLBLENDEQUATIONSEPARATEIPROC,

	/// The function pointer to `glBlendFunci()`
	pub blendfunci: PFNGLBLENDFUNCIPROC,

	/// The function pointer to `glBlendFuncSeparatei()`
	pub blendfuncseparatei: PFNGLBLENDFUNCSEPARATEIPROC,

	/// The function pointer to `glDrawArraysIndirect()`
	pub drawarraysindirect: PFNGLDRAWARRAYSINDIRECTPROC,

	/// The function pointer to `glDrawElementsIndirect()`
	pub drawelementsindirect: PFNGLDRAWELEMENTSINDIRECTPROC,

	/// The function pointer to `glUniform1d()`
	pub uniform1d: PFNGLUNIFORM1DPROC,

	/// The function pointer to `glUniform2d()`
	pub uniform2d: PFNGLUNIFORM2DPROC,

	/// The function pointer to `glUniform3d()`
	pub uniform3d: PFNGLUNIFORM3DPROC,

	/// The function pointer to `glUniform4d()`
	pub uniform4d: PFNGLUNIFORM4DPROC,

	/// The function pointer to `glUniform1dv()`
	pub uniform1dv: PFNGLUNIFORM1DVPROC,

	/// The function pointer to `glUniform2dv()`
	pub uniform2dv: PFNGLUNIFORM2DVPROC,

	/// The function pointer to `glUniform3dv()`
	pub uniform3dv: PFNGLUNIFORM3DVPROC,

	/// The function pointer to `glUniform4dv()`
	pub uniform4dv: PFNGLUNIFORM4DVPROC,

	/// The function pointer to `glUniformMatrix2dv()`
	pub uniformmatrix2dv: PFNGLUNIFORMMATRIX2DVPROC,

	/// The function pointer to `glUniformMatrix3dv()`
	pub uniformmatrix3dv: PFNGLUNIFORMMATRIX3DVPROC,

	/// The function pointer to `glUniformMatrix4dv()`
	pub uniformmatrix4dv: PFNGLUNIFORMMATRIX4DVPROC,

	/// The function pointer to `glUniformMatrix2x3dv()`
	pub uniformmatrix2x3dv: PFNGLUNIFORMMATRIX2X3DVPROC,

	/// The function pointer to `glUniformMatrix2x4dv()`
	pub uniformmatrix2x4dv: PFNGLUNIFORMMATRIX2X4DVPROC,

	/// The function pointer to `glUniformMatrix3x2dv()`
	pub uniformmatrix3x2dv: PFNGLUNIFORMMATRIX3X2DVPROC,

	/// The function pointer to `glUniformMatrix3x4dv()`
	pub uniformmatrix3x4dv: PFNGLUNIFORMMATRIX3X4DVPROC,

	/// The function pointer to `glUniformMatrix4x2dv()`
	pub uniformmatrix4x2dv: PFNGLUNIFORMMATRIX4X2DVPROC,

	/// The function pointer to `glUniformMatrix4x3dv()`
	pub uniformmatrix4x3dv: PFNGLUNIFORMMATRIX4X3DVPROC,

	/// The function pointer to `glGetUniformdv()`
	pub getuniformdv: PFNGLGETUNIFORMDVPROC,

	/// The function pointer to `glGetSubroutineUniformLocation()`
	pub getsubroutineuniformlocation: PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC,

	/// The function pointer to `glGetSubroutineIndex()`
	pub getsubroutineindex: PFNGLGETSUBROUTINEINDEXPROC,

	/// The function pointer to `glGetActiveSubroutineUniformiv()`
	pub getactivesubroutineuniformiv: PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC,

	/// The function pointer to `glGetActiveSubroutineUniformName()`
	pub getactivesubroutineuniformname: PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC,

	/// The function pointer to `glGetActiveSubroutineName()`
	pub getactivesubroutinename: PFNGLGETACTIVESUBROUTINENAMEPROC,

	/// The function pointer to `glUniformSubroutinesuiv()`
	pub uniformsubroutinesuiv: PFNGLUNIFORMSUBROUTINESUIVPROC,

	/// The function pointer to `glGetUniformSubroutineuiv()`
	pub getuniformsubroutineuiv: PFNGLGETUNIFORMSUBROUTINEUIVPROC,

	/// The function pointer to `glGetProgramStageiv()`
	pub getprogramstageiv: PFNGLGETPROGRAMSTAGEIVPROC,

	/// The function pointer to `glPatchParameteri()`
	pub patchparameteri: PFNGLPATCHPARAMETERIPROC,

	/// The function pointer to `glPatchParameterfv()`
	pub patchparameterfv: PFNGLPATCHPARAMETERFVPROC,

	/// The function pointer to `glBindTransformFeedback()`
	pub bindtransformfeedback: PFNGLBINDTRANSFORMFEEDBACKPROC,

	/// The function pointer to `glDeleteTransformFeedbacks()`
	pub deletetransformfeedbacks: PFNGLDELETETRANSFORMFEEDBACKSPROC,

	/// The function pointer to `glGenTransformFeedbacks()`
	pub gentransformfeedbacks: PFNGLGENTRANSFORMFEEDBACKSPROC,

	/// The function pointer to `glIsTransformFeedback()`
	pub istransformfeedback: PFNGLISTRANSFORMFEEDBACKPROC,

	/// The function pointer to `glPauseTransformFeedback()`
	pub pausetransformfeedback: PFNGLPAUSETRANSFORMFEEDBACKPROC,

	/// The function pointer to `glResumeTransformFeedback()`
	pub resumetransformfeedback: PFNGLRESUMETRANSFORMFEEDBACKPROC,

	/// The function pointer to `glDrawTransformFeedback()`
	pub drawtransformfeedback: PFNGLDRAWTRANSFORMFEEDBACKPROC,

	/// The function pointer to `glDrawTransformFeedbackStream()`
	pub drawtransformfeedbackstream: PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC,

	/// The function pointer to `glBeginQueryIndexed()`
	pub beginqueryindexed: PFNGLBEGINQUERYINDEXEDPROC,

	/// The function pointer to `glEndQueryIndexed()`
	pub endqueryindexed: PFNGLENDQUERYINDEXEDPROC,

	/// The function pointer to `glGetQueryIndexediv()`
	pub getqueryindexediv: PFNGLGETQUERYINDEXEDIVPROC,
}

impl GL_4_0 for Version40 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMinSampleShading.xhtml>
	#[inline(always)]
	fn glMinSampleShading(&self, value: GLfloat) -> Result<()> {
		let ret = process_catch("glMinSampleShading", catch_unwind(||(self.minsampleshading)(value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMinSampleShading", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendEquationi.xhtml>
	#[inline(always)]
	fn glBlendEquationi(&self, buf: GLuint, mode: GLenum) -> Result<()> {
		let ret = process_catch("glBlendEquationi", catch_unwind(||(self.blendequationi)(buf, mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendEquationi", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendEquationSeparatei.xhtml>
	#[inline(always)]
	fn glBlendEquationSeparatei(&self, buf: GLuint, modeRGB: GLenum, modeAlpha: GLenum) -> Result<()> {
		let ret = process_catch("glBlendEquationSeparatei", catch_unwind(||(self.blendequationseparatei)(buf, modeRGB, modeAlpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendEquationSeparatei", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendFunci.xhtml>
	#[inline(always)]
	fn glBlendFunci(&self, buf: GLuint, src: GLenum, dst: GLenum) -> Result<()> {
		let ret = process_catch("glBlendFunci", catch_unwind(||(self.blendfunci)(buf, src, dst)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendFunci", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendFuncSeparatei.xhtml>
	#[inline(always)]
	fn glBlendFuncSeparatei(&self, buf: GLuint, srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum) -> Result<()> {
		let ret = process_catch("glBlendFuncSeparatei", catch_unwind(||(self.blendfuncseparatei)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendFuncSeparatei", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawArraysIndirect.xhtml>
	#[inline(always)]
	fn glDrawArraysIndirect(&self, mode: GLenum, indirect: *const c_void) -> Result<()> {
		let ret = process_catch("glDrawArraysIndirect", catch_unwind(||(self.drawarraysindirect)(mode, indirect)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawArraysIndirect", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsIndirect.xhtml>
	#[inline(always)]
	fn glDrawElementsIndirect(&self, mode: GLenum, type_: GLenum, indirect: *const c_void) -> Result<()> {
		let ret = process_catch("glDrawElementsIndirect", catch_unwind(||(self.drawelementsindirect)(mode, type_, indirect)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsIndirect", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1d.xhtml>
	#[inline(always)]
	fn glUniform1d(&self, location: GLint, x: GLdouble) -> Result<()> {
		let ret = process_catch("glUniform1d", catch_unwind(||(self.uniform1d)(location, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2d.xhtml>
	#[inline(always)]
	fn glUniform2d(&self, location: GLint, x: GLdouble, y: GLdouble) -> Result<()> {
		let ret = process_catch("glUniform2d", catch_unwind(||(self.uniform2d)(location, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3d.xhtml>
	#[inline(always)]
	fn glUniform3d(&self, location: GLint, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()> {
		let ret = process_catch("glUniform3d", catch_unwind(||(self.uniform3d)(location, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4d.xhtml>
	#[inline(always)]
	fn glUniform4d(&self, location: GLint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble) -> Result<()> {
		let ret = process_catch("glUniform4d", catch_unwind(||(self.uniform4d)(location, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1dv.xhtml>
	#[inline(always)]
	fn glUniform1dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniform1dv", catch_unwind(||(self.uniform1dv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2dv.xhtml>
	#[inline(always)]
	fn glUniform2dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniform2dv", catch_unwind(||(self.uniform2dv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3dv.xhtml>
	#[inline(always)]
	fn glUniform3dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniform3dv", catch_unwind(||(self.uniform3dv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4dv.xhtml>
	#[inline(always)]
	fn glUniform4dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniform4dv", catch_unwind(||(self.uniform4dv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix2dv.xhtml>
	#[inline(always)]
	fn glUniformMatrix2dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix2dv", catch_unwind(||(self.uniformmatrix2dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix3dv.xhtml>
	#[inline(always)]
	fn glUniformMatrix3dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix3dv", catch_unwind(||(self.uniformmatrix3dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix4dv.xhtml>
	#[inline(always)]
	fn glUniformMatrix4dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix4dv", catch_unwind(||(self.uniformmatrix4dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix2x3dv.xhtml>
	#[inline(always)]
	fn glUniformMatrix2x3dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix2x3dv", catch_unwind(||(self.uniformmatrix2x3dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2x3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix2x4dv.xhtml>
	#[inline(always)]
	fn glUniformMatrix2x4dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix2x4dv", catch_unwind(||(self.uniformmatrix2x4dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2x4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix3x2dv.xhtml>
	#[inline(always)]
	fn glUniformMatrix3x2dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix3x2dv", catch_unwind(||(self.uniformmatrix3x2dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3x2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix3x4dv.xhtml>
	#[inline(always)]
	fn glUniformMatrix3x4dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix3x4dv", catch_unwind(||(self.uniformmatrix3x4dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3x4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix4x2dv.xhtml>
	#[inline(always)]
	fn glUniformMatrix4x2dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix4x2dv", catch_unwind(||(self.uniformmatrix4x2dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4x2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix4x3dv.xhtml>
	#[inline(always)]
	fn glUniformMatrix4x3dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix4x3dv", catch_unwind(||(self.uniformmatrix4x3dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4x3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformdv.xhtml>
	#[inline(always)]
	fn glGetUniformdv(&self, program: GLuint, location: GLint, params: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetUniformdv", catch_unwind(||(self.getuniformdv)(program, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformdv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSubroutineUniformLocation.xhtml>
	#[inline(always)]
	fn glGetSubroutineUniformLocation(&self, program: GLuint, shadertype: GLenum, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetSubroutineUniformLocation", catch_unwind(||(self.getsubroutineuniformlocation)(program, shadertype, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSubroutineUniformLocation", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSubroutineIndex.xhtml>
	#[inline(always)]
	fn glGetSubroutineIndex(&self, program: GLuint, shadertype: GLenum, name: *const GLchar) -> Result<GLuint> {
		let ret = process_catch("glGetSubroutineIndex", catch_unwind(||(self.getsubroutineindex)(program, shadertype, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSubroutineIndex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniformiv.xhtml>
	#[inline(always)]
	fn glGetActiveSubroutineUniformiv(&self, program: GLuint, shadertype: GLenum, index: GLuint, pname: GLenum, values: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetActiveSubroutineUniformiv", catch_unwind(||(self.getactivesubroutineuniformiv)(program, shadertype, index, pname, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveSubroutineUniformiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniformName.xhtml>
	#[inline(always)]
	fn glGetActiveSubroutineUniformName(&self, program: GLuint, shadertype: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveSubroutineUniformName", catch_unwind(||(self.getactivesubroutineuniformname)(program, shadertype, index, bufSize, length, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveSubroutineUniformName", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveSubroutineName.xhtml>
	#[inline(always)]
	fn glGetActiveSubroutineName(&self, program: GLuint, shadertype: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveSubroutineName", catch_unwind(||(self.getactivesubroutinename)(program, shadertype, index, bufSize, length, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveSubroutineName", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformSubroutinesuiv.xhtml>
	#[inline(always)]
	fn glUniformSubroutinesuiv(&self, shadertype: GLenum, count: GLsizei, indices: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniformSubroutinesuiv", catch_unwind(||(self.uniformsubroutinesuiv)(shadertype, count, indices)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformSubroutinesuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformSubroutineuiv.xhtml>
	#[inline(always)]
	fn glGetUniformSubroutineuiv(&self, shadertype: GLenum, location: GLint, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetUniformSubroutineuiv", catch_unwind(||(self.getuniformsubroutineuiv)(shadertype, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformSubroutineuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramStageiv.xhtml>
	#[inline(always)]
	fn glGetProgramStageiv(&self, program: GLuint, shadertype: GLenum, pname: GLenum, values: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramStageiv", catch_unwind(||(self.getprogramstageiv)(program, shadertype, pname, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramStageiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPatchParameteri.xhtml>
	#[inline(always)]
	fn glPatchParameteri(&self, pname: GLenum, value: GLint) -> Result<()> {
		let ret = process_catch("glPatchParameteri", catch_unwind(||(self.patchparameteri)(pname, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPatchParameteri", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPatchParameterfv.xhtml>
	#[inline(always)]
	fn glPatchParameterfv(&self, pname: GLenum, values: *const GLfloat) -> Result<()> {
		let ret = process_catch("glPatchParameterfv", catch_unwind(||(self.patchparameterfv)(pname, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPatchParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindTransformFeedback.xhtml>
	#[inline(always)]
	fn glBindTransformFeedback(&self, target: GLenum, id: GLuint) -> Result<()> {
		let ret = process_catch("glBindTransformFeedback", catch_unwind(||(self.bindtransformfeedback)(target, id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindTransformFeedback", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteTransformFeedbacks.xhtml>
	#[inline(always)]
	fn glDeleteTransformFeedbacks(&self, n: GLsizei, ids: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteTransformFeedbacks", catch_unwind(||(self.deletetransformfeedbacks)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteTransformFeedbacks", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenTransformFeedbacks.xhtml>
	#[inline(always)]
	fn glGenTransformFeedbacks(&self, n: GLsizei, ids: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenTransformFeedbacks", catch_unwind(||(self.gentransformfeedbacks)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenTransformFeedbacks", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsTransformFeedback.xhtml>
	#[inline(always)]
	fn glIsTransformFeedback(&self, id: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsTransformFeedback", catch_unwind(||(self.istransformfeedback)(id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsTransformFeedback", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPauseTransformFeedback.xhtml>
	#[inline(always)]
	fn glPauseTransformFeedback(&self) -> Result<()> {
		let ret = process_catch("glPauseTransformFeedback", catch_unwind(||(self.pausetransformfeedback)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPauseTransformFeedback", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glResumeTransformFeedback.xhtml>
	#[inline(always)]
	fn glResumeTransformFeedback(&self) -> Result<()> {
		let ret = process_catch("glResumeTransformFeedback", catch_unwind(||(self.resumetransformfeedback)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glResumeTransformFeedback", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawTransformFeedback.xhtml>
	#[inline(always)]
	fn glDrawTransformFeedback(&self, mode: GLenum, id: GLuint) -> Result<()> {
		let ret = process_catch("glDrawTransformFeedback", catch_unwind(||(self.drawtransformfeedback)(mode, id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawTransformFeedback", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStream.xhtml>
	#[inline(always)]
	fn glDrawTransformFeedbackStream(&self, mode: GLenum, id: GLuint, stream: GLuint) -> Result<()> {
		let ret = process_catch("glDrawTransformFeedbackStream", catch_unwind(||(self.drawtransformfeedbackstream)(mode, id, stream)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawTransformFeedbackStream", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml>
	#[inline(always)]
	fn glBeginQueryIndexed(&self, target: GLenum, index: GLuint, id: GLuint) -> Result<()> {
		let ret = process_catch("glBeginQueryIndexed", catch_unwind(||(self.beginqueryindexed)(target, index, id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBeginQueryIndexed", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEndQueryIndexed.xhtml>
	#[inline(always)]
	fn glEndQueryIndexed(&self, target: GLenum, index: GLuint) -> Result<()> {
		let ret = process_catch("glEndQueryIndexed", catch_unwind(||(self.endqueryindexed)(target, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEndQueryIndexed", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryIndexediv.xhtml>
	#[inline(always)]
	fn glGetQueryIndexediv(&self, target: GLenum, index: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetQueryIndexediv", catch_unwind(||(self.getqueryindexediv)(target, index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryIndexediv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version40 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (4, 0, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			minsampleshading: {let proc = get_proc_address("glMinSampleShading"); if proc == null() {dummy_pfnglminsampleshadingproc} else {unsafe{transmute(proc)}}},
			blendequationi: {let proc = get_proc_address("glBlendEquationi"); if proc == null() {dummy_pfnglblendequationiproc} else {unsafe{transmute(proc)}}},
			blendequationseparatei: {let proc = get_proc_address("glBlendEquationSeparatei"); if proc == null() {dummy_pfnglblendequationseparateiproc} else {unsafe{transmute(proc)}}},
			blendfunci: {let proc = get_proc_address("glBlendFunci"); if proc == null() {dummy_pfnglblendfunciproc} else {unsafe{transmute(proc)}}},
			blendfuncseparatei: {let proc = get_proc_address("glBlendFuncSeparatei"); if proc == null() {dummy_pfnglblendfuncseparateiproc} else {unsafe{transmute(proc)}}},
			drawarraysindirect: {let proc = get_proc_address("glDrawArraysIndirect"); if proc == null() {dummy_pfngldrawarraysindirectproc} else {unsafe{transmute(proc)}}},
			drawelementsindirect: {let proc = get_proc_address("glDrawElementsIndirect"); if proc == null() {dummy_pfngldrawelementsindirectproc} else {unsafe{transmute(proc)}}},
			uniform1d: {let proc = get_proc_address("glUniform1d"); if proc == null() {dummy_pfngluniform1dproc} else {unsafe{transmute(proc)}}},
			uniform2d: {let proc = get_proc_address("glUniform2d"); if proc == null() {dummy_pfngluniform2dproc} else {unsafe{transmute(proc)}}},
			uniform3d: {let proc = get_proc_address("glUniform3d"); if proc == null() {dummy_pfngluniform3dproc} else {unsafe{transmute(proc)}}},
			uniform4d: {let proc = get_proc_address("glUniform4d"); if proc == null() {dummy_pfngluniform4dproc} else {unsafe{transmute(proc)}}},
			uniform1dv: {let proc = get_proc_address("glUniform1dv"); if proc == null() {dummy_pfngluniform1dvproc} else {unsafe{transmute(proc)}}},
			uniform2dv: {let proc = get_proc_address("glUniform2dv"); if proc == null() {dummy_pfngluniform2dvproc} else {unsafe{transmute(proc)}}},
			uniform3dv: {let proc = get_proc_address("glUniform3dv"); if proc == null() {dummy_pfngluniform3dvproc} else {unsafe{transmute(proc)}}},
			uniform4dv: {let proc = get_proc_address("glUniform4dv"); if proc == null() {dummy_pfngluniform4dvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix2dv: {let proc = get_proc_address("glUniformMatrix2dv"); if proc == null() {dummy_pfngluniformmatrix2dvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix3dv: {let proc = get_proc_address("glUniformMatrix3dv"); if proc == null() {dummy_pfngluniformmatrix3dvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix4dv: {let proc = get_proc_address("glUniformMatrix4dv"); if proc == null() {dummy_pfngluniformmatrix4dvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix2x3dv: {let proc = get_proc_address("glUniformMatrix2x3dv"); if proc == null() {dummy_pfngluniformmatrix2x3dvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix2x4dv: {let proc = get_proc_address("glUniformMatrix2x4dv"); if proc == null() {dummy_pfngluniformmatrix2x4dvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix3x2dv: {let proc = get_proc_address("glUniformMatrix3x2dv"); if proc == null() {dummy_pfngluniformmatrix3x2dvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix3x4dv: {let proc = get_proc_address("glUniformMatrix3x4dv"); if proc == null() {dummy_pfngluniformmatrix3x4dvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix4x2dv: {let proc = get_proc_address("glUniformMatrix4x2dv"); if proc == null() {dummy_pfngluniformmatrix4x2dvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix4x3dv: {let proc = get_proc_address("glUniformMatrix4x3dv"); if proc == null() {dummy_pfngluniformmatrix4x3dvproc} else {unsafe{transmute(proc)}}},
			getuniformdv: {let proc = get_proc_address("glGetUniformdv"); if proc == null() {dummy_pfnglgetuniformdvproc} else {unsafe{transmute(proc)}}},
			getsubroutineuniformlocation: {let proc = get_proc_address("glGetSubroutineUniformLocation"); if proc == null() {dummy_pfnglgetsubroutineuniformlocationproc} else {unsafe{transmute(proc)}}},
			getsubroutineindex: {let proc = get_proc_address("glGetSubroutineIndex"); if proc == null() {dummy_pfnglgetsubroutineindexproc} else {unsafe{transmute(proc)}}},
			getactivesubroutineuniformiv: {let proc = get_proc_address("glGetActiveSubroutineUniformiv"); if proc == null() {dummy_pfnglgetactivesubroutineuniformivproc} else {unsafe{transmute(proc)}}},
			getactivesubroutineuniformname: {let proc = get_proc_address("glGetActiveSubroutineUniformName"); if proc == null() {dummy_pfnglgetactivesubroutineuniformnameproc} else {unsafe{transmute(proc)}}},
			getactivesubroutinename: {let proc = get_proc_address("glGetActiveSubroutineName"); if proc == null() {dummy_pfnglgetactivesubroutinenameproc} else {unsafe{transmute(proc)}}},
			uniformsubroutinesuiv: {let proc = get_proc_address("glUniformSubroutinesuiv"); if proc == null() {dummy_pfngluniformsubroutinesuivproc} else {unsafe{transmute(proc)}}},
			getuniformsubroutineuiv: {let proc = get_proc_address("glGetUniformSubroutineuiv"); if proc == null() {dummy_pfnglgetuniformsubroutineuivproc} else {unsafe{transmute(proc)}}},
			getprogramstageiv: {let proc = get_proc_address("glGetProgramStageiv"); if proc == null() {dummy_pfnglgetprogramstageivproc} else {unsafe{transmute(proc)}}},
			patchparameteri: {let proc = get_proc_address("glPatchParameteri"); if proc == null() {dummy_pfnglpatchparameteriproc} else {unsafe{transmute(proc)}}},
			patchparameterfv: {let proc = get_proc_address("glPatchParameterfv"); if proc == null() {dummy_pfnglpatchparameterfvproc} else {unsafe{transmute(proc)}}},
			bindtransformfeedback: {let proc = get_proc_address("glBindTransformFeedback"); if proc == null() {dummy_pfnglbindtransformfeedbackproc} else {unsafe{transmute(proc)}}},
			deletetransformfeedbacks: {let proc = get_proc_address("glDeleteTransformFeedbacks"); if proc == null() {dummy_pfngldeletetransformfeedbacksproc} else {unsafe{transmute(proc)}}},
			gentransformfeedbacks: {let proc = get_proc_address("glGenTransformFeedbacks"); if proc == null() {dummy_pfnglgentransformfeedbacksproc} else {unsafe{transmute(proc)}}},
			istransformfeedback: {let proc = get_proc_address("glIsTransformFeedback"); if proc == null() {dummy_pfnglistransformfeedbackproc} else {unsafe{transmute(proc)}}},
			pausetransformfeedback: {let proc = get_proc_address("glPauseTransformFeedback"); if proc == null() {dummy_pfnglpausetransformfeedbackproc} else {unsafe{transmute(proc)}}},
			resumetransformfeedback: {let proc = get_proc_address("glResumeTransformFeedback"); if proc == null() {dummy_pfnglresumetransformfeedbackproc} else {unsafe{transmute(proc)}}},
			drawtransformfeedback: {let proc = get_proc_address("glDrawTransformFeedback"); if proc == null() {dummy_pfngldrawtransformfeedbackproc} else {unsafe{transmute(proc)}}},
			drawtransformfeedbackstream: {let proc = get_proc_address("glDrawTransformFeedbackStream"); if proc == null() {dummy_pfngldrawtransformfeedbackstreamproc} else {unsafe{transmute(proc)}}},
			beginqueryindexed: {let proc = get_proc_address("glBeginQueryIndexed"); if proc == null() {dummy_pfnglbeginqueryindexedproc} else {unsafe{transmute(proc)}}},
			endqueryindexed: {let proc = get_proc_address("glEndQueryIndexed"); if proc == null() {dummy_pfnglendqueryindexedproc} else {unsafe{transmute(proc)}}},
			getqueryindexediv: {let proc = get_proc_address("glGetQueryIndexediv"); if proc == null() {dummy_pfnglgetqueryindexedivproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version40 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			minsampleshading: dummy_pfnglminsampleshadingproc,
			blendequationi: dummy_pfnglblendequationiproc,
			blendequationseparatei: dummy_pfnglblendequationseparateiproc,
			blendfunci: dummy_pfnglblendfunciproc,
			blendfuncseparatei: dummy_pfnglblendfuncseparateiproc,
			drawarraysindirect: dummy_pfngldrawarraysindirectproc,
			drawelementsindirect: dummy_pfngldrawelementsindirectproc,
			uniform1d: dummy_pfngluniform1dproc,
			uniform2d: dummy_pfngluniform2dproc,
			uniform3d: dummy_pfngluniform3dproc,
			uniform4d: dummy_pfngluniform4dproc,
			uniform1dv: dummy_pfngluniform1dvproc,
			uniform2dv: dummy_pfngluniform2dvproc,
			uniform3dv: dummy_pfngluniform3dvproc,
			uniform4dv: dummy_pfngluniform4dvproc,
			uniformmatrix2dv: dummy_pfngluniformmatrix2dvproc,
			uniformmatrix3dv: dummy_pfngluniformmatrix3dvproc,
			uniformmatrix4dv: dummy_pfngluniformmatrix4dvproc,
			uniformmatrix2x3dv: dummy_pfngluniformmatrix2x3dvproc,
			uniformmatrix2x4dv: dummy_pfngluniformmatrix2x4dvproc,
			uniformmatrix3x2dv: dummy_pfngluniformmatrix3x2dvproc,
			uniformmatrix3x4dv: dummy_pfngluniformmatrix3x4dvproc,
			uniformmatrix4x2dv: dummy_pfngluniformmatrix4x2dvproc,
			uniformmatrix4x3dv: dummy_pfngluniformmatrix4x3dvproc,
			getuniformdv: dummy_pfnglgetuniformdvproc,
			getsubroutineuniformlocation: dummy_pfnglgetsubroutineuniformlocationproc,
			getsubroutineindex: dummy_pfnglgetsubroutineindexproc,
			getactivesubroutineuniformiv: dummy_pfnglgetactivesubroutineuniformivproc,
			getactivesubroutineuniformname: dummy_pfnglgetactivesubroutineuniformnameproc,
			getactivesubroutinename: dummy_pfnglgetactivesubroutinenameproc,
			uniformsubroutinesuiv: dummy_pfngluniformsubroutinesuivproc,
			getuniformsubroutineuiv: dummy_pfnglgetuniformsubroutineuivproc,
			getprogramstageiv: dummy_pfnglgetprogramstageivproc,
			patchparameteri: dummy_pfnglpatchparameteriproc,
			patchparameterfv: dummy_pfnglpatchparameterfvproc,
			bindtransformfeedback: dummy_pfnglbindtransformfeedbackproc,
			deletetransformfeedbacks: dummy_pfngldeletetransformfeedbacksproc,
			gentransformfeedbacks: dummy_pfnglgentransformfeedbacksproc,
			istransformfeedback: dummy_pfnglistransformfeedbackproc,
			pausetransformfeedback: dummy_pfnglpausetransformfeedbackproc,
			resumetransformfeedback: dummy_pfnglresumetransformfeedbackproc,
			drawtransformfeedback: dummy_pfngldrawtransformfeedbackproc,
			drawtransformfeedbackstream: dummy_pfngldrawtransformfeedbackstreamproc,
			beginqueryindexed: dummy_pfnglbeginqueryindexedproc,
			endqueryindexed: dummy_pfnglendqueryindexedproc,
			getqueryindexediv: dummy_pfnglgetqueryindexedivproc,
		}
	}
}
impl Debug for Version40 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version40")
			.field("available", &self.available)
			.field("minsampleshading", unsafe{if transmute::<_, *const c_void>(self.minsampleshading) == (dummy_pfnglminsampleshadingproc as *const c_void) {&null::<PFNGLMINSAMPLESHADINGPROC>()} else {&self.minsampleshading}})
			.field("blendequationi", unsafe{if transmute::<_, *const c_void>(self.blendequationi) == (dummy_pfnglblendequationiproc as *const c_void) {&null::<PFNGLBLENDEQUATIONIPROC>()} else {&self.blendequationi}})
			.field("blendequationseparatei", unsafe{if transmute::<_, *const c_void>(self.blendequationseparatei) == (dummy_pfnglblendequationseparateiproc as *const c_void) {&null::<PFNGLBLENDEQUATIONSEPARATEIPROC>()} else {&self.blendequationseparatei}})
			.field("blendfunci", unsafe{if transmute::<_, *const c_void>(self.blendfunci) == (dummy_pfnglblendfunciproc as *const c_void) {&null::<PFNGLBLENDFUNCIPROC>()} else {&self.blendfunci}})
			.field("blendfuncseparatei", unsafe{if transmute::<_, *const c_void>(self.blendfuncseparatei) == (dummy_pfnglblendfuncseparateiproc as *const c_void) {&null::<PFNGLBLENDFUNCSEPARATEIPROC>()} else {&self.blendfuncseparatei}})
			.field("drawarraysindirect", unsafe{if transmute::<_, *const c_void>(self.drawarraysindirect) == (dummy_pfngldrawarraysindirectproc as *const c_void) {&null::<PFNGLDRAWARRAYSINDIRECTPROC>()} else {&self.drawarraysindirect}})
			.field("drawelementsindirect", unsafe{if transmute::<_, *const c_void>(self.drawelementsindirect) == (dummy_pfngldrawelementsindirectproc as *const c_void) {&null::<PFNGLDRAWELEMENTSINDIRECTPROC>()} else {&self.drawelementsindirect}})
			.field("uniform1d", unsafe{if transmute::<_, *const c_void>(self.uniform1d) == (dummy_pfngluniform1dproc as *const c_void) {&null::<PFNGLUNIFORM1DPROC>()} else {&self.uniform1d}})
			.field("uniform2d", unsafe{if transmute::<_, *const c_void>(self.uniform2d) == (dummy_pfngluniform2dproc as *const c_void) {&null::<PFNGLUNIFORM2DPROC>()} else {&self.uniform2d}})
			.field("uniform3d", unsafe{if transmute::<_, *const c_void>(self.uniform3d) == (dummy_pfngluniform3dproc as *const c_void) {&null::<PFNGLUNIFORM3DPROC>()} else {&self.uniform3d}})
			.field("uniform4d", unsafe{if transmute::<_, *const c_void>(self.uniform4d) == (dummy_pfngluniform4dproc as *const c_void) {&null::<PFNGLUNIFORM4DPROC>()} else {&self.uniform4d}})
			.field("uniform1dv", unsafe{if transmute::<_, *const c_void>(self.uniform1dv) == (dummy_pfngluniform1dvproc as *const c_void) {&null::<PFNGLUNIFORM1DVPROC>()} else {&self.uniform1dv}})
			.field("uniform2dv", unsafe{if transmute::<_, *const c_void>(self.uniform2dv) == (dummy_pfngluniform2dvproc as *const c_void) {&null::<PFNGLUNIFORM2DVPROC>()} else {&self.uniform2dv}})
			.field("uniform3dv", unsafe{if transmute::<_, *const c_void>(self.uniform3dv) == (dummy_pfngluniform3dvproc as *const c_void) {&null::<PFNGLUNIFORM3DVPROC>()} else {&self.uniform3dv}})
			.field("uniform4dv", unsafe{if transmute::<_, *const c_void>(self.uniform4dv) == (dummy_pfngluniform4dvproc as *const c_void) {&null::<PFNGLUNIFORM4DVPROC>()} else {&self.uniform4dv}})
			.field("uniformmatrix2dv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix2dv) == (dummy_pfngluniformmatrix2dvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX2DVPROC>()} else {&self.uniformmatrix2dv}})
			.field("uniformmatrix3dv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix3dv) == (dummy_pfngluniformmatrix3dvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX3DVPROC>()} else {&self.uniformmatrix3dv}})
			.field("uniformmatrix4dv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix4dv) == (dummy_pfngluniformmatrix4dvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX4DVPROC>()} else {&self.uniformmatrix4dv}})
			.field("uniformmatrix2x3dv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix2x3dv) == (dummy_pfngluniformmatrix2x3dvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX2X3DVPROC>()} else {&self.uniformmatrix2x3dv}})
			.field("uniformmatrix2x4dv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix2x4dv) == (dummy_pfngluniformmatrix2x4dvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX2X4DVPROC>()} else {&self.uniformmatrix2x4dv}})
			.field("uniformmatrix3x2dv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix3x2dv) == (dummy_pfngluniformmatrix3x2dvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX3X2DVPROC>()} else {&self.uniformmatrix3x2dv}})
			.field("uniformmatrix3x4dv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix3x4dv) == (dummy_pfngluniformmatrix3x4dvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX3X4DVPROC>()} else {&self.uniformmatrix3x4dv}})
			.field("uniformmatrix4x2dv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix4x2dv) == (dummy_pfngluniformmatrix4x2dvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX4X2DVPROC>()} else {&self.uniformmatrix4x2dv}})
			.field("uniformmatrix4x3dv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix4x3dv) == (dummy_pfngluniformmatrix4x3dvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX4X3DVPROC>()} else {&self.uniformmatrix4x3dv}})
			.field("getuniformdv", unsafe{if transmute::<_, *const c_void>(self.getuniformdv) == (dummy_pfnglgetuniformdvproc as *const c_void) {&null::<PFNGLGETUNIFORMDVPROC>()} else {&self.getuniformdv}})
			.field("getsubroutineuniformlocation", unsafe{if transmute::<_, *const c_void>(self.getsubroutineuniformlocation) == (dummy_pfnglgetsubroutineuniformlocationproc as *const c_void) {&null::<PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC>()} else {&self.getsubroutineuniformlocation}})
			.field("getsubroutineindex", unsafe{if transmute::<_, *const c_void>(self.getsubroutineindex) == (dummy_pfnglgetsubroutineindexproc as *const c_void) {&null::<PFNGLGETSUBROUTINEINDEXPROC>()} else {&self.getsubroutineindex}})
			.field("getactivesubroutineuniformiv", unsafe{if transmute::<_, *const c_void>(self.getactivesubroutineuniformiv) == (dummy_pfnglgetactivesubroutineuniformivproc as *const c_void) {&null::<PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC>()} else {&self.getactivesubroutineuniformiv}})
			.field("getactivesubroutineuniformname", unsafe{if transmute::<_, *const c_void>(self.getactivesubroutineuniformname) == (dummy_pfnglgetactivesubroutineuniformnameproc as *const c_void) {&null::<PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC>()} else {&self.getactivesubroutineuniformname}})
			.field("getactivesubroutinename", unsafe{if transmute::<_, *const c_void>(self.getactivesubroutinename) == (dummy_pfnglgetactivesubroutinenameproc as *const c_void) {&null::<PFNGLGETACTIVESUBROUTINENAMEPROC>()} else {&self.getactivesubroutinename}})
			.field("uniformsubroutinesuiv", unsafe{if transmute::<_, *const c_void>(self.uniformsubroutinesuiv) == (dummy_pfngluniformsubroutinesuivproc as *const c_void) {&null::<PFNGLUNIFORMSUBROUTINESUIVPROC>()} else {&self.uniformsubroutinesuiv}})
			.field("getuniformsubroutineuiv", unsafe{if transmute::<_, *const c_void>(self.getuniformsubroutineuiv) == (dummy_pfnglgetuniformsubroutineuivproc as *const c_void) {&null::<PFNGLGETUNIFORMSUBROUTINEUIVPROC>()} else {&self.getuniformsubroutineuiv}})
			.field("getprogramstageiv", unsafe{if transmute::<_, *const c_void>(self.getprogramstageiv) == (dummy_pfnglgetprogramstageivproc as *const c_void) {&null::<PFNGLGETPROGRAMSTAGEIVPROC>()} else {&self.getprogramstageiv}})
			.field("patchparameteri", unsafe{if transmute::<_, *const c_void>(self.patchparameteri) == (dummy_pfnglpatchparameteriproc as *const c_void) {&null::<PFNGLPATCHPARAMETERIPROC>()} else {&self.patchparameteri}})
			.field("patchparameterfv", unsafe{if transmute::<_, *const c_void>(self.patchparameterfv) == (dummy_pfnglpatchparameterfvproc as *const c_void) {&null::<PFNGLPATCHPARAMETERFVPROC>()} else {&self.patchparameterfv}})
			.field("bindtransformfeedback", unsafe{if transmute::<_, *const c_void>(self.bindtransformfeedback) == (dummy_pfnglbindtransformfeedbackproc as *const c_void) {&null::<PFNGLBINDTRANSFORMFEEDBACKPROC>()} else {&self.bindtransformfeedback}})
			.field("deletetransformfeedbacks", unsafe{if transmute::<_, *const c_void>(self.deletetransformfeedbacks) == (dummy_pfngldeletetransformfeedbacksproc as *const c_void) {&null::<PFNGLDELETETRANSFORMFEEDBACKSPROC>()} else {&self.deletetransformfeedbacks}})
			.field("gentransformfeedbacks", unsafe{if transmute::<_, *const c_void>(self.gentransformfeedbacks) == (dummy_pfnglgentransformfeedbacksproc as *const c_void) {&null::<PFNGLGENTRANSFORMFEEDBACKSPROC>()} else {&self.gentransformfeedbacks}})
			.field("istransformfeedback", unsafe{if transmute::<_, *const c_void>(self.istransformfeedback) == (dummy_pfnglistransformfeedbackproc as *const c_void) {&null::<PFNGLISTRANSFORMFEEDBACKPROC>()} else {&self.istransformfeedback}})
			.field("pausetransformfeedback", unsafe{if transmute::<_, *const c_void>(self.pausetransformfeedback) == (dummy_pfnglpausetransformfeedbackproc as *const c_void) {&null::<PFNGLPAUSETRANSFORMFEEDBACKPROC>()} else {&self.pausetransformfeedback}})
			.field("resumetransformfeedback", unsafe{if transmute::<_, *const c_void>(self.resumetransformfeedback) == (dummy_pfnglresumetransformfeedbackproc as *const c_void) {&null::<PFNGLRESUMETRANSFORMFEEDBACKPROC>()} else {&self.resumetransformfeedback}})
			.field("drawtransformfeedback", unsafe{if transmute::<_, *const c_void>(self.drawtransformfeedback) == (dummy_pfngldrawtransformfeedbackproc as *const c_void) {&null::<PFNGLDRAWTRANSFORMFEEDBACKPROC>()} else {&self.drawtransformfeedback}})
			.field("drawtransformfeedbackstream", unsafe{if transmute::<_, *const c_void>(self.drawtransformfeedbackstream) == (dummy_pfngldrawtransformfeedbackstreamproc as *const c_void) {&null::<PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC>()} else {&self.drawtransformfeedbackstream}})
			.field("beginqueryindexed", unsafe{if transmute::<_, *const c_void>(self.beginqueryindexed) == (dummy_pfnglbeginqueryindexedproc as *const c_void) {&null::<PFNGLBEGINQUERYINDEXEDPROC>()} else {&self.beginqueryindexed}})
			.field("endqueryindexed", unsafe{if transmute::<_, *const c_void>(self.endqueryindexed) == (dummy_pfnglendqueryindexedproc as *const c_void) {&null::<PFNGLENDQUERYINDEXEDPROC>()} else {&self.endqueryindexed}})
			.field("getqueryindexediv", unsafe{if transmute::<_, *const c_void>(self.getqueryindexediv) == (dummy_pfnglgetqueryindexedivproc as *const c_void) {&null::<PFNGLGETQUERYINDEXEDIVPROC>()} else {&self.getqueryindexediv}})
			.finish()
		} else {
			f.debug_struct("Version40")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

/// The prototype to the OpenGL function `ReleaseShaderCompiler`
type PFNGLRELEASESHADERCOMPILERPROC = extern "system" fn();

/// The prototype to the OpenGL function `ShaderBinary`
type PFNGLSHADERBINARYPROC = extern "system" fn(GLsizei, *const GLuint, GLenum, *const c_void, GLsizei);

/// The prototype to the OpenGL function `GetShaderPrecisionFormat`
type PFNGLGETSHADERPRECISIONFORMATPROC = extern "system" fn(GLenum, GLenum, *mut GLint, *mut GLint);

/// The prototype to the OpenGL function `DepthRangef`
type PFNGLDEPTHRANGEFPROC = extern "system" fn(GLfloat, GLfloat);

/// The prototype to the OpenGL function `ClearDepthf`
type PFNGLCLEARDEPTHFPROC = extern "system" fn(GLfloat);

/// The prototype to the OpenGL function `GetProgramBinary`
type PFNGLGETPROGRAMBINARYPROC = extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLenum, *mut c_void);

/// The prototype to the OpenGL function `ProgramBinary`
type PFNGLPROGRAMBINARYPROC = extern "system" fn(GLuint, GLenum, *const c_void, GLsizei);

/// The prototype to the OpenGL function `ProgramParameteri`
type PFNGLPROGRAMPARAMETERIPROC = extern "system" fn(GLuint, GLenum, GLint);

/// The prototype to the OpenGL function `UseProgramStages`
type PFNGLUSEPROGRAMSTAGESPROC = extern "system" fn(GLuint, GLbitfield, GLuint);

/// The prototype to the OpenGL function `ActiveShaderProgram`
type PFNGLACTIVESHADERPROGRAMPROC = extern "system" fn(GLuint, GLuint);

/// The prototype to the OpenGL function `CreateShaderProgramv`
type PFNGLCREATESHADERPROGRAMVPROC = extern "system" fn(GLenum, GLsizei, *const *const GLchar) -> GLuint;

/// The prototype to the OpenGL function `BindProgramPipeline`
type PFNGLBINDPROGRAMPIPELINEPROC = extern "system" fn(GLuint);

/// The prototype to the OpenGL function `DeleteProgramPipelines`
type PFNGLDELETEPROGRAMPIPELINESPROC = extern "system" fn(GLsizei, *const GLuint);

/// The prototype to the OpenGL function `GenProgramPipelines`
type PFNGLGENPROGRAMPIPELINESPROC = extern "system" fn(GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `IsProgramPipeline`
type PFNGLISPROGRAMPIPELINEPROC = extern "system" fn(GLuint) -> GLboolean;

/// The prototype to the OpenGL function `GetProgramPipelineiv`
type PFNGLGETPROGRAMPIPELINEIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `ProgramUniform1i`
type PFNGLPROGRAMUNIFORM1IPROC = extern "system" fn(GLuint, GLint, GLint);

/// The prototype to the OpenGL function `ProgramUniform1iv`
type PFNGLPROGRAMUNIFORM1IVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLint);

/// The prototype to the OpenGL function `ProgramUniform1f`
type PFNGLPROGRAMUNIFORM1FPROC = extern "system" fn(GLuint, GLint, GLfloat);

/// The prototype to the OpenGL function `ProgramUniform1fv`
type PFNGLPROGRAMUNIFORM1FVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat);

/// The prototype to the OpenGL function `ProgramUniform1d`
type PFNGLPROGRAMUNIFORM1DPROC = extern "system" fn(GLuint, GLint, GLdouble);

/// The prototype to the OpenGL function `ProgramUniform1dv`
type PFNGLPROGRAMUNIFORM1DVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLdouble);

/// The prototype to the OpenGL function `ProgramUniform1ui`
type PFNGLPROGRAMUNIFORM1UIPROC = extern "system" fn(GLuint, GLint, GLuint);

/// The prototype to the OpenGL function `ProgramUniform1uiv`
type PFNGLPROGRAMUNIFORM1UIVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLuint);

/// The prototype to the OpenGL function `ProgramUniform2i`
type PFNGLPROGRAMUNIFORM2IPROC = extern "system" fn(GLuint, GLint, GLint, GLint);

/// The prototype to the OpenGL function `ProgramUniform2iv`
type PFNGLPROGRAMUNIFORM2IVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLint);

/// The prototype to the OpenGL function `ProgramUniform2f`
type PFNGLPROGRAMUNIFORM2FPROC = extern "system" fn(GLuint, GLint, GLfloat, GLfloat);

/// The prototype to the OpenGL function `ProgramUniform2fv`
type PFNGLPROGRAMUNIFORM2FVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat);

/// The prototype to the OpenGL function `ProgramUniform2d`
type PFNGLPROGRAMUNIFORM2DPROC = extern "system" fn(GLuint, GLint, GLdouble, GLdouble);

/// The prototype to the OpenGL function `ProgramUniform2dv`
type PFNGLPROGRAMUNIFORM2DVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLdouble);

/// The prototype to the OpenGL function `ProgramUniform2ui`
type PFNGLPROGRAMUNIFORM2UIPROC = extern "system" fn(GLuint, GLint, GLuint, GLuint);

/// The prototype to the OpenGL function `ProgramUniform2uiv`
type PFNGLPROGRAMUNIFORM2UIVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLuint);

/// The prototype to the OpenGL function `ProgramUniform3i`
type PFNGLPROGRAMUNIFORM3IPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint);

/// The prototype to the OpenGL function `ProgramUniform3iv`
type PFNGLPROGRAMUNIFORM3IVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLint);

/// The prototype to the OpenGL function `ProgramUniform3f`
type PFNGLPROGRAMUNIFORM3FPROC = extern "system" fn(GLuint, GLint, GLfloat, GLfloat, GLfloat);

/// The prototype to the OpenGL function `ProgramUniform3fv`
type PFNGLPROGRAMUNIFORM3FVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat);

/// The prototype to the OpenGL function `ProgramUniform3d`
type PFNGLPROGRAMUNIFORM3DPROC = extern "system" fn(GLuint, GLint, GLdouble, GLdouble, GLdouble);

/// The prototype to the OpenGL function `ProgramUniform3dv`
type PFNGLPROGRAMUNIFORM3DVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLdouble);

/// The prototype to the OpenGL function `ProgramUniform3ui`
type PFNGLPROGRAMUNIFORM3UIPROC = extern "system" fn(GLuint, GLint, GLuint, GLuint, GLuint);

/// The prototype to the OpenGL function `ProgramUniform3uiv`
type PFNGLPROGRAMUNIFORM3UIVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLuint);

/// The prototype to the OpenGL function `ProgramUniform4i`
type PFNGLPROGRAMUNIFORM4IPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLint);

/// The prototype to the OpenGL function `ProgramUniform4iv`
type PFNGLPROGRAMUNIFORM4IVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLint);

/// The prototype to the OpenGL function `ProgramUniform4f`
type PFNGLPROGRAMUNIFORM4FPROC = extern "system" fn(GLuint, GLint, GLfloat, GLfloat, GLfloat, GLfloat);

/// The prototype to the OpenGL function `ProgramUniform4fv`
type PFNGLPROGRAMUNIFORM4FVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat);

/// The prototype to the OpenGL function `ProgramUniform4d`
type PFNGLPROGRAMUNIFORM4DPROC = extern "system" fn(GLuint, GLint, GLdouble, GLdouble, GLdouble, GLdouble);

/// The prototype to the OpenGL function `ProgramUniform4dv`
type PFNGLPROGRAMUNIFORM4DVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLdouble);

/// The prototype to the OpenGL function `ProgramUniform4ui`
type PFNGLPROGRAMUNIFORM4UIPROC = extern "system" fn(GLuint, GLint, GLuint, GLuint, GLuint, GLuint);

/// The prototype to the OpenGL function `ProgramUniform4uiv`
type PFNGLPROGRAMUNIFORM4UIVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLuint);

/// The prototype to the OpenGL function `ProgramUniformMatrix2fv`
type PFNGLPROGRAMUNIFORMMATRIX2FVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat);

/// The prototype to the OpenGL function `ProgramUniformMatrix3fv`
type PFNGLPROGRAMUNIFORMMATRIX3FVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat);

/// The prototype to the OpenGL function `ProgramUniformMatrix4fv`
type PFNGLPROGRAMUNIFORMMATRIX4FVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat);

/// The prototype to the OpenGL function `ProgramUniformMatrix2dv`
type PFNGLPROGRAMUNIFORMMATRIX2DVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble);

/// The prototype to the OpenGL function `ProgramUniformMatrix3dv`
type PFNGLPROGRAMUNIFORMMATRIX3DVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble);

/// The prototype to the OpenGL function `ProgramUniformMatrix4dv`
type PFNGLPROGRAMUNIFORMMATRIX4DVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble);

/// The prototype to the OpenGL function `ProgramUniformMatrix2x3fv`
type PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat);

/// The prototype to the OpenGL function `ProgramUniformMatrix3x2fv`
type PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat);

/// The prototype to the OpenGL function `ProgramUniformMatrix2x4fv`
type PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat);

/// The prototype to the OpenGL function `ProgramUniformMatrix4x2fv`
type PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat);

/// The prototype to the OpenGL function `ProgramUniformMatrix3x4fv`
type PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat);

/// The prototype to the OpenGL function `ProgramUniformMatrix4x3fv`
type PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat);

/// The prototype to the OpenGL function `ProgramUniformMatrix2x3dv`
type PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble);

/// The prototype to the OpenGL function `ProgramUniformMatrix3x2dv`
type PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble);

/// The prototype to the OpenGL function `ProgramUniformMatrix2x4dv`
type PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble);

/// The prototype to the OpenGL function `ProgramUniformMatrix4x2dv`
type PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble);

/// The prototype to the OpenGL function `ProgramUniformMatrix3x4dv`
type PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble);

/// The prototype to the OpenGL function `ProgramUniformMatrix4x3dv`
type PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble);

/// The prototype to the OpenGL function `ValidateProgramPipeline`
type PFNGLVALIDATEPROGRAMPIPELINEPROC = extern "system" fn(GLuint);

/// The prototype to the OpenGL function `GetProgramPipelineInfoLog`
type PFNGLGETPROGRAMPIPELINEINFOLOGPROC = extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar);

/// The prototype to the OpenGL function `VertexAttribL1d`
type PFNGLVERTEXATTRIBL1DPROC = extern "system" fn(GLuint, GLdouble);

/// The prototype to the OpenGL function `VertexAttribL2d`
type PFNGLVERTEXATTRIBL2DPROC = extern "system" fn(GLuint, GLdouble, GLdouble);

/// The prototype to the OpenGL function `VertexAttribL3d`
type PFNGLVERTEXATTRIBL3DPROC = extern "system" fn(GLuint, GLdouble, GLdouble, GLdouble);

/// The prototype to the OpenGL function `VertexAttribL4d`
type PFNGLVERTEXATTRIBL4DPROC = extern "system" fn(GLuint, GLdouble, GLdouble, GLdouble, GLdouble);

/// The prototype to the OpenGL function `VertexAttribL1dv`
type PFNGLVERTEXATTRIBL1DVPROC = extern "system" fn(GLuint, *const GLdouble);

/// The prototype to the OpenGL function `VertexAttribL2dv`
type PFNGLVERTEXATTRIBL2DVPROC = extern "system" fn(GLuint, *const GLdouble);

/// The prototype to the OpenGL function `VertexAttribL3dv`
type PFNGLVERTEXATTRIBL3DVPROC = extern "system" fn(GLuint, *const GLdouble);

/// The prototype to the OpenGL function `VertexAttribL4dv`
type PFNGLVERTEXATTRIBL4DVPROC = extern "system" fn(GLuint, *const GLdouble);

/// The prototype to the OpenGL function `VertexAttribLPointer`
type PFNGLVERTEXATTRIBLPOINTERPROC = extern "system" fn(GLuint, GLint, GLenum, GLsizei, *const c_void);

/// The prototype to the OpenGL function `GetVertexAttribLdv`
type PFNGLGETVERTEXATTRIBLDVPROC = extern "system" fn(GLuint, GLenum, *mut GLdouble);

/// The prototype to the OpenGL function `ViewportArrayv`
type PFNGLVIEWPORTARRAYVPROC = extern "system" fn(GLuint, GLsizei, *const GLfloat);

/// The prototype to the OpenGL function `ViewportIndexedf`
type PFNGLVIEWPORTINDEXEDFPROC = extern "system" fn(GLuint, GLfloat, GLfloat, GLfloat, GLfloat);

/// The prototype to the OpenGL function `ViewportIndexedfv`
type PFNGLVIEWPORTINDEXEDFVPROC = extern "system" fn(GLuint, *const GLfloat);

/// The prototype to the OpenGL function `ScissorArrayv`
type PFNGLSCISSORARRAYVPROC = extern "system" fn(GLuint, GLsizei, *const GLint);

/// The prototype to the OpenGL function `ScissorIndexed`
type PFNGLSCISSORINDEXEDPROC = extern "system" fn(GLuint, GLint, GLint, GLsizei, GLsizei);

/// The prototype to the OpenGL function `ScissorIndexedv`
type PFNGLSCISSORINDEXEDVPROC = extern "system" fn(GLuint, *const GLint);

/// The prototype to the OpenGL function `DepthRangeArrayv`
type PFNGLDEPTHRANGEARRAYVPROC = extern "system" fn(GLuint, GLsizei, *const GLdouble);

/// The prototype to the OpenGL function `DepthRangeIndexed`
type PFNGLDEPTHRANGEINDEXEDPROC = extern "system" fn(GLuint, GLdouble, GLdouble);

/// The prototype to the OpenGL function `GetFloati_v`
type PFNGLGETFLOATI_VPROC = extern "system" fn(GLenum, GLuint, *mut GLfloat);

/// The prototype to the OpenGL function `GetDoublei_v`
type PFNGLGETDOUBLEI_VPROC = extern "system" fn(GLenum, GLuint, *mut GLdouble);

/// The dummy function of `ReleaseShaderCompiler()`
extern "system" fn dummy_pfnglreleaseshadercompilerproc () {
	panic!("OpenGL function pointer `glReleaseShaderCompiler()` is null.")
}

/// The dummy function of `ShaderBinary()`
extern "system" fn dummy_pfnglshaderbinaryproc (_: GLsizei, _: *const GLuint, _: GLenum, _: *const c_void, _: GLsizei) {
	panic!("OpenGL function pointer `glShaderBinary()` is null.")
}

/// The dummy function of `GetShaderPrecisionFormat()`
extern "system" fn dummy_pfnglgetshaderprecisionformatproc (_: GLenum, _: GLenum, _: *mut GLint, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetShaderPrecisionFormat()` is null.")
}

/// The dummy function of `DepthRangef()`
extern "system" fn dummy_pfngldepthrangefproc (_: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glDepthRangef()` is null.")
}

/// The dummy function of `ClearDepthf()`
extern "system" fn dummy_pfnglcleardepthfproc (_: GLfloat) {
	panic!("OpenGL function pointer `glClearDepthf()` is null.")
}

/// The dummy function of `GetProgramBinary()`
extern "system" fn dummy_pfnglgetprogrambinaryproc (_: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLenum, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetProgramBinary()` is null.")
}

/// The dummy function of `ProgramBinary()`
extern "system" fn dummy_pfnglprogrambinaryproc (_: GLuint, _: GLenum, _: *const c_void, _: GLsizei) {
	panic!("OpenGL function pointer `glProgramBinary()` is null.")
}

/// The dummy function of `ProgramParameteri()`
extern "system" fn dummy_pfnglprogramparameteriproc (_: GLuint, _: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glProgramParameteri()` is null.")
}

/// The dummy function of `UseProgramStages()`
extern "system" fn dummy_pfngluseprogramstagesproc (_: GLuint, _: GLbitfield, _: GLuint) {
	panic!("OpenGL function pointer `glUseProgramStages()` is null.")
}

/// The dummy function of `ActiveShaderProgram()`
extern "system" fn dummy_pfnglactiveshaderprogramproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glActiveShaderProgram()` is null.")
}

/// The dummy function of `CreateShaderProgramv()`
extern "system" fn dummy_pfnglcreateshaderprogramvproc (_: GLenum, _: GLsizei, _: *const *const GLchar) -> GLuint {
	panic!("OpenGL function pointer `glCreateShaderProgramv()` is null.")
}

/// The dummy function of `BindProgramPipeline()`
extern "system" fn dummy_pfnglbindprogrampipelineproc (_: GLuint) {
	panic!("OpenGL function pointer `glBindProgramPipeline()` is null.")
}

/// The dummy function of `DeleteProgramPipelines()`
extern "system" fn dummy_pfngldeleteprogrampipelinesproc (_: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glDeleteProgramPipelines()` is null.")
}

/// The dummy function of `GenProgramPipelines()`
extern "system" fn dummy_pfnglgenprogrampipelinesproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGenProgramPipelines()` is null.")
}

/// The dummy function of `IsProgramPipeline()`
extern "system" fn dummy_pfnglisprogrampipelineproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsProgramPipeline()` is null.")
}

/// The dummy function of `GetProgramPipelineiv()`
extern "system" fn dummy_pfnglgetprogrampipelineivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetProgramPipelineiv()` is null.")
}

/// The dummy function of `ProgramUniform1i()`
extern "system" fn dummy_pfnglprogramuniform1iproc (_: GLuint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glProgramUniform1i()` is null.")
}

/// The dummy function of `ProgramUniform1iv()`
extern "system" fn dummy_pfnglprogramuniform1ivproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glProgramUniform1iv()` is null.")
}

/// The dummy function of `ProgramUniform1f()`
extern "system" fn dummy_pfnglprogramuniform1fproc (_: GLuint, _: GLint, _: GLfloat) {
	panic!("OpenGL function pointer `glProgramUniform1f()` is null.")
}

/// The dummy function of `ProgramUniform1fv()`
extern "system" fn dummy_pfnglprogramuniform1fvproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniform1fv()` is null.")
}

/// The dummy function of `ProgramUniform1d()`
extern "system" fn dummy_pfnglprogramuniform1dproc (_: GLuint, _: GLint, _: GLdouble) {
	panic!("OpenGL function pointer `glProgramUniform1d()` is null.")
}

/// The dummy function of `ProgramUniform1dv()`
extern "system" fn dummy_pfnglprogramuniform1dvproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniform1dv()` is null.")
}

/// The dummy function of `ProgramUniform1ui()`
extern "system" fn dummy_pfnglprogramuniform1uiproc (_: GLuint, _: GLint, _: GLuint) {
	panic!("OpenGL function pointer `glProgramUniform1ui()` is null.")
}

/// The dummy function of `ProgramUniform1uiv()`
extern "system" fn dummy_pfnglprogramuniform1uivproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glProgramUniform1uiv()` is null.")
}

/// The dummy function of `ProgramUniform2i()`
extern "system" fn dummy_pfnglprogramuniform2iproc (_: GLuint, _: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glProgramUniform2i()` is null.")
}

/// The dummy function of `ProgramUniform2iv()`
extern "system" fn dummy_pfnglprogramuniform2ivproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glProgramUniform2iv()` is null.")
}

/// The dummy function of `ProgramUniform2f()`
extern "system" fn dummy_pfnglprogramuniform2fproc (_: GLuint, _: GLint, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glProgramUniform2f()` is null.")
}

/// The dummy function of `ProgramUniform2fv()`
extern "system" fn dummy_pfnglprogramuniform2fvproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniform2fv()` is null.")
}

/// The dummy function of `ProgramUniform2d()`
extern "system" fn dummy_pfnglprogramuniform2dproc (_: GLuint, _: GLint, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glProgramUniform2d()` is null.")
}

/// The dummy function of `ProgramUniform2dv()`
extern "system" fn dummy_pfnglprogramuniform2dvproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniform2dv()` is null.")
}

/// The dummy function of `ProgramUniform2ui()`
extern "system" fn dummy_pfnglprogramuniform2uiproc (_: GLuint, _: GLint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glProgramUniform2ui()` is null.")
}

/// The dummy function of `ProgramUniform2uiv()`
extern "system" fn dummy_pfnglprogramuniform2uivproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glProgramUniform2uiv()` is null.")
}

/// The dummy function of `ProgramUniform3i()`
extern "system" fn dummy_pfnglprogramuniform3iproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glProgramUniform3i()` is null.")
}

/// The dummy function of `ProgramUniform3iv()`
extern "system" fn dummy_pfnglprogramuniform3ivproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glProgramUniform3iv()` is null.")
}

/// The dummy function of `ProgramUniform3f()`
extern "system" fn dummy_pfnglprogramuniform3fproc (_: GLuint, _: GLint, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glProgramUniform3f()` is null.")
}

/// The dummy function of `ProgramUniform3fv()`
extern "system" fn dummy_pfnglprogramuniform3fvproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniform3fv()` is null.")
}

/// The dummy function of `ProgramUniform3d()`
extern "system" fn dummy_pfnglprogramuniform3dproc (_: GLuint, _: GLint, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glProgramUniform3d()` is null.")
}

/// The dummy function of `ProgramUniform3dv()`
extern "system" fn dummy_pfnglprogramuniform3dvproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniform3dv()` is null.")
}

/// The dummy function of `ProgramUniform3ui()`
extern "system" fn dummy_pfnglprogramuniform3uiproc (_: GLuint, _: GLint, _: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glProgramUniform3ui()` is null.")
}

/// The dummy function of `ProgramUniform3uiv()`
extern "system" fn dummy_pfnglprogramuniform3uivproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glProgramUniform3uiv()` is null.")
}

/// The dummy function of `ProgramUniform4i()`
extern "system" fn dummy_pfnglprogramuniform4iproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glProgramUniform4i()` is null.")
}

/// The dummy function of `ProgramUniform4iv()`
extern "system" fn dummy_pfnglprogramuniform4ivproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glProgramUniform4iv()` is null.")
}

/// The dummy function of `ProgramUniform4f()`
extern "system" fn dummy_pfnglprogramuniform4fproc (_: GLuint, _: GLint, _: GLfloat, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glProgramUniform4f()` is null.")
}

/// The dummy function of `ProgramUniform4fv()`
extern "system" fn dummy_pfnglprogramuniform4fvproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniform4fv()` is null.")
}

/// The dummy function of `ProgramUniform4d()`
extern "system" fn dummy_pfnglprogramuniform4dproc (_: GLuint, _: GLint, _: GLdouble, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glProgramUniform4d()` is null.")
}

/// The dummy function of `ProgramUniform4dv()`
extern "system" fn dummy_pfnglprogramuniform4dvproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniform4dv()` is null.")
}

/// The dummy function of `ProgramUniform4ui()`
extern "system" fn dummy_pfnglprogramuniform4uiproc (_: GLuint, _: GLint, _: GLuint, _: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glProgramUniform4ui()` is null.")
}

/// The dummy function of `ProgramUniform4uiv()`
extern "system" fn dummy_pfnglprogramuniform4uivproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glProgramUniform4uiv()` is null.")
}

/// The dummy function of `ProgramUniformMatrix2fv()`
extern "system" fn dummy_pfnglprogramuniformmatrix2fvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniformMatrix2fv()` is null.")
}

/// The dummy function of `ProgramUniformMatrix3fv()`
extern "system" fn dummy_pfnglprogramuniformmatrix3fvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniformMatrix3fv()` is null.")
}

/// The dummy function of `ProgramUniformMatrix4fv()`
extern "system" fn dummy_pfnglprogramuniformmatrix4fvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniformMatrix4fv()` is null.")
}

/// The dummy function of `ProgramUniformMatrix2dv()`
extern "system" fn dummy_pfnglprogramuniformmatrix2dvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniformMatrix2dv()` is null.")
}

/// The dummy function of `ProgramUniformMatrix3dv()`
extern "system" fn dummy_pfnglprogramuniformmatrix3dvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniformMatrix3dv()` is null.")
}

/// The dummy function of `ProgramUniformMatrix4dv()`
extern "system" fn dummy_pfnglprogramuniformmatrix4dvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniformMatrix4dv()` is null.")
}

/// The dummy function of `ProgramUniformMatrix2x3fv()`
extern "system" fn dummy_pfnglprogramuniformmatrix2x3fvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniformMatrix2x3fv()` is null.")
}

/// The dummy function of `ProgramUniformMatrix3x2fv()`
extern "system" fn dummy_pfnglprogramuniformmatrix3x2fvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniformMatrix3x2fv()` is null.")
}

/// The dummy function of `ProgramUniformMatrix2x4fv()`
extern "system" fn dummy_pfnglprogramuniformmatrix2x4fvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniformMatrix2x4fv()` is null.")
}

/// The dummy function of `ProgramUniformMatrix4x2fv()`
extern "system" fn dummy_pfnglprogramuniformmatrix4x2fvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniformMatrix4x2fv()` is null.")
}

/// The dummy function of `ProgramUniformMatrix3x4fv()`
extern "system" fn dummy_pfnglprogramuniformmatrix3x4fvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniformMatrix3x4fv()` is null.")
}

/// The dummy function of `ProgramUniformMatrix4x3fv()`
extern "system" fn dummy_pfnglprogramuniformmatrix4x3fvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniformMatrix4x3fv()` is null.")
}

/// The dummy function of `ProgramUniformMatrix2x3dv()`
extern "system" fn dummy_pfnglprogramuniformmatrix2x3dvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniformMatrix2x3dv()` is null.")
}

/// The dummy function of `ProgramUniformMatrix3x2dv()`
extern "system" fn dummy_pfnglprogramuniformmatrix3x2dvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniformMatrix3x2dv()` is null.")
}

/// The dummy function of `ProgramUniformMatrix2x4dv()`
extern "system" fn dummy_pfnglprogramuniformmatrix2x4dvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniformMatrix2x4dv()` is null.")
}

/// The dummy function of `ProgramUniformMatrix4x2dv()`
extern "system" fn dummy_pfnglprogramuniformmatrix4x2dvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniformMatrix4x2dv()` is null.")
}

/// The dummy function of `ProgramUniformMatrix3x4dv()`
extern "system" fn dummy_pfnglprogramuniformmatrix3x4dvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniformMatrix3x4dv()` is null.")
}

/// The dummy function of `ProgramUniformMatrix4x3dv()`
extern "system" fn dummy_pfnglprogramuniformmatrix4x3dvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniformMatrix4x3dv()` is null.")
}

/// The dummy function of `ValidateProgramPipeline()`
extern "system" fn dummy_pfnglvalidateprogrampipelineproc (_: GLuint) {
	panic!("OpenGL function pointer `glValidateProgramPipeline()` is null.")
}

/// The dummy function of `GetProgramPipelineInfoLog()`
extern "system" fn dummy_pfnglgetprogrampipelineinfologproc (_: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetProgramPipelineInfoLog()` is null.")
}

/// The dummy function of `VertexAttribL1d()`
extern "system" fn dummy_pfnglvertexattribl1dproc (_: GLuint, _: GLdouble) {
	panic!("OpenGL function pointer `glVertexAttribL1d()` is null.")
}

/// The dummy function of `VertexAttribL2d()`
extern "system" fn dummy_pfnglvertexattribl2dproc (_: GLuint, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glVertexAttribL2d()` is null.")
}

/// The dummy function of `VertexAttribL3d()`
extern "system" fn dummy_pfnglvertexattribl3dproc (_: GLuint, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glVertexAttribL3d()` is null.")
}

/// The dummy function of `VertexAttribL4d()`
extern "system" fn dummy_pfnglvertexattribl4dproc (_: GLuint, _: GLdouble, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glVertexAttribL4d()` is null.")
}

/// The dummy function of `VertexAttribL1dv()`
extern "system" fn dummy_pfnglvertexattribl1dvproc (_: GLuint, _: *const GLdouble) {
	panic!("OpenGL function pointer `glVertexAttribL1dv()` is null.")
}

/// The dummy function of `VertexAttribL2dv()`
extern "system" fn dummy_pfnglvertexattribl2dvproc (_: GLuint, _: *const GLdouble) {
	panic!("OpenGL function pointer `glVertexAttribL2dv()` is null.")
}

/// The dummy function of `VertexAttribL3dv()`
extern "system" fn dummy_pfnglvertexattribl3dvproc (_: GLuint, _: *const GLdouble) {
	panic!("OpenGL function pointer `glVertexAttribL3dv()` is null.")
}

/// The dummy function of `VertexAttribL4dv()`
extern "system" fn dummy_pfnglvertexattribl4dvproc (_: GLuint, _: *const GLdouble) {
	panic!("OpenGL function pointer `glVertexAttribL4dv()` is null.")
}

/// The dummy function of `VertexAttribLPointer()`
extern "system" fn dummy_pfnglvertexattriblpointerproc (_: GLuint, _: GLint, _: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glVertexAttribLPointer()` is null.")
}

/// The dummy function of `GetVertexAttribLdv()`
extern "system" fn dummy_pfnglgetvertexattribldvproc (_: GLuint, _: GLenum, _: *mut GLdouble) {
	panic!("OpenGL function pointer `glGetVertexAttribLdv()` is null.")
}

/// The dummy function of `ViewportArrayv()`
extern "system" fn dummy_pfnglviewportarrayvproc (_: GLuint, _: GLsizei, _: *const GLfloat) {
	panic!("OpenGL function pointer `glViewportArrayv()` is null.")
}

/// The dummy function of `ViewportIndexedf()`
extern "system" fn dummy_pfnglviewportindexedfproc (_: GLuint, _: GLfloat, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glViewportIndexedf()` is null.")
}

/// The dummy function of `ViewportIndexedfv()`
extern "system" fn dummy_pfnglviewportindexedfvproc (_: GLuint, _: *const GLfloat) {
	panic!("OpenGL function pointer `glViewportIndexedfv()` is null.")
}

/// The dummy function of `ScissorArrayv()`
extern "system" fn dummy_pfnglscissorarrayvproc (_: GLuint, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glScissorArrayv()` is null.")
}

/// The dummy function of `ScissorIndexed()`
extern "system" fn dummy_pfnglscissorindexedproc (_: GLuint, _: GLint, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glScissorIndexed()` is null.")
}

/// The dummy function of `ScissorIndexedv()`
extern "system" fn dummy_pfnglscissorindexedvproc (_: GLuint, _: *const GLint) {
	panic!("OpenGL function pointer `glScissorIndexedv()` is null.")
}

/// The dummy function of `DepthRangeArrayv()`
extern "system" fn dummy_pfngldepthrangearrayvproc (_: GLuint, _: GLsizei, _: *const GLdouble) {
	panic!("OpenGL function pointer `glDepthRangeArrayv()` is null.")
}

/// The dummy function of `DepthRangeIndexed()`
extern "system" fn dummy_pfngldepthrangeindexedproc (_: GLuint, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glDepthRangeIndexed()` is null.")
}

/// The dummy function of `GetFloati_v()`
extern "system" fn dummy_pfnglgetfloati_vproc (_: GLenum, _: GLuint, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetFloati_v()` is null.")
}

/// The dummy function of `GetDoublei_v()`
extern "system" fn dummy_pfnglgetdoublei_vproc (_: GLenum, _: GLuint, _: *mut GLdouble) {
	panic!("OpenGL function pointer `glGetDoublei_v()` is null.")
}
/// Constant value defined from OpenGL 4.1
pub const GL_FIXED: GLenum = 0x140C;

/// Constant value defined from OpenGL 4.1
pub const GL_IMPLEMENTATION_COLOR_READ_TYPE: GLenum = 0x8B9A;

/// Constant value defined from OpenGL 4.1
pub const GL_IMPLEMENTATION_COLOR_READ_FORMAT: GLenum = 0x8B9B;

/// Constant value defined from OpenGL 4.1
pub const GL_LOW_FLOAT: GLenum = 0x8DF0;

/// Constant value defined from OpenGL 4.1
pub const GL_MEDIUM_FLOAT: GLenum = 0x8DF1;

/// Constant value defined from OpenGL 4.1
pub const GL_HIGH_FLOAT: GLenum = 0x8DF2;

/// Constant value defined from OpenGL 4.1
pub const GL_LOW_INT: GLenum = 0x8DF3;

/// Constant value defined from OpenGL 4.1
pub const GL_MEDIUM_INT: GLenum = 0x8DF4;

/// Constant value defined from OpenGL 4.1
pub const GL_HIGH_INT: GLenum = 0x8DF5;

/// Constant value defined from OpenGL 4.1
pub const GL_SHADER_COMPILER: GLenum = 0x8DFA;

/// Constant value defined from OpenGL 4.1
pub const GL_SHADER_BINARY_FORMATS: GLenum = 0x8DF8;

/// Constant value defined from OpenGL 4.1
pub const GL_NUM_SHADER_BINARY_FORMATS: GLenum = 0x8DF9;

/// Constant value defined from OpenGL 4.1
pub const GL_MAX_VERTEX_UNIFORM_VECTORS: GLenum = 0x8DFB;

/// Constant value defined from OpenGL 4.1
pub const GL_MAX_VARYING_VECTORS: GLenum = 0x8DFC;

/// Constant value defined from OpenGL 4.1
pub const GL_MAX_FRAGMENT_UNIFORM_VECTORS: GLenum = 0x8DFD;

/// Constant value defined from OpenGL 4.1
pub const GL_RGB565: GLenum = 0x8D62;

/// Constant value defined from OpenGL 4.1
pub const GL_PROGRAM_BINARY_RETRIEVABLE_HINT: GLenum = 0x8257;

/// Constant value defined from OpenGL 4.1
pub const GL_PROGRAM_BINARY_LENGTH: GLenum = 0x8741;

/// Constant value defined from OpenGL 4.1
pub const GL_NUM_PROGRAM_BINARY_FORMATS: GLenum = 0x87FE;

/// Constant value defined from OpenGL 4.1
pub const GL_PROGRAM_BINARY_FORMATS: GLenum = 0x87FF;

/// Constant value defined from OpenGL 4.1
pub const GL_VERTEX_SHADER_BIT: GLbitfield = 0x00000001;

/// Constant value defined from OpenGL 4.1
pub const GL_FRAGMENT_SHADER_BIT: GLbitfield = 0x00000002;

/// Constant value defined from OpenGL 4.1
pub const GL_GEOMETRY_SHADER_BIT: GLbitfield = 0x00000004;

/// Constant value defined from OpenGL 4.1
pub const GL_TESS_CONTROL_SHADER_BIT: GLbitfield = 0x00000008;

/// Constant value defined from OpenGL 4.1
pub const GL_TESS_EVALUATION_SHADER_BIT: GLbitfield = 0x00000010;

/// Constant value defined from OpenGL 4.1
pub const GL_ALL_SHADER_BITS: GLbitfield = 0xFFFFFFFF;

/// Constant value defined from OpenGL 4.1
pub const GL_PROGRAM_SEPARABLE: GLenum = 0x8258;

/// Constant value defined from OpenGL 4.1
pub const GL_ACTIVE_PROGRAM: GLenum = 0x8259;

/// Constant value defined from OpenGL 4.1
pub const GL_PROGRAM_PIPELINE_BINDING: GLenum = 0x825A;

/// Constant value defined from OpenGL 4.1
pub const GL_MAX_VIEWPORTS: GLenum = 0x825B;

/// Constant value defined from OpenGL 4.1
pub const GL_VIEWPORT_SUBPIXEL_BITS: GLenum = 0x825C;

/// Constant value defined from OpenGL 4.1
pub const GL_VIEWPORT_BOUNDS_RANGE: GLenum = 0x825D;

/// Constant value defined from OpenGL 4.1
pub const GL_LAYER_PROVOKING_VERTEX: GLenum = 0x825E;

/// Constant value defined from OpenGL 4.1
pub const GL_VIEWPORT_INDEX_PROVOKING_VERTEX: GLenum = 0x825F;

/// Constant value defined from OpenGL 4.1
pub const GL_UNDEFINED_VERTEX: GLenum = 0x8260;

/// Functions from OpenGL version 4.1
pub trait GL_4_1 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	fn glGetError(&self) -> GLenum;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glReleaseShaderCompiler.xhtml>
	fn glReleaseShaderCompiler(&self) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glShaderBinary.xhtml>
	fn glShaderBinary(&self, count: GLsizei, shaders: *const GLuint, binaryFormat: GLenum, binary: *const c_void, length: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShaderPrecisionFormat.xhtml>
	fn glGetShaderPrecisionFormat(&self, shadertype: GLenum, precisiontype: GLenum, range: *mut GLint, precision: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDepthRangef.xhtml>
	fn glDepthRangef(&self, n: GLfloat, f: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearDepthf.xhtml>
	fn glClearDepthf(&self, d: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramBinary.xhtml>
	fn glGetProgramBinary(&self, program: GLuint, bufSize: GLsizei, length: *mut GLsizei, binaryFormat: *mut GLenum, binary: *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramBinary.xhtml>
	fn glProgramBinary(&self, program: GLuint, binaryFormat: GLenum, binary: *const c_void, length: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramParameteri.xhtml>
	fn glProgramParameteri(&self, program: GLuint, pname: GLenum, value: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUseProgramStages.xhtml>
	fn glUseProgramStages(&self, pipeline: GLuint, stages: GLbitfield, program: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glActiveShaderProgram.xhtml>
	fn glActiveShaderProgram(&self, pipeline: GLuint, program: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateShaderProgramv.xhtml>
	fn glCreateShaderProgramv(&self, type_: GLenum, count: GLsizei, strings: *const *const GLchar) -> Result<GLuint>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindProgramPipeline.xhtml>
	fn glBindProgramPipeline(&self, pipeline: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteProgramPipelines.xhtml>
	fn glDeleteProgramPipelines(&self, n: GLsizei, pipelines: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenProgramPipelines.xhtml>
	fn glGenProgramPipelines(&self, n: GLsizei, pipelines: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsProgramPipeline.xhtml>
	fn glIsProgramPipeline(&self, pipeline: GLuint) -> Result<GLboolean>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramPipelineiv.xhtml>
	fn glGetProgramPipelineiv(&self, pipeline: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1i.xhtml>
	fn glProgramUniform1i(&self, program: GLuint, location: GLint, v0: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1iv.xhtml>
	fn glProgramUniform1iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1f.xhtml>
	fn glProgramUniform1f(&self, program: GLuint, location: GLint, v0: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1fv.xhtml>
	fn glProgramUniform1fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1d.xhtml>
	fn glProgramUniform1d(&self, program: GLuint, location: GLint, v0: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1dv.xhtml>
	fn glProgramUniform1dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1ui.xhtml>
	fn glProgramUniform1ui(&self, program: GLuint, location: GLint, v0: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1uiv.xhtml>
	fn glProgramUniform1uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2i.xhtml>
	fn glProgramUniform2i(&self, program: GLuint, location: GLint, v0: GLint, v1: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2iv.xhtml>
	fn glProgramUniform2iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2f.xhtml>
	fn glProgramUniform2f(&self, program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2fv.xhtml>
	fn glProgramUniform2fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2d.xhtml>
	fn glProgramUniform2d(&self, program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2dv.xhtml>
	fn glProgramUniform2dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2ui.xhtml>
	fn glProgramUniform2ui(&self, program: GLuint, location: GLint, v0: GLuint, v1: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2uiv.xhtml>
	fn glProgramUniform2uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3i.xhtml>
	fn glProgramUniform3i(&self, program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3iv.xhtml>
	fn glProgramUniform3iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3f.xhtml>
	fn glProgramUniform3f(&self, program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3fv.xhtml>
	fn glProgramUniform3fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3d.xhtml>
	fn glProgramUniform3d(&self, program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3dv.xhtml>
	fn glProgramUniform3dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3ui.xhtml>
	fn glProgramUniform3ui(&self, program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3uiv.xhtml>
	fn glProgramUniform3uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4i.xhtml>
	fn glProgramUniform4i(&self, program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4iv.xhtml>
	fn glProgramUniform4iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4f.xhtml>
	fn glProgramUniform4f(&self, program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4fv.xhtml>
	fn glProgramUniform4fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4d.xhtml>
	fn glProgramUniform4d(&self, program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble, v3: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4dv.xhtml>
	fn glProgramUniform4dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4ui.xhtml>
	fn glProgramUniform4ui(&self, program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4uiv.xhtml>
	fn glProgramUniform4uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix2fv.xhtml>
	fn glProgramUniformMatrix2fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix3fv.xhtml>
	fn glProgramUniformMatrix3fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix4fv.xhtml>
	fn glProgramUniformMatrix4fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix2dv.xhtml>
	fn glProgramUniformMatrix2dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix3dv.xhtml>
	fn glProgramUniformMatrix3dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix4dv.xhtml>
	fn glProgramUniformMatrix4dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix2x3fv.xhtml>
	fn glProgramUniformMatrix2x3fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix3x2fv.xhtml>
	fn glProgramUniformMatrix3x2fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix2x4fv.xhtml>
	fn glProgramUniformMatrix2x4fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix4x2fv.xhtml>
	fn glProgramUniformMatrix4x2fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix3x4fv.xhtml>
	fn glProgramUniformMatrix3x4fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix4x3fv.xhtml>
	fn glProgramUniformMatrix4x3fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix2x3dv.xhtml>
	fn glProgramUniformMatrix2x3dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix3x2dv.xhtml>
	fn glProgramUniformMatrix3x2dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix2x4dv.xhtml>
	fn glProgramUniformMatrix2x4dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix4x2dv.xhtml>
	fn glProgramUniformMatrix4x2dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix3x4dv.xhtml>
	fn glProgramUniformMatrix3x4dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix4x3dv.xhtml>
	fn glProgramUniformMatrix4x3dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glValidateProgramPipeline.xhtml>
	fn glValidateProgramPipeline(&self, pipeline: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramPipelineInfoLog.xhtml>
	fn glGetProgramPipelineInfoLog(&self, pipeline: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL1d.xhtml>
	fn glVertexAttribL1d(&self, index: GLuint, x: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL2d.xhtml>
	fn glVertexAttribL2d(&self, index: GLuint, x: GLdouble, y: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL3d.xhtml>
	fn glVertexAttribL3d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL4d.xhtml>
	fn glVertexAttribL4d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL1dv.xhtml>
	fn glVertexAttribL1dv(&self, index: GLuint, v: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL2dv.xhtml>
	fn glVertexAttribL2dv(&self, index: GLuint, v: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL3dv.xhtml>
	fn glVertexAttribL3dv(&self, index: GLuint, v: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL4dv.xhtml>
	fn glVertexAttribL4dv(&self, index: GLuint, v: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribLPointer.xhtml>
	fn glVertexAttribLPointer(&self, index: GLuint, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribLdv.xhtml>
	fn glGetVertexAttribLdv(&self, index: GLuint, pname: GLenum, params: *mut GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glViewportArrayv.xhtml>
	fn glViewportArrayv(&self, first: GLuint, count: GLsizei, v: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glViewportIndexedf.xhtml>
	fn glViewportIndexedf(&self, index: GLuint, x: GLfloat, y: GLfloat, w: GLfloat, h: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glViewportIndexedfv.xhtml>
	fn glViewportIndexedfv(&self, index: GLuint, v: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glScissorArrayv.xhtml>
	fn glScissorArrayv(&self, first: GLuint, count: GLsizei, v: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml>
	fn glScissorIndexed(&self, index: GLuint, left: GLint, bottom: GLint, width: GLsizei, height: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glScissorIndexedv.xhtml>
	fn glScissorIndexedv(&self, index: GLuint, v: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDepthRangeArrayv.xhtml>
	fn glDepthRangeArrayv(&self, first: GLuint, count: GLsizei, v: *const GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDepthRangeIndexed.xhtml>
	fn glDepthRangeIndexed(&self, index: GLuint, n: GLdouble, f: GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetFloati_v.xhtml>
	fn glGetFloati_v(&self, target: GLenum, index: GLuint, data: *mut GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetDoublei_v.xhtml>
	fn glGetDoublei_v(&self, target: GLenum, index: GLuint, data: *mut GLdouble) -> Result<()>;
}
/// Functions from OpenGL version 4.1
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version41 {
	/// Is OpenGL version 4.1 available
	available: bool,

	/// The function pointer to `glGetError()`
	pub geterror: PFNGLGETERRORPROC,

	/// The function pointer to `glReleaseShaderCompiler()`
	pub releaseshadercompiler: PFNGLRELEASESHADERCOMPILERPROC,

	/// The function pointer to `glShaderBinary()`
	pub shaderbinary: PFNGLSHADERBINARYPROC,

	/// The function pointer to `glGetShaderPrecisionFormat()`
	pub getshaderprecisionformat: PFNGLGETSHADERPRECISIONFORMATPROC,

	/// The function pointer to `glDepthRangef()`
	pub depthrangef: PFNGLDEPTHRANGEFPROC,

	/// The function pointer to `glClearDepthf()`
	pub cleardepthf: PFNGLCLEARDEPTHFPROC,

	/// The function pointer to `glGetProgramBinary()`
	pub getprogrambinary: PFNGLGETPROGRAMBINARYPROC,

	/// The function pointer to `glProgramBinary()`
	pub programbinary: PFNGLPROGRAMBINARYPROC,

	/// The function pointer to `glProgramParameteri()`
	pub programparameteri: PFNGLPROGRAMPARAMETERIPROC,

	/// The function pointer to `glUseProgramStages()`
	pub useprogramstages: PFNGLUSEPROGRAMSTAGESPROC,

	/// The function pointer to `glActiveShaderProgram()`
	pub activeshaderprogram: PFNGLACTIVESHADERPROGRAMPROC,

	/// The function pointer to `glCreateShaderProgramv()`
	pub createshaderprogramv: PFNGLCREATESHADERPROGRAMVPROC,

	/// The function pointer to `glBindProgramPipeline()`
	pub bindprogrampipeline: PFNGLBINDPROGRAMPIPELINEPROC,

	/// The function pointer to `glDeleteProgramPipelines()`
	pub deleteprogrampipelines: PFNGLDELETEPROGRAMPIPELINESPROC,

	/// The function pointer to `glGenProgramPipelines()`
	pub genprogrampipelines: PFNGLGENPROGRAMPIPELINESPROC,

	/// The function pointer to `glIsProgramPipeline()`
	pub isprogrampipeline: PFNGLISPROGRAMPIPELINEPROC,

	/// The function pointer to `glGetProgramPipelineiv()`
	pub getprogrampipelineiv: PFNGLGETPROGRAMPIPELINEIVPROC,

	/// The function pointer to `glProgramUniform1i()`
	pub programuniform1i: PFNGLPROGRAMUNIFORM1IPROC,

	/// The function pointer to `glProgramUniform1iv()`
	pub programuniform1iv: PFNGLPROGRAMUNIFORM1IVPROC,

	/// The function pointer to `glProgramUniform1f()`
	pub programuniform1f: PFNGLPROGRAMUNIFORM1FPROC,

	/// The function pointer to `glProgramUniform1fv()`
	pub programuniform1fv: PFNGLPROGRAMUNIFORM1FVPROC,

	/// The function pointer to `glProgramUniform1d()`
	pub programuniform1d: PFNGLPROGRAMUNIFORM1DPROC,

	/// The function pointer to `glProgramUniform1dv()`
	pub programuniform1dv: PFNGLPROGRAMUNIFORM1DVPROC,

	/// The function pointer to `glProgramUniform1ui()`
	pub programuniform1ui: PFNGLPROGRAMUNIFORM1UIPROC,

	/// The function pointer to `glProgramUniform1uiv()`
	pub programuniform1uiv: PFNGLPROGRAMUNIFORM1UIVPROC,

	/// The function pointer to `glProgramUniform2i()`
	pub programuniform2i: PFNGLPROGRAMUNIFORM2IPROC,

	/// The function pointer to `glProgramUniform2iv()`
	pub programuniform2iv: PFNGLPROGRAMUNIFORM2IVPROC,

	/// The function pointer to `glProgramUniform2f()`
	pub programuniform2f: PFNGLPROGRAMUNIFORM2FPROC,

	/// The function pointer to `glProgramUniform2fv()`
	pub programuniform2fv: PFNGLPROGRAMUNIFORM2FVPROC,

	/// The function pointer to `glProgramUniform2d()`
	pub programuniform2d: PFNGLPROGRAMUNIFORM2DPROC,

	/// The function pointer to `glProgramUniform2dv()`
	pub programuniform2dv: PFNGLPROGRAMUNIFORM2DVPROC,

	/// The function pointer to `glProgramUniform2ui()`
	pub programuniform2ui: PFNGLPROGRAMUNIFORM2UIPROC,

	/// The function pointer to `glProgramUniform2uiv()`
	pub programuniform2uiv: PFNGLPROGRAMUNIFORM2UIVPROC,

	/// The function pointer to `glProgramUniform3i()`
	pub programuniform3i: PFNGLPROGRAMUNIFORM3IPROC,

	/// The function pointer to `glProgramUniform3iv()`
	pub programuniform3iv: PFNGLPROGRAMUNIFORM3IVPROC,

	/// The function pointer to `glProgramUniform3f()`
	pub programuniform3f: PFNGLPROGRAMUNIFORM3FPROC,

	/// The function pointer to `glProgramUniform3fv()`
	pub programuniform3fv: PFNGLPROGRAMUNIFORM3FVPROC,

	/// The function pointer to `glProgramUniform3d()`
	pub programuniform3d: PFNGLPROGRAMUNIFORM3DPROC,

	/// The function pointer to `glProgramUniform3dv()`
	pub programuniform3dv: PFNGLPROGRAMUNIFORM3DVPROC,

	/// The function pointer to `glProgramUniform3ui()`
	pub programuniform3ui: PFNGLPROGRAMUNIFORM3UIPROC,

	/// The function pointer to `glProgramUniform3uiv()`
	pub programuniform3uiv: PFNGLPROGRAMUNIFORM3UIVPROC,

	/// The function pointer to `glProgramUniform4i()`
	pub programuniform4i: PFNGLPROGRAMUNIFORM4IPROC,

	/// The function pointer to `glProgramUniform4iv()`
	pub programuniform4iv: PFNGLPROGRAMUNIFORM4IVPROC,

	/// The function pointer to `glProgramUniform4f()`
	pub programuniform4f: PFNGLPROGRAMUNIFORM4FPROC,

	/// The function pointer to `glProgramUniform4fv()`
	pub programuniform4fv: PFNGLPROGRAMUNIFORM4FVPROC,

	/// The function pointer to `glProgramUniform4d()`
	pub programuniform4d: PFNGLPROGRAMUNIFORM4DPROC,

	/// The function pointer to `glProgramUniform4dv()`
	pub programuniform4dv: PFNGLPROGRAMUNIFORM4DVPROC,

	/// The function pointer to `glProgramUniform4ui()`
	pub programuniform4ui: PFNGLPROGRAMUNIFORM4UIPROC,

	/// The function pointer to `glProgramUniform4uiv()`
	pub programuniform4uiv: PFNGLPROGRAMUNIFORM4UIVPROC,

	/// The function pointer to `glProgramUniformMatrix2fv()`
	pub programuniformmatrix2fv: PFNGLPROGRAMUNIFORMMATRIX2FVPROC,

	/// The function pointer to `glProgramUniformMatrix3fv()`
	pub programuniformmatrix3fv: PFNGLPROGRAMUNIFORMMATRIX3FVPROC,

	/// The function pointer to `glProgramUniformMatrix4fv()`
	pub programuniformmatrix4fv: PFNGLPROGRAMUNIFORMMATRIX4FVPROC,

	/// The function pointer to `glProgramUniformMatrix2dv()`
	pub programuniformmatrix2dv: PFNGLPROGRAMUNIFORMMATRIX2DVPROC,

	/// The function pointer to `glProgramUniformMatrix3dv()`
	pub programuniformmatrix3dv: PFNGLPROGRAMUNIFORMMATRIX3DVPROC,

	/// The function pointer to `glProgramUniformMatrix4dv()`
	pub programuniformmatrix4dv: PFNGLPROGRAMUNIFORMMATRIX4DVPROC,

	/// The function pointer to `glProgramUniformMatrix2x3fv()`
	pub programuniformmatrix2x3fv: PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC,

	/// The function pointer to `glProgramUniformMatrix3x2fv()`
	pub programuniformmatrix3x2fv: PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC,

	/// The function pointer to `glProgramUniformMatrix2x4fv()`
	pub programuniformmatrix2x4fv: PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC,

	/// The function pointer to `glProgramUniformMatrix4x2fv()`
	pub programuniformmatrix4x2fv: PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC,

	/// The function pointer to `glProgramUniformMatrix3x4fv()`
	pub programuniformmatrix3x4fv: PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC,

	/// The function pointer to `glProgramUniformMatrix4x3fv()`
	pub programuniformmatrix4x3fv: PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC,

	/// The function pointer to `glProgramUniformMatrix2x3dv()`
	pub programuniformmatrix2x3dv: PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC,

	/// The function pointer to `glProgramUniformMatrix3x2dv()`
	pub programuniformmatrix3x2dv: PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC,

	/// The function pointer to `glProgramUniformMatrix2x4dv()`
	pub programuniformmatrix2x4dv: PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC,

	/// The function pointer to `glProgramUniformMatrix4x2dv()`
	pub programuniformmatrix4x2dv: PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC,

	/// The function pointer to `glProgramUniformMatrix3x4dv()`
	pub programuniformmatrix3x4dv: PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC,

	/// The function pointer to `glProgramUniformMatrix4x3dv()`
	pub programuniformmatrix4x3dv: PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC,

	/// The function pointer to `glValidateProgramPipeline()`
	pub validateprogrampipeline: PFNGLVALIDATEPROGRAMPIPELINEPROC,

	/// The function pointer to `glGetProgramPipelineInfoLog()`
	pub getprogrampipelineinfolog: PFNGLGETPROGRAMPIPELINEINFOLOGPROC,

	/// The function pointer to `glVertexAttribL1d()`
	pub vertexattribl1d: PFNGLVERTEXATTRIBL1DPROC,

	/// The function pointer to `glVertexAttribL2d()`
	pub vertexattribl2d: PFNGLVERTEXATTRIBL2DPROC,

	/// The function pointer to `glVertexAttribL3d()`
	pub vertexattribl3d: PFNGLVERTEXATTRIBL3DPROC,

	/// The function pointer to `glVertexAttribL4d()`
	pub vertexattribl4d: PFNGLVERTEXATTRIBL4DPROC,

	/// The function pointer to `glVertexAttribL1dv()`
	pub vertexattribl1dv: PFNGLVERTEXATTRIBL1DVPROC,

	/// The function pointer to `glVertexAttribL2dv()`
	pub vertexattribl2dv: PFNGLVERTEXATTRIBL2DVPROC,

	/// The function pointer to `glVertexAttribL3dv()`
	pub vertexattribl3dv: PFNGLVERTEXATTRIBL3DVPROC,

	/// The function pointer to `glVertexAttribL4dv()`
	pub vertexattribl4dv: PFNGLVERTEXATTRIBL4DVPROC,

	/// The function pointer to `glVertexAttribLPointer()`
	pub vertexattriblpointer: PFNGLVERTEXATTRIBLPOINTERPROC,

	/// The function pointer to `glGetVertexAttribLdv()`
	pub getvertexattribldv: PFNGLGETVERTEXATTRIBLDVPROC,

	/// The function pointer to `glViewportArrayv()`
	pub viewportarrayv: PFNGLVIEWPORTARRAYVPROC,

	/// The function pointer to `glViewportIndexedf()`
	pub viewportindexedf: PFNGLVIEWPORTINDEXEDFPROC,

	/// The function pointer to `glViewportIndexedfv()`
	pub viewportindexedfv: PFNGLVIEWPORTINDEXEDFVPROC,

	/// The function pointer to `glScissorArrayv()`
	pub scissorarrayv: PFNGLSCISSORARRAYVPROC,

	/// The function pointer to `glScissorIndexed()`
	pub scissorindexed: PFNGLSCISSORINDEXEDPROC,

	/// The function pointer to `glScissorIndexedv()`
	pub scissorindexedv: PFNGLSCISSORINDEXEDVPROC,

	/// The function pointer to `glDepthRangeArrayv()`
	pub depthrangearrayv: PFNGLDEPTHRANGEARRAYVPROC,

	/// The function pointer to `glDepthRangeIndexed()`
	pub depthrangeindexed: PFNGLDEPTHRANGEINDEXEDPROC,

	/// The function pointer to `glGetFloati_v()`
	pub getfloati_v: PFNGLGETFLOATI_VPROC,

	/// The function pointer to `glGetDoublei_v()`
	pub getdoublei_v: PFNGLGETDOUBLEI_VPROC,
}

impl GL_4_1 for Version41 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glReleaseShaderCompiler.xhtml>
	#[inline(always)]
	fn glReleaseShaderCompiler(&self) -> Result<()> {
		let ret = process_catch("glReleaseShaderCompiler", catch_unwind(||(self.releaseshadercompiler)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glReleaseShaderCompiler", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glShaderBinary.xhtml>
	#[inline(always)]
	fn glShaderBinary(&self, count: GLsizei, shaders: *const GLuint, binaryFormat: GLenum, binary: *const c_void, length: GLsizei) -> Result<()> {
		let ret = process_catch("glShaderBinary", catch_unwind(||(self.shaderbinary)(count, shaders, binaryFormat, binary, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glShaderBinary", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShaderPrecisionFormat.xhtml>
	#[inline(always)]
	fn glGetShaderPrecisionFormat(&self, shadertype: GLenum, precisiontype: GLenum, range: *mut GLint, precision: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetShaderPrecisionFormat", catch_unwind(||(self.getshaderprecisionformat)(shadertype, precisiontype, range, precision)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetShaderPrecisionFormat", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDepthRangef.xhtml>
	#[inline(always)]
	fn glDepthRangef(&self, n: GLfloat, f: GLfloat) -> Result<()> {
		let ret = process_catch("glDepthRangef", catch_unwind(||(self.depthrangef)(n, f)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthRangef", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearDepthf.xhtml>
	#[inline(always)]
	fn glClearDepthf(&self, d: GLfloat) -> Result<()> {
		let ret = process_catch("glClearDepthf", catch_unwind(||(self.cleardepthf)(d)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearDepthf", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramBinary.xhtml>
	#[inline(always)]
	fn glGetProgramBinary(&self, program: GLuint, bufSize: GLsizei, length: *mut GLsizei, binaryFormat: *mut GLenum, binary: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetProgramBinary", catch_unwind(||(self.getprogrambinary)(program, bufSize, length, binaryFormat, binary)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramBinary", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramBinary.xhtml>
	#[inline(always)]
	fn glProgramBinary(&self, program: GLuint, binaryFormat: GLenum, binary: *const c_void, length: GLsizei) -> Result<()> {
		let ret = process_catch("glProgramBinary", catch_unwind(||(self.programbinary)(program, binaryFormat, binary, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramBinary", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramParameteri.xhtml>
	#[inline(always)]
	fn glProgramParameteri(&self, program: GLuint, pname: GLenum, value: GLint) -> Result<()> {
		let ret = process_catch("glProgramParameteri", catch_unwind(||(self.programparameteri)(program, pname, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramParameteri", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUseProgramStages.xhtml>
	#[inline(always)]
	fn glUseProgramStages(&self, pipeline: GLuint, stages: GLbitfield, program: GLuint) -> Result<()> {
		let ret = process_catch("glUseProgramStages", catch_unwind(||(self.useprogramstages)(pipeline, stages, program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUseProgramStages", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glActiveShaderProgram.xhtml>
	#[inline(always)]
	fn glActiveShaderProgram(&self, pipeline: GLuint, program: GLuint) -> Result<()> {
		let ret = process_catch("glActiveShaderProgram", catch_unwind(||(self.activeshaderprogram)(pipeline, program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glActiveShaderProgram", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateShaderProgramv.xhtml>
	#[inline(always)]
	fn glCreateShaderProgramv(&self, type_: GLenum, count: GLsizei, strings: *const *const GLchar) -> Result<GLuint> {
		let ret = process_catch("glCreateShaderProgramv", catch_unwind(||(self.createshaderprogramv)(type_, count, strings)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateShaderProgramv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindProgramPipeline.xhtml>
	#[inline(always)]
	fn glBindProgramPipeline(&self, pipeline: GLuint) -> Result<()> {
		let ret = process_catch("glBindProgramPipeline", catch_unwind(||(self.bindprogrampipeline)(pipeline)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindProgramPipeline", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteProgramPipelines.xhtml>
	#[inline(always)]
	fn glDeleteProgramPipelines(&self, n: GLsizei, pipelines: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteProgramPipelines", catch_unwind(||(self.deleteprogrampipelines)(n, pipelines)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteProgramPipelines", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenProgramPipelines.xhtml>
	#[inline(always)]
	fn glGenProgramPipelines(&self, n: GLsizei, pipelines: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenProgramPipelines", catch_unwind(||(self.genprogrampipelines)(n, pipelines)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenProgramPipelines", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsProgramPipeline.xhtml>
	#[inline(always)]
	fn glIsProgramPipeline(&self, pipeline: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsProgramPipeline", catch_unwind(||(self.isprogrampipeline)(pipeline)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsProgramPipeline", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramPipelineiv.xhtml>
	#[inline(always)]
	fn glGetProgramPipelineiv(&self, pipeline: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramPipelineiv", catch_unwind(||(self.getprogrampipelineiv)(pipeline, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramPipelineiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1i.xhtml>
	#[inline(always)]
	fn glProgramUniform1i(&self, program: GLuint, location: GLint, v0: GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform1i", catch_unwind(||(self.programuniform1i)(program, location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1iv.xhtml>
	#[inline(always)]
	fn glProgramUniform1iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform1iv", catch_unwind(||(self.programuniform1iv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1f.xhtml>
	#[inline(always)]
	fn glProgramUniform1f(&self, program: GLuint, location: GLint, v0: GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform1f", catch_unwind(||(self.programuniform1f)(program, location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1fv.xhtml>
	#[inline(always)]
	fn glProgramUniform1fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform1fv", catch_unwind(||(self.programuniform1fv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1d.xhtml>
	#[inline(always)]
	fn glProgramUniform1d(&self, program: GLuint, location: GLint, v0: GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform1d", catch_unwind(||(self.programuniform1d)(program, location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1dv.xhtml>
	#[inline(always)]
	fn glProgramUniform1dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform1dv", catch_unwind(||(self.programuniform1dv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1ui.xhtml>
	#[inline(always)]
	fn glProgramUniform1ui(&self, program: GLuint, location: GLint, v0: GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform1ui", catch_unwind(||(self.programuniform1ui)(program, location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1uiv.xhtml>
	#[inline(always)]
	fn glProgramUniform1uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform1uiv", catch_unwind(||(self.programuniform1uiv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2i.xhtml>
	#[inline(always)]
	fn glProgramUniform2i(&self, program: GLuint, location: GLint, v0: GLint, v1: GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform2i", catch_unwind(||(self.programuniform2i)(program, location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2iv.xhtml>
	#[inline(always)]
	fn glProgramUniform2iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform2iv", catch_unwind(||(self.programuniform2iv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2f.xhtml>
	#[inline(always)]
	fn glProgramUniform2f(&self, program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform2f", catch_unwind(||(self.programuniform2f)(program, location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2fv.xhtml>
	#[inline(always)]
	fn glProgramUniform2fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform2fv", catch_unwind(||(self.programuniform2fv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2d.xhtml>
	#[inline(always)]
	fn glProgramUniform2d(&self, program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform2d", catch_unwind(||(self.programuniform2d)(program, location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2dv.xhtml>
	#[inline(always)]
	fn glProgramUniform2dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform2dv", catch_unwind(||(self.programuniform2dv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2ui.xhtml>
	#[inline(always)]
	fn glProgramUniform2ui(&self, program: GLuint, location: GLint, v0: GLuint, v1: GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform2ui", catch_unwind(||(self.programuniform2ui)(program, location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2uiv.xhtml>
	#[inline(always)]
	fn glProgramUniform2uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform2uiv", catch_unwind(||(self.programuniform2uiv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3i.xhtml>
	#[inline(always)]
	fn glProgramUniform3i(&self, program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform3i", catch_unwind(||(self.programuniform3i)(program, location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3iv.xhtml>
	#[inline(always)]
	fn glProgramUniform3iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform3iv", catch_unwind(||(self.programuniform3iv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3f.xhtml>
	#[inline(always)]
	fn glProgramUniform3f(&self, program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform3f", catch_unwind(||(self.programuniform3f)(program, location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3fv.xhtml>
	#[inline(always)]
	fn glProgramUniform3fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform3fv", catch_unwind(||(self.programuniform3fv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3d.xhtml>
	#[inline(always)]
	fn glProgramUniform3d(&self, program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform3d", catch_unwind(||(self.programuniform3d)(program, location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3dv.xhtml>
	#[inline(always)]
	fn glProgramUniform3dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform3dv", catch_unwind(||(self.programuniform3dv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3ui.xhtml>
	#[inline(always)]
	fn glProgramUniform3ui(&self, program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform3ui", catch_unwind(||(self.programuniform3ui)(program, location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3uiv.xhtml>
	#[inline(always)]
	fn glProgramUniform3uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform3uiv", catch_unwind(||(self.programuniform3uiv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4i.xhtml>
	#[inline(always)]
	fn glProgramUniform4i(&self, program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform4i", catch_unwind(||(self.programuniform4i)(program, location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4iv.xhtml>
	#[inline(always)]
	fn glProgramUniform4iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform4iv", catch_unwind(||(self.programuniform4iv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4f.xhtml>
	#[inline(always)]
	fn glProgramUniform4f(&self, program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform4f", catch_unwind(||(self.programuniform4f)(program, location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4fv.xhtml>
	#[inline(always)]
	fn glProgramUniform4fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform4fv", catch_unwind(||(self.programuniform4fv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4d.xhtml>
	#[inline(always)]
	fn glProgramUniform4d(&self, program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble, v3: GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform4d", catch_unwind(||(self.programuniform4d)(program, location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4dv.xhtml>
	#[inline(always)]
	fn glProgramUniform4dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform4dv", catch_unwind(||(self.programuniform4dv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4ui.xhtml>
	#[inline(always)]
	fn glProgramUniform4ui(&self, program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform4ui", catch_unwind(||(self.programuniform4ui)(program, location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4uiv.xhtml>
	#[inline(always)]
	fn glProgramUniform4uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform4uiv", catch_unwind(||(self.programuniform4uiv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix2fv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix2fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2fv", catch_unwind(||(self.programuniformmatrix2fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix3fv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix3fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3fv", catch_unwind(||(self.programuniformmatrix3fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix4fv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix4fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4fv", catch_unwind(||(self.programuniformmatrix4fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix2dv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix2dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2dv", catch_unwind(||(self.programuniformmatrix2dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix3dv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix3dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3dv", catch_unwind(||(self.programuniformmatrix3dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix4dv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix4dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4dv", catch_unwind(||(self.programuniformmatrix4dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix2x3fv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix2x3fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2x3fv", catch_unwind(||(self.programuniformmatrix2x3fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2x3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix3x2fv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix3x2fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3x2fv", catch_unwind(||(self.programuniformmatrix3x2fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3x2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix2x4fv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix2x4fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2x4fv", catch_unwind(||(self.programuniformmatrix2x4fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2x4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix4x2fv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix4x2fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4x2fv", catch_unwind(||(self.programuniformmatrix4x2fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4x2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix3x4fv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix3x4fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3x4fv", catch_unwind(||(self.programuniformmatrix3x4fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3x4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix4x3fv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix4x3fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4x3fv", catch_unwind(||(self.programuniformmatrix4x3fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4x3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix2x3dv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix2x3dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2x3dv", catch_unwind(||(self.programuniformmatrix2x3dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2x3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix3x2dv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix3x2dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3x2dv", catch_unwind(||(self.programuniformmatrix3x2dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3x2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix2x4dv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix2x4dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2x4dv", catch_unwind(||(self.programuniformmatrix2x4dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2x4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix4x2dv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix4x2dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4x2dv", catch_unwind(||(self.programuniformmatrix4x2dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4x2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix3x4dv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix3x4dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3x4dv", catch_unwind(||(self.programuniformmatrix3x4dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3x4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix4x3dv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix4x3dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4x3dv", catch_unwind(||(self.programuniformmatrix4x3dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4x3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glValidateProgramPipeline.xhtml>
	#[inline(always)]
	fn glValidateProgramPipeline(&self, pipeline: GLuint) -> Result<()> {
		let ret = process_catch("glValidateProgramPipeline", catch_unwind(||(self.validateprogrampipeline)(pipeline)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glValidateProgramPipeline", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramPipelineInfoLog.xhtml>
	#[inline(always)]
	fn glGetProgramPipelineInfoLog(&self, pipeline: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetProgramPipelineInfoLog", catch_unwind(||(self.getprogrampipelineinfolog)(pipeline, bufSize, length, infoLog)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramPipelineInfoLog", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL1d.xhtml>
	#[inline(always)]
	fn glVertexAttribL1d(&self, index: GLuint, x: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL1d", catch_unwind(||(self.vertexattribl1d)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL1d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL2d.xhtml>
	#[inline(always)]
	fn glVertexAttribL2d(&self, index: GLuint, x: GLdouble, y: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL2d", catch_unwind(||(self.vertexattribl2d)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL2d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL3d.xhtml>
	#[inline(always)]
	fn glVertexAttribL3d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL3d", catch_unwind(||(self.vertexattribl3d)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL3d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL4d.xhtml>
	#[inline(always)]
	fn glVertexAttribL4d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL4d", catch_unwind(||(self.vertexattribl4d)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL4d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL1dv.xhtml>
	#[inline(always)]
	fn glVertexAttribL1dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL1dv", catch_unwind(||(self.vertexattribl1dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL1dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL2dv.xhtml>
	#[inline(always)]
	fn glVertexAttribL2dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL2dv", catch_unwind(||(self.vertexattribl2dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL3dv.xhtml>
	#[inline(always)]
	fn glVertexAttribL3dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL3dv", catch_unwind(||(self.vertexattribl3dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL4dv.xhtml>
	#[inline(always)]
	fn glVertexAttribL4dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL4dv", catch_unwind(||(self.vertexattribl4dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribLPointer.xhtml>
	#[inline(always)]
	fn glVertexAttribLPointer(&self, index: GLuint, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glVertexAttribLPointer", catch_unwind(||(self.vertexattriblpointer)(index, size, type_, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribLPointer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribLdv.xhtml>
	#[inline(always)]
	fn glGetVertexAttribLdv(&self, index: GLuint, pname: GLenum, params: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetVertexAttribLdv", catch_unwind(||(self.getvertexattribldv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribLdv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glViewportArrayv.xhtml>
	#[inline(always)]
	fn glViewportArrayv(&self, first: GLuint, count: GLsizei, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glViewportArrayv", catch_unwind(||(self.viewportarrayv)(first, count, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glViewportArrayv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glViewportIndexedf.xhtml>
	#[inline(always)]
	fn glViewportIndexedf(&self, index: GLuint, x: GLfloat, y: GLfloat, w: GLfloat, h: GLfloat) -> Result<()> {
		let ret = process_catch("glViewportIndexedf", catch_unwind(||(self.viewportindexedf)(index, x, y, w, h)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glViewportIndexedf", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glViewportIndexedfv.xhtml>
	#[inline(always)]
	fn glViewportIndexedfv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glViewportIndexedfv", catch_unwind(||(self.viewportindexedfv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glViewportIndexedfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glScissorArrayv.xhtml>
	#[inline(always)]
	fn glScissorArrayv(&self, first: GLuint, count: GLsizei, v: *const GLint) -> Result<()> {
		let ret = process_catch("glScissorArrayv", catch_unwind(||(self.scissorarrayv)(first, count, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glScissorArrayv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml>
	#[inline(always)]
	fn glScissorIndexed(&self, index: GLuint, left: GLint, bottom: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glScissorIndexed", catch_unwind(||(self.scissorindexed)(index, left, bottom, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glScissorIndexed", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glScissorIndexedv.xhtml>
	#[inline(always)]
	fn glScissorIndexedv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glScissorIndexedv", catch_unwind(||(self.scissorindexedv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glScissorIndexedv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDepthRangeArrayv.xhtml>
	#[inline(always)]
	fn glDepthRangeArrayv(&self, first: GLuint, count: GLsizei, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glDepthRangeArrayv", catch_unwind(||(self.depthrangearrayv)(first, count, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthRangeArrayv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDepthRangeIndexed.xhtml>
	#[inline(always)]
	fn glDepthRangeIndexed(&self, index: GLuint, n: GLdouble, f: GLdouble) -> Result<()> {
		let ret = process_catch("glDepthRangeIndexed", catch_unwind(||(self.depthrangeindexed)(index, n, f)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthRangeIndexed", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetFloati_v.xhtml>
	#[inline(always)]
	fn glGetFloati_v(&self, target: GLenum, index: GLuint, data: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetFloati_v", catch_unwind(||(self.getfloati_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFloati_v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetDoublei_v.xhtml>
	#[inline(always)]
	fn glGetDoublei_v(&self, target: GLenum, index: GLuint, data: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetDoublei_v", catch_unwind(||(self.getdoublei_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetDoublei_v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version41 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (4, 1, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			releaseshadercompiler: {let proc = get_proc_address("glReleaseShaderCompiler"); if proc == null() {dummy_pfnglreleaseshadercompilerproc} else {unsafe{transmute(proc)}}},
			shaderbinary: {let proc = get_proc_address("glShaderBinary"); if proc == null() {dummy_pfnglshaderbinaryproc} else {unsafe{transmute(proc)}}},
			getshaderprecisionformat: {let proc = get_proc_address("glGetShaderPrecisionFormat"); if proc == null() {dummy_pfnglgetshaderprecisionformatproc} else {unsafe{transmute(proc)}}},
			depthrangef: {let proc = get_proc_address("glDepthRangef"); if proc == null() {dummy_pfngldepthrangefproc} else {unsafe{transmute(proc)}}},
			cleardepthf: {let proc = get_proc_address("glClearDepthf"); if proc == null() {dummy_pfnglcleardepthfproc} else {unsafe{transmute(proc)}}},
			getprogrambinary: {let proc = get_proc_address("glGetProgramBinary"); if proc == null() {dummy_pfnglgetprogrambinaryproc} else {unsafe{transmute(proc)}}},
			programbinary: {let proc = get_proc_address("glProgramBinary"); if proc == null() {dummy_pfnglprogrambinaryproc} else {unsafe{transmute(proc)}}},
			programparameteri: {let proc = get_proc_address("glProgramParameteri"); if proc == null() {dummy_pfnglprogramparameteriproc} else {unsafe{transmute(proc)}}},
			useprogramstages: {let proc = get_proc_address("glUseProgramStages"); if proc == null() {dummy_pfngluseprogramstagesproc} else {unsafe{transmute(proc)}}},
			activeshaderprogram: {let proc = get_proc_address("glActiveShaderProgram"); if proc == null() {dummy_pfnglactiveshaderprogramproc} else {unsafe{transmute(proc)}}},
			createshaderprogramv: {let proc = get_proc_address("glCreateShaderProgramv"); if proc == null() {dummy_pfnglcreateshaderprogramvproc} else {unsafe{transmute(proc)}}},
			bindprogrampipeline: {let proc = get_proc_address("glBindProgramPipeline"); if proc == null() {dummy_pfnglbindprogrampipelineproc} else {unsafe{transmute(proc)}}},
			deleteprogrampipelines: {let proc = get_proc_address("glDeleteProgramPipelines"); if proc == null() {dummy_pfngldeleteprogrampipelinesproc} else {unsafe{transmute(proc)}}},
			genprogrampipelines: {let proc = get_proc_address("glGenProgramPipelines"); if proc == null() {dummy_pfnglgenprogrampipelinesproc} else {unsafe{transmute(proc)}}},
			isprogrampipeline: {let proc = get_proc_address("glIsProgramPipeline"); if proc == null() {dummy_pfnglisprogrampipelineproc} else {unsafe{transmute(proc)}}},
			getprogrampipelineiv: {let proc = get_proc_address("glGetProgramPipelineiv"); if proc == null() {dummy_pfnglgetprogrampipelineivproc} else {unsafe{transmute(proc)}}},
			programuniform1i: {let proc = get_proc_address("glProgramUniform1i"); if proc == null() {dummy_pfnglprogramuniform1iproc} else {unsafe{transmute(proc)}}},
			programuniform1iv: {let proc = get_proc_address("glProgramUniform1iv"); if proc == null() {dummy_pfnglprogramuniform1ivproc} else {unsafe{transmute(proc)}}},
			programuniform1f: {let proc = get_proc_address("glProgramUniform1f"); if proc == null() {dummy_pfnglprogramuniform1fproc} else {unsafe{transmute(proc)}}},
			programuniform1fv: {let proc = get_proc_address("glProgramUniform1fv"); if proc == null() {dummy_pfnglprogramuniform1fvproc} else {unsafe{transmute(proc)}}},
			programuniform1d: {let proc = get_proc_address("glProgramUniform1d"); if proc == null() {dummy_pfnglprogramuniform1dproc} else {unsafe{transmute(proc)}}},
			programuniform1dv: {let proc = get_proc_address("glProgramUniform1dv"); if proc == null() {dummy_pfnglprogramuniform1dvproc} else {unsafe{transmute(proc)}}},
			programuniform1ui: {let proc = get_proc_address("glProgramUniform1ui"); if proc == null() {dummy_pfnglprogramuniform1uiproc} else {unsafe{transmute(proc)}}},
			programuniform1uiv: {let proc = get_proc_address("glProgramUniform1uiv"); if proc == null() {dummy_pfnglprogramuniform1uivproc} else {unsafe{transmute(proc)}}},
			programuniform2i: {let proc = get_proc_address("glProgramUniform2i"); if proc == null() {dummy_pfnglprogramuniform2iproc} else {unsafe{transmute(proc)}}},
			programuniform2iv: {let proc = get_proc_address("glProgramUniform2iv"); if proc == null() {dummy_pfnglprogramuniform2ivproc} else {unsafe{transmute(proc)}}},
			programuniform2f: {let proc = get_proc_address("glProgramUniform2f"); if proc == null() {dummy_pfnglprogramuniform2fproc} else {unsafe{transmute(proc)}}},
			programuniform2fv: {let proc = get_proc_address("glProgramUniform2fv"); if proc == null() {dummy_pfnglprogramuniform2fvproc} else {unsafe{transmute(proc)}}},
			programuniform2d: {let proc = get_proc_address("glProgramUniform2d"); if proc == null() {dummy_pfnglprogramuniform2dproc} else {unsafe{transmute(proc)}}},
			programuniform2dv: {let proc = get_proc_address("glProgramUniform2dv"); if proc == null() {dummy_pfnglprogramuniform2dvproc} else {unsafe{transmute(proc)}}},
			programuniform2ui: {let proc = get_proc_address("glProgramUniform2ui"); if proc == null() {dummy_pfnglprogramuniform2uiproc} else {unsafe{transmute(proc)}}},
			programuniform2uiv: {let proc = get_proc_address("glProgramUniform2uiv"); if proc == null() {dummy_pfnglprogramuniform2uivproc} else {unsafe{transmute(proc)}}},
			programuniform3i: {let proc = get_proc_address("glProgramUniform3i"); if proc == null() {dummy_pfnglprogramuniform3iproc} else {unsafe{transmute(proc)}}},
			programuniform3iv: {let proc = get_proc_address("glProgramUniform3iv"); if proc == null() {dummy_pfnglprogramuniform3ivproc} else {unsafe{transmute(proc)}}},
			programuniform3f: {let proc = get_proc_address("glProgramUniform3f"); if proc == null() {dummy_pfnglprogramuniform3fproc} else {unsafe{transmute(proc)}}},
			programuniform3fv: {let proc = get_proc_address("glProgramUniform3fv"); if proc == null() {dummy_pfnglprogramuniform3fvproc} else {unsafe{transmute(proc)}}},
			programuniform3d: {let proc = get_proc_address("glProgramUniform3d"); if proc == null() {dummy_pfnglprogramuniform3dproc} else {unsafe{transmute(proc)}}},
			programuniform3dv: {let proc = get_proc_address("glProgramUniform3dv"); if proc == null() {dummy_pfnglprogramuniform3dvproc} else {unsafe{transmute(proc)}}},
			programuniform3ui: {let proc = get_proc_address("glProgramUniform3ui"); if proc == null() {dummy_pfnglprogramuniform3uiproc} else {unsafe{transmute(proc)}}},
			programuniform3uiv: {let proc = get_proc_address("glProgramUniform3uiv"); if proc == null() {dummy_pfnglprogramuniform3uivproc} else {unsafe{transmute(proc)}}},
			programuniform4i: {let proc = get_proc_address("glProgramUniform4i"); if proc == null() {dummy_pfnglprogramuniform4iproc} else {unsafe{transmute(proc)}}},
			programuniform4iv: {let proc = get_proc_address("glProgramUniform4iv"); if proc == null() {dummy_pfnglprogramuniform4ivproc} else {unsafe{transmute(proc)}}},
			programuniform4f: {let proc = get_proc_address("glProgramUniform4f"); if proc == null() {dummy_pfnglprogramuniform4fproc} else {unsafe{transmute(proc)}}},
			programuniform4fv: {let proc = get_proc_address("glProgramUniform4fv"); if proc == null() {dummy_pfnglprogramuniform4fvproc} else {unsafe{transmute(proc)}}},
			programuniform4d: {let proc = get_proc_address("glProgramUniform4d"); if proc == null() {dummy_pfnglprogramuniform4dproc} else {unsafe{transmute(proc)}}},
			programuniform4dv: {let proc = get_proc_address("glProgramUniform4dv"); if proc == null() {dummy_pfnglprogramuniform4dvproc} else {unsafe{transmute(proc)}}},
			programuniform4ui: {let proc = get_proc_address("glProgramUniform4ui"); if proc == null() {dummy_pfnglprogramuniform4uiproc} else {unsafe{transmute(proc)}}},
			programuniform4uiv: {let proc = get_proc_address("glProgramUniform4uiv"); if proc == null() {dummy_pfnglprogramuniform4uivproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix2fv: {let proc = get_proc_address("glProgramUniformMatrix2fv"); if proc == null() {dummy_pfnglprogramuniformmatrix2fvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix3fv: {let proc = get_proc_address("glProgramUniformMatrix3fv"); if proc == null() {dummy_pfnglprogramuniformmatrix3fvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix4fv: {let proc = get_proc_address("glProgramUniformMatrix4fv"); if proc == null() {dummy_pfnglprogramuniformmatrix4fvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix2dv: {let proc = get_proc_address("glProgramUniformMatrix2dv"); if proc == null() {dummy_pfnglprogramuniformmatrix2dvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix3dv: {let proc = get_proc_address("glProgramUniformMatrix3dv"); if proc == null() {dummy_pfnglprogramuniformmatrix3dvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix4dv: {let proc = get_proc_address("glProgramUniformMatrix4dv"); if proc == null() {dummy_pfnglprogramuniformmatrix4dvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix2x3fv: {let proc = get_proc_address("glProgramUniformMatrix2x3fv"); if proc == null() {dummy_pfnglprogramuniformmatrix2x3fvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix3x2fv: {let proc = get_proc_address("glProgramUniformMatrix3x2fv"); if proc == null() {dummy_pfnglprogramuniformmatrix3x2fvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix2x4fv: {let proc = get_proc_address("glProgramUniformMatrix2x4fv"); if proc == null() {dummy_pfnglprogramuniformmatrix2x4fvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix4x2fv: {let proc = get_proc_address("glProgramUniformMatrix4x2fv"); if proc == null() {dummy_pfnglprogramuniformmatrix4x2fvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix3x4fv: {let proc = get_proc_address("glProgramUniformMatrix3x4fv"); if proc == null() {dummy_pfnglprogramuniformmatrix3x4fvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix4x3fv: {let proc = get_proc_address("glProgramUniformMatrix4x3fv"); if proc == null() {dummy_pfnglprogramuniformmatrix4x3fvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix2x3dv: {let proc = get_proc_address("glProgramUniformMatrix2x3dv"); if proc == null() {dummy_pfnglprogramuniformmatrix2x3dvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix3x2dv: {let proc = get_proc_address("glProgramUniformMatrix3x2dv"); if proc == null() {dummy_pfnglprogramuniformmatrix3x2dvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix2x4dv: {let proc = get_proc_address("glProgramUniformMatrix2x4dv"); if proc == null() {dummy_pfnglprogramuniformmatrix2x4dvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix4x2dv: {let proc = get_proc_address("glProgramUniformMatrix4x2dv"); if proc == null() {dummy_pfnglprogramuniformmatrix4x2dvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix3x4dv: {let proc = get_proc_address("glProgramUniformMatrix3x4dv"); if proc == null() {dummy_pfnglprogramuniformmatrix3x4dvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix4x3dv: {let proc = get_proc_address("glProgramUniformMatrix4x3dv"); if proc == null() {dummy_pfnglprogramuniformmatrix4x3dvproc} else {unsafe{transmute(proc)}}},
			validateprogrampipeline: {let proc = get_proc_address("glValidateProgramPipeline"); if proc == null() {dummy_pfnglvalidateprogrampipelineproc} else {unsafe{transmute(proc)}}},
			getprogrampipelineinfolog: {let proc = get_proc_address("glGetProgramPipelineInfoLog"); if proc == null() {dummy_pfnglgetprogrampipelineinfologproc} else {unsafe{transmute(proc)}}},
			vertexattribl1d: {let proc = get_proc_address("glVertexAttribL1d"); if proc == null() {dummy_pfnglvertexattribl1dproc} else {unsafe{transmute(proc)}}},
			vertexattribl2d: {let proc = get_proc_address("glVertexAttribL2d"); if proc == null() {dummy_pfnglvertexattribl2dproc} else {unsafe{transmute(proc)}}},
			vertexattribl3d: {let proc = get_proc_address("glVertexAttribL3d"); if proc == null() {dummy_pfnglvertexattribl3dproc} else {unsafe{transmute(proc)}}},
			vertexattribl4d: {let proc = get_proc_address("glVertexAttribL4d"); if proc == null() {dummy_pfnglvertexattribl4dproc} else {unsafe{transmute(proc)}}},
			vertexattribl1dv: {let proc = get_proc_address("glVertexAttribL1dv"); if proc == null() {dummy_pfnglvertexattribl1dvproc} else {unsafe{transmute(proc)}}},
			vertexattribl2dv: {let proc = get_proc_address("glVertexAttribL2dv"); if proc == null() {dummy_pfnglvertexattribl2dvproc} else {unsafe{transmute(proc)}}},
			vertexattribl3dv: {let proc = get_proc_address("glVertexAttribL3dv"); if proc == null() {dummy_pfnglvertexattribl3dvproc} else {unsafe{transmute(proc)}}},
			vertexattribl4dv: {let proc = get_proc_address("glVertexAttribL4dv"); if proc == null() {dummy_pfnglvertexattribl4dvproc} else {unsafe{transmute(proc)}}},
			vertexattriblpointer: {let proc = get_proc_address("glVertexAttribLPointer"); if proc == null() {dummy_pfnglvertexattriblpointerproc} else {unsafe{transmute(proc)}}},
			getvertexattribldv: {let proc = get_proc_address("glGetVertexAttribLdv"); if proc == null() {dummy_pfnglgetvertexattribldvproc} else {unsafe{transmute(proc)}}},
			viewportarrayv: {let proc = get_proc_address("glViewportArrayv"); if proc == null() {dummy_pfnglviewportarrayvproc} else {unsafe{transmute(proc)}}},
			viewportindexedf: {let proc = get_proc_address("glViewportIndexedf"); if proc == null() {dummy_pfnglviewportindexedfproc} else {unsafe{transmute(proc)}}},
			viewportindexedfv: {let proc = get_proc_address("glViewportIndexedfv"); if proc == null() {dummy_pfnglviewportindexedfvproc} else {unsafe{transmute(proc)}}},
			scissorarrayv: {let proc = get_proc_address("glScissorArrayv"); if proc == null() {dummy_pfnglscissorarrayvproc} else {unsafe{transmute(proc)}}},
			scissorindexed: {let proc = get_proc_address("glScissorIndexed"); if proc == null() {dummy_pfnglscissorindexedproc} else {unsafe{transmute(proc)}}},
			scissorindexedv: {let proc = get_proc_address("glScissorIndexedv"); if proc == null() {dummy_pfnglscissorindexedvproc} else {unsafe{transmute(proc)}}},
			depthrangearrayv: {let proc = get_proc_address("glDepthRangeArrayv"); if proc == null() {dummy_pfngldepthrangearrayvproc} else {unsafe{transmute(proc)}}},
			depthrangeindexed: {let proc = get_proc_address("glDepthRangeIndexed"); if proc == null() {dummy_pfngldepthrangeindexedproc} else {unsafe{transmute(proc)}}},
			getfloati_v: {let proc = get_proc_address("glGetFloati_v"); if proc == null() {dummy_pfnglgetfloati_vproc} else {unsafe{transmute(proc)}}},
			getdoublei_v: {let proc = get_proc_address("glGetDoublei_v"); if proc == null() {dummy_pfnglgetdoublei_vproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version41 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			releaseshadercompiler: dummy_pfnglreleaseshadercompilerproc,
			shaderbinary: dummy_pfnglshaderbinaryproc,
			getshaderprecisionformat: dummy_pfnglgetshaderprecisionformatproc,
			depthrangef: dummy_pfngldepthrangefproc,
			cleardepthf: dummy_pfnglcleardepthfproc,
			getprogrambinary: dummy_pfnglgetprogrambinaryproc,
			programbinary: dummy_pfnglprogrambinaryproc,
			programparameteri: dummy_pfnglprogramparameteriproc,
			useprogramstages: dummy_pfngluseprogramstagesproc,
			activeshaderprogram: dummy_pfnglactiveshaderprogramproc,
			createshaderprogramv: dummy_pfnglcreateshaderprogramvproc,
			bindprogrampipeline: dummy_pfnglbindprogrampipelineproc,
			deleteprogrampipelines: dummy_pfngldeleteprogrampipelinesproc,
			genprogrampipelines: dummy_pfnglgenprogrampipelinesproc,
			isprogrampipeline: dummy_pfnglisprogrampipelineproc,
			getprogrampipelineiv: dummy_pfnglgetprogrampipelineivproc,
			programuniform1i: dummy_pfnglprogramuniform1iproc,
			programuniform1iv: dummy_pfnglprogramuniform1ivproc,
			programuniform1f: dummy_pfnglprogramuniform1fproc,
			programuniform1fv: dummy_pfnglprogramuniform1fvproc,
			programuniform1d: dummy_pfnglprogramuniform1dproc,
			programuniform1dv: dummy_pfnglprogramuniform1dvproc,
			programuniform1ui: dummy_pfnglprogramuniform1uiproc,
			programuniform1uiv: dummy_pfnglprogramuniform1uivproc,
			programuniform2i: dummy_pfnglprogramuniform2iproc,
			programuniform2iv: dummy_pfnglprogramuniform2ivproc,
			programuniform2f: dummy_pfnglprogramuniform2fproc,
			programuniform2fv: dummy_pfnglprogramuniform2fvproc,
			programuniform2d: dummy_pfnglprogramuniform2dproc,
			programuniform2dv: dummy_pfnglprogramuniform2dvproc,
			programuniform2ui: dummy_pfnglprogramuniform2uiproc,
			programuniform2uiv: dummy_pfnglprogramuniform2uivproc,
			programuniform3i: dummy_pfnglprogramuniform3iproc,
			programuniform3iv: dummy_pfnglprogramuniform3ivproc,
			programuniform3f: dummy_pfnglprogramuniform3fproc,
			programuniform3fv: dummy_pfnglprogramuniform3fvproc,
			programuniform3d: dummy_pfnglprogramuniform3dproc,
			programuniform3dv: dummy_pfnglprogramuniform3dvproc,
			programuniform3ui: dummy_pfnglprogramuniform3uiproc,
			programuniform3uiv: dummy_pfnglprogramuniform3uivproc,
			programuniform4i: dummy_pfnglprogramuniform4iproc,
			programuniform4iv: dummy_pfnglprogramuniform4ivproc,
			programuniform4f: dummy_pfnglprogramuniform4fproc,
			programuniform4fv: dummy_pfnglprogramuniform4fvproc,
			programuniform4d: dummy_pfnglprogramuniform4dproc,
			programuniform4dv: dummy_pfnglprogramuniform4dvproc,
			programuniform4ui: dummy_pfnglprogramuniform4uiproc,
			programuniform4uiv: dummy_pfnglprogramuniform4uivproc,
			programuniformmatrix2fv: dummy_pfnglprogramuniformmatrix2fvproc,
			programuniformmatrix3fv: dummy_pfnglprogramuniformmatrix3fvproc,
			programuniformmatrix4fv: dummy_pfnglprogramuniformmatrix4fvproc,
			programuniformmatrix2dv: dummy_pfnglprogramuniformmatrix2dvproc,
			programuniformmatrix3dv: dummy_pfnglprogramuniformmatrix3dvproc,
			programuniformmatrix4dv: dummy_pfnglprogramuniformmatrix4dvproc,
			programuniformmatrix2x3fv: dummy_pfnglprogramuniformmatrix2x3fvproc,
			programuniformmatrix3x2fv: dummy_pfnglprogramuniformmatrix3x2fvproc,
			programuniformmatrix2x4fv: dummy_pfnglprogramuniformmatrix2x4fvproc,
			programuniformmatrix4x2fv: dummy_pfnglprogramuniformmatrix4x2fvproc,
			programuniformmatrix3x4fv: dummy_pfnglprogramuniformmatrix3x4fvproc,
			programuniformmatrix4x3fv: dummy_pfnglprogramuniformmatrix4x3fvproc,
			programuniformmatrix2x3dv: dummy_pfnglprogramuniformmatrix2x3dvproc,
			programuniformmatrix3x2dv: dummy_pfnglprogramuniformmatrix3x2dvproc,
			programuniformmatrix2x4dv: dummy_pfnglprogramuniformmatrix2x4dvproc,
			programuniformmatrix4x2dv: dummy_pfnglprogramuniformmatrix4x2dvproc,
			programuniformmatrix3x4dv: dummy_pfnglprogramuniformmatrix3x4dvproc,
			programuniformmatrix4x3dv: dummy_pfnglprogramuniformmatrix4x3dvproc,
			validateprogrampipeline: dummy_pfnglvalidateprogrampipelineproc,
			getprogrampipelineinfolog: dummy_pfnglgetprogrampipelineinfologproc,
			vertexattribl1d: dummy_pfnglvertexattribl1dproc,
			vertexattribl2d: dummy_pfnglvertexattribl2dproc,
			vertexattribl3d: dummy_pfnglvertexattribl3dproc,
			vertexattribl4d: dummy_pfnglvertexattribl4dproc,
			vertexattribl1dv: dummy_pfnglvertexattribl1dvproc,
			vertexattribl2dv: dummy_pfnglvertexattribl2dvproc,
			vertexattribl3dv: dummy_pfnglvertexattribl3dvproc,
			vertexattribl4dv: dummy_pfnglvertexattribl4dvproc,
			vertexattriblpointer: dummy_pfnglvertexattriblpointerproc,
			getvertexattribldv: dummy_pfnglgetvertexattribldvproc,
			viewportarrayv: dummy_pfnglviewportarrayvproc,
			viewportindexedf: dummy_pfnglviewportindexedfproc,
			viewportindexedfv: dummy_pfnglviewportindexedfvproc,
			scissorarrayv: dummy_pfnglscissorarrayvproc,
			scissorindexed: dummy_pfnglscissorindexedproc,
			scissorindexedv: dummy_pfnglscissorindexedvproc,
			depthrangearrayv: dummy_pfngldepthrangearrayvproc,
			depthrangeindexed: dummy_pfngldepthrangeindexedproc,
			getfloati_v: dummy_pfnglgetfloati_vproc,
			getdoublei_v: dummy_pfnglgetdoublei_vproc,
		}
	}
}
impl Debug for Version41 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version41")
			.field("available", &self.available)
			.field("releaseshadercompiler", unsafe{if transmute::<_, *const c_void>(self.releaseshadercompiler) == (dummy_pfnglreleaseshadercompilerproc as *const c_void) {&null::<PFNGLRELEASESHADERCOMPILERPROC>()} else {&self.releaseshadercompiler}})
			.field("shaderbinary", unsafe{if transmute::<_, *const c_void>(self.shaderbinary) == (dummy_pfnglshaderbinaryproc as *const c_void) {&null::<PFNGLSHADERBINARYPROC>()} else {&self.shaderbinary}})
			.field("getshaderprecisionformat", unsafe{if transmute::<_, *const c_void>(self.getshaderprecisionformat) == (dummy_pfnglgetshaderprecisionformatproc as *const c_void) {&null::<PFNGLGETSHADERPRECISIONFORMATPROC>()} else {&self.getshaderprecisionformat}})
			.field("depthrangef", unsafe{if transmute::<_, *const c_void>(self.depthrangef) == (dummy_pfngldepthrangefproc as *const c_void) {&null::<PFNGLDEPTHRANGEFPROC>()} else {&self.depthrangef}})
			.field("cleardepthf", unsafe{if transmute::<_, *const c_void>(self.cleardepthf) == (dummy_pfnglcleardepthfproc as *const c_void) {&null::<PFNGLCLEARDEPTHFPROC>()} else {&self.cleardepthf}})
			.field("getprogrambinary", unsafe{if transmute::<_, *const c_void>(self.getprogrambinary) == (dummy_pfnglgetprogrambinaryproc as *const c_void) {&null::<PFNGLGETPROGRAMBINARYPROC>()} else {&self.getprogrambinary}})
			.field("programbinary", unsafe{if transmute::<_, *const c_void>(self.programbinary) == (dummy_pfnglprogrambinaryproc as *const c_void) {&null::<PFNGLPROGRAMBINARYPROC>()} else {&self.programbinary}})
			.field("programparameteri", unsafe{if transmute::<_, *const c_void>(self.programparameteri) == (dummy_pfnglprogramparameteriproc as *const c_void) {&null::<PFNGLPROGRAMPARAMETERIPROC>()} else {&self.programparameteri}})
			.field("useprogramstages", unsafe{if transmute::<_, *const c_void>(self.useprogramstages) == (dummy_pfngluseprogramstagesproc as *const c_void) {&null::<PFNGLUSEPROGRAMSTAGESPROC>()} else {&self.useprogramstages}})
			.field("activeshaderprogram", unsafe{if transmute::<_, *const c_void>(self.activeshaderprogram) == (dummy_pfnglactiveshaderprogramproc as *const c_void) {&null::<PFNGLACTIVESHADERPROGRAMPROC>()} else {&self.activeshaderprogram}})
			.field("createshaderprogramv", unsafe{if transmute::<_, *const c_void>(self.createshaderprogramv) == (dummy_pfnglcreateshaderprogramvproc as *const c_void) {&null::<PFNGLCREATESHADERPROGRAMVPROC>()} else {&self.createshaderprogramv}})
			.field("bindprogrampipeline", unsafe{if transmute::<_, *const c_void>(self.bindprogrampipeline) == (dummy_pfnglbindprogrampipelineproc as *const c_void) {&null::<PFNGLBINDPROGRAMPIPELINEPROC>()} else {&self.bindprogrampipeline}})
			.field("deleteprogrampipelines", unsafe{if transmute::<_, *const c_void>(self.deleteprogrampipelines) == (dummy_pfngldeleteprogrampipelinesproc as *const c_void) {&null::<PFNGLDELETEPROGRAMPIPELINESPROC>()} else {&self.deleteprogrampipelines}})
			.field("genprogrampipelines", unsafe{if transmute::<_, *const c_void>(self.genprogrampipelines) == (dummy_pfnglgenprogrampipelinesproc as *const c_void) {&null::<PFNGLGENPROGRAMPIPELINESPROC>()} else {&self.genprogrampipelines}})
			.field("isprogrampipeline", unsafe{if transmute::<_, *const c_void>(self.isprogrampipeline) == (dummy_pfnglisprogrampipelineproc as *const c_void) {&null::<PFNGLISPROGRAMPIPELINEPROC>()} else {&self.isprogrampipeline}})
			.field("getprogrampipelineiv", unsafe{if transmute::<_, *const c_void>(self.getprogrampipelineiv) == (dummy_pfnglgetprogrampipelineivproc as *const c_void) {&null::<PFNGLGETPROGRAMPIPELINEIVPROC>()} else {&self.getprogrampipelineiv}})
			.field("programuniform1i", unsafe{if transmute::<_, *const c_void>(self.programuniform1i) == (dummy_pfnglprogramuniform1iproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM1IPROC>()} else {&self.programuniform1i}})
			.field("programuniform1iv", unsafe{if transmute::<_, *const c_void>(self.programuniform1iv) == (dummy_pfnglprogramuniform1ivproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM1IVPROC>()} else {&self.programuniform1iv}})
			.field("programuniform1f", unsafe{if transmute::<_, *const c_void>(self.programuniform1f) == (dummy_pfnglprogramuniform1fproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM1FPROC>()} else {&self.programuniform1f}})
			.field("programuniform1fv", unsafe{if transmute::<_, *const c_void>(self.programuniform1fv) == (dummy_pfnglprogramuniform1fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM1FVPROC>()} else {&self.programuniform1fv}})
			.field("programuniform1d", unsafe{if transmute::<_, *const c_void>(self.programuniform1d) == (dummy_pfnglprogramuniform1dproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM1DPROC>()} else {&self.programuniform1d}})
			.field("programuniform1dv", unsafe{if transmute::<_, *const c_void>(self.programuniform1dv) == (dummy_pfnglprogramuniform1dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM1DVPROC>()} else {&self.programuniform1dv}})
			.field("programuniform1ui", unsafe{if transmute::<_, *const c_void>(self.programuniform1ui) == (dummy_pfnglprogramuniform1uiproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM1UIPROC>()} else {&self.programuniform1ui}})
			.field("programuniform1uiv", unsafe{if transmute::<_, *const c_void>(self.programuniform1uiv) == (dummy_pfnglprogramuniform1uivproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM1UIVPROC>()} else {&self.programuniform1uiv}})
			.field("programuniform2i", unsafe{if transmute::<_, *const c_void>(self.programuniform2i) == (dummy_pfnglprogramuniform2iproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM2IPROC>()} else {&self.programuniform2i}})
			.field("programuniform2iv", unsafe{if transmute::<_, *const c_void>(self.programuniform2iv) == (dummy_pfnglprogramuniform2ivproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM2IVPROC>()} else {&self.programuniform2iv}})
			.field("programuniform2f", unsafe{if transmute::<_, *const c_void>(self.programuniform2f) == (dummy_pfnglprogramuniform2fproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM2FPROC>()} else {&self.programuniform2f}})
			.field("programuniform2fv", unsafe{if transmute::<_, *const c_void>(self.programuniform2fv) == (dummy_pfnglprogramuniform2fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM2FVPROC>()} else {&self.programuniform2fv}})
			.field("programuniform2d", unsafe{if transmute::<_, *const c_void>(self.programuniform2d) == (dummy_pfnglprogramuniform2dproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM2DPROC>()} else {&self.programuniform2d}})
			.field("programuniform2dv", unsafe{if transmute::<_, *const c_void>(self.programuniform2dv) == (dummy_pfnglprogramuniform2dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM2DVPROC>()} else {&self.programuniform2dv}})
			.field("programuniform2ui", unsafe{if transmute::<_, *const c_void>(self.programuniform2ui) == (dummy_pfnglprogramuniform2uiproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM2UIPROC>()} else {&self.programuniform2ui}})
			.field("programuniform2uiv", unsafe{if transmute::<_, *const c_void>(self.programuniform2uiv) == (dummy_pfnglprogramuniform2uivproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM2UIVPROC>()} else {&self.programuniform2uiv}})
			.field("programuniform3i", unsafe{if transmute::<_, *const c_void>(self.programuniform3i) == (dummy_pfnglprogramuniform3iproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM3IPROC>()} else {&self.programuniform3i}})
			.field("programuniform3iv", unsafe{if transmute::<_, *const c_void>(self.programuniform3iv) == (dummy_pfnglprogramuniform3ivproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM3IVPROC>()} else {&self.programuniform3iv}})
			.field("programuniform3f", unsafe{if transmute::<_, *const c_void>(self.programuniform3f) == (dummy_pfnglprogramuniform3fproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM3FPROC>()} else {&self.programuniform3f}})
			.field("programuniform3fv", unsafe{if transmute::<_, *const c_void>(self.programuniform3fv) == (dummy_pfnglprogramuniform3fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM3FVPROC>()} else {&self.programuniform3fv}})
			.field("programuniform3d", unsafe{if transmute::<_, *const c_void>(self.programuniform3d) == (dummy_pfnglprogramuniform3dproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM3DPROC>()} else {&self.programuniform3d}})
			.field("programuniform3dv", unsafe{if transmute::<_, *const c_void>(self.programuniform3dv) == (dummy_pfnglprogramuniform3dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM3DVPROC>()} else {&self.programuniform3dv}})
			.field("programuniform3ui", unsafe{if transmute::<_, *const c_void>(self.programuniform3ui) == (dummy_pfnglprogramuniform3uiproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM3UIPROC>()} else {&self.programuniform3ui}})
			.field("programuniform3uiv", unsafe{if transmute::<_, *const c_void>(self.programuniform3uiv) == (dummy_pfnglprogramuniform3uivproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM3UIVPROC>()} else {&self.programuniform3uiv}})
			.field("programuniform4i", unsafe{if transmute::<_, *const c_void>(self.programuniform4i) == (dummy_pfnglprogramuniform4iproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM4IPROC>()} else {&self.programuniform4i}})
			.field("programuniform4iv", unsafe{if transmute::<_, *const c_void>(self.programuniform4iv) == (dummy_pfnglprogramuniform4ivproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM4IVPROC>()} else {&self.programuniform4iv}})
			.field("programuniform4f", unsafe{if transmute::<_, *const c_void>(self.programuniform4f) == (dummy_pfnglprogramuniform4fproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM4FPROC>()} else {&self.programuniform4f}})
			.field("programuniform4fv", unsafe{if transmute::<_, *const c_void>(self.programuniform4fv) == (dummy_pfnglprogramuniform4fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM4FVPROC>()} else {&self.programuniform4fv}})
			.field("programuniform4d", unsafe{if transmute::<_, *const c_void>(self.programuniform4d) == (dummy_pfnglprogramuniform4dproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM4DPROC>()} else {&self.programuniform4d}})
			.field("programuniform4dv", unsafe{if transmute::<_, *const c_void>(self.programuniform4dv) == (dummy_pfnglprogramuniform4dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM4DVPROC>()} else {&self.programuniform4dv}})
			.field("programuniform4ui", unsafe{if transmute::<_, *const c_void>(self.programuniform4ui) == (dummy_pfnglprogramuniform4uiproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM4UIPROC>()} else {&self.programuniform4ui}})
			.field("programuniform4uiv", unsafe{if transmute::<_, *const c_void>(self.programuniform4uiv) == (dummy_pfnglprogramuniform4uivproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM4UIVPROC>()} else {&self.programuniform4uiv}})
			.field("programuniformmatrix2fv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix2fv) == (dummy_pfnglprogramuniformmatrix2fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX2FVPROC>()} else {&self.programuniformmatrix2fv}})
			.field("programuniformmatrix3fv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix3fv) == (dummy_pfnglprogramuniformmatrix3fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX3FVPROC>()} else {&self.programuniformmatrix3fv}})
			.field("programuniformmatrix4fv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix4fv) == (dummy_pfnglprogramuniformmatrix4fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX4FVPROC>()} else {&self.programuniformmatrix4fv}})
			.field("programuniformmatrix2dv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix2dv) == (dummy_pfnglprogramuniformmatrix2dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX2DVPROC>()} else {&self.programuniformmatrix2dv}})
			.field("programuniformmatrix3dv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix3dv) == (dummy_pfnglprogramuniformmatrix3dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX3DVPROC>()} else {&self.programuniformmatrix3dv}})
			.field("programuniformmatrix4dv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix4dv) == (dummy_pfnglprogramuniformmatrix4dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX4DVPROC>()} else {&self.programuniformmatrix4dv}})
			.field("programuniformmatrix2x3fv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix2x3fv) == (dummy_pfnglprogramuniformmatrix2x3fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC>()} else {&self.programuniformmatrix2x3fv}})
			.field("programuniformmatrix3x2fv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix3x2fv) == (dummy_pfnglprogramuniformmatrix3x2fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC>()} else {&self.programuniformmatrix3x2fv}})
			.field("programuniformmatrix2x4fv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix2x4fv) == (dummy_pfnglprogramuniformmatrix2x4fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC>()} else {&self.programuniformmatrix2x4fv}})
			.field("programuniformmatrix4x2fv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix4x2fv) == (dummy_pfnglprogramuniformmatrix4x2fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC>()} else {&self.programuniformmatrix4x2fv}})
			.field("programuniformmatrix3x4fv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix3x4fv) == (dummy_pfnglprogramuniformmatrix3x4fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC>()} else {&self.programuniformmatrix3x4fv}})
			.field("programuniformmatrix4x3fv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix4x3fv) == (dummy_pfnglprogramuniformmatrix4x3fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC>()} else {&self.programuniformmatrix4x3fv}})
			.field("programuniformmatrix2x3dv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix2x3dv) == (dummy_pfnglprogramuniformmatrix2x3dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC>()} else {&self.programuniformmatrix2x3dv}})
			.field("programuniformmatrix3x2dv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix3x2dv) == (dummy_pfnglprogramuniformmatrix3x2dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC>()} else {&self.programuniformmatrix3x2dv}})
			.field("programuniformmatrix2x4dv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix2x4dv) == (dummy_pfnglprogramuniformmatrix2x4dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC>()} else {&self.programuniformmatrix2x4dv}})
			.field("programuniformmatrix4x2dv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix4x2dv) == (dummy_pfnglprogramuniformmatrix4x2dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC>()} else {&self.programuniformmatrix4x2dv}})
			.field("programuniformmatrix3x4dv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix3x4dv) == (dummy_pfnglprogramuniformmatrix3x4dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC>()} else {&self.programuniformmatrix3x4dv}})
			.field("programuniformmatrix4x3dv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix4x3dv) == (dummy_pfnglprogramuniformmatrix4x3dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC>()} else {&self.programuniformmatrix4x3dv}})
			.field("validateprogrampipeline", unsafe{if transmute::<_, *const c_void>(self.validateprogrampipeline) == (dummy_pfnglvalidateprogrampipelineproc as *const c_void) {&null::<PFNGLVALIDATEPROGRAMPIPELINEPROC>()} else {&self.validateprogrampipeline}})
			.field("getprogrampipelineinfolog", unsafe{if transmute::<_, *const c_void>(self.getprogrampipelineinfolog) == (dummy_pfnglgetprogrampipelineinfologproc as *const c_void) {&null::<PFNGLGETPROGRAMPIPELINEINFOLOGPROC>()} else {&self.getprogrampipelineinfolog}})
			.field("vertexattribl1d", unsafe{if transmute::<_, *const c_void>(self.vertexattribl1d) == (dummy_pfnglvertexattribl1dproc as *const c_void) {&null::<PFNGLVERTEXATTRIBL1DPROC>()} else {&self.vertexattribl1d}})
			.field("vertexattribl2d", unsafe{if transmute::<_, *const c_void>(self.vertexattribl2d) == (dummy_pfnglvertexattribl2dproc as *const c_void) {&null::<PFNGLVERTEXATTRIBL2DPROC>()} else {&self.vertexattribl2d}})
			.field("vertexattribl3d", unsafe{if transmute::<_, *const c_void>(self.vertexattribl3d) == (dummy_pfnglvertexattribl3dproc as *const c_void) {&null::<PFNGLVERTEXATTRIBL3DPROC>()} else {&self.vertexattribl3d}})
			.field("vertexattribl4d", unsafe{if transmute::<_, *const c_void>(self.vertexattribl4d) == (dummy_pfnglvertexattribl4dproc as *const c_void) {&null::<PFNGLVERTEXATTRIBL4DPROC>()} else {&self.vertexattribl4d}})
			.field("vertexattribl1dv", unsafe{if transmute::<_, *const c_void>(self.vertexattribl1dv) == (dummy_pfnglvertexattribl1dvproc as *const c_void) {&null::<PFNGLVERTEXATTRIBL1DVPROC>()} else {&self.vertexattribl1dv}})
			.field("vertexattribl2dv", unsafe{if transmute::<_, *const c_void>(self.vertexattribl2dv) == (dummy_pfnglvertexattribl2dvproc as *const c_void) {&null::<PFNGLVERTEXATTRIBL2DVPROC>()} else {&self.vertexattribl2dv}})
			.field("vertexattribl3dv", unsafe{if transmute::<_, *const c_void>(self.vertexattribl3dv) == (dummy_pfnglvertexattribl3dvproc as *const c_void) {&null::<PFNGLVERTEXATTRIBL3DVPROC>()} else {&self.vertexattribl3dv}})
			.field("vertexattribl4dv", unsafe{if transmute::<_, *const c_void>(self.vertexattribl4dv) == (dummy_pfnglvertexattribl4dvproc as *const c_void) {&null::<PFNGLVERTEXATTRIBL4DVPROC>()} else {&self.vertexattribl4dv}})
			.field("vertexattriblpointer", unsafe{if transmute::<_, *const c_void>(self.vertexattriblpointer) == (dummy_pfnglvertexattriblpointerproc as *const c_void) {&null::<PFNGLVERTEXATTRIBLPOINTERPROC>()} else {&self.vertexattriblpointer}})
			.field("getvertexattribldv", unsafe{if transmute::<_, *const c_void>(self.getvertexattribldv) == (dummy_pfnglgetvertexattribldvproc as *const c_void) {&null::<PFNGLGETVERTEXATTRIBLDVPROC>()} else {&self.getvertexattribldv}})
			.field("viewportarrayv", unsafe{if transmute::<_, *const c_void>(self.viewportarrayv) == (dummy_pfnglviewportarrayvproc as *const c_void) {&null::<PFNGLVIEWPORTARRAYVPROC>()} else {&self.viewportarrayv}})
			.field("viewportindexedf", unsafe{if transmute::<_, *const c_void>(self.viewportindexedf) == (dummy_pfnglviewportindexedfproc as *const c_void) {&null::<PFNGLVIEWPORTINDEXEDFPROC>()} else {&self.viewportindexedf}})
			.field("viewportindexedfv", unsafe{if transmute::<_, *const c_void>(self.viewportindexedfv) == (dummy_pfnglviewportindexedfvproc as *const c_void) {&null::<PFNGLVIEWPORTINDEXEDFVPROC>()} else {&self.viewportindexedfv}})
			.field("scissorarrayv", unsafe{if transmute::<_, *const c_void>(self.scissorarrayv) == (dummy_pfnglscissorarrayvproc as *const c_void) {&null::<PFNGLSCISSORARRAYVPROC>()} else {&self.scissorarrayv}})
			.field("scissorindexed", unsafe{if transmute::<_, *const c_void>(self.scissorindexed) == (dummy_pfnglscissorindexedproc as *const c_void) {&null::<PFNGLSCISSORINDEXEDPROC>()} else {&self.scissorindexed}})
			.field("scissorindexedv", unsafe{if transmute::<_, *const c_void>(self.scissorindexedv) == (dummy_pfnglscissorindexedvproc as *const c_void) {&null::<PFNGLSCISSORINDEXEDVPROC>()} else {&self.scissorindexedv}})
			.field("depthrangearrayv", unsafe{if transmute::<_, *const c_void>(self.depthrangearrayv) == (dummy_pfngldepthrangearrayvproc as *const c_void) {&null::<PFNGLDEPTHRANGEARRAYVPROC>()} else {&self.depthrangearrayv}})
			.field("depthrangeindexed", unsafe{if transmute::<_, *const c_void>(self.depthrangeindexed) == (dummy_pfngldepthrangeindexedproc as *const c_void) {&null::<PFNGLDEPTHRANGEINDEXEDPROC>()} else {&self.depthrangeindexed}})
			.field("getfloati_v", unsafe{if transmute::<_, *const c_void>(self.getfloati_v) == (dummy_pfnglgetfloati_vproc as *const c_void) {&null::<PFNGLGETFLOATI_VPROC>()} else {&self.getfloati_v}})
			.field("getdoublei_v", unsafe{if transmute::<_, *const c_void>(self.getdoublei_v) == (dummy_pfnglgetdoublei_vproc as *const c_void) {&null::<PFNGLGETDOUBLEI_VPROC>()} else {&self.getdoublei_v}})
			.finish()
		} else {
			f.debug_struct("Version41")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

/// The prototype to the OpenGL function `DrawArraysInstancedBaseInstance`
type PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC = extern "system" fn(GLenum, GLint, GLsizei, GLsizei, GLuint);

/// The prototype to the OpenGL function `DrawElementsInstancedBaseInstance`
type PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC = extern "system" fn(GLenum, GLsizei, GLenum, *const c_void, GLsizei, GLuint);

/// The prototype to the OpenGL function `DrawElementsInstancedBaseVertexBaseInstance`
type PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC = extern "system" fn(GLenum, GLsizei, GLenum, *const c_void, GLsizei, GLint, GLuint);

/// The prototype to the OpenGL function `GetInternalformativ`
type PFNGLGETINTERNALFORMATIVPROC = extern "system" fn(GLenum, GLenum, GLenum, GLsizei, *mut GLint);

/// The prototype to the OpenGL function `GetActiveAtomicCounterBufferiv`
type PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC = extern "system" fn(GLuint, GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `BindImageTexture`
type PFNGLBINDIMAGETEXTUREPROC = extern "system" fn(GLuint, GLuint, GLint, GLboolean, GLint, GLenum, GLenum);

/// The prototype to the OpenGL function `MemoryBarrier`
type PFNGLMEMORYBARRIERPROC = extern "system" fn(GLbitfield);

/// The prototype to the OpenGL function `TexStorage1D`
type PFNGLTEXSTORAGE1DPROC = extern "system" fn(GLenum, GLsizei, GLenum, GLsizei);

/// The prototype to the OpenGL function `TexStorage2D`
type PFNGLTEXSTORAGE2DPROC = extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei);

/// The prototype to the OpenGL function `TexStorage3D`
type PFNGLTEXSTORAGE3DPROC = extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei);

/// The prototype to the OpenGL function `DrawTransformFeedbackInstanced`
type PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC = extern "system" fn(GLenum, GLuint, GLsizei);

/// The prototype to the OpenGL function `DrawTransformFeedbackStreamInstanced`
type PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC = extern "system" fn(GLenum, GLuint, GLuint, GLsizei);

/// The dummy function of `DrawArraysInstancedBaseInstance()`
extern "system" fn dummy_pfngldrawarraysinstancedbaseinstanceproc (_: GLenum, _: GLint, _: GLsizei, _: GLsizei, _: GLuint) {
	panic!("OpenGL function pointer `glDrawArraysInstancedBaseInstance()` is null.")
}

/// The dummy function of `DrawElementsInstancedBaseInstance()`
extern "system" fn dummy_pfngldrawelementsinstancedbaseinstanceproc (_: GLenum, _: GLsizei, _: GLenum, _: *const c_void, _: GLsizei, _: GLuint) {
	panic!("OpenGL function pointer `glDrawElementsInstancedBaseInstance()` is null.")
}

/// The dummy function of `DrawElementsInstancedBaseVertexBaseInstance()`
extern "system" fn dummy_pfngldrawelementsinstancedbasevertexbaseinstanceproc (_: GLenum, _: GLsizei, _: GLenum, _: *const c_void, _: GLsizei, _: GLint, _: GLuint) {
	panic!("OpenGL function pointer `glDrawElementsInstancedBaseVertexBaseInstance()` is null.")
}

/// The dummy function of `GetInternalformativ()`
extern "system" fn dummy_pfnglgetinternalformativproc (_: GLenum, _: GLenum, _: GLenum, _: GLsizei, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetInternalformativ()` is null.")
}

/// The dummy function of `GetActiveAtomicCounterBufferiv()`
extern "system" fn dummy_pfnglgetactiveatomiccounterbufferivproc (_: GLuint, _: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetActiveAtomicCounterBufferiv()` is null.")
}

/// The dummy function of `BindImageTexture()`
extern "system" fn dummy_pfnglbindimagetextureproc (_: GLuint, _: GLuint, _: GLint, _: GLboolean, _: GLint, _: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glBindImageTexture()` is null.")
}

/// The dummy function of `MemoryBarrier()`
extern "system" fn dummy_pfnglmemorybarrierproc (_: GLbitfield) {
	panic!("OpenGL function pointer `glMemoryBarrier()` is null.")
}

/// The dummy function of `TexStorage1D()`
extern "system" fn dummy_pfngltexstorage1dproc (_: GLenum, _: GLsizei, _: GLenum, _: GLsizei) {
	panic!("OpenGL function pointer `glTexStorage1D()` is null.")
}

/// The dummy function of `TexStorage2D()`
extern "system" fn dummy_pfngltexstorage2dproc (_: GLenum, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glTexStorage2D()` is null.")
}

/// The dummy function of `TexStorage3D()`
extern "system" fn dummy_pfngltexstorage3dproc (_: GLenum, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glTexStorage3D()` is null.")
}

/// The dummy function of `DrawTransformFeedbackInstanced()`
extern "system" fn dummy_pfngldrawtransformfeedbackinstancedproc (_: GLenum, _: GLuint, _: GLsizei) {
	panic!("OpenGL function pointer `glDrawTransformFeedbackInstanced()` is null.")
}

/// The dummy function of `DrawTransformFeedbackStreamInstanced()`
extern "system" fn dummy_pfngldrawtransformfeedbackstreaminstancedproc (_: GLenum, _: GLuint, _: GLuint, _: GLsizei) {
	panic!("OpenGL function pointer `glDrawTransformFeedbackStreamInstanced()` is null.")
}
/// Constant value defined from OpenGL 4.2
pub const GL_COPY_READ_BUFFER_BINDING: GLenum = 0x8F36;

/// Constant value defined from OpenGL 4.2
pub const GL_COPY_WRITE_BUFFER_BINDING: GLenum = 0x8F37;

/// Constant value defined from OpenGL 4.2
pub const GL_TRANSFORM_FEEDBACK_ACTIVE: GLenum = 0x8E24;

/// Constant value defined from OpenGL 4.2
pub const GL_TRANSFORM_FEEDBACK_PAUSED: GLenum = 0x8E23;

/// Constant value defined from OpenGL 4.2
pub const GL_UNPACK_COMPRESSED_BLOCK_WIDTH: GLenum = 0x9127;

/// Constant value defined from OpenGL 4.2
pub const GL_UNPACK_COMPRESSED_BLOCK_HEIGHT: GLenum = 0x9128;

/// Constant value defined from OpenGL 4.2
pub const GL_UNPACK_COMPRESSED_BLOCK_DEPTH: GLenum = 0x9129;

/// Constant value defined from OpenGL 4.2
pub const GL_UNPACK_COMPRESSED_BLOCK_SIZE: GLenum = 0x912A;

/// Constant value defined from OpenGL 4.2
pub const GL_PACK_COMPRESSED_BLOCK_WIDTH: GLenum = 0x912B;

/// Constant value defined from OpenGL 4.2
pub const GL_PACK_COMPRESSED_BLOCK_HEIGHT: GLenum = 0x912C;

/// Constant value defined from OpenGL 4.2
pub const GL_PACK_COMPRESSED_BLOCK_DEPTH: GLenum = 0x912D;

/// Constant value defined from OpenGL 4.2
pub const GL_PACK_COMPRESSED_BLOCK_SIZE: GLenum = 0x912E;

/// Constant value defined from OpenGL 4.2
pub const GL_NUM_SAMPLE_COUNTS: GLenum = 0x9380;

/// Constant value defined from OpenGL 4.2
pub const GL_MIN_MAP_BUFFER_ALIGNMENT: GLenum = 0x90BC;

/// Constant value defined from OpenGL 4.2
pub const GL_ATOMIC_COUNTER_BUFFER: GLenum = 0x92C0;

/// Constant value defined from OpenGL 4.2
pub const GL_ATOMIC_COUNTER_BUFFER_BINDING: GLenum = 0x92C1;

/// Constant value defined from OpenGL 4.2
pub const GL_ATOMIC_COUNTER_BUFFER_START: GLenum = 0x92C2;

/// Constant value defined from OpenGL 4.2
pub const GL_ATOMIC_COUNTER_BUFFER_SIZE: GLenum = 0x92C3;

/// Constant value defined from OpenGL 4.2
pub const GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE: GLenum = 0x92C4;

/// Constant value defined from OpenGL 4.2
pub const GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS: GLenum = 0x92C5;

/// Constant value defined from OpenGL 4.2
pub const GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES: GLenum = 0x92C6;

/// Constant value defined from OpenGL 4.2
pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER: GLenum = 0x92C7;

/// Constant value defined from OpenGL 4.2
pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER: GLenum = 0x92C8;

/// Constant value defined from OpenGL 4.2
pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER: GLenum = 0x92C9;

/// Constant value defined from OpenGL 4.2
pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER: GLenum = 0x92CA;

/// Constant value defined from OpenGL 4.2
pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER: GLenum = 0x92CB;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CC;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CD;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CE;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CF;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92D0;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92D1;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_VERTEX_ATOMIC_COUNTERS: GLenum = 0x92D2;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS: GLenum = 0x92D3;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS: GLenum = 0x92D4;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_GEOMETRY_ATOMIC_COUNTERS: GLenum = 0x92D5;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_FRAGMENT_ATOMIC_COUNTERS: GLenum = 0x92D6;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_COMBINED_ATOMIC_COUNTERS: GLenum = 0x92D7;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE: GLenum = 0x92D8;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS: GLenum = 0x92DC;

/// Constant value defined from OpenGL 4.2
pub const GL_ACTIVE_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92D9;

/// Constant value defined from OpenGL 4.2
pub const GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX: GLenum = 0x92DA;

/// Constant value defined from OpenGL 4.2
pub const GL_UNSIGNED_INT_ATOMIC_COUNTER: GLenum = 0x92DB;

/// Constant value defined from OpenGL 4.2
pub const GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT: GLbitfield = 0x00000001;

/// Constant value defined from OpenGL 4.2
pub const GL_ELEMENT_ARRAY_BARRIER_BIT: GLbitfield = 0x00000002;

/// Constant value defined from OpenGL 4.2
pub const GL_UNIFORM_BARRIER_BIT: GLbitfield = 0x00000004;

/// Constant value defined from OpenGL 4.2
pub const GL_TEXTURE_FETCH_BARRIER_BIT: GLbitfield = 0x00000008;

/// Constant value defined from OpenGL 4.2
pub const GL_SHADER_IMAGE_ACCESS_BARRIER_BIT: GLbitfield = 0x00000020;

/// Constant value defined from OpenGL 4.2
pub const GL_COMMAND_BARRIER_BIT: GLbitfield = 0x00000040;

/// Constant value defined from OpenGL 4.2
pub const GL_PIXEL_BUFFER_BARRIER_BIT: GLbitfield = 0x00000080;

/// Constant value defined from OpenGL 4.2
pub const GL_TEXTURE_UPDATE_BARRIER_BIT: GLbitfield = 0x00000100;

/// Constant value defined from OpenGL 4.2
pub const GL_BUFFER_UPDATE_BARRIER_BIT: GLbitfield = 0x00000200;

/// Constant value defined from OpenGL 4.2
pub const GL_FRAMEBUFFER_BARRIER_BIT: GLbitfield = 0x00000400;

/// Constant value defined from OpenGL 4.2
pub const GL_TRANSFORM_FEEDBACK_BARRIER_BIT: GLbitfield = 0x00000800;

/// Constant value defined from OpenGL 4.2
pub const GL_ATOMIC_COUNTER_BARRIER_BIT: GLbitfield = 0x00001000;

/// Constant value defined from OpenGL 4.2
pub const GL_ALL_BARRIER_BITS: GLbitfield = 0xFFFFFFFF;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_IMAGE_UNITS: GLenum = 0x8F38;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS: GLenum = 0x8F39;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_BINDING_NAME: GLenum = 0x8F3A;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_BINDING_LEVEL: GLenum = 0x8F3B;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_BINDING_LAYERED: GLenum = 0x8F3C;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_BINDING_LAYER: GLenum = 0x8F3D;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_BINDING_ACCESS: GLenum = 0x8F3E;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_1D: GLenum = 0x904C;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_2D: GLenum = 0x904D;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_3D: GLenum = 0x904E;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_2D_RECT: GLenum = 0x904F;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_CUBE: GLenum = 0x9050;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_BUFFER: GLenum = 0x9051;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_1D_ARRAY: GLenum = 0x9052;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_2D_ARRAY: GLenum = 0x9053;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_CUBE_MAP_ARRAY: GLenum = 0x9054;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_2D_MULTISAMPLE: GLenum = 0x9055;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9056;

/// Constant value defined from OpenGL 4.2
pub const GL_INT_IMAGE_1D: GLenum = 0x9057;

/// Constant value defined from OpenGL 4.2
pub const GL_INT_IMAGE_2D: GLenum = 0x9058;

/// Constant value defined from OpenGL 4.2
pub const GL_INT_IMAGE_3D: GLenum = 0x9059;

/// Constant value defined from OpenGL 4.2
pub const GL_INT_IMAGE_2D_RECT: GLenum = 0x905A;

/// Constant value defined from OpenGL 4.2
pub const GL_INT_IMAGE_CUBE: GLenum = 0x905B;

/// Constant value defined from OpenGL 4.2
pub const GL_INT_IMAGE_BUFFER: GLenum = 0x905C;

/// Constant value defined from OpenGL 4.2
pub const GL_INT_IMAGE_1D_ARRAY: GLenum = 0x905D;

/// Constant value defined from OpenGL 4.2
pub const GL_INT_IMAGE_2D_ARRAY: GLenum = 0x905E;

/// Constant value defined from OpenGL 4.2
pub const GL_INT_IMAGE_CUBE_MAP_ARRAY: GLenum = 0x905F;

/// Constant value defined from OpenGL 4.2
pub const GL_INT_IMAGE_2D_MULTISAMPLE: GLenum = 0x9060;

/// Constant value defined from OpenGL 4.2
pub const GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9061;

/// Constant value defined from OpenGL 4.2
pub const GL_UNSIGNED_INT_IMAGE_1D: GLenum = 0x9062;

/// Constant value defined from OpenGL 4.2
pub const GL_UNSIGNED_INT_IMAGE_2D: GLenum = 0x9063;

/// Constant value defined from OpenGL 4.2
pub const GL_UNSIGNED_INT_IMAGE_3D: GLenum = 0x9064;

/// Constant value defined from OpenGL 4.2
pub const GL_UNSIGNED_INT_IMAGE_2D_RECT: GLenum = 0x9065;

/// Constant value defined from OpenGL 4.2
pub const GL_UNSIGNED_INT_IMAGE_CUBE: GLenum = 0x9066;

/// Constant value defined from OpenGL 4.2
pub const GL_UNSIGNED_INT_IMAGE_BUFFER: GLenum = 0x9067;

/// Constant value defined from OpenGL 4.2
pub const GL_UNSIGNED_INT_IMAGE_1D_ARRAY: GLenum = 0x9068;

/// Constant value defined from OpenGL 4.2
pub const GL_UNSIGNED_INT_IMAGE_2D_ARRAY: GLenum = 0x9069;

/// Constant value defined from OpenGL 4.2
pub const GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY: GLenum = 0x906A;

/// Constant value defined from OpenGL 4.2
pub const GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE: GLenum = 0x906B;

/// Constant value defined from OpenGL 4.2
pub const GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY: GLenum = 0x906C;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_IMAGE_SAMPLES: GLenum = 0x906D;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_BINDING_FORMAT: GLenum = 0x906E;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_FORMAT_COMPATIBILITY_TYPE: GLenum = 0x90C7;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE: GLenum = 0x90C8;

/// Constant value defined from OpenGL 4.2
pub const GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS: GLenum = 0x90C9;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_VERTEX_IMAGE_UNIFORMS: GLenum = 0x90CA;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS: GLenum = 0x90CB;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS: GLenum = 0x90CC;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_GEOMETRY_IMAGE_UNIFORMS: GLenum = 0x90CD;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_FRAGMENT_IMAGE_UNIFORMS: GLenum = 0x90CE;

/// Constant value defined from OpenGL 4.2
pub const GL_MAX_COMBINED_IMAGE_UNIFORMS: GLenum = 0x90CF;

/// Constant value defined from OpenGL 4.2
pub const GL_COMPRESSED_RGBA_BPTC_UNORM: GLenum = 0x8E8C;

/// Constant value defined from OpenGL 4.2
pub const GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM: GLenum = 0x8E8D;

/// Constant value defined from OpenGL 4.2
pub const GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT: GLenum = 0x8E8E;

/// Constant value defined from OpenGL 4.2
pub const GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT: GLenum = 0x8E8F;

/// Constant value defined from OpenGL 4.2
pub const GL_TEXTURE_IMMUTABLE_FORMAT: GLenum = 0x912F;

/// Functions from OpenGL version 4.2
pub trait GL_4_2 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	fn glGetError(&self) -> GLenum;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawArraysInstancedBaseInstance.xhtml>
	fn glDrawArraysInstancedBaseInstance(&self, mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei, baseinstance: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseInstance.xhtml>
	fn glDrawElementsInstancedBaseInstance(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei, baseinstance: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertexBaseInstance.xhtml>
	fn glDrawElementsInstancedBaseVertexBaseInstance(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei, basevertex: GLint, baseinstance: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetInternalformativ.xhtml>
	fn glGetInternalformativ(&self, target: GLenum, internalformat: GLenum, pname: GLenum, count: GLsizei, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveAtomicCounterBufferiv.xhtml>
	fn glGetActiveAtomicCounterBufferiv(&self, program: GLuint, bufferIndex: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindImageTexture.xhtml>
	fn glBindImageTexture(&self, unit: GLuint, texture: GLuint, level: GLint, layered: GLboolean, layer: GLint, access: GLenum, format: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml>
	fn glMemoryBarrier(&self, barriers: GLbitfield) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml>
	fn glTexStorage1D(&self, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml>
	fn glTexStorage2D(&self, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml>
	fn glTexStorage3D(&self, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackInstanced.xhtml>
	fn glDrawTransformFeedbackInstanced(&self, mode: GLenum, id: GLuint, instancecount: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStreamInstanced.xhtml>
	fn glDrawTransformFeedbackStreamInstanced(&self, mode: GLenum, id: GLuint, stream: GLuint, instancecount: GLsizei) -> Result<()>;
}
/// Functions from OpenGL version 4.2
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version42 {
	/// Is OpenGL version 4.2 available
	available: bool,

	/// The function pointer to `glGetError()`
	pub geterror: PFNGLGETERRORPROC,

	/// The function pointer to `glDrawArraysInstancedBaseInstance()`
	pub drawarraysinstancedbaseinstance: PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC,

	/// The function pointer to `glDrawElementsInstancedBaseInstance()`
	pub drawelementsinstancedbaseinstance: PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC,

	/// The function pointer to `glDrawElementsInstancedBaseVertexBaseInstance()`
	pub drawelementsinstancedbasevertexbaseinstance: PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC,

	/// The function pointer to `glGetInternalformativ()`
	pub getinternalformativ: PFNGLGETINTERNALFORMATIVPROC,

	/// The function pointer to `glGetActiveAtomicCounterBufferiv()`
	pub getactiveatomiccounterbufferiv: PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC,

	/// The function pointer to `glBindImageTexture()`
	pub bindimagetexture: PFNGLBINDIMAGETEXTUREPROC,

	/// The function pointer to `glMemoryBarrier()`
	pub memorybarrier: PFNGLMEMORYBARRIERPROC,

	/// The function pointer to `glTexStorage1D()`
	pub texstorage1d: PFNGLTEXSTORAGE1DPROC,

	/// The function pointer to `glTexStorage2D()`
	pub texstorage2d: PFNGLTEXSTORAGE2DPROC,

	/// The function pointer to `glTexStorage3D()`
	pub texstorage3d: PFNGLTEXSTORAGE3DPROC,

	/// The function pointer to `glDrawTransformFeedbackInstanced()`
	pub drawtransformfeedbackinstanced: PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC,

	/// The function pointer to `glDrawTransformFeedbackStreamInstanced()`
	pub drawtransformfeedbackstreaminstanced: PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC,
}

impl GL_4_2 for Version42 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawArraysInstancedBaseInstance.xhtml>
	#[inline(always)]
	fn glDrawArraysInstancedBaseInstance(&self, mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei, baseinstance: GLuint) -> Result<()> {
		let ret = process_catch("glDrawArraysInstancedBaseInstance", catch_unwind(||(self.drawarraysinstancedbaseinstance)(mode, first, count, instancecount, baseinstance)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawArraysInstancedBaseInstance", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseInstance.xhtml>
	#[inline(always)]
	fn glDrawElementsInstancedBaseInstance(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei, baseinstance: GLuint) -> Result<()> {
		let ret = process_catch("glDrawElementsInstancedBaseInstance", catch_unwind(||(self.drawelementsinstancedbaseinstance)(mode, count, type_, indices, instancecount, baseinstance)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsInstancedBaseInstance", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertexBaseInstance.xhtml>
	#[inline(always)]
	fn glDrawElementsInstancedBaseVertexBaseInstance(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei, basevertex: GLint, baseinstance: GLuint) -> Result<()> {
		let ret = process_catch("glDrawElementsInstancedBaseVertexBaseInstance", catch_unwind(||(self.drawelementsinstancedbasevertexbaseinstance)(mode, count, type_, indices, instancecount, basevertex, baseinstance)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsInstancedBaseVertexBaseInstance", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetInternalformativ.xhtml>
	#[inline(always)]
	fn glGetInternalformativ(&self, target: GLenum, internalformat: GLenum, pname: GLenum, count: GLsizei, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetInternalformativ", catch_unwind(||(self.getinternalformativ)(target, internalformat, pname, count, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetInternalformativ", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveAtomicCounterBufferiv.xhtml>
	#[inline(always)]
	fn glGetActiveAtomicCounterBufferiv(&self, program: GLuint, bufferIndex: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetActiveAtomicCounterBufferiv", catch_unwind(||(self.getactiveatomiccounterbufferiv)(program, bufferIndex, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveAtomicCounterBufferiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindImageTexture.xhtml>
	#[inline(always)]
	fn glBindImageTexture(&self, unit: GLuint, texture: GLuint, level: GLint, layered: GLboolean, layer: GLint, access: GLenum, format: GLenum) -> Result<()> {
		let ret = process_catch("glBindImageTexture", catch_unwind(||(self.bindimagetexture)(unit, texture, level, layered, layer, access, format)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindImageTexture", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml>
	#[inline(always)]
	fn glMemoryBarrier(&self, barriers: GLbitfield) -> Result<()> {
		let ret = process_catch("glMemoryBarrier", catch_unwind(||(self.memorybarrier)(barriers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMemoryBarrier", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml>
	#[inline(always)]
	fn glTexStorage1D(&self, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei) -> Result<()> {
		let ret = process_catch("glTexStorage1D", catch_unwind(||(self.texstorage1d)(target, levels, internalformat, width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml>
	#[inline(always)]
	fn glTexStorage2D(&self, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glTexStorage2D", catch_unwind(||(self.texstorage2d)(target, levels, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml>
	#[inline(always)]
	fn glTexStorage3D(&self, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei) -> Result<()> {
		let ret = process_catch("glTexStorage3D", catch_unwind(||(self.texstorage3d)(target, levels, internalformat, width, height, depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackInstanced.xhtml>
	#[inline(always)]
	fn glDrawTransformFeedbackInstanced(&self, mode: GLenum, id: GLuint, instancecount: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawTransformFeedbackInstanced", catch_unwind(||(self.drawtransformfeedbackinstanced)(mode, id, instancecount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawTransformFeedbackInstanced", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStreamInstanced.xhtml>
	#[inline(always)]
	fn glDrawTransformFeedbackStreamInstanced(&self, mode: GLenum, id: GLuint, stream: GLuint, instancecount: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawTransformFeedbackStreamInstanced", catch_unwind(||(self.drawtransformfeedbackstreaminstanced)(mode, id, stream, instancecount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawTransformFeedbackStreamInstanced", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version42 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (4, 2, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			drawarraysinstancedbaseinstance: {let proc = get_proc_address("glDrawArraysInstancedBaseInstance"); if proc == null() {dummy_pfngldrawarraysinstancedbaseinstanceproc} else {unsafe{transmute(proc)}}},
			drawelementsinstancedbaseinstance: {let proc = get_proc_address("glDrawElementsInstancedBaseInstance"); if proc == null() {dummy_pfngldrawelementsinstancedbaseinstanceproc} else {unsafe{transmute(proc)}}},
			drawelementsinstancedbasevertexbaseinstance: {let proc = get_proc_address("glDrawElementsInstancedBaseVertexBaseInstance"); if proc == null() {dummy_pfngldrawelementsinstancedbasevertexbaseinstanceproc} else {unsafe{transmute(proc)}}},
			getinternalformativ: {let proc = get_proc_address("glGetInternalformativ"); if proc == null() {dummy_pfnglgetinternalformativproc} else {unsafe{transmute(proc)}}},
			getactiveatomiccounterbufferiv: {let proc = get_proc_address("glGetActiveAtomicCounterBufferiv"); if proc == null() {dummy_pfnglgetactiveatomiccounterbufferivproc} else {unsafe{transmute(proc)}}},
			bindimagetexture: {let proc = get_proc_address("glBindImageTexture"); if proc == null() {dummy_pfnglbindimagetextureproc} else {unsafe{transmute(proc)}}},
			memorybarrier: {let proc = get_proc_address("glMemoryBarrier"); if proc == null() {dummy_pfnglmemorybarrierproc} else {unsafe{transmute(proc)}}},
			texstorage1d: {let proc = get_proc_address("glTexStorage1D"); if proc == null() {dummy_pfngltexstorage1dproc} else {unsafe{transmute(proc)}}},
			texstorage2d: {let proc = get_proc_address("glTexStorage2D"); if proc == null() {dummy_pfngltexstorage2dproc} else {unsafe{transmute(proc)}}},
			texstorage3d: {let proc = get_proc_address("glTexStorage3D"); if proc == null() {dummy_pfngltexstorage3dproc} else {unsafe{transmute(proc)}}},
			drawtransformfeedbackinstanced: {let proc = get_proc_address("glDrawTransformFeedbackInstanced"); if proc == null() {dummy_pfngldrawtransformfeedbackinstancedproc} else {unsafe{transmute(proc)}}},
			drawtransformfeedbackstreaminstanced: {let proc = get_proc_address("glDrawTransformFeedbackStreamInstanced"); if proc == null() {dummy_pfngldrawtransformfeedbackstreaminstancedproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version42 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			drawarraysinstancedbaseinstance: dummy_pfngldrawarraysinstancedbaseinstanceproc,
			drawelementsinstancedbaseinstance: dummy_pfngldrawelementsinstancedbaseinstanceproc,
			drawelementsinstancedbasevertexbaseinstance: dummy_pfngldrawelementsinstancedbasevertexbaseinstanceproc,
			getinternalformativ: dummy_pfnglgetinternalformativproc,
			getactiveatomiccounterbufferiv: dummy_pfnglgetactiveatomiccounterbufferivproc,
			bindimagetexture: dummy_pfnglbindimagetextureproc,
			memorybarrier: dummy_pfnglmemorybarrierproc,
			texstorage1d: dummy_pfngltexstorage1dproc,
			texstorage2d: dummy_pfngltexstorage2dproc,
			texstorage3d: dummy_pfngltexstorage3dproc,
			drawtransformfeedbackinstanced: dummy_pfngldrawtransformfeedbackinstancedproc,
			drawtransformfeedbackstreaminstanced: dummy_pfngldrawtransformfeedbackstreaminstancedproc,
		}
	}
}
impl Debug for Version42 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version42")
			.field("available", &self.available)
			.field("drawarraysinstancedbaseinstance", unsafe{if transmute::<_, *const c_void>(self.drawarraysinstancedbaseinstance) == (dummy_pfngldrawarraysinstancedbaseinstanceproc as *const c_void) {&null::<PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC>()} else {&self.drawarraysinstancedbaseinstance}})
			.field("drawelementsinstancedbaseinstance", unsafe{if transmute::<_, *const c_void>(self.drawelementsinstancedbaseinstance) == (dummy_pfngldrawelementsinstancedbaseinstanceproc as *const c_void) {&null::<PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC>()} else {&self.drawelementsinstancedbaseinstance}})
			.field("drawelementsinstancedbasevertexbaseinstance", unsafe{if transmute::<_, *const c_void>(self.drawelementsinstancedbasevertexbaseinstance) == (dummy_pfngldrawelementsinstancedbasevertexbaseinstanceproc as *const c_void) {&null::<PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC>()} else {&self.drawelementsinstancedbasevertexbaseinstance}})
			.field("getinternalformativ", unsafe{if transmute::<_, *const c_void>(self.getinternalformativ) == (dummy_pfnglgetinternalformativproc as *const c_void) {&null::<PFNGLGETINTERNALFORMATIVPROC>()} else {&self.getinternalformativ}})
			.field("getactiveatomiccounterbufferiv", unsafe{if transmute::<_, *const c_void>(self.getactiveatomiccounterbufferiv) == (dummy_pfnglgetactiveatomiccounterbufferivproc as *const c_void) {&null::<PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC>()} else {&self.getactiveatomiccounterbufferiv}})
			.field("bindimagetexture", unsafe{if transmute::<_, *const c_void>(self.bindimagetexture) == (dummy_pfnglbindimagetextureproc as *const c_void) {&null::<PFNGLBINDIMAGETEXTUREPROC>()} else {&self.bindimagetexture}})
			.field("memorybarrier", unsafe{if transmute::<_, *const c_void>(self.memorybarrier) == (dummy_pfnglmemorybarrierproc as *const c_void) {&null::<PFNGLMEMORYBARRIERPROC>()} else {&self.memorybarrier}})
			.field("texstorage1d", unsafe{if transmute::<_, *const c_void>(self.texstorage1d) == (dummy_pfngltexstorage1dproc as *const c_void) {&null::<PFNGLTEXSTORAGE1DPROC>()} else {&self.texstorage1d}})
			.field("texstorage2d", unsafe{if transmute::<_, *const c_void>(self.texstorage2d) == (dummy_pfngltexstorage2dproc as *const c_void) {&null::<PFNGLTEXSTORAGE2DPROC>()} else {&self.texstorage2d}})
			.field("texstorage3d", unsafe{if transmute::<_, *const c_void>(self.texstorage3d) == (dummy_pfngltexstorage3dproc as *const c_void) {&null::<PFNGLTEXSTORAGE3DPROC>()} else {&self.texstorage3d}})
			.field("drawtransformfeedbackinstanced", unsafe{if transmute::<_, *const c_void>(self.drawtransformfeedbackinstanced) == (dummy_pfngldrawtransformfeedbackinstancedproc as *const c_void) {&null::<PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC>()} else {&self.drawtransformfeedbackinstanced}})
			.field("drawtransformfeedbackstreaminstanced", unsafe{if transmute::<_, *const c_void>(self.drawtransformfeedbackstreaminstanced) == (dummy_pfngldrawtransformfeedbackstreaminstancedproc as *const c_void) {&null::<PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC>()} else {&self.drawtransformfeedbackstreaminstanced}})
			.finish()
		} else {
			f.debug_struct("Version42")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

/// The prototype to the OpenGL function `ClearBufferData`
type PFNGLCLEARBUFFERDATAPROC = extern "system" fn(GLenum, GLenum, GLenum, GLenum, *const c_void);

/// The prototype to the OpenGL function `ClearBufferSubData`
type PFNGLCLEARBUFFERSUBDATAPROC = extern "system" fn(GLenum, GLenum, GLintptr, GLsizeiptr, GLenum, GLenum, *const c_void);

/// The prototype to the OpenGL function `DispatchCompute`
type PFNGLDISPATCHCOMPUTEPROC = extern "system" fn(GLuint, GLuint, GLuint);

/// The prototype to the OpenGL function `DispatchComputeIndirect`
type PFNGLDISPATCHCOMPUTEINDIRECTPROC = extern "system" fn(GLintptr);

/// The prototype to the OpenGL function `CopyImageSubData`
type PFNGLCOPYIMAGESUBDATAPROC = extern "system" fn(GLuint, GLenum, GLint, GLint, GLint, GLint, GLuint, GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei);

/// The prototype to the OpenGL function `FramebufferParameteri`
type PFNGLFRAMEBUFFERPARAMETERIPROC = extern "system" fn(GLenum, GLenum, GLint);

/// The prototype to the OpenGL function `GetFramebufferParameteriv`
type PFNGLGETFRAMEBUFFERPARAMETERIVPROC = extern "system" fn(GLenum, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetInternalformati64v`
type PFNGLGETINTERNALFORMATI64VPROC = extern "system" fn(GLenum, GLenum, GLenum, GLsizei, *mut GLint64);

/// The prototype to the OpenGL function `InvalidateTexSubImage`
type PFNGLINVALIDATETEXSUBIMAGEPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei);

/// The prototype to the OpenGL function `InvalidateTexImage`
type PFNGLINVALIDATETEXIMAGEPROC = extern "system" fn(GLuint, GLint);

/// The prototype to the OpenGL function `InvalidateBufferSubData`
type PFNGLINVALIDATEBUFFERSUBDATAPROC = extern "system" fn(GLuint, GLintptr, GLsizeiptr);

/// The prototype to the OpenGL function `InvalidateBufferData`
type PFNGLINVALIDATEBUFFERDATAPROC = extern "system" fn(GLuint);

/// The prototype to the OpenGL function `InvalidateFramebuffer`
type PFNGLINVALIDATEFRAMEBUFFERPROC = extern "system" fn(GLenum, GLsizei, *const GLenum);

/// The prototype to the OpenGL function `InvalidateSubFramebuffer`
type PFNGLINVALIDATESUBFRAMEBUFFERPROC = extern "system" fn(GLenum, GLsizei, *const GLenum, GLint, GLint, GLsizei, GLsizei);

/// The prototype to the OpenGL function `MultiDrawArraysIndirect`
type PFNGLMULTIDRAWARRAYSINDIRECTPROC = extern "system" fn(GLenum, *const c_void, GLsizei, GLsizei);

/// The prototype to the OpenGL function `MultiDrawElementsIndirect`
type PFNGLMULTIDRAWELEMENTSINDIRECTPROC = extern "system" fn(GLenum, GLenum, *const c_void, GLsizei, GLsizei);

/// The prototype to the OpenGL function `GetProgramInterfaceiv`
type PFNGLGETPROGRAMINTERFACEIVPROC = extern "system" fn(GLuint, GLenum, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetProgramResourceIndex`
type PFNGLGETPROGRAMRESOURCEINDEXPROC = extern "system" fn(GLuint, GLenum, *const GLchar) -> GLuint;

/// The prototype to the OpenGL function `GetProgramResourceName`
type PFNGLGETPROGRAMRESOURCENAMEPROC = extern "system" fn(GLuint, GLenum, GLuint, GLsizei, *mut GLsizei, *mut GLchar);

/// The prototype to the OpenGL function `GetProgramResourceiv`
type PFNGLGETPROGRAMRESOURCEIVPROC = extern "system" fn(GLuint, GLenum, GLuint, GLsizei, *const GLenum, GLsizei, *mut GLsizei, *mut GLint);

/// The prototype to the OpenGL function `GetProgramResourceLocation`
type PFNGLGETPROGRAMRESOURCELOCATIONPROC = extern "system" fn(GLuint, GLenum, *const GLchar) -> GLint;

/// The prototype to the OpenGL function `GetProgramResourceLocationIndex`
type PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC = extern "system" fn(GLuint, GLenum, *const GLchar) -> GLint;

/// The prototype to the OpenGL function `ShaderStorageBlockBinding`
type PFNGLSHADERSTORAGEBLOCKBINDINGPROC = extern "system" fn(GLuint, GLuint, GLuint);

/// The prototype to the OpenGL function `TexBufferRange`
type PFNGLTEXBUFFERRANGEPROC = extern "system" fn(GLenum, GLenum, GLuint, GLintptr, GLsizeiptr);

/// The prototype to the OpenGL function `TexStorage2DMultisample`
type PFNGLTEXSTORAGE2DMULTISAMPLEPROC = extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLboolean);

/// The prototype to the OpenGL function `TexStorage3DMultisample`
type PFNGLTEXSTORAGE3DMULTISAMPLEPROC = extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei, GLboolean);

/// The prototype to the OpenGL function `TextureView`
type PFNGLTEXTUREVIEWPROC = extern "system" fn(GLuint, GLenum, GLuint, GLenum, GLuint, GLuint, GLuint, GLuint);

/// The prototype to the OpenGL function `BindVertexBuffer`
type PFNGLBINDVERTEXBUFFERPROC = extern "system" fn(GLuint, GLuint, GLintptr, GLsizei);

/// The prototype to the OpenGL function `VertexAttribFormat`
type PFNGLVERTEXATTRIBFORMATPROC = extern "system" fn(GLuint, GLint, GLenum, GLboolean, GLuint);

/// The prototype to the OpenGL function `VertexAttribIFormat`
type PFNGLVERTEXATTRIBIFORMATPROC = extern "system" fn(GLuint, GLint, GLenum, GLuint);

/// The prototype to the OpenGL function `VertexAttribLFormat`
type PFNGLVERTEXATTRIBLFORMATPROC = extern "system" fn(GLuint, GLint, GLenum, GLuint);

/// The prototype to the OpenGL function `VertexAttribBinding`
type PFNGLVERTEXATTRIBBINDINGPROC = extern "system" fn(GLuint, GLuint);

/// The prototype to the OpenGL function `VertexBindingDivisor`
type PFNGLVERTEXBINDINGDIVISORPROC = extern "system" fn(GLuint, GLuint);

/// The prototype to the OpenGL function `DebugMessageControl`
type PFNGLDEBUGMESSAGECONTROLPROC = extern "system" fn(GLenum, GLenum, GLenum, GLsizei, *const GLuint, GLboolean);

/// The prototype to the OpenGL function `DebugMessageInsert`
type PFNGLDEBUGMESSAGEINSERTPROC = extern "system" fn(GLenum, GLenum, GLuint, GLenum, GLsizei, *const GLchar);

/// The prototype to the OpenGL function `DebugMessageCallback`
type PFNGLDEBUGMESSAGECALLBACKPROC = extern "system" fn(GLDEBUGPROC, *const c_void);

/// The prototype to the OpenGL function `GetDebugMessageLog`
type PFNGLGETDEBUGMESSAGELOGPROC = extern "system" fn(GLuint, GLsizei, *mut GLenum, *mut GLenum, *mut GLuint, *mut GLenum, *mut GLsizei, *mut GLchar) -> GLuint;

/// The prototype to the OpenGL function `PushDebugGroup`
type PFNGLPUSHDEBUGGROUPPROC = extern "system" fn(GLenum, GLuint, GLsizei, *const GLchar);

/// The prototype to the OpenGL function `PopDebugGroup`
type PFNGLPOPDEBUGGROUPPROC = extern "system" fn();

/// The prototype to the OpenGL function `ObjectLabel`
type PFNGLOBJECTLABELPROC = extern "system" fn(GLenum, GLuint, GLsizei, *const GLchar);

/// The prototype to the OpenGL function `GetObjectLabel`
type PFNGLGETOBJECTLABELPROC = extern "system" fn(GLenum, GLuint, GLsizei, *mut GLsizei, *mut GLchar);

/// The prototype to the OpenGL function `ObjectPtrLabel`
type PFNGLOBJECTPTRLABELPROC = extern "system" fn(*const c_void, GLsizei, *const GLchar);

/// The prototype to the OpenGL function `GetObjectPtrLabel`
type PFNGLGETOBJECTPTRLABELPROC = extern "system" fn(*const c_void, GLsizei, *mut GLsizei, *mut GLchar);

/// The dummy function of `ClearBufferData()`
extern "system" fn dummy_pfnglclearbufferdataproc (_: GLenum, _: GLenum, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glClearBufferData()` is null.")
}

/// The dummy function of `ClearBufferSubData()`
extern "system" fn dummy_pfnglclearbuffersubdataproc (_: GLenum, _: GLenum, _: GLintptr, _: GLsizeiptr, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glClearBufferSubData()` is null.")
}

/// The dummy function of `DispatchCompute()`
extern "system" fn dummy_pfngldispatchcomputeproc (_: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glDispatchCompute()` is null.")
}

/// The dummy function of `DispatchComputeIndirect()`
extern "system" fn dummy_pfngldispatchcomputeindirectproc (_: GLintptr) {
	panic!("OpenGL function pointer `glDispatchComputeIndirect()` is null.")
}

/// The dummy function of `CopyImageSubData()`
extern "system" fn dummy_pfnglcopyimagesubdataproc (_: GLuint, _: GLenum, _: GLint, _: GLint, _: GLint, _: GLint, _: GLuint, _: GLenum, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glCopyImageSubData()` is null.")
}

/// The dummy function of `FramebufferParameteri()`
extern "system" fn dummy_pfnglframebufferparameteriproc (_: GLenum, _: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glFramebufferParameteri()` is null.")
}

/// The dummy function of `GetFramebufferParameteriv()`
extern "system" fn dummy_pfnglgetframebufferparameterivproc (_: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetFramebufferParameteriv()` is null.")
}

/// The dummy function of `GetInternalformati64v()`
extern "system" fn dummy_pfnglgetinternalformati64vproc (_: GLenum, _: GLenum, _: GLenum, _: GLsizei, _: *mut GLint64) {
	panic!("OpenGL function pointer `glGetInternalformati64v()` is null.")
}

/// The dummy function of `InvalidateTexSubImage()`
extern "system" fn dummy_pfnglinvalidatetexsubimageproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glInvalidateTexSubImage()` is null.")
}

/// The dummy function of `InvalidateTexImage()`
extern "system" fn dummy_pfnglinvalidateteximageproc (_: GLuint, _: GLint) {
	panic!("OpenGL function pointer `glInvalidateTexImage()` is null.")
}

/// The dummy function of `InvalidateBufferSubData()`
extern "system" fn dummy_pfnglinvalidatebuffersubdataproc (_: GLuint, _: GLintptr, _: GLsizeiptr) {
	panic!("OpenGL function pointer `glInvalidateBufferSubData()` is null.")
}

/// The dummy function of `InvalidateBufferData()`
extern "system" fn dummy_pfnglinvalidatebufferdataproc (_: GLuint) {
	panic!("OpenGL function pointer `glInvalidateBufferData()` is null.")
}

/// The dummy function of `InvalidateFramebuffer()`
extern "system" fn dummy_pfnglinvalidateframebufferproc (_: GLenum, _: GLsizei, _: *const GLenum) {
	panic!("OpenGL function pointer `glInvalidateFramebuffer()` is null.")
}

/// The dummy function of `InvalidateSubFramebuffer()`
extern "system" fn dummy_pfnglinvalidatesubframebufferproc (_: GLenum, _: GLsizei, _: *const GLenum, _: GLint, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glInvalidateSubFramebuffer()` is null.")
}

/// The dummy function of `MultiDrawArraysIndirect()`
extern "system" fn dummy_pfnglmultidrawarraysindirectproc (_: GLenum, _: *const c_void, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glMultiDrawArraysIndirect()` is null.")
}

/// The dummy function of `MultiDrawElementsIndirect()`
extern "system" fn dummy_pfnglmultidrawelementsindirectproc (_: GLenum, _: GLenum, _: *const c_void, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glMultiDrawElementsIndirect()` is null.")
}

/// The dummy function of `GetProgramInterfaceiv()`
extern "system" fn dummy_pfnglgetprograminterfaceivproc (_: GLuint, _: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetProgramInterfaceiv()` is null.")
}

/// The dummy function of `GetProgramResourceIndex()`
extern "system" fn dummy_pfnglgetprogramresourceindexproc (_: GLuint, _: GLenum, _: *const GLchar) -> GLuint {
	panic!("OpenGL function pointer `glGetProgramResourceIndex()` is null.")
}

/// The dummy function of `GetProgramResourceName()`
extern "system" fn dummy_pfnglgetprogramresourcenameproc (_: GLuint, _: GLenum, _: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetProgramResourceName()` is null.")
}

/// The dummy function of `GetProgramResourceiv()`
extern "system" fn dummy_pfnglgetprogramresourceivproc (_: GLuint, _: GLenum, _: GLuint, _: GLsizei, _: *const GLenum, _: GLsizei, _: *mut GLsizei, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetProgramResourceiv()` is null.")
}

/// The dummy function of `GetProgramResourceLocation()`
extern "system" fn dummy_pfnglgetprogramresourcelocationproc (_: GLuint, _: GLenum, _: *const GLchar) -> GLint {
	panic!("OpenGL function pointer `glGetProgramResourceLocation()` is null.")
}

/// The dummy function of `GetProgramResourceLocationIndex()`
extern "system" fn dummy_pfnglgetprogramresourcelocationindexproc (_: GLuint, _: GLenum, _: *const GLchar) -> GLint {
	panic!("OpenGL function pointer `glGetProgramResourceLocationIndex()` is null.")
}

/// The dummy function of `ShaderStorageBlockBinding()`
extern "system" fn dummy_pfnglshaderstorageblockbindingproc (_: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glShaderStorageBlockBinding()` is null.")
}

/// The dummy function of `TexBufferRange()`
extern "system" fn dummy_pfngltexbufferrangeproc (_: GLenum, _: GLenum, _: GLuint, _: GLintptr, _: GLsizeiptr) {
	panic!("OpenGL function pointer `glTexBufferRange()` is null.")
}

/// The dummy function of `TexStorage2DMultisample()`
extern "system" fn dummy_pfngltexstorage2dmultisampleproc (_: GLenum, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei, _: GLboolean) {
	panic!("OpenGL function pointer `glTexStorage2DMultisample()` is null.")
}

/// The dummy function of `TexStorage3DMultisample()`
extern "system" fn dummy_pfngltexstorage3dmultisampleproc (_: GLenum, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei, _: GLsizei, _: GLboolean) {
	panic!("OpenGL function pointer `glTexStorage3DMultisample()` is null.")
}

/// The dummy function of `TextureView()`
extern "system" fn dummy_pfngltextureviewproc (_: GLuint, _: GLenum, _: GLuint, _: GLenum, _: GLuint, _: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glTextureView()` is null.")
}

/// The dummy function of `BindVertexBuffer()`
extern "system" fn dummy_pfnglbindvertexbufferproc (_: GLuint, _: GLuint, _: GLintptr, _: GLsizei) {
	panic!("OpenGL function pointer `glBindVertexBuffer()` is null.")
}

/// The dummy function of `VertexAttribFormat()`
extern "system" fn dummy_pfnglvertexattribformatproc (_: GLuint, _: GLint, _: GLenum, _: GLboolean, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribFormat()` is null.")
}

/// The dummy function of `VertexAttribIFormat()`
extern "system" fn dummy_pfnglvertexattribiformatproc (_: GLuint, _: GLint, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribIFormat()` is null.")
}

/// The dummy function of `VertexAttribLFormat()`
extern "system" fn dummy_pfnglvertexattriblformatproc (_: GLuint, _: GLint, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribLFormat()` is null.")
}

/// The dummy function of `VertexAttribBinding()`
extern "system" fn dummy_pfnglvertexattribbindingproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribBinding()` is null.")
}

/// The dummy function of `VertexBindingDivisor()`
extern "system" fn dummy_pfnglvertexbindingdivisorproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexBindingDivisor()` is null.")
}

/// The dummy function of `DebugMessageControl()`
extern "system" fn dummy_pfngldebugmessagecontrolproc (_: GLenum, _: GLenum, _: GLenum, _: GLsizei, _: *const GLuint, _: GLboolean) {
	panic!("OpenGL function pointer `glDebugMessageControl()` is null.")
}

/// The dummy function of `DebugMessageInsert()`
extern "system" fn dummy_pfngldebugmessageinsertproc (_: GLenum, _: GLenum, _: GLuint, _: GLenum, _: GLsizei, _: *const GLchar) {
	panic!("OpenGL function pointer `glDebugMessageInsert()` is null.")
}

/// The dummy function of `DebugMessageCallback()`
extern "system" fn dummy_pfngldebugmessagecallbackproc (_: GLDEBUGPROC, _: *const c_void) {
	panic!("OpenGL function pointer `glDebugMessageCallback()` is null.")
}

/// The dummy function of `GetDebugMessageLog()`
extern "system" fn dummy_pfnglgetdebugmessagelogproc (_: GLuint, _: GLsizei, _: *mut GLenum, _: *mut GLenum, _: *mut GLuint, _: *mut GLenum, _: *mut GLsizei, _: *mut GLchar) -> GLuint {
	panic!("OpenGL function pointer `glGetDebugMessageLog()` is null.")
}

/// The dummy function of `PushDebugGroup()`
extern "system" fn dummy_pfnglpushdebuggroupproc (_: GLenum, _: GLuint, _: GLsizei, _: *const GLchar) {
	panic!("OpenGL function pointer `glPushDebugGroup()` is null.")
}

/// The dummy function of `PopDebugGroup()`
extern "system" fn dummy_pfnglpopdebuggroupproc () {
	panic!("OpenGL function pointer `glPopDebugGroup()` is null.")
}

/// The dummy function of `ObjectLabel()`
extern "system" fn dummy_pfnglobjectlabelproc (_: GLenum, _: GLuint, _: GLsizei, _: *const GLchar) {
	panic!("OpenGL function pointer `glObjectLabel()` is null.")
}

/// The dummy function of `GetObjectLabel()`
extern "system" fn dummy_pfnglgetobjectlabelproc (_: GLenum, _: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetObjectLabel()` is null.")
}

/// The dummy function of `ObjectPtrLabel()`
extern "system" fn dummy_pfnglobjectptrlabelproc (_: *const c_void, _: GLsizei, _: *const GLchar) {
	panic!("OpenGL function pointer `glObjectPtrLabel()` is null.")
}

/// The dummy function of `GetObjectPtrLabel()`
extern "system" fn dummy_pfnglgetobjectptrlabelproc (_: *const c_void, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetObjectPtrLabel()` is null.")
}
/// Constant value defined from OpenGL 4.3
pub const GL_NUM_SHADING_LANGUAGE_VERSIONS: GLenum = 0x82E9;

/// Constant value defined from OpenGL 4.3
pub const GL_VERTEX_ATTRIB_ARRAY_LONG: GLenum = 0x874E;

/// Constant value defined from OpenGL 4.3
pub const GL_COMPRESSED_RGB8_ETC2: GLenum = 0x9274;

/// Constant value defined from OpenGL 4.3
pub const GL_COMPRESSED_SRGB8_ETC2: GLenum = 0x9275;

/// Constant value defined from OpenGL 4.3
pub const GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: GLenum = 0x9276;

/// Constant value defined from OpenGL 4.3
pub const GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: GLenum = 0x9277;

/// Constant value defined from OpenGL 4.3
pub const GL_COMPRESSED_RGBA8_ETC2_EAC: GLenum = 0x9278;

/// Constant value defined from OpenGL 4.3
pub const GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: GLenum = 0x9279;

/// Constant value defined from OpenGL 4.3
pub const GL_COMPRESSED_R11_EAC: GLenum = 0x9270;

/// Constant value defined from OpenGL 4.3
pub const GL_COMPRESSED_SIGNED_R11_EAC: GLenum = 0x9271;

/// Constant value defined from OpenGL 4.3
pub const GL_COMPRESSED_RG11_EAC: GLenum = 0x9272;

/// Constant value defined from OpenGL 4.3
pub const GL_COMPRESSED_SIGNED_RG11_EAC: GLenum = 0x9273;

/// Constant value defined from OpenGL 4.3
pub const GL_PRIMITIVE_RESTART_FIXED_INDEX: GLenum = 0x8D69;

/// Constant value defined from OpenGL 4.3
pub const GL_ANY_SAMPLES_PASSED_CONSERVATIVE: GLenum = 0x8D6A;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_ELEMENT_INDEX: GLenum = 0x8D6B;

/// Constant value defined from OpenGL 4.3
pub const GL_COMPUTE_SHADER: GLenum = 0x91B9;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_COMPUTE_UNIFORM_BLOCKS: GLenum = 0x91BB;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS: GLenum = 0x91BC;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_COMPUTE_IMAGE_UNIFORMS: GLenum = 0x91BD;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_COMPUTE_SHARED_MEMORY_SIZE: GLenum = 0x8262;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_COMPUTE_UNIFORM_COMPONENTS: GLenum = 0x8263;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS: GLenum = 0x8264;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_COMPUTE_ATOMIC_COUNTERS: GLenum = 0x8265;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS: GLenum = 0x8266;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS: GLenum = 0x90EB;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_COMPUTE_WORK_GROUP_COUNT: GLenum = 0x91BE;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_COMPUTE_WORK_GROUP_SIZE: GLenum = 0x91BF;

/// Constant value defined from OpenGL 4.3
pub const GL_COMPUTE_WORK_GROUP_SIZE: GLenum = 0x8267;

/// Constant value defined from OpenGL 4.3
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER: GLenum = 0x90EC;

/// Constant value defined from OpenGL 4.3
pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER: GLenum = 0x90ED;

/// Constant value defined from OpenGL 4.3
pub const GL_DISPATCH_INDIRECT_BUFFER: GLenum = 0x90EE;

/// Constant value defined from OpenGL 4.3
pub const GL_DISPATCH_INDIRECT_BUFFER_BINDING: GLenum = 0x90EF;

/// Constant value defined from OpenGL 4.3
pub const GL_COMPUTE_SHADER_BIT: GLbitfield = 0x00000020;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_OUTPUT_SYNCHRONOUS: GLenum = 0x8242;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH: GLenum = 0x8243;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_CALLBACK_FUNCTION: GLenum = 0x8244;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_CALLBACK_USER_PARAM: GLenum = 0x8245;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_SOURCE_API: GLenum = 0x8246;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_SOURCE_WINDOW_SYSTEM: GLenum = 0x8247;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_SOURCE_SHADER_COMPILER: GLenum = 0x8248;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_SOURCE_THIRD_PARTY: GLenum = 0x8249;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_SOURCE_APPLICATION: GLenum = 0x824A;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_SOURCE_OTHER: GLenum = 0x824B;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_TYPE_ERROR: GLenum = 0x824C;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: GLenum = 0x824D;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: GLenum = 0x824E;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_TYPE_PORTABILITY: GLenum = 0x824F;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_TYPE_PERFORMANCE: GLenum = 0x8250;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_TYPE_OTHER: GLenum = 0x8251;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_DEBUG_MESSAGE_LENGTH: GLenum = 0x9143;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_DEBUG_LOGGED_MESSAGES: GLenum = 0x9144;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_LOGGED_MESSAGES: GLenum = 0x9145;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_SEVERITY_HIGH: GLenum = 0x9146;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_SEVERITY_MEDIUM: GLenum = 0x9147;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_SEVERITY_LOW: GLenum = 0x9148;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_TYPE_MARKER: GLenum = 0x8268;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_TYPE_PUSH_GROUP: GLenum = 0x8269;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_TYPE_POP_GROUP: GLenum = 0x826A;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_SEVERITY_NOTIFICATION: GLenum = 0x826B;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_DEBUG_GROUP_STACK_DEPTH: GLenum = 0x826C;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_GROUP_STACK_DEPTH: GLenum = 0x826D;

/// Constant value defined from OpenGL 4.3
pub const GL_BUFFER: GLenum = 0x82E0;

/// Constant value defined from OpenGL 4.3
pub const GL_SHADER: GLenum = 0x82E1;

/// Constant value defined from OpenGL 4.3
pub const GL_PROGRAM: GLenum = 0x82E2;

/// Constant value defined from OpenGL 4.3
pub const GL_QUERY: GLenum = 0x82E3;

/// Constant value defined from OpenGL 4.3
pub const GL_PROGRAM_PIPELINE: GLenum = 0x82E4;

/// Constant value defined from OpenGL 4.3
pub const GL_SAMPLER: GLenum = 0x82E6;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_LABEL_LENGTH: GLenum = 0x82E8;

/// Constant value defined from OpenGL 4.3
pub const GL_DEBUG_OUTPUT: GLenum = 0x92E0;

/// Constant value defined from OpenGL 4.3
pub const GL_CONTEXT_FLAG_DEBUG_BIT: GLbitfield = 0x00000002;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_UNIFORM_LOCATIONS: GLenum = 0x826E;

/// Constant value defined from OpenGL 4.3
pub const GL_FRAMEBUFFER_DEFAULT_WIDTH: GLenum = 0x9310;

/// Constant value defined from OpenGL 4.3
pub const GL_FRAMEBUFFER_DEFAULT_HEIGHT: GLenum = 0x9311;

/// Constant value defined from OpenGL 4.3
pub const GL_FRAMEBUFFER_DEFAULT_LAYERS: GLenum = 0x9312;

/// Constant value defined from OpenGL 4.3
pub const GL_FRAMEBUFFER_DEFAULT_SAMPLES: GLenum = 0x9313;

/// Constant value defined from OpenGL 4.3
pub const GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS: GLenum = 0x9314;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_FRAMEBUFFER_WIDTH: GLenum = 0x9315;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_FRAMEBUFFER_HEIGHT: GLenum = 0x9316;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_FRAMEBUFFER_LAYERS: GLenum = 0x9317;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_FRAMEBUFFER_SAMPLES: GLenum = 0x9318;

/// Constant value defined from OpenGL 4.3
pub const GL_INTERNALFORMAT_SUPPORTED: GLenum = 0x826F;

/// Constant value defined from OpenGL 4.3
pub const GL_INTERNALFORMAT_PREFERRED: GLenum = 0x8270;

/// Constant value defined from OpenGL 4.3
pub const GL_INTERNALFORMAT_RED_SIZE: GLenum = 0x8271;

/// Constant value defined from OpenGL 4.3
pub const GL_INTERNALFORMAT_GREEN_SIZE: GLenum = 0x8272;

/// Constant value defined from OpenGL 4.3
pub const GL_INTERNALFORMAT_BLUE_SIZE: GLenum = 0x8273;

/// Constant value defined from OpenGL 4.3
pub const GL_INTERNALFORMAT_ALPHA_SIZE: GLenum = 0x8274;

/// Constant value defined from OpenGL 4.3
pub const GL_INTERNALFORMAT_DEPTH_SIZE: GLenum = 0x8275;

/// Constant value defined from OpenGL 4.3
pub const GL_INTERNALFORMAT_STENCIL_SIZE: GLenum = 0x8276;

/// Constant value defined from OpenGL 4.3
pub const GL_INTERNALFORMAT_SHARED_SIZE: GLenum = 0x8277;

/// Constant value defined from OpenGL 4.3
pub const GL_INTERNALFORMAT_RED_TYPE: GLenum = 0x8278;

/// Constant value defined from OpenGL 4.3
pub const GL_INTERNALFORMAT_GREEN_TYPE: GLenum = 0x8279;

/// Constant value defined from OpenGL 4.3
pub const GL_INTERNALFORMAT_BLUE_TYPE: GLenum = 0x827A;

/// Constant value defined from OpenGL 4.3
pub const GL_INTERNALFORMAT_ALPHA_TYPE: GLenum = 0x827B;

/// Constant value defined from OpenGL 4.3
pub const GL_INTERNALFORMAT_DEPTH_TYPE: GLenum = 0x827C;

/// Constant value defined from OpenGL 4.3
pub const GL_INTERNALFORMAT_STENCIL_TYPE: GLenum = 0x827D;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_WIDTH: GLenum = 0x827E;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_HEIGHT: GLenum = 0x827F;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_DEPTH: GLenum = 0x8280;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_LAYERS: GLenum = 0x8281;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_COMBINED_DIMENSIONS: GLenum = 0x8282;

/// Constant value defined from OpenGL 4.3
pub const GL_COLOR_COMPONENTS: GLenum = 0x8283;

/// Constant value defined from OpenGL 4.3
pub const GL_DEPTH_COMPONENTS: GLenum = 0x8284;

/// Constant value defined from OpenGL 4.3
pub const GL_STENCIL_COMPONENTS: GLenum = 0x8285;

/// Constant value defined from OpenGL 4.3
pub const GL_COLOR_RENDERABLE: GLenum = 0x8286;

/// Constant value defined from OpenGL 4.3
pub const GL_DEPTH_RENDERABLE: GLenum = 0x8287;

/// Constant value defined from OpenGL 4.3
pub const GL_STENCIL_RENDERABLE: GLenum = 0x8288;

/// Constant value defined from OpenGL 4.3
pub const GL_FRAMEBUFFER_RENDERABLE: GLenum = 0x8289;

/// Constant value defined from OpenGL 4.3
pub const GL_FRAMEBUFFER_RENDERABLE_LAYERED: GLenum = 0x828A;

/// Constant value defined from OpenGL 4.3
pub const GL_FRAMEBUFFER_BLEND: GLenum = 0x828B;

/// Constant value defined from OpenGL 4.3
pub const GL_READ_PIXELS: GLenum = 0x828C;

/// Constant value defined from OpenGL 4.3
pub const GL_READ_PIXELS_FORMAT: GLenum = 0x828D;

/// Constant value defined from OpenGL 4.3
pub const GL_READ_PIXELS_TYPE: GLenum = 0x828E;

/// Constant value defined from OpenGL 4.3
pub const GL_TEXTURE_IMAGE_FORMAT: GLenum = 0x828F;

/// Constant value defined from OpenGL 4.3
pub const GL_TEXTURE_IMAGE_TYPE: GLenum = 0x8290;

/// Constant value defined from OpenGL 4.3
pub const GL_GET_TEXTURE_IMAGE_FORMAT: GLenum = 0x8291;

/// Constant value defined from OpenGL 4.3
pub const GL_GET_TEXTURE_IMAGE_TYPE: GLenum = 0x8292;

/// Constant value defined from OpenGL 4.3
pub const GL_MIPMAP: GLenum = 0x8293;

/// Constant value defined from OpenGL 4.3
pub const GL_MANUAL_GENERATE_MIPMAP: GLenum = 0x8294;

/// Constant value defined from OpenGL 4.3
pub const GL_AUTO_GENERATE_MIPMAP: GLenum = 0x8295;

/// Constant value defined from OpenGL 4.3
pub const GL_COLOR_ENCODING: GLenum = 0x8296;

/// Constant value defined from OpenGL 4.3
pub const GL_SRGB_READ: GLenum = 0x8297;

/// Constant value defined from OpenGL 4.3
pub const GL_SRGB_WRITE: GLenum = 0x8298;

/// Constant value defined from OpenGL 4.3
pub const GL_FILTER: GLenum = 0x829A;

/// Constant value defined from OpenGL 4.3
pub const GL_VERTEX_TEXTURE: GLenum = 0x829B;

/// Constant value defined from OpenGL 4.3
pub const GL_TESS_CONTROL_TEXTURE: GLenum = 0x829C;

/// Constant value defined from OpenGL 4.3
pub const GL_TESS_EVALUATION_TEXTURE: GLenum = 0x829D;

/// Constant value defined from OpenGL 4.3
pub const GL_GEOMETRY_TEXTURE: GLenum = 0x829E;

/// Constant value defined from OpenGL 4.3
pub const GL_FRAGMENT_TEXTURE: GLenum = 0x829F;

/// Constant value defined from OpenGL 4.3
pub const GL_COMPUTE_TEXTURE: GLenum = 0x82A0;

/// Constant value defined from OpenGL 4.3
pub const GL_TEXTURE_SHADOW: GLenum = 0x82A1;

/// Constant value defined from OpenGL 4.3
pub const GL_TEXTURE_GATHER: GLenum = 0x82A2;

/// Constant value defined from OpenGL 4.3
pub const GL_TEXTURE_GATHER_SHADOW: GLenum = 0x82A3;

/// Constant value defined from OpenGL 4.3
pub const GL_SHADER_IMAGE_LOAD: GLenum = 0x82A4;

/// Constant value defined from OpenGL 4.3
pub const GL_SHADER_IMAGE_STORE: GLenum = 0x82A5;

/// Constant value defined from OpenGL 4.3
pub const GL_SHADER_IMAGE_ATOMIC: GLenum = 0x82A6;

/// Constant value defined from OpenGL 4.3
pub const GL_IMAGE_TEXEL_SIZE: GLenum = 0x82A7;

/// Constant value defined from OpenGL 4.3
pub const GL_IMAGE_COMPATIBILITY_CLASS: GLenum = 0x82A8;

/// Constant value defined from OpenGL 4.3
pub const GL_IMAGE_PIXEL_FORMAT: GLenum = 0x82A9;

/// Constant value defined from OpenGL 4.3
pub const GL_IMAGE_PIXEL_TYPE: GLenum = 0x82AA;

/// Constant value defined from OpenGL 4.3
pub const GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST: GLenum = 0x82AC;

/// Constant value defined from OpenGL 4.3
pub const GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST: GLenum = 0x82AD;

/// Constant value defined from OpenGL 4.3
pub const GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE: GLenum = 0x82AE;

/// Constant value defined from OpenGL 4.3
pub const GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE: GLenum = 0x82AF;

/// Constant value defined from OpenGL 4.3
pub const GL_TEXTURE_COMPRESSED_BLOCK_WIDTH: GLenum = 0x82B1;

/// Constant value defined from OpenGL 4.3
pub const GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT: GLenum = 0x82B2;

/// Constant value defined from OpenGL 4.3
pub const GL_TEXTURE_COMPRESSED_BLOCK_SIZE: GLenum = 0x82B3;

/// Constant value defined from OpenGL 4.3
pub const GL_CLEAR_BUFFER: GLenum = 0x82B4;

/// Constant value defined from OpenGL 4.3
pub const GL_TEXTURE_VIEW: GLenum = 0x82B5;

/// Constant value defined from OpenGL 4.3
pub const GL_VIEW_COMPATIBILITY_CLASS: GLenum = 0x82B6;

/// Constant value defined from OpenGL 4.3
pub const GL_FULL_SUPPORT: GLenum = 0x82B7;

/// Constant value defined from OpenGL 4.3
pub const GL_CAVEAT_SUPPORT: GLenum = 0x82B8;

/// Constant value defined from OpenGL 4.3
pub const GL_IMAGE_CLASS_4_X_32: GLenum = 0x82B9;

/// Constant value defined from OpenGL 4.3
pub const GL_IMAGE_CLASS_2_X_32: GLenum = 0x82BA;

/// Constant value defined from OpenGL 4.3
pub const GL_IMAGE_CLASS_1_X_32: GLenum = 0x82BB;

/// Constant value defined from OpenGL 4.3
pub const GL_IMAGE_CLASS_4_X_16: GLenum = 0x82BC;

/// Constant value defined from OpenGL 4.3
pub const GL_IMAGE_CLASS_2_X_16: GLenum = 0x82BD;

/// Constant value defined from OpenGL 4.3
pub const GL_IMAGE_CLASS_1_X_16: GLenum = 0x82BE;

/// Constant value defined from OpenGL 4.3
pub const GL_IMAGE_CLASS_4_X_8: GLenum = 0x82BF;

/// Constant value defined from OpenGL 4.3
pub const GL_IMAGE_CLASS_2_X_8: GLenum = 0x82C0;

/// Constant value defined from OpenGL 4.3
pub const GL_IMAGE_CLASS_1_X_8: GLenum = 0x82C1;

/// Constant value defined from OpenGL 4.3
pub const GL_IMAGE_CLASS_11_11_10: GLenum = 0x82C2;

/// Constant value defined from OpenGL 4.3
pub const GL_IMAGE_CLASS_10_10_10_2: GLenum = 0x82C3;

/// Constant value defined from OpenGL 4.3
pub const GL_VIEW_CLASS_128_BITS: GLenum = 0x82C4;

/// Constant value defined from OpenGL 4.3
pub const GL_VIEW_CLASS_96_BITS: GLenum = 0x82C5;

/// Constant value defined from OpenGL 4.3
pub const GL_VIEW_CLASS_64_BITS: GLenum = 0x82C6;

/// Constant value defined from OpenGL 4.3
pub const GL_VIEW_CLASS_48_BITS: GLenum = 0x82C7;

/// Constant value defined from OpenGL 4.3
pub const GL_VIEW_CLASS_32_BITS: GLenum = 0x82C8;

/// Constant value defined from OpenGL 4.3
pub const GL_VIEW_CLASS_24_BITS: GLenum = 0x82C9;

/// Constant value defined from OpenGL 4.3
pub const GL_VIEW_CLASS_16_BITS: GLenum = 0x82CA;

/// Constant value defined from OpenGL 4.3
pub const GL_VIEW_CLASS_8_BITS: GLenum = 0x82CB;

/// Constant value defined from OpenGL 4.3
pub const GL_VIEW_CLASS_S3TC_DXT1_RGB: GLenum = 0x82CC;

/// Constant value defined from OpenGL 4.3
pub const GL_VIEW_CLASS_S3TC_DXT1_RGBA: GLenum = 0x82CD;

/// Constant value defined from OpenGL 4.3
pub const GL_VIEW_CLASS_S3TC_DXT3_RGBA: GLenum = 0x82CE;

/// Constant value defined from OpenGL 4.3
pub const GL_VIEW_CLASS_S3TC_DXT5_RGBA: GLenum = 0x82CF;

/// Constant value defined from OpenGL 4.3
pub const GL_VIEW_CLASS_RGTC1_RED: GLenum = 0x82D0;

/// Constant value defined from OpenGL 4.3
pub const GL_VIEW_CLASS_RGTC2_RG: GLenum = 0x82D1;

/// Constant value defined from OpenGL 4.3
pub const GL_VIEW_CLASS_BPTC_UNORM: GLenum = 0x82D2;

/// Constant value defined from OpenGL 4.3
pub const GL_VIEW_CLASS_BPTC_FLOAT: GLenum = 0x82D3;

/// Constant value defined from OpenGL 4.3
pub const GL_UNIFORM: GLenum = 0x92E1;

/// Constant value defined from OpenGL 4.3
pub const GL_UNIFORM_BLOCK: GLenum = 0x92E2;

/// Constant value defined from OpenGL 4.3
pub const GL_PROGRAM_INPUT: GLenum = 0x92E3;

/// Constant value defined from OpenGL 4.3
pub const GL_PROGRAM_OUTPUT: GLenum = 0x92E4;

/// Constant value defined from OpenGL 4.3
pub const GL_BUFFER_VARIABLE: GLenum = 0x92E5;

/// Constant value defined from OpenGL 4.3
pub const GL_SHADER_STORAGE_BLOCK: GLenum = 0x92E6;

/// Constant value defined from OpenGL 4.3
pub const GL_VERTEX_SUBROUTINE: GLenum = 0x92E8;

/// Constant value defined from OpenGL 4.3
pub const GL_TESS_CONTROL_SUBROUTINE: GLenum = 0x92E9;

/// Constant value defined from OpenGL 4.3
pub const GL_TESS_EVALUATION_SUBROUTINE: GLenum = 0x92EA;

/// Constant value defined from OpenGL 4.3
pub const GL_GEOMETRY_SUBROUTINE: GLenum = 0x92EB;

/// Constant value defined from OpenGL 4.3
pub const GL_FRAGMENT_SUBROUTINE: GLenum = 0x92EC;

/// Constant value defined from OpenGL 4.3
pub const GL_COMPUTE_SUBROUTINE: GLenum = 0x92ED;

/// Constant value defined from OpenGL 4.3
pub const GL_VERTEX_SUBROUTINE_UNIFORM: GLenum = 0x92EE;

/// Constant value defined from OpenGL 4.3
pub const GL_TESS_CONTROL_SUBROUTINE_UNIFORM: GLenum = 0x92EF;

/// Constant value defined from OpenGL 4.3
pub const GL_TESS_EVALUATION_SUBROUTINE_UNIFORM: GLenum = 0x92F0;

/// Constant value defined from OpenGL 4.3
pub const GL_GEOMETRY_SUBROUTINE_UNIFORM: GLenum = 0x92F1;

/// Constant value defined from OpenGL 4.3
pub const GL_FRAGMENT_SUBROUTINE_UNIFORM: GLenum = 0x92F2;

/// Constant value defined from OpenGL 4.3
pub const GL_COMPUTE_SUBROUTINE_UNIFORM: GLenum = 0x92F3;

/// Constant value defined from OpenGL 4.3
pub const GL_TRANSFORM_FEEDBACK_VARYING: GLenum = 0x92F4;

/// Constant value defined from OpenGL 4.3
pub const GL_ACTIVE_RESOURCES: GLenum = 0x92F5;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_NAME_LENGTH: GLenum = 0x92F6;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_NUM_ACTIVE_VARIABLES: GLenum = 0x92F7;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_NUM_COMPATIBLE_SUBROUTINES: GLenum = 0x92F8;

/// Constant value defined from OpenGL 4.3
pub const GL_NAME_LENGTH: GLenum = 0x92F9;

/// Constant value defined from OpenGL 4.3
pub const GL_TYPE: GLenum = 0x92FA;

/// Constant value defined from OpenGL 4.3
pub const GL_ARRAY_SIZE: GLenum = 0x92FB;

/// Constant value defined from OpenGL 4.3
pub const GL_OFFSET: GLenum = 0x92FC;

/// Constant value defined from OpenGL 4.3
pub const GL_BLOCK_INDEX: GLenum = 0x92FD;

/// Constant value defined from OpenGL 4.3
pub const GL_ARRAY_STRIDE: GLenum = 0x92FE;

/// Constant value defined from OpenGL 4.3
pub const GL_MATRIX_STRIDE: GLenum = 0x92FF;

/// Constant value defined from OpenGL 4.3
pub const GL_IS_ROW_MAJOR: GLenum = 0x9300;

/// Constant value defined from OpenGL 4.3
pub const GL_ATOMIC_COUNTER_BUFFER_INDEX: GLenum = 0x9301;

/// Constant value defined from OpenGL 4.3
pub const GL_BUFFER_BINDING: GLenum = 0x9302;

/// Constant value defined from OpenGL 4.3
pub const GL_BUFFER_DATA_SIZE: GLenum = 0x9303;

/// Constant value defined from OpenGL 4.3
pub const GL_NUM_ACTIVE_VARIABLES: GLenum = 0x9304;

/// Constant value defined from OpenGL 4.3
pub const GL_ACTIVE_VARIABLES: GLenum = 0x9305;

/// Constant value defined from OpenGL 4.3
pub const GL_REFERENCED_BY_VERTEX_SHADER: GLenum = 0x9306;

/// Constant value defined from OpenGL 4.3
pub const GL_REFERENCED_BY_TESS_CONTROL_SHADER: GLenum = 0x9307;

/// Constant value defined from OpenGL 4.3
pub const GL_REFERENCED_BY_TESS_EVALUATION_SHADER: GLenum = 0x9308;

/// Constant value defined from OpenGL 4.3
pub const GL_REFERENCED_BY_GEOMETRY_SHADER: GLenum = 0x9309;

/// Constant value defined from OpenGL 4.3
pub const GL_REFERENCED_BY_FRAGMENT_SHADER: GLenum = 0x930A;

/// Constant value defined from OpenGL 4.3
pub const GL_REFERENCED_BY_COMPUTE_SHADER: GLenum = 0x930B;

/// Constant value defined from OpenGL 4.3
pub const GL_TOP_LEVEL_ARRAY_SIZE: GLenum = 0x930C;

/// Constant value defined from OpenGL 4.3
pub const GL_TOP_LEVEL_ARRAY_STRIDE: GLenum = 0x930D;

/// Constant value defined from OpenGL 4.3
pub const GL_LOCATION: GLenum = 0x930E;

/// Constant value defined from OpenGL 4.3
pub const GL_LOCATION_INDEX: GLenum = 0x930F;

/// Constant value defined from OpenGL 4.3
pub const GL_IS_PER_PATCH: GLenum = 0x92E7;

/// Constant value defined from OpenGL 4.3
pub const GL_SHADER_STORAGE_BUFFER: GLenum = 0x90D2;

/// Constant value defined from OpenGL 4.3
pub const GL_SHADER_STORAGE_BUFFER_BINDING: GLenum = 0x90D3;

/// Constant value defined from OpenGL 4.3
pub const GL_SHADER_STORAGE_BUFFER_START: GLenum = 0x90D4;

/// Constant value defined from OpenGL 4.3
pub const GL_SHADER_STORAGE_BUFFER_SIZE: GLenum = 0x90D5;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS: GLenum = 0x90D6;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS: GLenum = 0x90D7;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS: GLenum = 0x90D8;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS: GLenum = 0x90D9;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS: GLenum = 0x90DA;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS: GLenum = 0x90DB;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS: GLenum = 0x90DC;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS: GLenum = 0x90DD;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_SHADER_STORAGE_BLOCK_SIZE: GLenum = 0x90DE;

/// Constant value defined from OpenGL 4.3
pub const GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT: GLenum = 0x90DF;

/// Constant value defined from OpenGL 4.3
pub const GL_SHADER_STORAGE_BARRIER_BIT: GLbitfield = 0x00002000;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES: GLenum = 0x8F39;

/// Constant value defined from OpenGL 4.3
pub const GL_DEPTH_STENCIL_TEXTURE_MODE: GLenum = 0x90EA;

/// Constant value defined from OpenGL 4.3
pub const GL_TEXTURE_BUFFER_OFFSET: GLenum = 0x919D;

/// Constant value defined from OpenGL 4.3
pub const GL_TEXTURE_BUFFER_SIZE: GLenum = 0x919E;

/// Constant value defined from OpenGL 4.3
pub const GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT: GLenum = 0x919F;

/// Constant value defined from OpenGL 4.3
pub const GL_TEXTURE_VIEW_MIN_LEVEL: GLenum = 0x82DB;

/// Constant value defined from OpenGL 4.3
pub const GL_TEXTURE_VIEW_NUM_LEVELS: GLenum = 0x82DC;

/// Constant value defined from OpenGL 4.3
pub const GL_TEXTURE_VIEW_MIN_LAYER: GLenum = 0x82DD;

/// Constant value defined from OpenGL 4.3
pub const GL_TEXTURE_VIEW_NUM_LAYERS: GLenum = 0x82DE;

/// Constant value defined from OpenGL 4.3
pub const GL_TEXTURE_IMMUTABLE_LEVELS: GLenum = 0x82DF;

/// Constant value defined from OpenGL 4.3
pub const GL_VERTEX_ATTRIB_BINDING: GLenum = 0x82D4;

/// Constant value defined from OpenGL 4.3
pub const GL_VERTEX_ATTRIB_RELATIVE_OFFSET: GLenum = 0x82D5;

/// Constant value defined from OpenGL 4.3
pub const GL_VERTEX_BINDING_DIVISOR: GLenum = 0x82D6;

/// Constant value defined from OpenGL 4.3
pub const GL_VERTEX_BINDING_OFFSET: GLenum = 0x82D7;

/// Constant value defined from OpenGL 4.3
pub const GL_VERTEX_BINDING_STRIDE: GLenum = 0x82D8;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET: GLenum = 0x82D9;

/// Constant value defined from OpenGL 4.3
pub const GL_MAX_VERTEX_ATTRIB_BINDINGS: GLenum = 0x82DA;

/// Constant value defined from OpenGL 4.3
pub const GL_VERTEX_BINDING_BUFFER: GLenum = 0x8F4F;

/// Constant value defined from OpenGL 4.3
pub const GL_DISPLAY_LIST: GLenum = 0x82E7;

/// Functions from OpenGL version 4.3
pub trait GL_4_3 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	fn glGetError(&self) -> GLenum;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml>
	fn glClearBufferData(&self, target: GLenum, internalformat: GLenum, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml>
	fn glClearBufferSubData(&self, target: GLenum, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDispatchCompute.xhtml>
	fn glDispatchCompute(&self, num_groups_x: GLuint, num_groups_y: GLuint, num_groups_z: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDispatchComputeIndirect.xhtml>
	fn glDispatchComputeIndirect(&self, indirect: GLintptr) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyImageSubData.xhtml>
	fn glCopyImageSubData(&self, srcName: GLuint, srcTarget: GLenum, srcLevel: GLint, srcX: GLint, srcY: GLint, srcZ: GLint, dstName: GLuint, dstTarget: GLenum, dstLevel: GLint, dstX: GLint, dstY: GLint, dstZ: GLint, srcWidth: GLsizei, srcHeight: GLsizei, srcDepth: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml>
	fn glFramebufferParameteri(&self, target: GLenum, pname: GLenum, param: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetFramebufferParameteriv.xhtml>
	fn glGetFramebufferParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetInternalformati64v.xhtml>
	fn glGetInternalformati64v(&self, target: GLenum, internalformat: GLenum, pname: GLenum, count: GLsizei, params: *mut GLint64) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateTexSubImage.xhtml>
	fn glInvalidateTexSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateTexImage.xhtml>
	fn glInvalidateTexImage(&self, texture: GLuint, level: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateBufferSubData.xhtml>
	fn glInvalidateBufferSubData(&self, buffer: GLuint, offset: GLintptr, length: GLsizeiptr) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateBufferData.xhtml>
	fn glInvalidateBufferData(&self, buffer: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml>
	fn glInvalidateFramebuffer(&self, target: GLenum, numAttachments: GLsizei, attachments: *const GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml>
	fn glInvalidateSubFramebuffer(&self, target: GLenum, numAttachments: GLsizei, attachments: *const GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawArraysIndirect.xhtml>
	fn glMultiDrawArraysIndirect(&self, mode: GLenum, indirect: *const c_void, drawcount: GLsizei, stride: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawElementsIndirect.xhtml>
	fn glMultiDrawElementsIndirect(&self, mode: GLenum, type_: GLenum, indirect: *const c_void, drawcount: GLsizei, stride: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramInterfaceiv.xhtml>
	fn glGetProgramInterfaceiv(&self, program: GLuint, programInterface: GLenum, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramResourceIndex.xhtml>
	fn glGetProgramResourceIndex(&self, program: GLuint, programInterface: GLenum, name: *const GLchar) -> Result<GLuint>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramResourceName.xhtml>
	fn glGetProgramResourceName(&self, program: GLuint, programInterface: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramResourceiv.xhtml>
	fn glGetProgramResourceiv(&self, program: GLuint, programInterface: GLenum, index: GLuint, propCount: GLsizei, props: *const GLenum, count: GLsizei, length: *mut GLsizei, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramResourceLocation.xhtml>
	fn glGetProgramResourceLocation(&self, program: GLuint, programInterface: GLenum, name: *const GLchar) -> Result<GLint>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramResourceLocationIndex.xhtml>
	fn glGetProgramResourceLocationIndex(&self, program: GLuint, programInterface: GLenum, name: *const GLchar) -> Result<GLint>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glShaderStorageBlockBinding.xhtml>
	fn glShaderStorageBlockBinding(&self, program: GLuint, storageBlockIndex: GLuint, storageBlockBinding: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml>
	fn glTexBufferRange(&self, target: GLenum, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml>
	fn glTexStorage2DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml>
	fn glTexStorage3DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureView.xhtml>
	fn glTextureView(&self, texture: GLuint, target: GLenum, origtexture: GLuint, internalformat: GLenum, minlevel: GLuint, numlevels: GLuint, minlayer: GLuint, numlayers: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml>
	fn glBindVertexBuffer(&self, bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml>
	fn glVertexAttribFormat(&self, attribindex: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, relativeoffset: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribIFormat.xhtml>
	fn glVertexAttribIFormat(&self, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribLFormat.xhtml>
	fn glVertexAttribLFormat(&self, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml>
	fn glVertexAttribBinding(&self, attribindex: GLuint, bindingindex: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml>
	fn glVertexBindingDivisor(&self, bindingindex: GLuint, divisor: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDebugMessageControl.xhtml>
	fn glDebugMessageControl(&self, source: GLenum, type_: GLenum, severity: GLenum, count: GLsizei, ids: *const GLuint, enabled: GLboolean) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDebugMessageInsert.xhtml>
	fn glDebugMessageInsert(&self, source: GLenum, type_: GLenum, id: GLuint, severity: GLenum, length: GLsizei, buf: *const GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDebugMessageCallback.xhtml>
	fn glDebugMessageCallback(&self, callback: GLDEBUGPROC, userParam: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetDebugMessageLog.xhtml>
	fn glGetDebugMessageLog(&self, count: GLuint, bufSize: GLsizei, sources: *mut GLenum, types: *mut GLenum, ids: *mut GLuint, severities: *mut GLenum, lengths: *mut GLsizei, messageLog: *mut GLchar) -> Result<GLuint>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPushDebugGroup.xhtml>
	fn glPushDebugGroup(&self, source: GLenum, id: GLuint, length: GLsizei, message: *const GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPopDebugGroup.xhtml>
	fn glPopDebugGroup(&self) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glObjectLabel.xhtml>
	fn glObjectLabel(&self, identifier: GLenum, name: GLuint, length: GLsizei, label: *const GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetObjectLabel.xhtml>
	fn glGetObjectLabel(&self, identifier: GLenum, name: GLuint, bufSize: GLsizei, length: *mut GLsizei, label: *mut GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glObjectPtrLabel.xhtml>
	fn glObjectPtrLabel(&self, ptr: *const c_void, length: GLsizei, label: *const GLchar) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetObjectPtrLabel.xhtml>
	fn glGetObjectPtrLabel(&self, ptr: *const c_void, bufSize: GLsizei, length: *mut GLsizei, label: *mut GLchar) -> Result<()>;
}
/// Functions from OpenGL version 4.3
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version43 {
	/// Is OpenGL version 4.3 available
	available: bool,

	/// The function pointer to `glGetError()`
	pub geterror: PFNGLGETERRORPROC,

	/// The function pointer to `glClearBufferData()`
	pub clearbufferdata: PFNGLCLEARBUFFERDATAPROC,

	/// The function pointer to `glClearBufferSubData()`
	pub clearbuffersubdata: PFNGLCLEARBUFFERSUBDATAPROC,

	/// The function pointer to `glDispatchCompute()`
	pub dispatchcompute: PFNGLDISPATCHCOMPUTEPROC,

	/// The function pointer to `glDispatchComputeIndirect()`
	pub dispatchcomputeindirect: PFNGLDISPATCHCOMPUTEINDIRECTPROC,

	/// The function pointer to `glCopyImageSubData()`
	pub copyimagesubdata: PFNGLCOPYIMAGESUBDATAPROC,

	/// The function pointer to `glFramebufferParameteri()`
	pub framebufferparameteri: PFNGLFRAMEBUFFERPARAMETERIPROC,

	/// The function pointer to `glGetFramebufferParameteriv()`
	pub getframebufferparameteriv: PFNGLGETFRAMEBUFFERPARAMETERIVPROC,

	/// The function pointer to `glGetInternalformati64v()`
	pub getinternalformati64v: PFNGLGETINTERNALFORMATI64VPROC,

	/// The function pointer to `glInvalidateTexSubImage()`
	pub invalidatetexsubimage: PFNGLINVALIDATETEXSUBIMAGEPROC,

	/// The function pointer to `glInvalidateTexImage()`
	pub invalidateteximage: PFNGLINVALIDATETEXIMAGEPROC,

	/// The function pointer to `glInvalidateBufferSubData()`
	pub invalidatebuffersubdata: PFNGLINVALIDATEBUFFERSUBDATAPROC,

	/// The function pointer to `glInvalidateBufferData()`
	pub invalidatebufferdata: PFNGLINVALIDATEBUFFERDATAPROC,

	/// The function pointer to `glInvalidateFramebuffer()`
	pub invalidateframebuffer: PFNGLINVALIDATEFRAMEBUFFERPROC,

	/// The function pointer to `glInvalidateSubFramebuffer()`
	pub invalidatesubframebuffer: PFNGLINVALIDATESUBFRAMEBUFFERPROC,

	/// The function pointer to `glMultiDrawArraysIndirect()`
	pub multidrawarraysindirect: PFNGLMULTIDRAWARRAYSINDIRECTPROC,

	/// The function pointer to `glMultiDrawElementsIndirect()`
	pub multidrawelementsindirect: PFNGLMULTIDRAWELEMENTSINDIRECTPROC,

	/// The function pointer to `glGetProgramInterfaceiv()`
	pub getprograminterfaceiv: PFNGLGETPROGRAMINTERFACEIVPROC,

	/// The function pointer to `glGetProgramResourceIndex()`
	pub getprogramresourceindex: PFNGLGETPROGRAMRESOURCEINDEXPROC,

	/// The function pointer to `glGetProgramResourceName()`
	pub getprogramresourcename: PFNGLGETPROGRAMRESOURCENAMEPROC,

	/// The function pointer to `glGetProgramResourceiv()`
	pub getprogramresourceiv: PFNGLGETPROGRAMRESOURCEIVPROC,

	/// The function pointer to `glGetProgramResourceLocation()`
	pub getprogramresourcelocation: PFNGLGETPROGRAMRESOURCELOCATIONPROC,

	/// The function pointer to `glGetProgramResourceLocationIndex()`
	pub getprogramresourcelocationindex: PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC,

	/// The function pointer to `glShaderStorageBlockBinding()`
	pub shaderstorageblockbinding: PFNGLSHADERSTORAGEBLOCKBINDINGPROC,

	/// The function pointer to `glTexBufferRange()`
	pub texbufferrange: PFNGLTEXBUFFERRANGEPROC,

	/// The function pointer to `glTexStorage2DMultisample()`
	pub texstorage2dmultisample: PFNGLTEXSTORAGE2DMULTISAMPLEPROC,

	/// The function pointer to `glTexStorage3DMultisample()`
	pub texstorage3dmultisample: PFNGLTEXSTORAGE3DMULTISAMPLEPROC,

	/// The function pointer to `glTextureView()`
	pub textureview: PFNGLTEXTUREVIEWPROC,

	/// The function pointer to `glBindVertexBuffer()`
	pub bindvertexbuffer: PFNGLBINDVERTEXBUFFERPROC,

	/// The function pointer to `glVertexAttribFormat()`
	pub vertexattribformat: PFNGLVERTEXATTRIBFORMATPROC,

	/// The function pointer to `glVertexAttribIFormat()`
	pub vertexattribiformat: PFNGLVERTEXATTRIBIFORMATPROC,

	/// The function pointer to `glVertexAttribLFormat()`
	pub vertexattriblformat: PFNGLVERTEXATTRIBLFORMATPROC,

	/// The function pointer to `glVertexAttribBinding()`
	pub vertexattribbinding: PFNGLVERTEXATTRIBBINDINGPROC,

	/// The function pointer to `glVertexBindingDivisor()`
	pub vertexbindingdivisor: PFNGLVERTEXBINDINGDIVISORPROC,

	/// The function pointer to `glDebugMessageControl()`
	pub debugmessagecontrol: PFNGLDEBUGMESSAGECONTROLPROC,

	/// The function pointer to `glDebugMessageInsert()`
	pub debugmessageinsert: PFNGLDEBUGMESSAGEINSERTPROC,

	/// The function pointer to `glDebugMessageCallback()`
	pub debugmessagecallback: PFNGLDEBUGMESSAGECALLBACKPROC,

	/// The function pointer to `glGetDebugMessageLog()`
	pub getdebugmessagelog: PFNGLGETDEBUGMESSAGELOGPROC,

	/// The function pointer to `glPushDebugGroup()`
	pub pushdebuggroup: PFNGLPUSHDEBUGGROUPPROC,

	/// The function pointer to `glPopDebugGroup()`
	pub popdebuggroup: PFNGLPOPDEBUGGROUPPROC,

	/// The function pointer to `glObjectLabel()`
	pub objectlabel: PFNGLOBJECTLABELPROC,

	/// The function pointer to `glGetObjectLabel()`
	pub getobjectlabel: PFNGLGETOBJECTLABELPROC,

	/// The function pointer to `glObjectPtrLabel()`
	pub objectptrlabel: PFNGLOBJECTPTRLABELPROC,

	/// The function pointer to `glGetObjectPtrLabel()`
	pub getobjectptrlabel: PFNGLGETOBJECTPTRLABELPROC,
}

impl GL_4_3 for Version43 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml>
	#[inline(always)]
	fn glClearBufferData(&self, target: GLenum, internalformat: GLenum, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearBufferData", catch_unwind(||(self.clearbufferdata)(target, internalformat, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml>
	#[inline(always)]
	fn glClearBufferSubData(&self, target: GLenum, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearBufferSubData", catch_unwind(||(self.clearbuffersubdata)(target, internalformat, offset, size, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDispatchCompute.xhtml>
	#[inline(always)]
	fn glDispatchCompute(&self, num_groups_x: GLuint, num_groups_y: GLuint, num_groups_z: GLuint) -> Result<()> {
		let ret = process_catch("glDispatchCompute", catch_unwind(||(self.dispatchcompute)(num_groups_x, num_groups_y, num_groups_z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDispatchCompute", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDispatchComputeIndirect.xhtml>
	#[inline(always)]
	fn glDispatchComputeIndirect(&self, indirect: GLintptr) -> Result<()> {
		let ret = process_catch("glDispatchComputeIndirect", catch_unwind(||(self.dispatchcomputeindirect)(indirect)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDispatchComputeIndirect", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyImageSubData.xhtml>
	#[inline(always)]
	fn glCopyImageSubData(&self, srcName: GLuint, srcTarget: GLenum, srcLevel: GLint, srcX: GLint, srcY: GLint, srcZ: GLint, dstName: GLuint, dstTarget: GLenum, dstLevel: GLint, dstX: GLint, dstY: GLint, dstZ: GLint, srcWidth: GLsizei, srcHeight: GLsizei, srcDepth: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyImageSubData", catch_unwind(||(self.copyimagesubdata)(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyImageSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml>
	#[inline(always)]
	fn glFramebufferParameteri(&self, target: GLenum, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferParameteri", catch_unwind(||(self.framebufferparameteri)(target, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferParameteri", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetFramebufferParameteriv.xhtml>
	#[inline(always)]
	fn glGetFramebufferParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetFramebufferParameteriv", catch_unwind(||(self.getframebufferparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFramebufferParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetInternalformati64v.xhtml>
	#[inline(always)]
	fn glGetInternalformati64v(&self, target: GLenum, internalformat: GLenum, pname: GLenum, count: GLsizei, params: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetInternalformati64v", catch_unwind(||(self.getinternalformati64v)(target, internalformat, pname, count, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetInternalformati64v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateTexSubImage.xhtml>
	#[inline(always)]
	fn glInvalidateTexSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei) -> Result<()> {
		let ret = process_catch("glInvalidateTexSubImage", catch_unwind(||(self.invalidatetexsubimage)(texture, level, xoffset, yoffset, zoffset, width, height, depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateTexSubImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateTexImage.xhtml>
	#[inline(always)]
	fn glInvalidateTexImage(&self, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glInvalidateTexImage", catch_unwind(||(self.invalidateteximage)(texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateTexImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateBufferSubData.xhtml>
	#[inline(always)]
	fn glInvalidateBufferSubData(&self, buffer: GLuint, offset: GLintptr, length: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glInvalidateBufferSubData", catch_unwind(||(self.invalidatebuffersubdata)(buffer, offset, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateBufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateBufferData.xhtml>
	#[inline(always)]
	fn glInvalidateBufferData(&self, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glInvalidateBufferData", catch_unwind(||(self.invalidatebufferdata)(buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateBufferData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml>
	#[inline(always)]
	fn glInvalidateFramebuffer(&self, target: GLenum, numAttachments: GLsizei, attachments: *const GLenum) -> Result<()> {
		let ret = process_catch("glInvalidateFramebuffer", catch_unwind(||(self.invalidateframebuffer)(target, numAttachments, attachments)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateFramebuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml>
	#[inline(always)]
	fn glInvalidateSubFramebuffer(&self, target: GLenum, numAttachments: GLsizei, attachments: *const GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glInvalidateSubFramebuffer", catch_unwind(||(self.invalidatesubframebuffer)(target, numAttachments, attachments, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateSubFramebuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawArraysIndirect.xhtml>
	#[inline(always)]
	fn glMultiDrawArraysIndirect(&self, mode: GLenum, indirect: *const c_void, drawcount: GLsizei, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawArraysIndirect", catch_unwind(||(self.multidrawarraysindirect)(mode, indirect, drawcount, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawArraysIndirect", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawElementsIndirect.xhtml>
	#[inline(always)]
	fn glMultiDrawElementsIndirect(&self, mode: GLenum, type_: GLenum, indirect: *const c_void, drawcount: GLsizei, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawElementsIndirect", catch_unwind(||(self.multidrawelementsindirect)(mode, type_, indirect, drawcount, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawElementsIndirect", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramInterfaceiv.xhtml>
	#[inline(always)]
	fn glGetProgramInterfaceiv(&self, program: GLuint, programInterface: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramInterfaceiv", catch_unwind(||(self.getprograminterfaceiv)(program, programInterface, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramInterfaceiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramResourceIndex.xhtml>
	#[inline(always)]
	fn glGetProgramResourceIndex(&self, program: GLuint, programInterface: GLenum, name: *const GLchar) -> Result<GLuint> {
		let ret = process_catch("glGetProgramResourceIndex", catch_unwind(||(self.getprogramresourceindex)(program, programInterface, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceIndex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramResourceName.xhtml>
	#[inline(always)]
	fn glGetProgramResourceName(&self, program: GLuint, programInterface: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetProgramResourceName", catch_unwind(||(self.getprogramresourcename)(program, programInterface, index, bufSize, length, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceName", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramResourceiv.xhtml>
	#[inline(always)]
	fn glGetProgramResourceiv(&self, program: GLuint, programInterface: GLenum, index: GLuint, propCount: GLsizei, props: *const GLenum, count: GLsizei, length: *mut GLsizei, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramResourceiv", catch_unwind(||(self.getprogramresourceiv)(program, programInterface, index, propCount, props, count, length, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramResourceLocation.xhtml>
	#[inline(always)]
	fn glGetProgramResourceLocation(&self, program: GLuint, programInterface: GLenum, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetProgramResourceLocation", catch_unwind(||(self.getprogramresourcelocation)(program, programInterface, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceLocation", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramResourceLocationIndex.xhtml>
	#[inline(always)]
	fn glGetProgramResourceLocationIndex(&self, program: GLuint, programInterface: GLenum, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetProgramResourceLocationIndex", catch_unwind(||(self.getprogramresourcelocationindex)(program, programInterface, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceLocationIndex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glShaderStorageBlockBinding.xhtml>
	#[inline(always)]
	fn glShaderStorageBlockBinding(&self, program: GLuint, storageBlockIndex: GLuint, storageBlockBinding: GLuint) -> Result<()> {
		let ret = process_catch("glShaderStorageBlockBinding", catch_unwind(||(self.shaderstorageblockbinding)(program, storageBlockIndex, storageBlockBinding)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glShaderStorageBlockBinding", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml>
	#[inline(always)]
	fn glTexBufferRange(&self, target: GLenum, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glTexBufferRange", catch_unwind(||(self.texbufferrange)(target, internalformat, buffer, offset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexBufferRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml>
	#[inline(always)]
	fn glTexStorage2DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTexStorage2DMultisample", catch_unwind(||(self.texstorage2dmultisample)(target, samples, internalformat, width, height, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage2DMultisample", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml>
	#[inline(always)]
	fn glTexStorage3DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTexStorage3DMultisample", catch_unwind(||(self.texstorage3dmultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage3DMultisample", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureView.xhtml>
	#[inline(always)]
	fn glTextureView(&self, texture: GLuint, target: GLenum, origtexture: GLuint, internalformat: GLenum, minlevel: GLuint, numlevels: GLuint, minlayer: GLuint, numlayers: GLuint) -> Result<()> {
		let ret = process_catch("glTextureView", catch_unwind(||(self.textureview)(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureView", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml>
	#[inline(always)]
	fn glBindVertexBuffer(&self, bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glBindVertexBuffer", catch_unwind(||(self.bindvertexbuffer)(bindingindex, buffer, offset, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindVertexBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml>
	#[inline(always)]
	fn glVertexAttribFormat(&self, attribindex: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribFormat", catch_unwind(||(self.vertexattribformat)(attribindex, size, type_, normalized, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribFormat", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribIFormat.xhtml>
	#[inline(always)]
	fn glVertexAttribIFormat(&self, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribIFormat", catch_unwind(||(self.vertexattribiformat)(attribindex, size, type_, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribIFormat", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribLFormat.xhtml>
	#[inline(always)]
	fn glVertexAttribLFormat(&self, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribLFormat", catch_unwind(||(self.vertexattriblformat)(attribindex, size, type_, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribLFormat", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml>
	#[inline(always)]
	fn glVertexAttribBinding(&self, attribindex: GLuint, bindingindex: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribBinding", catch_unwind(||(self.vertexattribbinding)(attribindex, bindingindex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribBinding", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml>
	#[inline(always)]
	fn glVertexBindingDivisor(&self, bindingindex: GLuint, divisor: GLuint) -> Result<()> {
		let ret = process_catch("glVertexBindingDivisor", catch_unwind(||(self.vertexbindingdivisor)(bindingindex, divisor)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexBindingDivisor", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDebugMessageControl.xhtml>
	#[inline(always)]
	fn glDebugMessageControl(&self, source: GLenum, type_: GLenum, severity: GLenum, count: GLsizei, ids: *const GLuint, enabled: GLboolean) -> Result<()> {
		let ret = process_catch("glDebugMessageControl", catch_unwind(||(self.debugmessagecontrol)(source, type_, severity, count, ids, enabled)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDebugMessageControl", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDebugMessageInsert.xhtml>
	#[inline(always)]
	fn glDebugMessageInsert(&self, source: GLenum, type_: GLenum, id: GLuint, severity: GLenum, length: GLsizei, buf: *const GLchar) -> Result<()> {
		let ret = process_catch("glDebugMessageInsert", catch_unwind(||(self.debugmessageinsert)(source, type_, id, severity, length, buf)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDebugMessageInsert", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDebugMessageCallback.xhtml>
	#[inline(always)]
	fn glDebugMessageCallback(&self, callback: GLDEBUGPROC, userParam: *const c_void) -> Result<()> {
		let ret = process_catch("glDebugMessageCallback", catch_unwind(||(self.debugmessagecallback)(callback, userParam)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDebugMessageCallback", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetDebugMessageLog.xhtml>
	#[inline(always)]
	fn glGetDebugMessageLog(&self, count: GLuint, bufSize: GLsizei, sources: *mut GLenum, types: *mut GLenum, ids: *mut GLuint, severities: *mut GLenum, lengths: *mut GLsizei, messageLog: *mut GLchar) -> Result<GLuint> {
		let ret = process_catch("glGetDebugMessageLog", catch_unwind(||(self.getdebugmessagelog)(count, bufSize, sources, types, ids, severities, lengths, messageLog)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetDebugMessageLog", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPushDebugGroup.xhtml>
	#[inline(always)]
	fn glPushDebugGroup(&self, source: GLenum, id: GLuint, length: GLsizei, message: *const GLchar) -> Result<()> {
		let ret = process_catch("glPushDebugGroup", catch_unwind(||(self.pushdebuggroup)(source, id, length, message)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPushDebugGroup", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPopDebugGroup.xhtml>
	#[inline(always)]
	fn glPopDebugGroup(&self) -> Result<()> {
		let ret = process_catch("glPopDebugGroup", catch_unwind(||(self.popdebuggroup)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPopDebugGroup", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glObjectLabel.xhtml>
	#[inline(always)]
	fn glObjectLabel(&self, identifier: GLenum, name: GLuint, length: GLsizei, label: *const GLchar) -> Result<()> {
		let ret = process_catch("glObjectLabel", catch_unwind(||(self.objectlabel)(identifier, name, length, label)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glObjectLabel", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetObjectLabel.xhtml>
	#[inline(always)]
	fn glGetObjectLabel(&self, identifier: GLenum, name: GLuint, bufSize: GLsizei, length: *mut GLsizei, label: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetObjectLabel", catch_unwind(||(self.getobjectlabel)(identifier, name, bufSize, length, label)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetObjectLabel", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glObjectPtrLabel.xhtml>
	#[inline(always)]
	fn glObjectPtrLabel(&self, ptr: *const c_void, length: GLsizei, label: *const GLchar) -> Result<()> {
		let ret = process_catch("glObjectPtrLabel", catch_unwind(||(self.objectptrlabel)(ptr, length, label)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glObjectPtrLabel", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetObjectPtrLabel.xhtml>
	#[inline(always)]
	fn glGetObjectPtrLabel(&self, ptr: *const c_void, bufSize: GLsizei, length: *mut GLsizei, label: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetObjectPtrLabel", catch_unwind(||(self.getobjectptrlabel)(ptr, bufSize, length, label)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetObjectPtrLabel", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version43 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (4, 3, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			clearbufferdata: {let proc = get_proc_address("glClearBufferData"); if proc == null() {dummy_pfnglclearbufferdataproc} else {unsafe{transmute(proc)}}},
			clearbuffersubdata: {let proc = get_proc_address("glClearBufferSubData"); if proc == null() {dummy_pfnglclearbuffersubdataproc} else {unsafe{transmute(proc)}}},
			dispatchcompute: {let proc = get_proc_address("glDispatchCompute"); if proc == null() {dummy_pfngldispatchcomputeproc} else {unsafe{transmute(proc)}}},
			dispatchcomputeindirect: {let proc = get_proc_address("glDispatchComputeIndirect"); if proc == null() {dummy_pfngldispatchcomputeindirectproc} else {unsafe{transmute(proc)}}},
			copyimagesubdata: {let proc = get_proc_address("glCopyImageSubData"); if proc == null() {dummy_pfnglcopyimagesubdataproc} else {unsafe{transmute(proc)}}},
			framebufferparameteri: {let proc = get_proc_address("glFramebufferParameteri"); if proc == null() {dummy_pfnglframebufferparameteriproc} else {unsafe{transmute(proc)}}},
			getframebufferparameteriv: {let proc = get_proc_address("glGetFramebufferParameteriv"); if proc == null() {dummy_pfnglgetframebufferparameterivproc} else {unsafe{transmute(proc)}}},
			getinternalformati64v: {let proc = get_proc_address("glGetInternalformati64v"); if proc == null() {dummy_pfnglgetinternalformati64vproc} else {unsafe{transmute(proc)}}},
			invalidatetexsubimage: {let proc = get_proc_address("glInvalidateTexSubImage"); if proc == null() {dummy_pfnglinvalidatetexsubimageproc} else {unsafe{transmute(proc)}}},
			invalidateteximage: {let proc = get_proc_address("glInvalidateTexImage"); if proc == null() {dummy_pfnglinvalidateteximageproc} else {unsafe{transmute(proc)}}},
			invalidatebuffersubdata: {let proc = get_proc_address("glInvalidateBufferSubData"); if proc == null() {dummy_pfnglinvalidatebuffersubdataproc} else {unsafe{transmute(proc)}}},
			invalidatebufferdata: {let proc = get_proc_address("glInvalidateBufferData"); if proc == null() {dummy_pfnglinvalidatebufferdataproc} else {unsafe{transmute(proc)}}},
			invalidateframebuffer: {let proc = get_proc_address("glInvalidateFramebuffer"); if proc == null() {dummy_pfnglinvalidateframebufferproc} else {unsafe{transmute(proc)}}},
			invalidatesubframebuffer: {let proc = get_proc_address("glInvalidateSubFramebuffer"); if proc == null() {dummy_pfnglinvalidatesubframebufferproc} else {unsafe{transmute(proc)}}},
			multidrawarraysindirect: {let proc = get_proc_address("glMultiDrawArraysIndirect"); if proc == null() {dummy_pfnglmultidrawarraysindirectproc} else {unsafe{transmute(proc)}}},
			multidrawelementsindirect: {let proc = get_proc_address("glMultiDrawElementsIndirect"); if proc == null() {dummy_pfnglmultidrawelementsindirectproc} else {unsafe{transmute(proc)}}},
			getprograminterfaceiv: {let proc = get_proc_address("glGetProgramInterfaceiv"); if proc == null() {dummy_pfnglgetprograminterfaceivproc} else {unsafe{transmute(proc)}}},
			getprogramresourceindex: {let proc = get_proc_address("glGetProgramResourceIndex"); if proc == null() {dummy_pfnglgetprogramresourceindexproc} else {unsafe{transmute(proc)}}},
			getprogramresourcename: {let proc = get_proc_address("glGetProgramResourceName"); if proc == null() {dummy_pfnglgetprogramresourcenameproc} else {unsafe{transmute(proc)}}},
			getprogramresourceiv: {let proc = get_proc_address("glGetProgramResourceiv"); if proc == null() {dummy_pfnglgetprogramresourceivproc} else {unsafe{transmute(proc)}}},
			getprogramresourcelocation: {let proc = get_proc_address("glGetProgramResourceLocation"); if proc == null() {dummy_pfnglgetprogramresourcelocationproc} else {unsafe{transmute(proc)}}},
			getprogramresourcelocationindex: {let proc = get_proc_address("glGetProgramResourceLocationIndex"); if proc == null() {dummy_pfnglgetprogramresourcelocationindexproc} else {unsafe{transmute(proc)}}},
			shaderstorageblockbinding: {let proc = get_proc_address("glShaderStorageBlockBinding"); if proc == null() {dummy_pfnglshaderstorageblockbindingproc} else {unsafe{transmute(proc)}}},
			texbufferrange: {let proc = get_proc_address("glTexBufferRange"); if proc == null() {dummy_pfngltexbufferrangeproc} else {unsafe{transmute(proc)}}},
			texstorage2dmultisample: {let proc = get_proc_address("glTexStorage2DMultisample"); if proc == null() {dummy_pfngltexstorage2dmultisampleproc} else {unsafe{transmute(proc)}}},
			texstorage3dmultisample: {let proc = get_proc_address("glTexStorage3DMultisample"); if proc == null() {dummy_pfngltexstorage3dmultisampleproc} else {unsafe{transmute(proc)}}},
			textureview: {let proc = get_proc_address("glTextureView"); if proc == null() {dummy_pfngltextureviewproc} else {unsafe{transmute(proc)}}},
			bindvertexbuffer: {let proc = get_proc_address("glBindVertexBuffer"); if proc == null() {dummy_pfnglbindvertexbufferproc} else {unsafe{transmute(proc)}}},
			vertexattribformat: {let proc = get_proc_address("glVertexAttribFormat"); if proc == null() {dummy_pfnglvertexattribformatproc} else {unsafe{transmute(proc)}}},
			vertexattribiformat: {let proc = get_proc_address("glVertexAttribIFormat"); if proc == null() {dummy_pfnglvertexattribiformatproc} else {unsafe{transmute(proc)}}},
			vertexattriblformat: {let proc = get_proc_address("glVertexAttribLFormat"); if proc == null() {dummy_pfnglvertexattriblformatproc} else {unsafe{transmute(proc)}}},
			vertexattribbinding: {let proc = get_proc_address("glVertexAttribBinding"); if proc == null() {dummy_pfnglvertexattribbindingproc} else {unsafe{transmute(proc)}}},
			vertexbindingdivisor: {let proc = get_proc_address("glVertexBindingDivisor"); if proc == null() {dummy_pfnglvertexbindingdivisorproc} else {unsafe{transmute(proc)}}},
			debugmessagecontrol: {let proc = get_proc_address("glDebugMessageControl"); if proc == null() {dummy_pfngldebugmessagecontrolproc} else {unsafe{transmute(proc)}}},
			debugmessageinsert: {let proc = get_proc_address("glDebugMessageInsert"); if proc == null() {dummy_pfngldebugmessageinsertproc} else {unsafe{transmute(proc)}}},
			debugmessagecallback: {let proc = get_proc_address("glDebugMessageCallback"); if proc == null() {dummy_pfngldebugmessagecallbackproc} else {unsafe{transmute(proc)}}},
			getdebugmessagelog: {let proc = get_proc_address("glGetDebugMessageLog"); if proc == null() {dummy_pfnglgetdebugmessagelogproc} else {unsafe{transmute(proc)}}},
			pushdebuggroup: {let proc = get_proc_address("glPushDebugGroup"); if proc == null() {dummy_pfnglpushdebuggroupproc} else {unsafe{transmute(proc)}}},
			popdebuggroup: {let proc = get_proc_address("glPopDebugGroup"); if proc == null() {dummy_pfnglpopdebuggroupproc} else {unsafe{transmute(proc)}}},
			objectlabel: {let proc = get_proc_address("glObjectLabel"); if proc == null() {dummy_pfnglobjectlabelproc} else {unsafe{transmute(proc)}}},
			getobjectlabel: {let proc = get_proc_address("glGetObjectLabel"); if proc == null() {dummy_pfnglgetobjectlabelproc} else {unsafe{transmute(proc)}}},
			objectptrlabel: {let proc = get_proc_address("glObjectPtrLabel"); if proc == null() {dummy_pfnglobjectptrlabelproc} else {unsafe{transmute(proc)}}},
			getobjectptrlabel: {let proc = get_proc_address("glGetObjectPtrLabel"); if proc == null() {dummy_pfnglgetobjectptrlabelproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version43 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			clearbufferdata: dummy_pfnglclearbufferdataproc,
			clearbuffersubdata: dummy_pfnglclearbuffersubdataproc,
			dispatchcompute: dummy_pfngldispatchcomputeproc,
			dispatchcomputeindirect: dummy_pfngldispatchcomputeindirectproc,
			copyimagesubdata: dummy_pfnglcopyimagesubdataproc,
			framebufferparameteri: dummy_pfnglframebufferparameteriproc,
			getframebufferparameteriv: dummy_pfnglgetframebufferparameterivproc,
			getinternalformati64v: dummy_pfnglgetinternalformati64vproc,
			invalidatetexsubimage: dummy_pfnglinvalidatetexsubimageproc,
			invalidateteximage: dummy_pfnglinvalidateteximageproc,
			invalidatebuffersubdata: dummy_pfnglinvalidatebuffersubdataproc,
			invalidatebufferdata: dummy_pfnglinvalidatebufferdataproc,
			invalidateframebuffer: dummy_pfnglinvalidateframebufferproc,
			invalidatesubframebuffer: dummy_pfnglinvalidatesubframebufferproc,
			multidrawarraysindirect: dummy_pfnglmultidrawarraysindirectproc,
			multidrawelementsindirect: dummy_pfnglmultidrawelementsindirectproc,
			getprograminterfaceiv: dummy_pfnglgetprograminterfaceivproc,
			getprogramresourceindex: dummy_pfnglgetprogramresourceindexproc,
			getprogramresourcename: dummy_pfnglgetprogramresourcenameproc,
			getprogramresourceiv: dummy_pfnglgetprogramresourceivproc,
			getprogramresourcelocation: dummy_pfnglgetprogramresourcelocationproc,
			getprogramresourcelocationindex: dummy_pfnglgetprogramresourcelocationindexproc,
			shaderstorageblockbinding: dummy_pfnglshaderstorageblockbindingproc,
			texbufferrange: dummy_pfngltexbufferrangeproc,
			texstorage2dmultisample: dummy_pfngltexstorage2dmultisampleproc,
			texstorage3dmultisample: dummy_pfngltexstorage3dmultisampleproc,
			textureview: dummy_pfngltextureviewproc,
			bindvertexbuffer: dummy_pfnglbindvertexbufferproc,
			vertexattribformat: dummy_pfnglvertexattribformatproc,
			vertexattribiformat: dummy_pfnglvertexattribiformatproc,
			vertexattriblformat: dummy_pfnglvertexattriblformatproc,
			vertexattribbinding: dummy_pfnglvertexattribbindingproc,
			vertexbindingdivisor: dummy_pfnglvertexbindingdivisorproc,
			debugmessagecontrol: dummy_pfngldebugmessagecontrolproc,
			debugmessageinsert: dummy_pfngldebugmessageinsertproc,
			debugmessagecallback: dummy_pfngldebugmessagecallbackproc,
			getdebugmessagelog: dummy_pfnglgetdebugmessagelogproc,
			pushdebuggroup: dummy_pfnglpushdebuggroupproc,
			popdebuggroup: dummy_pfnglpopdebuggroupproc,
			objectlabel: dummy_pfnglobjectlabelproc,
			getobjectlabel: dummy_pfnglgetobjectlabelproc,
			objectptrlabel: dummy_pfnglobjectptrlabelproc,
			getobjectptrlabel: dummy_pfnglgetobjectptrlabelproc,
		}
	}
}
impl Debug for Version43 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version43")
			.field("available", &self.available)
			.field("clearbufferdata", unsafe{if transmute::<_, *const c_void>(self.clearbufferdata) == (dummy_pfnglclearbufferdataproc as *const c_void) {&null::<PFNGLCLEARBUFFERDATAPROC>()} else {&self.clearbufferdata}})
			.field("clearbuffersubdata", unsafe{if transmute::<_, *const c_void>(self.clearbuffersubdata) == (dummy_pfnglclearbuffersubdataproc as *const c_void) {&null::<PFNGLCLEARBUFFERSUBDATAPROC>()} else {&self.clearbuffersubdata}})
			.field("dispatchcompute", unsafe{if transmute::<_, *const c_void>(self.dispatchcompute) == (dummy_pfngldispatchcomputeproc as *const c_void) {&null::<PFNGLDISPATCHCOMPUTEPROC>()} else {&self.dispatchcompute}})
			.field("dispatchcomputeindirect", unsafe{if transmute::<_, *const c_void>(self.dispatchcomputeindirect) == (dummy_pfngldispatchcomputeindirectproc as *const c_void) {&null::<PFNGLDISPATCHCOMPUTEINDIRECTPROC>()} else {&self.dispatchcomputeindirect}})
			.field("copyimagesubdata", unsafe{if transmute::<_, *const c_void>(self.copyimagesubdata) == (dummy_pfnglcopyimagesubdataproc as *const c_void) {&null::<PFNGLCOPYIMAGESUBDATAPROC>()} else {&self.copyimagesubdata}})
			.field("framebufferparameteri", unsafe{if transmute::<_, *const c_void>(self.framebufferparameteri) == (dummy_pfnglframebufferparameteriproc as *const c_void) {&null::<PFNGLFRAMEBUFFERPARAMETERIPROC>()} else {&self.framebufferparameteri}})
			.field("getframebufferparameteriv", unsafe{if transmute::<_, *const c_void>(self.getframebufferparameteriv) == (dummy_pfnglgetframebufferparameterivproc as *const c_void) {&null::<PFNGLGETFRAMEBUFFERPARAMETERIVPROC>()} else {&self.getframebufferparameteriv}})
			.field("getinternalformati64v", unsafe{if transmute::<_, *const c_void>(self.getinternalformati64v) == (dummy_pfnglgetinternalformati64vproc as *const c_void) {&null::<PFNGLGETINTERNALFORMATI64VPROC>()} else {&self.getinternalformati64v}})
			.field("invalidatetexsubimage", unsafe{if transmute::<_, *const c_void>(self.invalidatetexsubimage) == (dummy_pfnglinvalidatetexsubimageproc as *const c_void) {&null::<PFNGLINVALIDATETEXSUBIMAGEPROC>()} else {&self.invalidatetexsubimage}})
			.field("invalidateteximage", unsafe{if transmute::<_, *const c_void>(self.invalidateteximage) == (dummy_pfnglinvalidateteximageproc as *const c_void) {&null::<PFNGLINVALIDATETEXIMAGEPROC>()} else {&self.invalidateteximage}})
			.field("invalidatebuffersubdata", unsafe{if transmute::<_, *const c_void>(self.invalidatebuffersubdata) == (dummy_pfnglinvalidatebuffersubdataproc as *const c_void) {&null::<PFNGLINVALIDATEBUFFERSUBDATAPROC>()} else {&self.invalidatebuffersubdata}})
			.field("invalidatebufferdata", unsafe{if transmute::<_, *const c_void>(self.invalidatebufferdata) == (dummy_pfnglinvalidatebufferdataproc as *const c_void) {&null::<PFNGLINVALIDATEBUFFERDATAPROC>()} else {&self.invalidatebufferdata}})
			.field("invalidateframebuffer", unsafe{if transmute::<_, *const c_void>(self.invalidateframebuffer) == (dummy_pfnglinvalidateframebufferproc as *const c_void) {&null::<PFNGLINVALIDATEFRAMEBUFFERPROC>()} else {&self.invalidateframebuffer}})
			.field("invalidatesubframebuffer", unsafe{if transmute::<_, *const c_void>(self.invalidatesubframebuffer) == (dummy_pfnglinvalidatesubframebufferproc as *const c_void) {&null::<PFNGLINVALIDATESUBFRAMEBUFFERPROC>()} else {&self.invalidatesubframebuffer}})
			.field("multidrawarraysindirect", unsafe{if transmute::<_, *const c_void>(self.multidrawarraysindirect) == (dummy_pfnglmultidrawarraysindirectproc as *const c_void) {&null::<PFNGLMULTIDRAWARRAYSINDIRECTPROC>()} else {&self.multidrawarraysindirect}})
			.field("multidrawelementsindirect", unsafe{if transmute::<_, *const c_void>(self.multidrawelementsindirect) == (dummy_pfnglmultidrawelementsindirectproc as *const c_void) {&null::<PFNGLMULTIDRAWELEMENTSINDIRECTPROC>()} else {&self.multidrawelementsindirect}})
			.field("getprograminterfaceiv", unsafe{if transmute::<_, *const c_void>(self.getprograminterfaceiv) == (dummy_pfnglgetprograminterfaceivproc as *const c_void) {&null::<PFNGLGETPROGRAMINTERFACEIVPROC>()} else {&self.getprograminterfaceiv}})
			.field("getprogramresourceindex", unsafe{if transmute::<_, *const c_void>(self.getprogramresourceindex) == (dummy_pfnglgetprogramresourceindexproc as *const c_void) {&null::<PFNGLGETPROGRAMRESOURCEINDEXPROC>()} else {&self.getprogramresourceindex}})
			.field("getprogramresourcename", unsafe{if transmute::<_, *const c_void>(self.getprogramresourcename) == (dummy_pfnglgetprogramresourcenameproc as *const c_void) {&null::<PFNGLGETPROGRAMRESOURCENAMEPROC>()} else {&self.getprogramresourcename}})
			.field("getprogramresourceiv", unsafe{if transmute::<_, *const c_void>(self.getprogramresourceiv) == (dummy_pfnglgetprogramresourceivproc as *const c_void) {&null::<PFNGLGETPROGRAMRESOURCEIVPROC>()} else {&self.getprogramresourceiv}})
			.field("getprogramresourcelocation", unsafe{if transmute::<_, *const c_void>(self.getprogramresourcelocation) == (dummy_pfnglgetprogramresourcelocationproc as *const c_void) {&null::<PFNGLGETPROGRAMRESOURCELOCATIONPROC>()} else {&self.getprogramresourcelocation}})
			.field("getprogramresourcelocationindex", unsafe{if transmute::<_, *const c_void>(self.getprogramresourcelocationindex) == (dummy_pfnglgetprogramresourcelocationindexproc as *const c_void) {&null::<PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC>()} else {&self.getprogramresourcelocationindex}})
			.field("shaderstorageblockbinding", unsafe{if transmute::<_, *const c_void>(self.shaderstorageblockbinding) == (dummy_pfnglshaderstorageblockbindingproc as *const c_void) {&null::<PFNGLSHADERSTORAGEBLOCKBINDINGPROC>()} else {&self.shaderstorageblockbinding}})
			.field("texbufferrange", unsafe{if transmute::<_, *const c_void>(self.texbufferrange) == (dummy_pfngltexbufferrangeproc as *const c_void) {&null::<PFNGLTEXBUFFERRANGEPROC>()} else {&self.texbufferrange}})
			.field("texstorage2dmultisample", unsafe{if transmute::<_, *const c_void>(self.texstorage2dmultisample) == (dummy_pfngltexstorage2dmultisampleproc as *const c_void) {&null::<PFNGLTEXSTORAGE2DMULTISAMPLEPROC>()} else {&self.texstorage2dmultisample}})
			.field("texstorage3dmultisample", unsafe{if transmute::<_, *const c_void>(self.texstorage3dmultisample) == (dummy_pfngltexstorage3dmultisampleproc as *const c_void) {&null::<PFNGLTEXSTORAGE3DMULTISAMPLEPROC>()} else {&self.texstorage3dmultisample}})
			.field("textureview", unsafe{if transmute::<_, *const c_void>(self.textureview) == (dummy_pfngltextureviewproc as *const c_void) {&null::<PFNGLTEXTUREVIEWPROC>()} else {&self.textureview}})
			.field("bindvertexbuffer", unsafe{if transmute::<_, *const c_void>(self.bindvertexbuffer) == (dummy_pfnglbindvertexbufferproc as *const c_void) {&null::<PFNGLBINDVERTEXBUFFERPROC>()} else {&self.bindvertexbuffer}})
			.field("vertexattribformat", unsafe{if transmute::<_, *const c_void>(self.vertexattribformat) == (dummy_pfnglvertexattribformatproc as *const c_void) {&null::<PFNGLVERTEXATTRIBFORMATPROC>()} else {&self.vertexattribformat}})
			.field("vertexattribiformat", unsafe{if transmute::<_, *const c_void>(self.vertexattribiformat) == (dummy_pfnglvertexattribiformatproc as *const c_void) {&null::<PFNGLVERTEXATTRIBIFORMATPROC>()} else {&self.vertexattribiformat}})
			.field("vertexattriblformat", unsafe{if transmute::<_, *const c_void>(self.vertexattriblformat) == (dummy_pfnglvertexattriblformatproc as *const c_void) {&null::<PFNGLVERTEXATTRIBLFORMATPROC>()} else {&self.vertexattriblformat}})
			.field("vertexattribbinding", unsafe{if transmute::<_, *const c_void>(self.vertexattribbinding) == (dummy_pfnglvertexattribbindingproc as *const c_void) {&null::<PFNGLVERTEXATTRIBBINDINGPROC>()} else {&self.vertexattribbinding}})
			.field("vertexbindingdivisor", unsafe{if transmute::<_, *const c_void>(self.vertexbindingdivisor) == (dummy_pfnglvertexbindingdivisorproc as *const c_void) {&null::<PFNGLVERTEXBINDINGDIVISORPROC>()} else {&self.vertexbindingdivisor}})
			.field("debugmessagecontrol", unsafe{if transmute::<_, *const c_void>(self.debugmessagecontrol) == (dummy_pfngldebugmessagecontrolproc as *const c_void) {&null::<PFNGLDEBUGMESSAGECONTROLPROC>()} else {&self.debugmessagecontrol}})
			.field("debugmessageinsert", unsafe{if transmute::<_, *const c_void>(self.debugmessageinsert) == (dummy_pfngldebugmessageinsertproc as *const c_void) {&null::<PFNGLDEBUGMESSAGEINSERTPROC>()} else {&self.debugmessageinsert}})
			.field("debugmessagecallback", unsafe{if transmute::<_, *const c_void>(self.debugmessagecallback) == (dummy_pfngldebugmessagecallbackproc as *const c_void) {&null::<PFNGLDEBUGMESSAGECALLBACKPROC>()} else {&self.debugmessagecallback}})
			.field("getdebugmessagelog", unsafe{if transmute::<_, *const c_void>(self.getdebugmessagelog) == (dummy_pfnglgetdebugmessagelogproc as *const c_void) {&null::<PFNGLGETDEBUGMESSAGELOGPROC>()} else {&self.getdebugmessagelog}})
			.field("pushdebuggroup", unsafe{if transmute::<_, *const c_void>(self.pushdebuggroup) == (dummy_pfnglpushdebuggroupproc as *const c_void) {&null::<PFNGLPUSHDEBUGGROUPPROC>()} else {&self.pushdebuggroup}})
			.field("popdebuggroup", unsafe{if transmute::<_, *const c_void>(self.popdebuggroup) == (dummy_pfnglpopdebuggroupproc as *const c_void) {&null::<PFNGLPOPDEBUGGROUPPROC>()} else {&self.popdebuggroup}})
			.field("objectlabel", unsafe{if transmute::<_, *const c_void>(self.objectlabel) == (dummy_pfnglobjectlabelproc as *const c_void) {&null::<PFNGLOBJECTLABELPROC>()} else {&self.objectlabel}})
			.field("getobjectlabel", unsafe{if transmute::<_, *const c_void>(self.getobjectlabel) == (dummy_pfnglgetobjectlabelproc as *const c_void) {&null::<PFNGLGETOBJECTLABELPROC>()} else {&self.getobjectlabel}})
			.field("objectptrlabel", unsafe{if transmute::<_, *const c_void>(self.objectptrlabel) == (dummy_pfnglobjectptrlabelproc as *const c_void) {&null::<PFNGLOBJECTPTRLABELPROC>()} else {&self.objectptrlabel}})
			.field("getobjectptrlabel", unsafe{if transmute::<_, *const c_void>(self.getobjectptrlabel) == (dummy_pfnglgetobjectptrlabelproc as *const c_void) {&null::<PFNGLGETOBJECTPTRLABELPROC>()} else {&self.getobjectptrlabel}})
			.finish()
		} else {
			f.debug_struct("Version43")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

/// The prototype to the OpenGL function `BufferStorage`
type PFNGLBUFFERSTORAGEPROC = extern "system" fn(GLenum, GLsizeiptr, *const c_void, GLbitfield);

/// The prototype to the OpenGL function `ClearTexImage`
type PFNGLCLEARTEXIMAGEPROC = extern "system" fn(GLuint, GLint, GLenum, GLenum, *const c_void);

/// The prototype to the OpenGL function `ClearTexSubImage`
type PFNGLCLEARTEXSUBIMAGEPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, *const c_void);

/// The prototype to the OpenGL function `BindBuffersBase`
type PFNGLBINDBUFFERSBASEPROC = extern "system" fn(GLenum, GLuint, GLsizei, *const GLuint);

/// The prototype to the OpenGL function `BindBuffersRange`
type PFNGLBINDBUFFERSRANGEPROC = extern "system" fn(GLenum, GLuint, GLsizei, *const GLuint, *const GLintptr, *const GLsizeiptr);

/// The prototype to the OpenGL function `BindTextures`
type PFNGLBINDTEXTURESPROC = extern "system" fn(GLuint, GLsizei, *const GLuint);

/// The prototype to the OpenGL function `BindSamplers`
type PFNGLBINDSAMPLERSPROC = extern "system" fn(GLuint, GLsizei, *const GLuint);

/// The prototype to the OpenGL function `BindImageTextures`
type PFNGLBINDIMAGETEXTURESPROC = extern "system" fn(GLuint, GLsizei, *const GLuint);

/// The prototype to the OpenGL function `BindVertexBuffers`
type PFNGLBINDVERTEXBUFFERSPROC = extern "system" fn(GLuint, GLsizei, *const GLuint, *const GLintptr, *const GLsizei);

/// The dummy function of `BufferStorage()`
extern "system" fn dummy_pfnglbufferstorageproc (_: GLenum, _: GLsizeiptr, _: *const c_void, _: GLbitfield) {
	panic!("OpenGL function pointer `glBufferStorage()` is null.")
}

/// The dummy function of `ClearTexImage()`
extern "system" fn dummy_pfnglclearteximageproc (_: GLuint, _: GLint, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glClearTexImage()` is null.")
}

/// The dummy function of `ClearTexSubImage()`
extern "system" fn dummy_pfnglcleartexsubimageproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glClearTexSubImage()` is null.")
}

/// The dummy function of `BindBuffersBase()`
extern "system" fn dummy_pfnglbindbuffersbaseproc (_: GLenum, _: GLuint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glBindBuffersBase()` is null.")
}

/// The dummy function of `BindBuffersRange()`
extern "system" fn dummy_pfnglbindbuffersrangeproc (_: GLenum, _: GLuint, _: GLsizei, _: *const GLuint, _: *const GLintptr, _: *const GLsizeiptr) {
	panic!("OpenGL function pointer `glBindBuffersRange()` is null.")
}

/// The dummy function of `BindTextures()`
extern "system" fn dummy_pfnglbindtexturesproc (_: GLuint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glBindTextures()` is null.")
}

/// The dummy function of `BindSamplers()`
extern "system" fn dummy_pfnglbindsamplersproc (_: GLuint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glBindSamplers()` is null.")
}

/// The dummy function of `BindImageTextures()`
extern "system" fn dummy_pfnglbindimagetexturesproc (_: GLuint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glBindImageTextures()` is null.")
}

/// The dummy function of `BindVertexBuffers()`
extern "system" fn dummy_pfnglbindvertexbuffersproc (_: GLuint, _: GLsizei, _: *const GLuint, _: *const GLintptr, _: *const GLsizei) {
	panic!("OpenGL function pointer `glBindVertexBuffers()` is null.")
}
/// Constant value defined from OpenGL 4.4
pub const GL_MAX_VERTEX_ATTRIB_STRIDE: GLenum = 0x82E5;

/// Constant value defined from OpenGL 4.4
pub const GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED: GLenum = 0x8221;

/// Constant value defined from OpenGL 4.4
pub const GL_TEXTURE_BUFFER_BINDING: GLenum = 0x8C2A;

/// Constant value defined from OpenGL 4.4
pub const GL_MAP_PERSISTENT_BIT: GLbitfield = 0x0040;

/// Constant value defined from OpenGL 4.4
pub const GL_MAP_COHERENT_BIT: GLbitfield = 0x0080;

/// Constant value defined from OpenGL 4.4
pub const GL_DYNAMIC_STORAGE_BIT: GLbitfield = 0x0100;

/// Constant value defined from OpenGL 4.4
pub const GL_CLIENT_STORAGE_BIT: GLbitfield = 0x0200;

/// Constant value defined from OpenGL 4.4
pub const GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT: GLbitfield = 0x00004000;

/// Constant value defined from OpenGL 4.4
pub const GL_BUFFER_IMMUTABLE_STORAGE: GLenum = 0x821F;

/// Constant value defined from OpenGL 4.4
pub const GL_BUFFER_STORAGE_FLAGS: GLenum = 0x8220;

/// Constant value defined from OpenGL 4.4
pub const GL_CLEAR_TEXTURE: GLenum = 0x9365;

/// Constant value defined from OpenGL 4.4
pub const GL_LOCATION_COMPONENT: GLenum = 0x934A;

/// Constant value defined from OpenGL 4.4
pub const GL_TRANSFORM_FEEDBACK_BUFFER_INDEX: GLenum = 0x934B;

/// Constant value defined from OpenGL 4.4
pub const GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE: GLenum = 0x934C;

/// Constant value defined from OpenGL 4.4
pub const GL_QUERY_BUFFER: GLenum = 0x9192;

/// Constant value defined from OpenGL 4.4
pub const GL_QUERY_BUFFER_BARRIER_BIT: GLbitfield = 0x00008000;

/// Constant value defined from OpenGL 4.4
pub const GL_QUERY_BUFFER_BINDING: GLenum = 0x9193;

/// Constant value defined from OpenGL 4.4
pub const GL_QUERY_RESULT_NO_WAIT: GLenum = 0x9194;

/// Constant value defined from OpenGL 4.4
pub const GL_MIRROR_CLAMP_TO_EDGE: GLenum = 0x8743;

/// Functions from OpenGL version 4.4
pub trait GL_4_4 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	fn glGetError(&self) -> GLenum;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml>
	fn glBufferStorage(&self, target: GLenum, size: GLsizeiptr, data: *const c_void, flags: GLbitfield) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearTexImage.xhtml>
	fn glClearTexImage(&self, texture: GLuint, level: GLint, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearTexSubImage.xhtml>
	fn glClearTexSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindBuffersBase.xhtml>
	fn glBindBuffersBase(&self, target: GLenum, first: GLuint, count: GLsizei, buffers: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindBuffersRange.xhtml>
	fn glBindBuffersRange(&self, target: GLenum, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, sizes: *const GLsizeiptr) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindTextures.xhtml>
	fn glBindTextures(&self, first: GLuint, count: GLsizei, textures: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindSamplers.xhtml>
	fn glBindSamplers(&self, first: GLuint, count: GLsizei, samplers: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindImageTextures.xhtml>
	fn glBindImageTextures(&self, first: GLuint, count: GLsizei, textures: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml>
	fn glBindVertexBuffers(&self, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, strides: *const GLsizei) -> Result<()>;
}
/// Functions from OpenGL version 4.4
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version44 {
	/// Is OpenGL version 4.4 available
	available: bool,

	/// The function pointer to `glGetError()`
	pub geterror: PFNGLGETERRORPROC,

	/// The function pointer to `glBufferStorage()`
	pub bufferstorage: PFNGLBUFFERSTORAGEPROC,

	/// The function pointer to `glClearTexImage()`
	pub clearteximage: PFNGLCLEARTEXIMAGEPROC,

	/// The function pointer to `glClearTexSubImage()`
	pub cleartexsubimage: PFNGLCLEARTEXSUBIMAGEPROC,

	/// The function pointer to `glBindBuffersBase()`
	pub bindbuffersbase: PFNGLBINDBUFFERSBASEPROC,

	/// The function pointer to `glBindBuffersRange()`
	pub bindbuffersrange: PFNGLBINDBUFFERSRANGEPROC,

	/// The function pointer to `glBindTextures()`
	pub bindtextures: PFNGLBINDTEXTURESPROC,

	/// The function pointer to `glBindSamplers()`
	pub bindsamplers: PFNGLBINDSAMPLERSPROC,

	/// The function pointer to `glBindImageTextures()`
	pub bindimagetextures: PFNGLBINDIMAGETEXTURESPROC,

	/// The function pointer to `glBindVertexBuffers()`
	pub bindvertexbuffers: PFNGLBINDVERTEXBUFFERSPROC,
}

impl GL_4_4 for Version44 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml>
	#[inline(always)]
	fn glBufferStorage(&self, target: GLenum, size: GLsizeiptr, data: *const c_void, flags: GLbitfield) -> Result<()> {
		let ret = process_catch("glBufferStorage", catch_unwind(||(self.bufferstorage)(target, size, data, flags)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBufferStorage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearTexImage.xhtml>
	#[inline(always)]
	fn glClearTexImage(&self, texture: GLuint, level: GLint, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearTexImage", catch_unwind(||(self.clearteximage)(texture, level, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearTexImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearTexSubImage.xhtml>
	#[inline(always)]
	fn glClearTexSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearTexSubImage", catch_unwind(||(self.cleartexsubimage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearTexSubImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindBuffersBase.xhtml>
	#[inline(always)]
	fn glBindBuffersBase(&self, target: GLenum, first: GLuint, count: GLsizei, buffers: *const GLuint) -> Result<()> {
		let ret = process_catch("glBindBuffersBase", catch_unwind(||(self.bindbuffersbase)(target, first, count, buffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBuffersBase", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindBuffersRange.xhtml>
	#[inline(always)]
	fn glBindBuffersRange(&self, target: GLenum, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, sizes: *const GLsizeiptr) -> Result<()> {
		let ret = process_catch("glBindBuffersRange", catch_unwind(||(self.bindbuffersrange)(target, first, count, buffers, offsets, sizes)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBuffersRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindTextures.xhtml>
	#[inline(always)]
	fn glBindTextures(&self, first: GLuint, count: GLsizei, textures: *const GLuint) -> Result<()> {
		let ret = process_catch("glBindTextures", catch_unwind(||(self.bindtextures)(first, count, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindTextures", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindSamplers.xhtml>
	#[inline(always)]
	fn glBindSamplers(&self, first: GLuint, count: GLsizei, samplers: *const GLuint) -> Result<()> {
		let ret = process_catch("glBindSamplers", catch_unwind(||(self.bindsamplers)(first, count, samplers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindSamplers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindImageTextures.xhtml>
	#[inline(always)]
	fn glBindImageTextures(&self, first: GLuint, count: GLsizei, textures: *const GLuint) -> Result<()> {
		let ret = process_catch("glBindImageTextures", catch_unwind(||(self.bindimagetextures)(first, count, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindImageTextures", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml>
	#[inline(always)]
	fn glBindVertexBuffers(&self, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, strides: *const GLsizei) -> Result<()> {
		let ret = process_catch("glBindVertexBuffers", catch_unwind(||(self.bindvertexbuffers)(first, count, buffers, offsets, strides)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindVertexBuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version44 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (4, 4, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			bufferstorage: {let proc = get_proc_address("glBufferStorage"); if proc == null() {dummy_pfnglbufferstorageproc} else {unsafe{transmute(proc)}}},
			clearteximage: {let proc = get_proc_address("glClearTexImage"); if proc == null() {dummy_pfnglclearteximageproc} else {unsafe{transmute(proc)}}},
			cleartexsubimage: {let proc = get_proc_address("glClearTexSubImage"); if proc == null() {dummy_pfnglcleartexsubimageproc} else {unsafe{transmute(proc)}}},
			bindbuffersbase: {let proc = get_proc_address("glBindBuffersBase"); if proc == null() {dummy_pfnglbindbuffersbaseproc} else {unsafe{transmute(proc)}}},
			bindbuffersrange: {let proc = get_proc_address("glBindBuffersRange"); if proc == null() {dummy_pfnglbindbuffersrangeproc} else {unsafe{transmute(proc)}}},
			bindtextures: {let proc = get_proc_address("glBindTextures"); if proc == null() {dummy_pfnglbindtexturesproc} else {unsafe{transmute(proc)}}},
			bindsamplers: {let proc = get_proc_address("glBindSamplers"); if proc == null() {dummy_pfnglbindsamplersproc} else {unsafe{transmute(proc)}}},
			bindimagetextures: {let proc = get_proc_address("glBindImageTextures"); if proc == null() {dummy_pfnglbindimagetexturesproc} else {unsafe{transmute(proc)}}},
			bindvertexbuffers: {let proc = get_proc_address("glBindVertexBuffers"); if proc == null() {dummy_pfnglbindvertexbuffersproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version44 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			bufferstorage: dummy_pfnglbufferstorageproc,
			clearteximage: dummy_pfnglclearteximageproc,
			cleartexsubimage: dummy_pfnglcleartexsubimageproc,
			bindbuffersbase: dummy_pfnglbindbuffersbaseproc,
			bindbuffersrange: dummy_pfnglbindbuffersrangeproc,
			bindtextures: dummy_pfnglbindtexturesproc,
			bindsamplers: dummy_pfnglbindsamplersproc,
			bindimagetextures: dummy_pfnglbindimagetexturesproc,
			bindvertexbuffers: dummy_pfnglbindvertexbuffersproc,
		}
	}
}
impl Debug for Version44 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version44")
			.field("available", &self.available)
			.field("bufferstorage", unsafe{if transmute::<_, *const c_void>(self.bufferstorage) == (dummy_pfnglbufferstorageproc as *const c_void) {&null::<PFNGLBUFFERSTORAGEPROC>()} else {&self.bufferstorage}})
			.field("clearteximage", unsafe{if transmute::<_, *const c_void>(self.clearteximage) == (dummy_pfnglclearteximageproc as *const c_void) {&null::<PFNGLCLEARTEXIMAGEPROC>()} else {&self.clearteximage}})
			.field("cleartexsubimage", unsafe{if transmute::<_, *const c_void>(self.cleartexsubimage) == (dummy_pfnglcleartexsubimageproc as *const c_void) {&null::<PFNGLCLEARTEXSUBIMAGEPROC>()} else {&self.cleartexsubimage}})
			.field("bindbuffersbase", unsafe{if transmute::<_, *const c_void>(self.bindbuffersbase) == (dummy_pfnglbindbuffersbaseproc as *const c_void) {&null::<PFNGLBINDBUFFERSBASEPROC>()} else {&self.bindbuffersbase}})
			.field("bindbuffersrange", unsafe{if transmute::<_, *const c_void>(self.bindbuffersrange) == (dummy_pfnglbindbuffersrangeproc as *const c_void) {&null::<PFNGLBINDBUFFERSRANGEPROC>()} else {&self.bindbuffersrange}})
			.field("bindtextures", unsafe{if transmute::<_, *const c_void>(self.bindtextures) == (dummy_pfnglbindtexturesproc as *const c_void) {&null::<PFNGLBINDTEXTURESPROC>()} else {&self.bindtextures}})
			.field("bindsamplers", unsafe{if transmute::<_, *const c_void>(self.bindsamplers) == (dummy_pfnglbindsamplersproc as *const c_void) {&null::<PFNGLBINDSAMPLERSPROC>()} else {&self.bindsamplers}})
			.field("bindimagetextures", unsafe{if transmute::<_, *const c_void>(self.bindimagetextures) == (dummy_pfnglbindimagetexturesproc as *const c_void) {&null::<PFNGLBINDIMAGETEXTURESPROC>()} else {&self.bindimagetextures}})
			.field("bindvertexbuffers", unsafe{if transmute::<_, *const c_void>(self.bindvertexbuffers) == (dummy_pfnglbindvertexbuffersproc as *const c_void) {&null::<PFNGLBINDVERTEXBUFFERSPROC>()} else {&self.bindvertexbuffers}})
			.finish()
		} else {
			f.debug_struct("Version44")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

/// The prototype to the OpenGL function `ClipControl`
type PFNGLCLIPCONTROLPROC = extern "system" fn(GLenum, GLenum);

/// The prototype to the OpenGL function `CreateTransformFeedbacks`
type PFNGLCREATETRANSFORMFEEDBACKSPROC = extern "system" fn(GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `TransformFeedbackBufferBase`
type PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC = extern "system" fn(GLuint, GLuint, GLuint);

/// The prototype to the OpenGL function `TransformFeedbackBufferRange`
type PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC = extern "system" fn(GLuint, GLuint, GLuint, GLintptr, GLsizeiptr);

/// The prototype to the OpenGL function `GetTransformFeedbackiv`
type PFNGLGETTRANSFORMFEEDBACKIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetTransformFeedbacki_v`
type PFNGLGETTRANSFORMFEEDBACKI_VPROC = extern "system" fn(GLuint, GLenum, GLuint, *mut GLint);

/// The prototype to the OpenGL function `GetTransformFeedbacki64_v`
type PFNGLGETTRANSFORMFEEDBACKI64_VPROC = extern "system" fn(GLuint, GLenum, GLuint, *mut GLint64);

/// The prototype to the OpenGL function `CreateBuffers`
type PFNGLCREATEBUFFERSPROC = extern "system" fn(GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `NamedBufferStorage`
type PFNGLNAMEDBUFFERSTORAGEPROC = extern "system" fn(GLuint, GLsizeiptr, *const c_void, GLbitfield);

/// The prototype to the OpenGL function `NamedBufferData`
type PFNGLNAMEDBUFFERDATAPROC = extern "system" fn(GLuint, GLsizeiptr, *const c_void, GLenum);

/// The prototype to the OpenGL function `NamedBufferSubData`
type PFNGLNAMEDBUFFERSUBDATAPROC = extern "system" fn(GLuint, GLintptr, GLsizeiptr, *const c_void);

/// The prototype to the OpenGL function `CopyNamedBufferSubData`
type PFNGLCOPYNAMEDBUFFERSUBDATAPROC = extern "system" fn(GLuint, GLuint, GLintptr, GLintptr, GLsizeiptr);

/// The prototype to the OpenGL function `ClearNamedBufferData`
type PFNGLCLEARNAMEDBUFFERDATAPROC = extern "system" fn(GLuint, GLenum, GLenum, GLenum, *const c_void);

/// The prototype to the OpenGL function `ClearNamedBufferSubData`
type PFNGLCLEARNAMEDBUFFERSUBDATAPROC = extern "system" fn(GLuint, GLenum, GLintptr, GLsizeiptr, GLenum, GLenum, *const c_void);

/// The prototype to the OpenGL function `MapNamedBuffer`
type PFNGLMAPNAMEDBUFFERPROC = extern "system" fn(GLuint, GLenum) -> *mut c_void;

/// The prototype to the OpenGL function `MapNamedBufferRange`
type PFNGLMAPNAMEDBUFFERRANGEPROC = extern "system" fn(GLuint, GLintptr, GLsizeiptr, GLbitfield) -> *mut c_void;

/// The prototype to the OpenGL function `UnmapNamedBuffer`
type PFNGLUNMAPNAMEDBUFFERPROC = extern "system" fn(GLuint) -> GLboolean;

/// The prototype to the OpenGL function `FlushMappedNamedBufferRange`
type PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC = extern "system" fn(GLuint, GLintptr, GLsizeiptr);

/// The prototype to the OpenGL function `GetNamedBufferParameteriv`
type PFNGLGETNAMEDBUFFERPARAMETERIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetNamedBufferParameteri64v`
type PFNGLGETNAMEDBUFFERPARAMETERI64VPROC = extern "system" fn(GLuint, GLenum, *mut GLint64);

/// The prototype to the OpenGL function `GetNamedBufferPointerv`
type PFNGLGETNAMEDBUFFERPOINTERVPROC = extern "system" fn(GLuint, GLenum, *mut *mut c_void);

/// The prototype to the OpenGL function `GetNamedBufferSubData`
type PFNGLGETNAMEDBUFFERSUBDATAPROC = extern "system" fn(GLuint, GLintptr, GLsizeiptr, *mut c_void);

/// The prototype to the OpenGL function `CreateFramebuffers`
type PFNGLCREATEFRAMEBUFFERSPROC = extern "system" fn(GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `NamedFramebufferRenderbuffer`
type PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC = extern "system" fn(GLuint, GLenum, GLenum, GLuint);

/// The prototype to the OpenGL function `NamedFramebufferParameteri`
type PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC = extern "system" fn(GLuint, GLenum, GLint);

/// The prototype to the OpenGL function `NamedFramebufferTexture`
type PFNGLNAMEDFRAMEBUFFERTEXTUREPROC = extern "system" fn(GLuint, GLenum, GLuint, GLint);

/// The prototype to the OpenGL function `NamedFramebufferTextureLayer`
type PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC = extern "system" fn(GLuint, GLenum, GLuint, GLint, GLint);

/// The prototype to the OpenGL function `NamedFramebufferDrawBuffer`
type PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC = extern "system" fn(GLuint, GLenum);

/// The prototype to the OpenGL function `NamedFramebufferDrawBuffers`
type PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC = extern "system" fn(GLuint, GLsizei, *const GLenum);

/// The prototype to the OpenGL function `NamedFramebufferReadBuffer`
type PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC = extern "system" fn(GLuint, GLenum);

/// The prototype to the OpenGL function `InvalidateNamedFramebufferData`
type PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC = extern "system" fn(GLuint, GLsizei, *const GLenum);

/// The prototype to the OpenGL function `InvalidateNamedFramebufferSubData`
type PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC = extern "system" fn(GLuint, GLsizei, *const GLenum, GLint, GLint, GLsizei, GLsizei);

/// The prototype to the OpenGL function `ClearNamedFramebufferiv`
type PFNGLCLEARNAMEDFRAMEBUFFERIVPROC = extern "system" fn(GLuint, GLenum, GLint, *const GLint);

/// The prototype to the OpenGL function `ClearNamedFramebufferuiv`
type PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC = extern "system" fn(GLuint, GLenum, GLint, *const GLuint);

/// The prototype to the OpenGL function `ClearNamedFramebufferfv`
type PFNGLCLEARNAMEDFRAMEBUFFERFVPROC = extern "system" fn(GLuint, GLenum, GLint, *const GLfloat);

/// The prototype to the OpenGL function `ClearNamedFramebufferfi`
type PFNGLCLEARNAMEDFRAMEBUFFERFIPROC = extern "system" fn(GLuint, GLenum, GLint, GLfloat, GLint);

/// The prototype to the OpenGL function `BlitNamedFramebuffer`
type PFNGLBLITNAMEDFRAMEBUFFERPROC = extern "system" fn(GLuint, GLuint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLbitfield, GLenum);

/// The prototype to the OpenGL function `CheckNamedFramebufferStatus`
type PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC = extern "system" fn(GLuint, GLenum) -> GLenum;

/// The prototype to the OpenGL function `GetNamedFramebufferParameteriv`
type PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetNamedFramebufferAttachmentParameteriv`
type PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC = extern "system" fn(GLuint, GLenum, GLenum, *mut GLint);

/// The prototype to the OpenGL function `CreateRenderbuffers`
type PFNGLCREATERENDERBUFFERSPROC = extern "system" fn(GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `NamedRenderbufferStorage`
type PFNGLNAMEDRENDERBUFFERSTORAGEPROC = extern "system" fn(GLuint, GLenum, GLsizei, GLsizei);

/// The prototype to the OpenGL function `NamedRenderbufferStorageMultisample`
type PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC = extern "system" fn(GLuint, GLsizei, GLenum, GLsizei, GLsizei);

/// The prototype to the OpenGL function `GetNamedRenderbufferParameteriv`
type PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `CreateTextures`
type PFNGLCREATETEXTURESPROC = extern "system" fn(GLenum, GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `TextureBuffer`
type PFNGLTEXTUREBUFFERPROC = extern "system" fn(GLuint, GLenum, GLuint);

/// The prototype to the OpenGL function `TextureBufferRange`
type PFNGLTEXTUREBUFFERRANGEPROC = extern "system" fn(GLuint, GLenum, GLuint, GLintptr, GLsizeiptr);

/// The prototype to the OpenGL function `TextureStorage1D`
type PFNGLTEXTURESTORAGE1DPROC = extern "system" fn(GLuint, GLsizei, GLenum, GLsizei);

/// The prototype to the OpenGL function `TextureStorage2D`
type PFNGLTEXTURESTORAGE2DPROC = extern "system" fn(GLuint, GLsizei, GLenum, GLsizei, GLsizei);

/// The prototype to the OpenGL function `TextureStorage3D`
type PFNGLTEXTURESTORAGE3DPROC = extern "system" fn(GLuint, GLsizei, GLenum, GLsizei, GLsizei, GLsizei);

/// The prototype to the OpenGL function `TextureStorage2DMultisample`
type PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC = extern "system" fn(GLuint, GLsizei, GLenum, GLsizei, GLsizei, GLboolean);

/// The prototype to the OpenGL function `TextureStorage3DMultisample`
type PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC = extern "system" fn(GLuint, GLsizei, GLenum, GLsizei, GLsizei, GLsizei, GLboolean);

/// The prototype to the OpenGL function `TextureSubImage1D`
type PFNGLTEXTURESUBIMAGE1DPROC = extern "system" fn(GLuint, GLint, GLint, GLsizei, GLenum, GLenum, *const c_void);

/// The prototype to the OpenGL function `TextureSubImage2D`
type PFNGLTEXTURESUBIMAGE2DPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, *const c_void);

/// The prototype to the OpenGL function `TextureSubImage3D`
type PFNGLTEXTURESUBIMAGE3DPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, *const c_void);

/// The prototype to the OpenGL function `CompressedTextureSubImage1D`
type PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC = extern "system" fn(GLuint, GLint, GLint, GLsizei, GLenum, GLsizei, *const c_void);

/// The prototype to the OpenGL function `CompressedTextureSubImage2D`
type PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, *const c_void);

/// The prototype to the OpenGL function `CompressedTextureSubImage3D`
type PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, *const c_void);

/// The prototype to the OpenGL function `CopyTextureSubImage1D`
type PFNGLCOPYTEXTURESUBIMAGE1DPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLsizei);

/// The prototype to the OpenGL function `CopyTextureSubImage2D`
type PFNGLCOPYTEXTURESUBIMAGE2DPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);

/// The prototype to the OpenGL function `CopyTextureSubImage3D`
type PFNGLCOPYTEXTURESUBIMAGE3DPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);

/// The prototype to the OpenGL function `TextureParameterf`
type PFNGLTEXTUREPARAMETERFPROC = extern "system" fn(GLuint, GLenum, GLfloat);

/// The prototype to the OpenGL function `TextureParameterfv`
type PFNGLTEXTUREPARAMETERFVPROC = extern "system" fn(GLuint, GLenum, *const GLfloat);

/// The prototype to the OpenGL function `TextureParameteri`
type PFNGLTEXTUREPARAMETERIPROC = extern "system" fn(GLuint, GLenum, GLint);

/// The prototype to the OpenGL function `TextureParameterIiv`
type PFNGLTEXTUREPARAMETERIIVPROC = extern "system" fn(GLuint, GLenum, *const GLint);

/// The prototype to the OpenGL function `TextureParameterIuiv`
type PFNGLTEXTUREPARAMETERIUIVPROC = extern "system" fn(GLuint, GLenum, *const GLuint);

/// The prototype to the OpenGL function `TextureParameteriv`
type PFNGLTEXTUREPARAMETERIVPROC = extern "system" fn(GLuint, GLenum, *const GLint);

/// The prototype to the OpenGL function `GenerateTextureMipmap`
type PFNGLGENERATETEXTUREMIPMAPPROC = extern "system" fn(GLuint);

/// The prototype to the OpenGL function `BindTextureUnit`
type PFNGLBINDTEXTUREUNITPROC = extern "system" fn(GLuint, GLuint);

/// The prototype to the OpenGL function `GetTextureImage`
type PFNGLGETTEXTUREIMAGEPROC = extern "system" fn(GLuint, GLint, GLenum, GLenum, GLsizei, *mut c_void);

/// The prototype to the OpenGL function `GetCompressedTextureImage`
type PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC = extern "system" fn(GLuint, GLint, GLsizei, *mut c_void);

/// The prototype to the OpenGL function `GetTextureLevelParameterfv`
type PFNGLGETTEXTURELEVELPARAMETERFVPROC = extern "system" fn(GLuint, GLint, GLenum, *mut GLfloat);

/// The prototype to the OpenGL function `GetTextureLevelParameteriv`
type PFNGLGETTEXTURELEVELPARAMETERIVPROC = extern "system" fn(GLuint, GLint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetTextureParameterfv`
type PFNGLGETTEXTUREPARAMETERFVPROC = extern "system" fn(GLuint, GLenum, *mut GLfloat);

/// The prototype to the OpenGL function `GetTextureParameterIiv`
type PFNGLGETTEXTUREPARAMETERIIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetTextureParameterIuiv`
type PFNGLGETTEXTUREPARAMETERIUIVPROC = extern "system" fn(GLuint, GLenum, *mut GLuint);

/// The prototype to the OpenGL function `GetTextureParameteriv`
type PFNGLGETTEXTUREPARAMETERIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `CreateVertexArrays`
type PFNGLCREATEVERTEXARRAYSPROC = extern "system" fn(GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `DisableVertexArrayAttrib`
type PFNGLDISABLEVERTEXARRAYATTRIBPROC = extern "system" fn(GLuint, GLuint);

/// The prototype to the OpenGL function `EnableVertexArrayAttrib`
type PFNGLENABLEVERTEXARRAYATTRIBPROC = extern "system" fn(GLuint, GLuint);

/// The prototype to the OpenGL function `VertexArrayElementBuffer`
type PFNGLVERTEXARRAYELEMENTBUFFERPROC = extern "system" fn(GLuint, GLuint);

/// The prototype to the OpenGL function `VertexArrayVertexBuffer`
type PFNGLVERTEXARRAYVERTEXBUFFERPROC = extern "system" fn(GLuint, GLuint, GLuint, GLintptr, GLsizei);

/// The prototype to the OpenGL function `VertexArrayVertexBuffers`
type PFNGLVERTEXARRAYVERTEXBUFFERSPROC = extern "system" fn(GLuint, GLuint, GLsizei, *const GLuint, *const GLintptr, *const GLsizei);

/// The prototype to the OpenGL function `VertexArrayAttribBinding`
type PFNGLVERTEXARRAYATTRIBBINDINGPROC = extern "system" fn(GLuint, GLuint, GLuint);

/// The prototype to the OpenGL function `VertexArrayAttribFormat`
type PFNGLVERTEXARRAYATTRIBFORMATPROC = extern "system" fn(GLuint, GLuint, GLint, GLenum, GLboolean, GLuint);

/// The prototype to the OpenGL function `VertexArrayAttribIFormat`
type PFNGLVERTEXARRAYATTRIBIFORMATPROC = extern "system" fn(GLuint, GLuint, GLint, GLenum, GLuint);

/// The prototype to the OpenGL function `VertexArrayAttribLFormat`
type PFNGLVERTEXARRAYATTRIBLFORMATPROC = extern "system" fn(GLuint, GLuint, GLint, GLenum, GLuint);

/// The prototype to the OpenGL function `VertexArrayBindingDivisor`
type PFNGLVERTEXARRAYBINDINGDIVISORPROC = extern "system" fn(GLuint, GLuint, GLuint);

/// The prototype to the OpenGL function `GetVertexArrayiv`
type PFNGLGETVERTEXARRAYIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetVertexArrayIndexediv`
type PFNGLGETVERTEXARRAYINDEXEDIVPROC = extern "system" fn(GLuint, GLuint, GLenum, *mut GLint);

/// The prototype to the OpenGL function `GetVertexArrayIndexed64iv`
type PFNGLGETVERTEXARRAYINDEXED64IVPROC = extern "system" fn(GLuint, GLuint, GLenum, *mut GLint64);

/// The prototype to the OpenGL function `CreateSamplers`
type PFNGLCREATESAMPLERSPROC = extern "system" fn(GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `CreateProgramPipelines`
type PFNGLCREATEPROGRAMPIPELINESPROC = extern "system" fn(GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `CreateQueries`
type PFNGLCREATEQUERIESPROC = extern "system" fn(GLenum, GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `GetQueryBufferObjecti64v`
type PFNGLGETQUERYBUFFEROBJECTI64VPROC = extern "system" fn(GLuint, GLuint, GLenum, GLintptr);

/// The prototype to the OpenGL function `GetQueryBufferObjectiv`
type PFNGLGETQUERYBUFFEROBJECTIVPROC = extern "system" fn(GLuint, GLuint, GLenum, GLintptr);

/// The prototype to the OpenGL function `GetQueryBufferObjectui64v`
type PFNGLGETQUERYBUFFEROBJECTUI64VPROC = extern "system" fn(GLuint, GLuint, GLenum, GLintptr);

/// The prototype to the OpenGL function `GetQueryBufferObjectuiv`
type PFNGLGETQUERYBUFFEROBJECTUIVPROC = extern "system" fn(GLuint, GLuint, GLenum, GLintptr);

/// The prototype to the OpenGL function `MemoryBarrierByRegion`
type PFNGLMEMORYBARRIERBYREGIONPROC = extern "system" fn(GLbitfield);

/// The prototype to the OpenGL function `GetTextureSubImage`
type PFNGLGETTEXTURESUBIMAGEPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, GLsizei, *mut c_void);

/// The prototype to the OpenGL function `GetCompressedTextureSubImage`
type PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLsizei, *mut c_void);

/// The prototype to the OpenGL function `GetGraphicsResetStatus`
type PFNGLGETGRAPHICSRESETSTATUSPROC = extern "system" fn() -> GLenum;

/// The prototype to the OpenGL function `GetnCompressedTexImage`
type PFNGLGETNCOMPRESSEDTEXIMAGEPROC = extern "system" fn(GLenum, GLint, GLsizei, *mut c_void);

/// The prototype to the OpenGL function `GetnTexImage`
type PFNGLGETNTEXIMAGEPROC = extern "system" fn(GLenum, GLint, GLenum, GLenum, GLsizei, *mut c_void);

/// The prototype to the OpenGL function `GetnUniformdv`
type PFNGLGETNUNIFORMDVPROC = extern "system" fn(GLuint, GLint, GLsizei, *mut GLdouble);

/// The prototype to the OpenGL function `GetnUniformfv`
type PFNGLGETNUNIFORMFVPROC = extern "system" fn(GLuint, GLint, GLsizei, *mut GLfloat);

/// The prototype to the OpenGL function `GetnUniformiv`
type PFNGLGETNUNIFORMIVPROC = extern "system" fn(GLuint, GLint, GLsizei, *mut GLint);

/// The prototype to the OpenGL function `GetnUniformuiv`
type PFNGLGETNUNIFORMUIVPROC = extern "system" fn(GLuint, GLint, GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `ReadnPixels`
type PFNGLREADNPIXELSPROC = extern "system" fn(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLsizei, *mut c_void);

/// The prototype to the OpenGL function `GetnMapdv`
type PFNGLGETNMAPDVPROC = extern "system" fn(GLenum, GLenum, GLsizei, *mut GLdouble);

/// The prototype to the OpenGL function `GetnMapfv`
type PFNGLGETNMAPFVPROC = extern "system" fn(GLenum, GLenum, GLsizei, *mut GLfloat);

/// The prototype to the OpenGL function `GetnMapiv`
type PFNGLGETNMAPIVPROC = extern "system" fn(GLenum, GLenum, GLsizei, *mut GLint);

/// The prototype to the OpenGL function `GetnPixelMapfv`
type PFNGLGETNPIXELMAPFVPROC = extern "system" fn(GLenum, GLsizei, *mut GLfloat);

/// The prototype to the OpenGL function `GetnPixelMapuiv`
type PFNGLGETNPIXELMAPUIVPROC = extern "system" fn(GLenum, GLsizei, *mut GLuint);

/// The prototype to the OpenGL function `GetnPixelMapusv`
type PFNGLGETNPIXELMAPUSVPROC = extern "system" fn(GLenum, GLsizei, *mut GLushort);

/// The prototype to the OpenGL function `GetnPolygonStipple`
type PFNGLGETNPOLYGONSTIPPLEPROC = extern "system" fn(GLsizei, *mut GLubyte);

/// The prototype to the OpenGL function `GetnColorTable`
type PFNGLGETNCOLORTABLEPROC = extern "system" fn(GLenum, GLenum, GLenum, GLsizei, *mut c_void);

/// The prototype to the OpenGL function `GetnConvolutionFilter`
type PFNGLGETNCONVOLUTIONFILTERPROC = extern "system" fn(GLenum, GLenum, GLenum, GLsizei, *mut c_void);

/// The prototype to the OpenGL function `GetnSeparableFilter`
type PFNGLGETNSEPARABLEFILTERPROC = extern "system" fn(GLenum, GLenum, GLenum, GLsizei, *mut c_void, GLsizei, *mut c_void, *mut c_void);

/// The prototype to the OpenGL function `GetnHistogram`
type PFNGLGETNHISTOGRAMPROC = extern "system" fn(GLenum, GLboolean, GLenum, GLenum, GLsizei, *mut c_void);

/// The prototype to the OpenGL function `GetnMinmax`
type PFNGLGETNMINMAXPROC = extern "system" fn(GLenum, GLboolean, GLenum, GLenum, GLsizei, *mut c_void);

/// The prototype to the OpenGL function `TextureBarrier`
type PFNGLTEXTUREBARRIERPROC = extern "system" fn();

/// The dummy function of `ClipControl()`
extern "system" fn dummy_pfnglclipcontrolproc (_: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glClipControl()` is null.")
}

/// The dummy function of `CreateTransformFeedbacks()`
extern "system" fn dummy_pfnglcreatetransformfeedbacksproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glCreateTransformFeedbacks()` is null.")
}

/// The dummy function of `TransformFeedbackBufferBase()`
extern "system" fn dummy_pfngltransformfeedbackbufferbaseproc (_: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glTransformFeedbackBufferBase()` is null.")
}

/// The dummy function of `TransformFeedbackBufferRange()`
extern "system" fn dummy_pfngltransformfeedbackbufferrangeproc (_: GLuint, _: GLuint, _: GLuint, _: GLintptr, _: GLsizeiptr) {
	panic!("OpenGL function pointer `glTransformFeedbackBufferRange()` is null.")
}

/// The dummy function of `GetTransformFeedbackiv()`
extern "system" fn dummy_pfnglgettransformfeedbackivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetTransformFeedbackiv()` is null.")
}

/// The dummy function of `GetTransformFeedbacki_v()`
extern "system" fn dummy_pfnglgettransformfeedbacki_vproc (_: GLuint, _: GLenum, _: GLuint, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetTransformFeedbacki_v()` is null.")
}

/// The dummy function of `GetTransformFeedbacki64_v()`
extern "system" fn dummy_pfnglgettransformfeedbacki64_vproc (_: GLuint, _: GLenum, _: GLuint, _: *mut GLint64) {
	panic!("OpenGL function pointer `glGetTransformFeedbacki64_v()` is null.")
}

/// The dummy function of `CreateBuffers()`
extern "system" fn dummy_pfnglcreatebuffersproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glCreateBuffers()` is null.")
}

/// The dummy function of `NamedBufferStorage()`
extern "system" fn dummy_pfnglnamedbufferstorageproc (_: GLuint, _: GLsizeiptr, _: *const c_void, _: GLbitfield) {
	panic!("OpenGL function pointer `glNamedBufferStorage()` is null.")
}

/// The dummy function of `NamedBufferData()`
extern "system" fn dummy_pfnglnamedbufferdataproc (_: GLuint, _: GLsizeiptr, _: *const c_void, _: GLenum) {
	panic!("OpenGL function pointer `glNamedBufferData()` is null.")
}

/// The dummy function of `NamedBufferSubData()`
extern "system" fn dummy_pfnglnamedbuffersubdataproc (_: GLuint, _: GLintptr, _: GLsizeiptr, _: *const c_void) {
	panic!("OpenGL function pointer `glNamedBufferSubData()` is null.")
}

/// The dummy function of `CopyNamedBufferSubData()`
extern "system" fn dummy_pfnglcopynamedbuffersubdataproc (_: GLuint, _: GLuint, _: GLintptr, _: GLintptr, _: GLsizeiptr) {
	panic!("OpenGL function pointer `glCopyNamedBufferSubData()` is null.")
}

/// The dummy function of `ClearNamedBufferData()`
extern "system" fn dummy_pfnglclearnamedbufferdataproc (_: GLuint, _: GLenum, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glClearNamedBufferData()` is null.")
}

/// The dummy function of `ClearNamedBufferSubData()`
extern "system" fn dummy_pfnglclearnamedbuffersubdataproc (_: GLuint, _: GLenum, _: GLintptr, _: GLsizeiptr, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glClearNamedBufferSubData()` is null.")
}

/// The dummy function of `MapNamedBuffer()`
extern "system" fn dummy_pfnglmapnamedbufferproc (_: GLuint, _: GLenum) -> *mut c_void {
	panic!("OpenGL function pointer `glMapNamedBuffer()` is null.")
}

/// The dummy function of `MapNamedBufferRange()`
extern "system" fn dummy_pfnglmapnamedbufferrangeproc (_: GLuint, _: GLintptr, _: GLsizeiptr, _: GLbitfield) -> *mut c_void {
	panic!("OpenGL function pointer `glMapNamedBufferRange()` is null.")
}

/// The dummy function of `UnmapNamedBuffer()`
extern "system" fn dummy_pfnglunmapnamedbufferproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glUnmapNamedBuffer()` is null.")
}

/// The dummy function of `FlushMappedNamedBufferRange()`
extern "system" fn dummy_pfnglflushmappednamedbufferrangeproc (_: GLuint, _: GLintptr, _: GLsizeiptr) {
	panic!("OpenGL function pointer `glFlushMappedNamedBufferRange()` is null.")
}

/// The dummy function of `GetNamedBufferParameteriv()`
extern "system" fn dummy_pfnglgetnamedbufferparameterivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetNamedBufferParameteriv()` is null.")
}

/// The dummy function of `GetNamedBufferParameteri64v()`
extern "system" fn dummy_pfnglgetnamedbufferparameteri64vproc (_: GLuint, _: GLenum, _: *mut GLint64) {
	panic!("OpenGL function pointer `glGetNamedBufferParameteri64v()` is null.")
}

/// The dummy function of `GetNamedBufferPointerv()`
extern "system" fn dummy_pfnglgetnamedbufferpointervproc (_: GLuint, _: GLenum, _: *mut *mut c_void) {
	panic!("OpenGL function pointer `glGetNamedBufferPointerv()` is null.")
}

/// The dummy function of `GetNamedBufferSubData()`
extern "system" fn dummy_pfnglgetnamedbuffersubdataproc (_: GLuint, _: GLintptr, _: GLsizeiptr, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetNamedBufferSubData()` is null.")
}

/// The dummy function of `CreateFramebuffers()`
extern "system" fn dummy_pfnglcreateframebuffersproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glCreateFramebuffers()` is null.")
}

/// The dummy function of `NamedFramebufferRenderbuffer()`
extern "system" fn dummy_pfnglnamedframebufferrenderbufferproc (_: GLuint, _: GLenum, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glNamedFramebufferRenderbuffer()` is null.")
}

/// The dummy function of `NamedFramebufferParameteri()`
extern "system" fn dummy_pfnglnamedframebufferparameteriproc (_: GLuint, _: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glNamedFramebufferParameteri()` is null.")
}

/// The dummy function of `NamedFramebufferTexture()`
extern "system" fn dummy_pfnglnamedframebuffertextureproc (_: GLuint, _: GLenum, _: GLuint, _: GLint) {
	panic!("OpenGL function pointer `glNamedFramebufferTexture()` is null.")
}

/// The dummy function of `NamedFramebufferTextureLayer()`
extern "system" fn dummy_pfnglnamedframebuffertexturelayerproc (_: GLuint, _: GLenum, _: GLuint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glNamedFramebufferTextureLayer()` is null.")
}

/// The dummy function of `NamedFramebufferDrawBuffer()`
extern "system" fn dummy_pfnglnamedframebufferdrawbufferproc (_: GLuint, _: GLenum) {
	panic!("OpenGL function pointer `glNamedFramebufferDrawBuffer()` is null.")
}

/// The dummy function of `NamedFramebufferDrawBuffers()`
extern "system" fn dummy_pfnglnamedframebufferdrawbuffersproc (_: GLuint, _: GLsizei, _: *const GLenum) {
	panic!("OpenGL function pointer `glNamedFramebufferDrawBuffers()` is null.")
}

/// The dummy function of `NamedFramebufferReadBuffer()`
extern "system" fn dummy_pfnglnamedframebufferreadbufferproc (_: GLuint, _: GLenum) {
	panic!("OpenGL function pointer `glNamedFramebufferReadBuffer()` is null.")
}

/// The dummy function of `InvalidateNamedFramebufferData()`
extern "system" fn dummy_pfnglinvalidatenamedframebufferdataproc (_: GLuint, _: GLsizei, _: *const GLenum) {
	panic!("OpenGL function pointer `glInvalidateNamedFramebufferData()` is null.")
}

/// The dummy function of `InvalidateNamedFramebufferSubData()`
extern "system" fn dummy_pfnglinvalidatenamedframebuffersubdataproc (_: GLuint, _: GLsizei, _: *const GLenum, _: GLint, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glInvalidateNamedFramebufferSubData()` is null.")
}

/// The dummy function of `ClearNamedFramebufferiv()`
extern "system" fn dummy_pfnglclearnamedframebufferivproc (_: GLuint, _: GLenum, _: GLint, _: *const GLint) {
	panic!("OpenGL function pointer `glClearNamedFramebufferiv()` is null.")
}

/// The dummy function of `ClearNamedFramebufferuiv()`
extern "system" fn dummy_pfnglclearnamedframebufferuivproc (_: GLuint, _: GLenum, _: GLint, _: *const GLuint) {
	panic!("OpenGL function pointer `glClearNamedFramebufferuiv()` is null.")
}

/// The dummy function of `ClearNamedFramebufferfv()`
extern "system" fn dummy_pfnglclearnamedframebufferfvproc (_: GLuint, _: GLenum, _: GLint, _: *const GLfloat) {
	panic!("OpenGL function pointer `glClearNamedFramebufferfv()` is null.")
}

/// The dummy function of `ClearNamedFramebufferfi()`
extern "system" fn dummy_pfnglclearnamedframebufferfiproc (_: GLuint, _: GLenum, _: GLint, _: GLfloat, _: GLint) {
	panic!("OpenGL function pointer `glClearNamedFramebufferfi()` is null.")
}

/// The dummy function of `BlitNamedFramebuffer()`
extern "system" fn dummy_pfnglblitnamedframebufferproc (_: GLuint, _: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLbitfield, _: GLenum) {
	panic!("OpenGL function pointer `glBlitNamedFramebuffer()` is null.")
}

/// The dummy function of `CheckNamedFramebufferStatus()`
extern "system" fn dummy_pfnglchecknamedframebufferstatusproc (_: GLuint, _: GLenum) -> GLenum {
	panic!("OpenGL function pointer `glCheckNamedFramebufferStatus()` is null.")
}

/// The dummy function of `GetNamedFramebufferParameteriv()`
extern "system" fn dummy_pfnglgetnamedframebufferparameterivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetNamedFramebufferParameteriv()` is null.")
}

/// The dummy function of `GetNamedFramebufferAttachmentParameteriv()`
extern "system" fn dummy_pfnglgetnamedframebufferattachmentparameterivproc (_: GLuint, _: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetNamedFramebufferAttachmentParameteriv()` is null.")
}

/// The dummy function of `CreateRenderbuffers()`
extern "system" fn dummy_pfnglcreaterenderbuffersproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glCreateRenderbuffers()` is null.")
}

/// The dummy function of `NamedRenderbufferStorage()`
extern "system" fn dummy_pfnglnamedrenderbufferstorageproc (_: GLuint, _: GLenum, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glNamedRenderbufferStorage()` is null.")
}

/// The dummy function of `NamedRenderbufferStorageMultisample()`
extern "system" fn dummy_pfnglnamedrenderbufferstoragemultisampleproc (_: GLuint, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glNamedRenderbufferStorageMultisample()` is null.")
}

/// The dummy function of `GetNamedRenderbufferParameteriv()`
extern "system" fn dummy_pfnglgetnamedrenderbufferparameterivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetNamedRenderbufferParameteriv()` is null.")
}

/// The dummy function of `CreateTextures()`
extern "system" fn dummy_pfnglcreatetexturesproc (_: GLenum, _: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glCreateTextures()` is null.")
}

/// The dummy function of `TextureBuffer()`
extern "system" fn dummy_pfngltexturebufferproc (_: GLuint, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glTextureBuffer()` is null.")
}

/// The dummy function of `TextureBufferRange()`
extern "system" fn dummy_pfngltexturebufferrangeproc (_: GLuint, _: GLenum, _: GLuint, _: GLintptr, _: GLsizeiptr) {
	panic!("OpenGL function pointer `glTextureBufferRange()` is null.")
}

/// The dummy function of `TextureStorage1D()`
extern "system" fn dummy_pfngltexturestorage1dproc (_: GLuint, _: GLsizei, _: GLenum, _: GLsizei) {
	panic!("OpenGL function pointer `glTextureStorage1D()` is null.")
}

/// The dummy function of `TextureStorage2D()`
extern "system" fn dummy_pfngltexturestorage2dproc (_: GLuint, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glTextureStorage2D()` is null.")
}

/// The dummy function of `TextureStorage3D()`
extern "system" fn dummy_pfngltexturestorage3dproc (_: GLuint, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glTextureStorage3D()` is null.")
}

/// The dummy function of `TextureStorage2DMultisample()`
extern "system" fn dummy_pfngltexturestorage2dmultisampleproc (_: GLuint, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei, _: GLboolean) {
	panic!("OpenGL function pointer `glTextureStorage2DMultisample()` is null.")
}

/// The dummy function of `TextureStorage3DMultisample()`
extern "system" fn dummy_pfngltexturestorage3dmultisampleproc (_: GLuint, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei, _: GLsizei, _: GLboolean) {
	panic!("OpenGL function pointer `glTextureStorage3DMultisample()` is null.")
}

/// The dummy function of `TextureSubImage1D()`
extern "system" fn dummy_pfngltexturesubimage1dproc (_: GLuint, _: GLint, _: GLint, _: GLsizei, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glTextureSubImage1D()` is null.")
}

/// The dummy function of `TextureSubImage2D()`
extern "system" fn dummy_pfngltexturesubimage2dproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glTextureSubImage2D()` is null.")
}

/// The dummy function of `TextureSubImage3D()`
extern "system" fn dummy_pfngltexturesubimage3dproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glTextureSubImage3D()` is null.")
}

/// The dummy function of `CompressedTextureSubImage1D()`
extern "system" fn dummy_pfnglcompressedtexturesubimage1dproc (_: GLuint, _: GLint, _: GLint, _: GLsizei, _: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glCompressedTextureSubImage1D()` is null.")
}

/// The dummy function of `CompressedTextureSubImage2D()`
extern "system" fn dummy_pfnglcompressedtexturesubimage2dproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glCompressedTextureSubImage2D()` is null.")
}

/// The dummy function of `CompressedTextureSubImage3D()`
extern "system" fn dummy_pfnglcompressedtexturesubimage3dproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei, _: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glCompressedTextureSubImage3D()` is null.")
}

/// The dummy function of `CopyTextureSubImage1D()`
extern "system" fn dummy_pfnglcopytexturesubimage1dproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei) {
	panic!("OpenGL function pointer `glCopyTextureSubImage1D()` is null.")
}

/// The dummy function of `CopyTextureSubImage2D()`
extern "system" fn dummy_pfnglcopytexturesubimage2dproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glCopyTextureSubImage2D()` is null.")
}

/// The dummy function of `CopyTextureSubImage3D()`
extern "system" fn dummy_pfnglcopytexturesubimage3dproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glCopyTextureSubImage3D()` is null.")
}

/// The dummy function of `TextureParameterf()`
extern "system" fn dummy_pfngltextureparameterfproc (_: GLuint, _: GLenum, _: GLfloat) {
	panic!("OpenGL function pointer `glTextureParameterf()` is null.")
}

/// The dummy function of `TextureParameterfv()`
extern "system" fn dummy_pfngltextureparameterfvproc (_: GLuint, _: GLenum, _: *const GLfloat) {
	panic!("OpenGL function pointer `glTextureParameterfv()` is null.")
}

/// The dummy function of `TextureParameteri()`
extern "system" fn dummy_pfngltextureparameteriproc (_: GLuint, _: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glTextureParameteri()` is null.")
}

/// The dummy function of `TextureParameterIiv()`
extern "system" fn dummy_pfngltextureparameteriivproc (_: GLuint, _: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glTextureParameterIiv()` is null.")
}

/// The dummy function of `TextureParameterIuiv()`
extern "system" fn dummy_pfngltextureparameteriuivproc (_: GLuint, _: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glTextureParameterIuiv()` is null.")
}

/// The dummy function of `TextureParameteriv()`
extern "system" fn dummy_pfngltextureparameterivproc (_: GLuint, _: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glTextureParameteriv()` is null.")
}

/// The dummy function of `GenerateTextureMipmap()`
extern "system" fn dummy_pfnglgeneratetexturemipmapproc (_: GLuint) {
	panic!("OpenGL function pointer `glGenerateTextureMipmap()` is null.")
}

/// The dummy function of `BindTextureUnit()`
extern "system" fn dummy_pfnglbindtextureunitproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glBindTextureUnit()` is null.")
}

/// The dummy function of `GetTextureImage()`
extern "system" fn dummy_pfnglgettextureimageproc (_: GLuint, _: GLint, _: GLenum, _: GLenum, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetTextureImage()` is null.")
}

/// The dummy function of `GetCompressedTextureImage()`
extern "system" fn dummy_pfnglgetcompressedtextureimageproc (_: GLuint, _: GLint, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetCompressedTextureImage()` is null.")
}

/// The dummy function of `GetTextureLevelParameterfv()`
extern "system" fn dummy_pfnglgettexturelevelparameterfvproc (_: GLuint, _: GLint, _: GLenum, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetTextureLevelParameterfv()` is null.")
}

/// The dummy function of `GetTextureLevelParameteriv()`
extern "system" fn dummy_pfnglgettexturelevelparameterivproc (_: GLuint, _: GLint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetTextureLevelParameteriv()` is null.")
}

/// The dummy function of `GetTextureParameterfv()`
extern "system" fn dummy_pfnglgettextureparameterfvproc (_: GLuint, _: GLenum, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetTextureParameterfv()` is null.")
}

/// The dummy function of `GetTextureParameterIiv()`
extern "system" fn dummy_pfnglgettextureparameteriivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetTextureParameterIiv()` is null.")
}

/// The dummy function of `GetTextureParameterIuiv()`
extern "system" fn dummy_pfnglgettextureparameteriuivproc (_: GLuint, _: GLenum, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetTextureParameterIuiv()` is null.")
}

/// The dummy function of `GetTextureParameteriv()`
extern "system" fn dummy_pfnglgettextureparameterivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetTextureParameteriv()` is null.")
}

/// The dummy function of `CreateVertexArrays()`
extern "system" fn dummy_pfnglcreatevertexarraysproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glCreateVertexArrays()` is null.")
}

/// The dummy function of `DisableVertexArrayAttrib()`
extern "system" fn dummy_pfngldisablevertexarrayattribproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glDisableVertexArrayAttrib()` is null.")
}

/// The dummy function of `EnableVertexArrayAttrib()`
extern "system" fn dummy_pfnglenablevertexarrayattribproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glEnableVertexArrayAttrib()` is null.")
}

/// The dummy function of `VertexArrayElementBuffer()`
extern "system" fn dummy_pfnglvertexarrayelementbufferproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexArrayElementBuffer()` is null.")
}

/// The dummy function of `VertexArrayVertexBuffer()`
extern "system" fn dummy_pfnglvertexarrayvertexbufferproc (_: GLuint, _: GLuint, _: GLuint, _: GLintptr, _: GLsizei) {
	panic!("OpenGL function pointer `glVertexArrayVertexBuffer()` is null.")
}

/// The dummy function of `VertexArrayVertexBuffers()`
extern "system" fn dummy_pfnglvertexarrayvertexbuffersproc (_: GLuint, _: GLuint, _: GLsizei, _: *const GLuint, _: *const GLintptr, _: *const GLsizei) {
	panic!("OpenGL function pointer `glVertexArrayVertexBuffers()` is null.")
}

/// The dummy function of `VertexArrayAttribBinding()`
extern "system" fn dummy_pfnglvertexarrayattribbindingproc (_: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexArrayAttribBinding()` is null.")
}

/// The dummy function of `VertexArrayAttribFormat()`
extern "system" fn dummy_pfnglvertexarrayattribformatproc (_: GLuint, _: GLuint, _: GLint, _: GLenum, _: GLboolean, _: GLuint) {
	panic!("OpenGL function pointer `glVertexArrayAttribFormat()` is null.")
}

/// The dummy function of `VertexArrayAttribIFormat()`
extern "system" fn dummy_pfnglvertexarrayattribiformatproc (_: GLuint, _: GLuint, _: GLint, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glVertexArrayAttribIFormat()` is null.")
}

/// The dummy function of `VertexArrayAttribLFormat()`
extern "system" fn dummy_pfnglvertexarrayattriblformatproc (_: GLuint, _: GLuint, _: GLint, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glVertexArrayAttribLFormat()` is null.")
}

/// The dummy function of `VertexArrayBindingDivisor()`
extern "system" fn dummy_pfnglvertexarraybindingdivisorproc (_: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexArrayBindingDivisor()` is null.")
}

/// The dummy function of `GetVertexArrayiv()`
extern "system" fn dummy_pfnglgetvertexarrayivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetVertexArrayiv()` is null.")
}

/// The dummy function of `GetVertexArrayIndexediv()`
extern "system" fn dummy_pfnglgetvertexarrayindexedivproc (_: GLuint, _: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetVertexArrayIndexediv()` is null.")
}

/// The dummy function of `GetVertexArrayIndexed64iv()`
extern "system" fn dummy_pfnglgetvertexarrayindexed64ivproc (_: GLuint, _: GLuint, _: GLenum, _: *mut GLint64) {
	panic!("OpenGL function pointer `glGetVertexArrayIndexed64iv()` is null.")
}

/// The dummy function of `CreateSamplers()`
extern "system" fn dummy_pfnglcreatesamplersproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glCreateSamplers()` is null.")
}

/// The dummy function of `CreateProgramPipelines()`
extern "system" fn dummy_pfnglcreateprogrampipelinesproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glCreateProgramPipelines()` is null.")
}

/// The dummy function of `CreateQueries()`
extern "system" fn dummy_pfnglcreatequeriesproc (_: GLenum, _: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glCreateQueries()` is null.")
}

/// The dummy function of `GetQueryBufferObjecti64v()`
extern "system" fn dummy_pfnglgetquerybufferobjecti64vproc (_: GLuint, _: GLuint, _: GLenum, _: GLintptr) {
	panic!("OpenGL function pointer `glGetQueryBufferObjecti64v()` is null.")
}

/// The dummy function of `GetQueryBufferObjectiv()`
extern "system" fn dummy_pfnglgetquerybufferobjectivproc (_: GLuint, _: GLuint, _: GLenum, _: GLintptr) {
	panic!("OpenGL function pointer `glGetQueryBufferObjectiv()` is null.")
}

/// The dummy function of `GetQueryBufferObjectui64v()`
extern "system" fn dummy_pfnglgetquerybufferobjectui64vproc (_: GLuint, _: GLuint, _: GLenum, _: GLintptr) {
	panic!("OpenGL function pointer `glGetQueryBufferObjectui64v()` is null.")
}

/// The dummy function of `GetQueryBufferObjectuiv()`
extern "system" fn dummy_pfnglgetquerybufferobjectuivproc (_: GLuint, _: GLuint, _: GLenum, _: GLintptr) {
	panic!("OpenGL function pointer `glGetQueryBufferObjectuiv()` is null.")
}

/// The dummy function of `MemoryBarrierByRegion()`
extern "system" fn dummy_pfnglmemorybarrierbyregionproc (_: GLbitfield) {
	panic!("OpenGL function pointer `glMemoryBarrierByRegion()` is null.")
}

/// The dummy function of `GetTextureSubImage()`
extern "system" fn dummy_pfnglgettexturesubimageproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei, _: GLenum, _: GLenum, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetTextureSubImage()` is null.")
}

/// The dummy function of `GetCompressedTextureSubImage()`
extern "system" fn dummy_pfnglgetcompressedtexturesubimageproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetCompressedTextureSubImage()` is null.")
}

/// The dummy function of `GetGraphicsResetStatus()`
extern "system" fn dummy_pfnglgetgraphicsresetstatusproc () -> GLenum {
	panic!("OpenGL function pointer `glGetGraphicsResetStatus()` is null.")
}

/// The dummy function of `GetnCompressedTexImage()`
extern "system" fn dummy_pfnglgetncompressedteximageproc (_: GLenum, _: GLint, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetnCompressedTexImage()` is null.")
}

/// The dummy function of `GetnTexImage()`
extern "system" fn dummy_pfnglgetnteximageproc (_: GLenum, _: GLint, _: GLenum, _: GLenum, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetnTexImage()` is null.")
}

/// The dummy function of `GetnUniformdv()`
extern "system" fn dummy_pfnglgetnuniformdvproc (_: GLuint, _: GLint, _: GLsizei, _: *mut GLdouble) {
	panic!("OpenGL function pointer `glGetnUniformdv()` is null.")
}

/// The dummy function of `GetnUniformfv()`
extern "system" fn dummy_pfnglgetnuniformfvproc (_: GLuint, _: GLint, _: GLsizei, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetnUniformfv()` is null.")
}

/// The dummy function of `GetnUniformiv()`
extern "system" fn dummy_pfnglgetnuniformivproc (_: GLuint, _: GLint, _: GLsizei, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetnUniformiv()` is null.")
}

/// The dummy function of `GetnUniformuiv()`
extern "system" fn dummy_pfnglgetnuniformuivproc (_: GLuint, _: GLint, _: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetnUniformuiv()` is null.")
}

/// The dummy function of `ReadnPixels()`
extern "system" fn dummy_pfnglreadnpixelsproc (_: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLenum, _: GLenum, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glReadnPixels()` is null.")
}

/// The dummy function of `GetnMapdv()`
extern "system" fn dummy_pfnglgetnmapdvproc (_: GLenum, _: GLenum, _: GLsizei, _: *mut GLdouble) {
	panic!("OpenGL function pointer `glGetnMapdv()` is null.")
}

/// The dummy function of `GetnMapfv()`
extern "system" fn dummy_pfnglgetnmapfvproc (_: GLenum, _: GLenum, _: GLsizei, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetnMapfv()` is null.")
}

/// The dummy function of `GetnMapiv()`
extern "system" fn dummy_pfnglgetnmapivproc (_: GLenum, _: GLenum, _: GLsizei, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetnMapiv()` is null.")
}

/// The dummy function of `GetnPixelMapfv()`
extern "system" fn dummy_pfnglgetnpixelmapfvproc (_: GLenum, _: GLsizei, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetnPixelMapfv()` is null.")
}

/// The dummy function of `GetnPixelMapuiv()`
extern "system" fn dummy_pfnglgetnpixelmapuivproc (_: GLenum, _: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetnPixelMapuiv()` is null.")
}

/// The dummy function of `GetnPixelMapusv()`
extern "system" fn dummy_pfnglgetnpixelmapusvproc (_: GLenum, _: GLsizei, _: *mut GLushort) {
	panic!("OpenGL function pointer `glGetnPixelMapusv()` is null.")
}

/// The dummy function of `GetnPolygonStipple()`
extern "system" fn dummy_pfnglgetnpolygonstippleproc (_: GLsizei, _: *mut GLubyte) {
	panic!("OpenGL function pointer `glGetnPolygonStipple()` is null.")
}

/// The dummy function of `GetnColorTable()`
extern "system" fn dummy_pfnglgetncolortableproc (_: GLenum, _: GLenum, _: GLenum, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetnColorTable()` is null.")
}

/// The dummy function of `GetnConvolutionFilter()`
extern "system" fn dummy_pfnglgetnconvolutionfilterproc (_: GLenum, _: GLenum, _: GLenum, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetnConvolutionFilter()` is null.")
}

/// The dummy function of `GetnSeparableFilter()`
extern "system" fn dummy_pfnglgetnseparablefilterproc (_: GLenum, _: GLenum, _: GLenum, _: GLsizei, _: *mut c_void, _: GLsizei, _: *mut c_void, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetnSeparableFilter()` is null.")
}

/// The dummy function of `GetnHistogram()`
extern "system" fn dummy_pfnglgetnhistogramproc (_: GLenum, _: GLboolean, _: GLenum, _: GLenum, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetnHistogram()` is null.")
}

/// The dummy function of `GetnMinmax()`
extern "system" fn dummy_pfnglgetnminmaxproc (_: GLenum, _: GLboolean, _: GLenum, _: GLenum, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetnMinmax()` is null.")
}

/// The dummy function of `TextureBarrier()`
extern "system" fn dummy_pfngltexturebarrierproc () {
	panic!("OpenGL function pointer `glTextureBarrier()` is null.")
}
/// Constant value defined from OpenGL 4.5
pub const GL_CONTEXT_LOST: GLenum = 0x0507;

/// Constant value defined from OpenGL 4.5
pub const GL_NEGATIVE_ONE_TO_ONE: GLenum = 0x935E;

/// Constant value defined from OpenGL 4.5
pub const GL_ZERO_TO_ONE: GLenum = 0x935F;

/// Constant value defined from OpenGL 4.5
pub const GL_CLIP_ORIGIN: GLenum = 0x935C;

/// Constant value defined from OpenGL 4.5
pub const GL_CLIP_DEPTH_MODE: GLenum = 0x935D;

/// Constant value defined from OpenGL 4.5
pub const GL_QUERY_WAIT_INVERTED: GLenum = 0x8E17;

/// Constant value defined from OpenGL 4.5
pub const GL_QUERY_NO_WAIT_INVERTED: GLenum = 0x8E18;

/// Constant value defined from OpenGL 4.5
pub const GL_QUERY_BY_REGION_WAIT_INVERTED: GLenum = 0x8E19;

/// Constant value defined from OpenGL 4.5
pub const GL_QUERY_BY_REGION_NO_WAIT_INVERTED: GLenum = 0x8E1A;

/// Constant value defined from OpenGL 4.5
pub const GL_MAX_CULL_DISTANCES: GLenum = 0x82F9;

/// Constant value defined from OpenGL 4.5
pub const GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES: GLenum = 0x82FA;

/// Constant value defined from OpenGL 4.5
pub const GL_TEXTURE_TARGET: GLenum = 0x1006;

/// Constant value defined from OpenGL 4.5
pub const GL_QUERY_TARGET: GLenum = 0x82EA;

/// Constant value defined from OpenGL 4.5
pub const GL_GUILTY_CONTEXT_RESET: GLenum = 0x8253;

/// Constant value defined from OpenGL 4.5
pub const GL_INNOCENT_CONTEXT_RESET: GLenum = 0x8254;

/// Constant value defined from OpenGL 4.5
pub const GL_UNKNOWN_CONTEXT_RESET: GLenum = 0x8255;

/// Constant value defined from OpenGL 4.5
pub const GL_RESET_NOTIFICATION_STRATEGY: GLenum = 0x8256;

/// Constant value defined from OpenGL 4.5
pub const GL_LOSE_CONTEXT_ON_RESET: GLenum = 0x8252;

/// Constant value defined from OpenGL 4.5
pub const GL_NO_RESET_NOTIFICATION: GLenum = 0x8261;

/// Constant value defined from OpenGL 4.5
pub const GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT: GLbitfield = 0x00000004;

/// Constant value defined from OpenGL 4.5
pub const GL_COLOR_TABLE: GLenum = 0x80D0;

/// Constant value defined from OpenGL 4.5
pub const GL_POST_CONVOLUTION_COLOR_TABLE: GLenum = 0x80D1;

/// Constant value defined from OpenGL 4.5
pub const GL_POST_COLOR_MATRIX_COLOR_TABLE: GLenum = 0x80D2;

/// Constant value defined from OpenGL 4.5
pub const GL_PROXY_COLOR_TABLE: GLenum = 0x80D3;

/// Constant value defined from OpenGL 4.5
pub const GL_PROXY_POST_CONVOLUTION_COLOR_TABLE: GLenum = 0x80D4;

/// Constant value defined from OpenGL 4.5
pub const GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE: GLenum = 0x80D5;

/// Constant value defined from OpenGL 4.5
pub const GL_CONVOLUTION_1D: GLenum = 0x8010;

/// Constant value defined from OpenGL 4.5
pub const GL_CONVOLUTION_2D: GLenum = 0x8011;

/// Constant value defined from OpenGL 4.5
pub const GL_SEPARABLE_2D: GLenum = 0x8012;

/// Constant value defined from OpenGL 4.5
pub const GL_HISTOGRAM: GLenum = 0x8024;

/// Constant value defined from OpenGL 4.5
pub const GL_PROXY_HISTOGRAM: GLenum = 0x8025;

/// Constant value defined from OpenGL 4.5
pub const GL_MINMAX: GLenum = 0x802E;

/// Constant value defined from OpenGL 4.5
pub const GL_CONTEXT_RELEASE_BEHAVIOR: GLenum = 0x82FB;

/// Constant value defined from OpenGL 4.5
pub const GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH: GLenum = 0x82FC;

/// Functions from OpenGL version 4.5
pub trait GL_4_5 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	fn glGetError(&self) -> GLenum;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClipControl.xhtml>
	fn glClipControl(&self, origin: GLenum, depth: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateTransformFeedbacks.xhtml>
	fn glCreateTransformFeedbacks(&self, n: GLsizei, ids: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferBase.xhtml>
	fn glTransformFeedbackBufferBase(&self, xfb: GLuint, index: GLuint, buffer: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferRange.xhtml>
	fn glTransformFeedbackBufferRange(&self, xfb: GLuint, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTransformFeedbackiv.xhtml>
	fn glGetTransformFeedbackiv(&self, xfb: GLuint, pname: GLenum, param: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTransformFeedbacki_v.xhtml>
	fn glGetTransformFeedbacki_v(&self, xfb: GLuint, pname: GLenum, index: GLuint, param: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTransformFeedbacki64_v.xhtml>
	fn glGetTransformFeedbacki64_v(&self, xfb: GLuint, pname: GLenum, index: GLuint, param: *mut GLint64) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateBuffers.xhtml>
	fn glCreateBuffers(&self, n: GLsizei, buffers: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedBufferStorage.xhtml>
	fn glNamedBufferStorage(&self, buffer: GLuint, size: GLsizeiptr, data: *const c_void, flags: GLbitfield) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedBufferData.xhtml>
	fn glNamedBufferData(&self, buffer: GLuint, size: GLsizeiptr, data: *const c_void, usage: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedBufferSubData.xhtml>
	fn glNamedBufferSubData(&self, buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyNamedBufferSubData.xhtml>
	fn glCopyNamedBufferSubData(&self, readBuffer: GLuint, writeBuffer: GLuint, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearNamedBufferData.xhtml>
	fn glClearNamedBufferData(&self, buffer: GLuint, internalformat: GLenum, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearNamedBufferSubData.xhtml>
	fn glClearNamedBufferSubData(&self, buffer: GLuint, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMapNamedBuffer.xhtml>
	fn glMapNamedBuffer(&self, buffer: GLuint, access: GLenum) -> Result<*mut c_void>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMapNamedBufferRange.xhtml>
	fn glMapNamedBufferRange(&self, buffer: GLuint, offset: GLintptr, length: GLsizeiptr, access: GLbitfield) -> Result<*mut c_void>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUnmapNamedBuffer.xhtml>
	fn glUnmapNamedBuffer(&self, buffer: GLuint) -> Result<GLboolean>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFlushMappedNamedBufferRange.xhtml>
	fn glFlushMappedNamedBufferRange(&self, buffer: GLuint, offset: GLintptr, length: GLsizeiptr) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedBufferParameteriv.xhtml>
	fn glGetNamedBufferParameteriv(&self, buffer: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedBufferParameteri64v.xhtml>
	fn glGetNamedBufferParameteri64v(&self, buffer: GLuint, pname: GLenum, params: *mut GLint64) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedBufferPointerv.xhtml>
	fn glGetNamedBufferPointerv(&self, buffer: GLuint, pname: GLenum, params: *mut *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedBufferSubData.xhtml>
	fn glGetNamedBufferSubData(&self, buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateFramebuffers.xhtml>
	fn glCreateFramebuffers(&self, n: GLsizei, framebuffers: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferRenderbuffer.xhtml>
	fn glNamedFramebufferRenderbuffer(&self, framebuffer: GLuint, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferParameteri.xhtml>
	fn glNamedFramebufferParameteri(&self, framebuffer: GLuint, pname: GLenum, param: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferTexture.xhtml>
	fn glNamedFramebufferTexture(&self, framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferTextureLayer.xhtml>
	fn glNamedFramebufferTextureLayer(&self, framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferDrawBuffer.xhtml>
	fn glNamedFramebufferDrawBuffer(&self, framebuffer: GLuint, buf: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferDrawBuffers.xhtml>
	fn glNamedFramebufferDrawBuffers(&self, framebuffer: GLuint, n: GLsizei, bufs: *const GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferReadBuffer.xhtml>
	fn glNamedFramebufferReadBuffer(&self, framebuffer: GLuint, src: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateNamedFramebufferData.xhtml>
	fn glInvalidateNamedFramebufferData(&self, framebuffer: GLuint, numAttachments: GLsizei, attachments: *const GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateNamedFramebufferSubData.xhtml>
	fn glInvalidateNamedFramebufferSubData(&self, framebuffer: GLuint, numAttachments: GLsizei, attachments: *const GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearNamedFramebufferiv.xhtml>
	fn glClearNamedFramebufferiv(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearNamedFramebufferuiv.xhtml>
	fn glClearNamedFramebufferuiv(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearNamedFramebufferfv.xhtml>
	fn glClearNamedFramebufferfv(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearNamedFramebufferfi.xhtml>
	fn glClearNamedFramebufferfi(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlitNamedFramebuffer.xhtml>
	fn glBlitNamedFramebuffer(&self, readFramebuffer: GLuint, drawFramebuffer: GLuint, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCheckNamedFramebufferStatus.xhtml>
	fn glCheckNamedFramebufferStatus(&self, framebuffer: GLuint, target: GLenum) -> Result<GLenum>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedFramebufferParameteriv.xhtml>
	fn glGetNamedFramebufferParameteriv(&self, framebuffer: GLuint, pname: GLenum, param: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedFramebufferAttachmentParameteriv.xhtml>
	fn glGetNamedFramebufferAttachmentParameteriv(&self, framebuffer: GLuint, attachment: GLenum, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateRenderbuffers.xhtml>
	fn glCreateRenderbuffers(&self, n: GLsizei, renderbuffers: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedRenderbufferStorage.xhtml>
	fn glNamedRenderbufferStorage(&self, renderbuffer: GLuint, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedRenderbufferStorageMultisample.xhtml>
	fn glNamedRenderbufferStorageMultisample(&self, renderbuffer: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedRenderbufferParameteriv.xhtml>
	fn glGetNamedRenderbufferParameteriv(&self, renderbuffer: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateTextures.xhtml>
	fn glCreateTextures(&self, target: GLenum, n: GLsizei, textures: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureBuffer.xhtml>
	fn glTextureBuffer(&self, texture: GLuint, internalformat: GLenum, buffer: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureBufferRange.xhtml>
	fn glTextureBufferRange(&self, texture: GLuint, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureStorage1D.xhtml>
	fn glTextureStorage1D(&self, texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureStorage2D.xhtml>
	fn glTextureStorage2D(&self, texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureStorage3D.xhtml>
	fn glTextureStorage3D(&self, texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureStorage2DMultisample.xhtml>
	fn glTextureStorage2DMultisample(&self, texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureStorage3DMultisample.xhtml>
	fn glTextureStorage3DMultisample(&self, texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureSubImage1D.xhtml>
	fn glTextureSubImage1D(&self, texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureSubImage2D.xhtml>
	fn glTextureSubImage2D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureSubImage3D.xhtml>
	fn glTextureSubImage3D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTextureSubImage1D.xhtml>
	fn glCompressedTextureSubImage1D(&self, texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTextureSubImage2D.xhtml>
	fn glCompressedTextureSubImage2D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTextureSubImage3D.xhtml>
	fn glCompressedTextureSubImage3D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTextureSubImage1D.xhtml>
	fn glCopyTextureSubImage1D(&self, texture: GLuint, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTextureSubImage2D.xhtml>
	fn glCopyTextureSubImage2D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTextureSubImage3D.xhtml>
	fn glCopyTextureSubImage3D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureParameterf.xhtml>
	fn glTextureParameterf(&self, texture: GLuint, pname: GLenum, param: GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureParameterfv.xhtml>
	fn glTextureParameterfv(&self, texture: GLuint, pname: GLenum, param: *const GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureParameteri.xhtml>
	fn glTextureParameteri(&self, texture: GLuint, pname: GLenum, param: GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureParameterIiv.xhtml>
	fn glTextureParameterIiv(&self, texture: GLuint, pname: GLenum, params: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureParameterIuiv.xhtml>
	fn glTextureParameterIuiv(&self, texture: GLuint, pname: GLenum, params: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureParameteriv.xhtml>
	fn glTextureParameteriv(&self, texture: GLuint, pname: GLenum, param: *const GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenerateTextureMipmap.xhtml>
	fn glGenerateTextureMipmap(&self, texture: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindTextureUnit.xhtml>
	fn glBindTextureUnit(&self, unit: GLuint, texture: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureImage.xhtml>
	fn glGetTextureImage(&self, texture: GLuint, level: GLint, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetCompressedTextureImage.xhtml>
	fn glGetCompressedTextureImage(&self, texture: GLuint, level: GLint, bufSize: GLsizei, pixels: *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureLevelParameterfv.xhtml>
	fn glGetTextureLevelParameterfv(&self, texture: GLuint, level: GLint, pname: GLenum, params: *mut GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureLevelParameteriv.xhtml>
	fn glGetTextureLevelParameteriv(&self, texture: GLuint, level: GLint, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureParameterfv.xhtml>
	fn glGetTextureParameterfv(&self, texture: GLuint, pname: GLenum, params: *mut GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureParameterIiv.xhtml>
	fn glGetTextureParameterIiv(&self, texture: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureParameterIuiv.xhtml>
	fn glGetTextureParameterIuiv(&self, texture: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureParameteriv.xhtml>
	fn glGetTextureParameteriv(&self, texture: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateVertexArrays.xhtml>
	fn glCreateVertexArrays(&self, n: GLsizei, arrays: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDisableVertexArrayAttrib.xhtml>
	fn glDisableVertexArrayAttrib(&self, vaobj: GLuint, index: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEnableVertexArrayAttrib.xhtml>
	fn glEnableVertexArrayAttrib(&self, vaobj: GLuint, index: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayElementBuffer.xhtml>
	fn glVertexArrayElementBuffer(&self, vaobj: GLuint, buffer: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayVertexBuffer.xhtml>
	fn glVertexArrayVertexBuffer(&self, vaobj: GLuint, bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayVertexBuffers.xhtml>
	fn glVertexArrayVertexBuffers(&self, vaobj: GLuint, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, strides: *const GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayAttribBinding.xhtml>
	fn glVertexArrayAttribBinding(&self, vaobj: GLuint, attribindex: GLuint, bindingindex: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayAttribFormat.xhtml>
	fn glVertexArrayAttribFormat(&self, vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, relativeoffset: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayAttribIFormat.xhtml>
	fn glVertexArrayAttribIFormat(&self, vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayAttribLFormat.xhtml>
	fn glVertexArrayAttribLFormat(&self, vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayBindingDivisor.xhtml>
	fn glVertexArrayBindingDivisor(&self, vaobj: GLuint, bindingindex: GLuint, divisor: GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexArrayiv.xhtml>
	fn glGetVertexArrayiv(&self, vaobj: GLuint, pname: GLenum, param: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexediv.xhtml>
	fn glGetVertexArrayIndexediv(&self, vaobj: GLuint, index: GLuint, pname: GLenum, param: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed64iv.xhtml>
	fn glGetVertexArrayIndexed64iv(&self, vaobj: GLuint, index: GLuint, pname: GLenum, param: *mut GLint64) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateSamplers.xhtml>
	fn glCreateSamplers(&self, n: GLsizei, samplers: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateProgramPipelines.xhtml>
	fn glCreateProgramPipelines(&self, n: GLsizei, pipelines: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateQueries.xhtml>
	fn glCreateQueries(&self, target: GLenum, n: GLsizei, ids: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryBufferObjecti64v.xhtml>
	fn glGetQueryBufferObjecti64v(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryBufferObjectiv.xhtml>
	fn glGetQueryBufferObjectiv(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryBufferObjectui64v.xhtml>
	fn glGetQueryBufferObjectui64v(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryBufferObjectuiv.xhtml>
	fn glGetQueryBufferObjectuiv(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMemoryBarrierByRegion.xhtml>
	fn glMemoryBarrierByRegion(&self, barriers: GLbitfield) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureSubImage.xhtml>
	fn glGetTextureSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetCompressedTextureSubImage.xhtml>
	fn glGetCompressedTextureSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, bufSize: GLsizei, pixels: *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetGraphicsResetStatus.xhtml>
	fn glGetGraphicsResetStatus(&self) -> Result<GLenum>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnCompressedTexImage.xhtml>
	fn glGetnCompressedTexImage(&self, target: GLenum, lod: GLint, bufSize: GLsizei, pixels: *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnTexImage.xhtml>
	fn glGetnTexImage(&self, target: GLenum, level: GLint, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnUniformdv.xhtml>
	fn glGetnUniformdv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnUniformfv.xhtml>
	fn glGetnUniformfv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnUniformiv.xhtml>
	fn glGetnUniformiv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnUniformuiv.xhtml>
	fn glGetnUniformuiv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glReadnPixels.xhtml>
	fn glReadnPixels(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, bufSize: GLsizei, data: *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnMapdv.xhtml>
	fn glGetnMapdv(&self, target: GLenum, query: GLenum, bufSize: GLsizei, v: *mut GLdouble) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnMapfv.xhtml>
	fn glGetnMapfv(&self, target: GLenum, query: GLenum, bufSize: GLsizei, v: *mut GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnMapiv.xhtml>
	fn glGetnMapiv(&self, target: GLenum, query: GLenum, bufSize: GLsizei, v: *mut GLint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnPixelMapfv.xhtml>
	fn glGetnPixelMapfv(&self, map: GLenum, bufSize: GLsizei, values: *mut GLfloat) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnPixelMapuiv.xhtml>
	fn glGetnPixelMapuiv(&self, map: GLenum, bufSize: GLsizei, values: *mut GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnPixelMapusv.xhtml>
	fn glGetnPixelMapusv(&self, map: GLenum, bufSize: GLsizei, values: *mut GLushort) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnPolygonStipple.xhtml>
	fn glGetnPolygonStipple(&self, bufSize: GLsizei, pattern: *mut GLubyte) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnColorTable.xhtml>
	fn glGetnColorTable(&self, target: GLenum, format: GLenum, type_: GLenum, bufSize: GLsizei, table: *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnConvolutionFilter.xhtml>
	fn glGetnConvolutionFilter(&self, target: GLenum, format: GLenum, type_: GLenum, bufSize: GLsizei, image: *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnSeparableFilter.xhtml>
	fn glGetnSeparableFilter(&self, target: GLenum, format: GLenum, type_: GLenum, rowBufSize: GLsizei, row: *mut c_void, columnBufSize: GLsizei, column: *mut c_void, span: *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnHistogram.xhtml>
	fn glGetnHistogram(&self, target: GLenum, reset: GLboolean, format: GLenum, type_: GLenum, bufSize: GLsizei, values: *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnMinmax.xhtml>
	fn glGetnMinmax(&self, target: GLenum, reset: GLboolean, format: GLenum, type_: GLenum, bufSize: GLsizei, values: *mut c_void) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureBarrier.xhtml>
	fn glTextureBarrier(&self) -> Result<()>;
}
/// Functions from OpenGL version 4.5
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version45 {
	/// Is OpenGL version 4.5 available
	available: bool,

	/// The function pointer to `glGetError()`
	pub geterror: PFNGLGETERRORPROC,

	/// The function pointer to `glClipControl()`
	pub clipcontrol: PFNGLCLIPCONTROLPROC,

	/// The function pointer to `glCreateTransformFeedbacks()`
	pub createtransformfeedbacks: PFNGLCREATETRANSFORMFEEDBACKSPROC,

	/// The function pointer to `glTransformFeedbackBufferBase()`
	pub transformfeedbackbufferbase: PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC,

	/// The function pointer to `glTransformFeedbackBufferRange()`
	pub transformfeedbackbufferrange: PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC,

	/// The function pointer to `glGetTransformFeedbackiv()`
	pub gettransformfeedbackiv: PFNGLGETTRANSFORMFEEDBACKIVPROC,

	/// The function pointer to `glGetTransformFeedbacki_v()`
	pub gettransformfeedbacki_v: PFNGLGETTRANSFORMFEEDBACKI_VPROC,

	/// The function pointer to `glGetTransformFeedbacki64_v()`
	pub gettransformfeedbacki64_v: PFNGLGETTRANSFORMFEEDBACKI64_VPROC,

	/// The function pointer to `glCreateBuffers()`
	pub createbuffers: PFNGLCREATEBUFFERSPROC,

	/// The function pointer to `glNamedBufferStorage()`
	pub namedbufferstorage: PFNGLNAMEDBUFFERSTORAGEPROC,

	/// The function pointer to `glNamedBufferData()`
	pub namedbufferdata: PFNGLNAMEDBUFFERDATAPROC,

	/// The function pointer to `glNamedBufferSubData()`
	pub namedbuffersubdata: PFNGLNAMEDBUFFERSUBDATAPROC,

	/// The function pointer to `glCopyNamedBufferSubData()`
	pub copynamedbuffersubdata: PFNGLCOPYNAMEDBUFFERSUBDATAPROC,

	/// The function pointer to `glClearNamedBufferData()`
	pub clearnamedbufferdata: PFNGLCLEARNAMEDBUFFERDATAPROC,

	/// The function pointer to `glClearNamedBufferSubData()`
	pub clearnamedbuffersubdata: PFNGLCLEARNAMEDBUFFERSUBDATAPROC,

	/// The function pointer to `glMapNamedBuffer()`
	pub mapnamedbuffer: PFNGLMAPNAMEDBUFFERPROC,

	/// The function pointer to `glMapNamedBufferRange()`
	pub mapnamedbufferrange: PFNGLMAPNAMEDBUFFERRANGEPROC,

	/// The function pointer to `glUnmapNamedBuffer()`
	pub unmapnamedbuffer: PFNGLUNMAPNAMEDBUFFERPROC,

	/// The function pointer to `glFlushMappedNamedBufferRange()`
	pub flushmappednamedbufferrange: PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC,

	/// The function pointer to `glGetNamedBufferParameteriv()`
	pub getnamedbufferparameteriv: PFNGLGETNAMEDBUFFERPARAMETERIVPROC,

	/// The function pointer to `glGetNamedBufferParameteri64v()`
	pub getnamedbufferparameteri64v: PFNGLGETNAMEDBUFFERPARAMETERI64VPROC,

	/// The function pointer to `glGetNamedBufferPointerv()`
	pub getnamedbufferpointerv: PFNGLGETNAMEDBUFFERPOINTERVPROC,

	/// The function pointer to `glGetNamedBufferSubData()`
	pub getnamedbuffersubdata: PFNGLGETNAMEDBUFFERSUBDATAPROC,

	/// The function pointer to `glCreateFramebuffers()`
	pub createframebuffers: PFNGLCREATEFRAMEBUFFERSPROC,

	/// The function pointer to `glNamedFramebufferRenderbuffer()`
	pub namedframebufferrenderbuffer: PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC,

	/// The function pointer to `glNamedFramebufferParameteri()`
	pub namedframebufferparameteri: PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC,

	/// The function pointer to `glNamedFramebufferTexture()`
	pub namedframebuffertexture: PFNGLNAMEDFRAMEBUFFERTEXTUREPROC,

	/// The function pointer to `glNamedFramebufferTextureLayer()`
	pub namedframebuffertexturelayer: PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC,

	/// The function pointer to `glNamedFramebufferDrawBuffer()`
	pub namedframebufferdrawbuffer: PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC,

	/// The function pointer to `glNamedFramebufferDrawBuffers()`
	pub namedframebufferdrawbuffers: PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC,

	/// The function pointer to `glNamedFramebufferReadBuffer()`
	pub namedframebufferreadbuffer: PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC,

	/// The function pointer to `glInvalidateNamedFramebufferData()`
	pub invalidatenamedframebufferdata: PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC,

	/// The function pointer to `glInvalidateNamedFramebufferSubData()`
	pub invalidatenamedframebuffersubdata: PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC,

	/// The function pointer to `glClearNamedFramebufferiv()`
	pub clearnamedframebufferiv: PFNGLCLEARNAMEDFRAMEBUFFERIVPROC,

	/// The function pointer to `glClearNamedFramebufferuiv()`
	pub clearnamedframebufferuiv: PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC,

	/// The function pointer to `glClearNamedFramebufferfv()`
	pub clearnamedframebufferfv: PFNGLCLEARNAMEDFRAMEBUFFERFVPROC,

	/// The function pointer to `glClearNamedFramebufferfi()`
	pub clearnamedframebufferfi: PFNGLCLEARNAMEDFRAMEBUFFERFIPROC,

	/// The function pointer to `glBlitNamedFramebuffer()`
	pub blitnamedframebuffer: PFNGLBLITNAMEDFRAMEBUFFERPROC,

	/// The function pointer to `glCheckNamedFramebufferStatus()`
	pub checknamedframebufferstatus: PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC,

	/// The function pointer to `glGetNamedFramebufferParameteriv()`
	pub getnamedframebufferparameteriv: PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC,

	/// The function pointer to `glGetNamedFramebufferAttachmentParameteriv()`
	pub getnamedframebufferattachmentparameteriv: PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC,

	/// The function pointer to `glCreateRenderbuffers()`
	pub createrenderbuffers: PFNGLCREATERENDERBUFFERSPROC,

	/// The function pointer to `glNamedRenderbufferStorage()`
	pub namedrenderbufferstorage: PFNGLNAMEDRENDERBUFFERSTORAGEPROC,

	/// The function pointer to `glNamedRenderbufferStorageMultisample()`
	pub namedrenderbufferstoragemultisample: PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC,

	/// The function pointer to `glGetNamedRenderbufferParameteriv()`
	pub getnamedrenderbufferparameteriv: PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC,

	/// The function pointer to `glCreateTextures()`
	pub createtextures: PFNGLCREATETEXTURESPROC,

	/// The function pointer to `glTextureBuffer()`
	pub texturebuffer: PFNGLTEXTUREBUFFERPROC,

	/// The function pointer to `glTextureBufferRange()`
	pub texturebufferrange: PFNGLTEXTUREBUFFERRANGEPROC,

	/// The function pointer to `glTextureStorage1D()`
	pub texturestorage1d: PFNGLTEXTURESTORAGE1DPROC,

	/// The function pointer to `glTextureStorage2D()`
	pub texturestorage2d: PFNGLTEXTURESTORAGE2DPROC,

	/// The function pointer to `glTextureStorage3D()`
	pub texturestorage3d: PFNGLTEXTURESTORAGE3DPROC,

	/// The function pointer to `glTextureStorage2DMultisample()`
	pub texturestorage2dmultisample: PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC,

	/// The function pointer to `glTextureStorage3DMultisample()`
	pub texturestorage3dmultisample: PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC,

	/// The function pointer to `glTextureSubImage1D()`
	pub texturesubimage1d: PFNGLTEXTURESUBIMAGE1DPROC,

	/// The function pointer to `glTextureSubImage2D()`
	pub texturesubimage2d: PFNGLTEXTURESUBIMAGE2DPROC,

	/// The function pointer to `glTextureSubImage3D()`
	pub texturesubimage3d: PFNGLTEXTURESUBIMAGE3DPROC,

	/// The function pointer to `glCompressedTextureSubImage1D()`
	pub compressedtexturesubimage1d: PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC,

	/// The function pointer to `glCompressedTextureSubImage2D()`
	pub compressedtexturesubimage2d: PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC,

	/// The function pointer to `glCompressedTextureSubImage3D()`
	pub compressedtexturesubimage3d: PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC,

	/// The function pointer to `glCopyTextureSubImage1D()`
	pub copytexturesubimage1d: PFNGLCOPYTEXTURESUBIMAGE1DPROC,

	/// The function pointer to `glCopyTextureSubImage2D()`
	pub copytexturesubimage2d: PFNGLCOPYTEXTURESUBIMAGE2DPROC,

	/// The function pointer to `glCopyTextureSubImage3D()`
	pub copytexturesubimage3d: PFNGLCOPYTEXTURESUBIMAGE3DPROC,

	/// The function pointer to `glTextureParameterf()`
	pub textureparameterf: PFNGLTEXTUREPARAMETERFPROC,

	/// The function pointer to `glTextureParameterfv()`
	pub textureparameterfv: PFNGLTEXTUREPARAMETERFVPROC,

	/// The function pointer to `glTextureParameteri()`
	pub textureparameteri: PFNGLTEXTUREPARAMETERIPROC,

	/// The function pointer to `glTextureParameterIiv()`
	pub textureparameteriiv: PFNGLTEXTUREPARAMETERIIVPROC,

	/// The function pointer to `glTextureParameterIuiv()`
	pub textureparameteriuiv: PFNGLTEXTUREPARAMETERIUIVPROC,

	/// The function pointer to `glTextureParameteriv()`
	pub textureparameteriv: PFNGLTEXTUREPARAMETERIVPROC,

	/// The function pointer to `glGenerateTextureMipmap()`
	pub generatetexturemipmap: PFNGLGENERATETEXTUREMIPMAPPROC,

	/// The function pointer to `glBindTextureUnit()`
	pub bindtextureunit: PFNGLBINDTEXTUREUNITPROC,

	/// The function pointer to `glGetTextureImage()`
	pub gettextureimage: PFNGLGETTEXTUREIMAGEPROC,

	/// The function pointer to `glGetCompressedTextureImage()`
	pub getcompressedtextureimage: PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC,

	/// The function pointer to `glGetTextureLevelParameterfv()`
	pub gettexturelevelparameterfv: PFNGLGETTEXTURELEVELPARAMETERFVPROC,

	/// The function pointer to `glGetTextureLevelParameteriv()`
	pub gettexturelevelparameteriv: PFNGLGETTEXTURELEVELPARAMETERIVPROC,

	/// The function pointer to `glGetTextureParameterfv()`
	pub gettextureparameterfv: PFNGLGETTEXTUREPARAMETERFVPROC,

	/// The function pointer to `glGetTextureParameterIiv()`
	pub gettextureparameteriiv: PFNGLGETTEXTUREPARAMETERIIVPROC,

	/// The function pointer to `glGetTextureParameterIuiv()`
	pub gettextureparameteriuiv: PFNGLGETTEXTUREPARAMETERIUIVPROC,

	/// The function pointer to `glGetTextureParameteriv()`
	pub gettextureparameteriv: PFNGLGETTEXTUREPARAMETERIVPROC,

	/// The function pointer to `glCreateVertexArrays()`
	pub createvertexarrays: PFNGLCREATEVERTEXARRAYSPROC,

	/// The function pointer to `glDisableVertexArrayAttrib()`
	pub disablevertexarrayattrib: PFNGLDISABLEVERTEXARRAYATTRIBPROC,

	/// The function pointer to `glEnableVertexArrayAttrib()`
	pub enablevertexarrayattrib: PFNGLENABLEVERTEXARRAYATTRIBPROC,

	/// The function pointer to `glVertexArrayElementBuffer()`
	pub vertexarrayelementbuffer: PFNGLVERTEXARRAYELEMENTBUFFERPROC,

	/// The function pointer to `glVertexArrayVertexBuffer()`
	pub vertexarrayvertexbuffer: PFNGLVERTEXARRAYVERTEXBUFFERPROC,

	/// The function pointer to `glVertexArrayVertexBuffers()`
	pub vertexarrayvertexbuffers: PFNGLVERTEXARRAYVERTEXBUFFERSPROC,

	/// The function pointer to `glVertexArrayAttribBinding()`
	pub vertexarrayattribbinding: PFNGLVERTEXARRAYATTRIBBINDINGPROC,

	/// The function pointer to `glVertexArrayAttribFormat()`
	pub vertexarrayattribformat: PFNGLVERTEXARRAYATTRIBFORMATPROC,

	/// The function pointer to `glVertexArrayAttribIFormat()`
	pub vertexarrayattribiformat: PFNGLVERTEXARRAYATTRIBIFORMATPROC,

	/// The function pointer to `glVertexArrayAttribLFormat()`
	pub vertexarrayattriblformat: PFNGLVERTEXARRAYATTRIBLFORMATPROC,

	/// The function pointer to `glVertexArrayBindingDivisor()`
	pub vertexarraybindingdivisor: PFNGLVERTEXARRAYBINDINGDIVISORPROC,

	/// The function pointer to `glGetVertexArrayiv()`
	pub getvertexarrayiv: PFNGLGETVERTEXARRAYIVPROC,

	/// The function pointer to `glGetVertexArrayIndexediv()`
	pub getvertexarrayindexediv: PFNGLGETVERTEXARRAYINDEXEDIVPROC,

	/// The function pointer to `glGetVertexArrayIndexed64iv()`
	pub getvertexarrayindexed64iv: PFNGLGETVERTEXARRAYINDEXED64IVPROC,

	/// The function pointer to `glCreateSamplers()`
	pub createsamplers: PFNGLCREATESAMPLERSPROC,

	/// The function pointer to `glCreateProgramPipelines()`
	pub createprogrampipelines: PFNGLCREATEPROGRAMPIPELINESPROC,

	/// The function pointer to `glCreateQueries()`
	pub createqueries: PFNGLCREATEQUERIESPROC,

	/// The function pointer to `glGetQueryBufferObjecti64v()`
	pub getquerybufferobjecti64v: PFNGLGETQUERYBUFFEROBJECTI64VPROC,

	/// The function pointer to `glGetQueryBufferObjectiv()`
	pub getquerybufferobjectiv: PFNGLGETQUERYBUFFEROBJECTIVPROC,

	/// The function pointer to `glGetQueryBufferObjectui64v()`
	pub getquerybufferobjectui64v: PFNGLGETQUERYBUFFEROBJECTUI64VPROC,

	/// The function pointer to `glGetQueryBufferObjectuiv()`
	pub getquerybufferobjectuiv: PFNGLGETQUERYBUFFEROBJECTUIVPROC,

	/// The function pointer to `glMemoryBarrierByRegion()`
	pub memorybarrierbyregion: PFNGLMEMORYBARRIERBYREGIONPROC,

	/// The function pointer to `glGetTextureSubImage()`
	pub gettexturesubimage: PFNGLGETTEXTURESUBIMAGEPROC,

	/// The function pointer to `glGetCompressedTextureSubImage()`
	pub getcompressedtexturesubimage: PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC,

	/// The function pointer to `glGetGraphicsResetStatus()`
	pub getgraphicsresetstatus: PFNGLGETGRAPHICSRESETSTATUSPROC,

	/// The function pointer to `glGetnCompressedTexImage()`
	pub getncompressedteximage: PFNGLGETNCOMPRESSEDTEXIMAGEPROC,

	/// The function pointer to `glGetnTexImage()`
	pub getnteximage: PFNGLGETNTEXIMAGEPROC,

	/// The function pointer to `glGetnUniformdv()`
	pub getnuniformdv: PFNGLGETNUNIFORMDVPROC,

	/// The function pointer to `glGetnUniformfv()`
	pub getnuniformfv: PFNGLGETNUNIFORMFVPROC,

	/// The function pointer to `glGetnUniformiv()`
	pub getnuniformiv: PFNGLGETNUNIFORMIVPROC,

	/// The function pointer to `glGetnUniformuiv()`
	pub getnuniformuiv: PFNGLGETNUNIFORMUIVPROC,

	/// The function pointer to `glReadnPixels()`
	pub readnpixels: PFNGLREADNPIXELSPROC,

	/// The function pointer to `glGetnMapdv()`
	pub getnmapdv: PFNGLGETNMAPDVPROC,

	/// The function pointer to `glGetnMapfv()`
	pub getnmapfv: PFNGLGETNMAPFVPROC,

	/// The function pointer to `glGetnMapiv()`
	pub getnmapiv: PFNGLGETNMAPIVPROC,

	/// The function pointer to `glGetnPixelMapfv()`
	pub getnpixelmapfv: PFNGLGETNPIXELMAPFVPROC,

	/// The function pointer to `glGetnPixelMapuiv()`
	pub getnpixelmapuiv: PFNGLGETNPIXELMAPUIVPROC,

	/// The function pointer to `glGetnPixelMapusv()`
	pub getnpixelmapusv: PFNGLGETNPIXELMAPUSVPROC,

	/// The function pointer to `glGetnPolygonStipple()`
	pub getnpolygonstipple: PFNGLGETNPOLYGONSTIPPLEPROC,

	/// The function pointer to `glGetnColorTable()`
	pub getncolortable: PFNGLGETNCOLORTABLEPROC,

	/// The function pointer to `glGetnConvolutionFilter()`
	pub getnconvolutionfilter: PFNGLGETNCONVOLUTIONFILTERPROC,

	/// The function pointer to `glGetnSeparableFilter()`
	pub getnseparablefilter: PFNGLGETNSEPARABLEFILTERPROC,

	/// The function pointer to `glGetnHistogram()`
	pub getnhistogram: PFNGLGETNHISTOGRAMPROC,

	/// The function pointer to `glGetnMinmax()`
	pub getnminmax: PFNGLGETNMINMAXPROC,

	/// The function pointer to `glTextureBarrier()`
	pub texturebarrier: PFNGLTEXTUREBARRIERPROC,
}

impl GL_4_5 for Version45 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClipControl.xhtml>
	#[inline(always)]
	fn glClipControl(&self, origin: GLenum, depth: GLenum) -> Result<()> {
		let ret = process_catch("glClipControl", catch_unwind(||(self.clipcontrol)(origin, depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClipControl", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateTransformFeedbacks.xhtml>
	#[inline(always)]
	fn glCreateTransformFeedbacks(&self, n: GLsizei, ids: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateTransformFeedbacks", catch_unwind(||(self.createtransformfeedbacks)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateTransformFeedbacks", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferBase.xhtml>
	#[inline(always)]
	fn glTransformFeedbackBufferBase(&self, xfb: GLuint, index: GLuint, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glTransformFeedbackBufferBase", catch_unwind(||(self.transformfeedbackbufferbase)(xfb, index, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTransformFeedbackBufferBase", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferRange.xhtml>
	#[inline(always)]
	fn glTransformFeedbackBufferRange(&self, xfb: GLuint, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glTransformFeedbackBufferRange", catch_unwind(||(self.transformfeedbackbufferrange)(xfb, index, buffer, offset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTransformFeedbackBufferRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTransformFeedbackiv.xhtml>
	#[inline(always)]
	fn glGetTransformFeedbackiv(&self, xfb: GLuint, pname: GLenum, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTransformFeedbackiv", catch_unwind(||(self.gettransformfeedbackiv)(xfb, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTransformFeedbackiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTransformFeedbacki_v.xhtml>
	#[inline(always)]
	fn glGetTransformFeedbacki_v(&self, xfb: GLuint, pname: GLenum, index: GLuint, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTransformFeedbacki_v", catch_unwind(||(self.gettransformfeedbacki_v)(xfb, pname, index, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTransformFeedbacki_v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTransformFeedbacki64_v.xhtml>
	#[inline(always)]
	fn glGetTransformFeedbacki64_v(&self, xfb: GLuint, pname: GLenum, index: GLuint, param: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetTransformFeedbacki64_v", catch_unwind(||(self.gettransformfeedbacki64_v)(xfb, pname, index, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTransformFeedbacki64_v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateBuffers.xhtml>
	#[inline(always)]
	fn glCreateBuffers(&self, n: GLsizei, buffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateBuffers", catch_unwind(||(self.createbuffers)(n, buffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateBuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedBufferStorage.xhtml>
	#[inline(always)]
	fn glNamedBufferStorage(&self, buffer: GLuint, size: GLsizeiptr, data: *const c_void, flags: GLbitfield) -> Result<()> {
		let ret = process_catch("glNamedBufferStorage", catch_unwind(||(self.namedbufferstorage)(buffer, size, data, flags)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedBufferStorage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedBufferData.xhtml>
	#[inline(always)]
	fn glNamedBufferData(&self, buffer: GLuint, size: GLsizeiptr, data: *const c_void, usage: GLenum) -> Result<()> {
		let ret = process_catch("glNamedBufferData", catch_unwind(||(self.namedbufferdata)(buffer, size, data, usage)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedBufferData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedBufferSubData.xhtml>
	#[inline(always)]
	fn glNamedBufferSubData(&self, buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: *const c_void) -> Result<()> {
		let ret = process_catch("glNamedBufferSubData", catch_unwind(||(self.namedbuffersubdata)(buffer, offset, size, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedBufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyNamedBufferSubData.xhtml>
	#[inline(always)]
	fn glCopyNamedBufferSubData(&self, readBuffer: GLuint, writeBuffer: GLuint, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glCopyNamedBufferSubData", catch_unwind(||(self.copynamedbuffersubdata)(readBuffer, writeBuffer, readOffset, writeOffset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyNamedBufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearNamedBufferData.xhtml>
	#[inline(always)]
	fn glClearNamedBufferData(&self, buffer: GLuint, internalformat: GLenum, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearNamedBufferData", catch_unwind(||(self.clearnamedbufferdata)(buffer, internalformat, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedBufferData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearNamedBufferSubData.xhtml>
	#[inline(always)]
	fn glClearNamedBufferSubData(&self, buffer: GLuint, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearNamedBufferSubData", catch_unwind(||(self.clearnamedbuffersubdata)(buffer, internalformat, offset, size, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedBufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMapNamedBuffer.xhtml>
	#[inline(always)]
	fn glMapNamedBuffer(&self, buffer: GLuint, access: GLenum) -> Result<*mut c_void> {
		let ret = process_catch("glMapNamedBuffer", catch_unwind(||(self.mapnamedbuffer)(buffer, access)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMapNamedBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMapNamedBufferRange.xhtml>
	#[inline(always)]
	fn glMapNamedBufferRange(&self, buffer: GLuint, offset: GLintptr, length: GLsizeiptr, access: GLbitfield) -> Result<*mut c_void> {
		let ret = process_catch("glMapNamedBufferRange", catch_unwind(||(self.mapnamedbufferrange)(buffer, offset, length, access)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMapNamedBufferRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUnmapNamedBuffer.xhtml>
	#[inline(always)]
	fn glUnmapNamedBuffer(&self, buffer: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glUnmapNamedBuffer", catch_unwind(||(self.unmapnamedbuffer)(buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUnmapNamedBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFlushMappedNamedBufferRange.xhtml>
	#[inline(always)]
	fn glFlushMappedNamedBufferRange(&self, buffer: GLuint, offset: GLintptr, length: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glFlushMappedNamedBufferRange", catch_unwind(||(self.flushmappednamedbufferrange)(buffer, offset, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFlushMappedNamedBufferRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedBufferParameteriv.xhtml>
	#[inline(always)]
	fn glGetNamedBufferParameteriv(&self, buffer: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetNamedBufferParameteriv", catch_unwind(||(self.getnamedbufferparameteriv)(buffer, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedBufferParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedBufferParameteri64v.xhtml>
	#[inline(always)]
	fn glGetNamedBufferParameteri64v(&self, buffer: GLuint, pname: GLenum, params: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetNamedBufferParameteri64v", catch_unwind(||(self.getnamedbufferparameteri64v)(buffer, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedBufferParameteri64v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedBufferPointerv.xhtml>
	#[inline(always)]
	fn glGetNamedBufferPointerv(&self, buffer: GLuint, pname: GLenum, params: *mut *mut c_void) -> Result<()> {
		let ret = process_catch("glGetNamedBufferPointerv", catch_unwind(||(self.getnamedbufferpointerv)(buffer, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedBufferPointerv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedBufferSubData.xhtml>
	#[inline(always)]
	fn glGetNamedBufferSubData(&self, buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetNamedBufferSubData", catch_unwind(||(self.getnamedbuffersubdata)(buffer, offset, size, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedBufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateFramebuffers.xhtml>
	#[inline(always)]
	fn glCreateFramebuffers(&self, n: GLsizei, framebuffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateFramebuffers", catch_unwind(||(self.createframebuffers)(n, framebuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateFramebuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferRenderbuffer.xhtml>
	#[inline(always)]
	fn glNamedFramebufferRenderbuffer(&self, framebuffer: GLuint, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint) -> Result<()> {
		let ret = process_catch("glNamedFramebufferRenderbuffer", catch_unwind(||(self.namedframebufferrenderbuffer)(framebuffer, attachment, renderbuffertarget, renderbuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferRenderbuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferParameteri.xhtml>
	#[inline(always)]
	fn glNamedFramebufferParameteri(&self, framebuffer: GLuint, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glNamedFramebufferParameteri", catch_unwind(||(self.namedframebufferparameteri)(framebuffer, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferParameteri", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferTexture.xhtml>
	#[inline(always)]
	fn glNamedFramebufferTexture(&self, framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glNamedFramebufferTexture", catch_unwind(||(self.namedframebuffertexture)(framebuffer, attachment, texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferTexture", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferTextureLayer.xhtml>
	#[inline(always)]
	fn glNamedFramebufferTextureLayer(&self, framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint) -> Result<()> {
		let ret = process_catch("glNamedFramebufferTextureLayer", catch_unwind(||(self.namedframebuffertexturelayer)(framebuffer, attachment, texture, level, layer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferTextureLayer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferDrawBuffer.xhtml>
	#[inline(always)]
	fn glNamedFramebufferDrawBuffer(&self, framebuffer: GLuint, buf: GLenum) -> Result<()> {
		let ret = process_catch("glNamedFramebufferDrawBuffer", catch_unwind(||(self.namedframebufferdrawbuffer)(framebuffer, buf)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferDrawBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferDrawBuffers.xhtml>
	#[inline(always)]
	fn glNamedFramebufferDrawBuffers(&self, framebuffer: GLuint, n: GLsizei, bufs: *const GLenum) -> Result<()> {
		let ret = process_catch("glNamedFramebufferDrawBuffers", catch_unwind(||(self.namedframebufferdrawbuffers)(framebuffer, n, bufs)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferDrawBuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferReadBuffer.xhtml>
	#[inline(always)]
	fn glNamedFramebufferReadBuffer(&self, framebuffer: GLuint, src: GLenum) -> Result<()> {
		let ret = process_catch("glNamedFramebufferReadBuffer", catch_unwind(||(self.namedframebufferreadbuffer)(framebuffer, src)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferReadBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateNamedFramebufferData.xhtml>
	#[inline(always)]
	fn glInvalidateNamedFramebufferData(&self, framebuffer: GLuint, numAttachments: GLsizei, attachments: *const GLenum) -> Result<()> {
		let ret = process_catch("glInvalidateNamedFramebufferData", catch_unwind(||(self.invalidatenamedframebufferdata)(framebuffer, numAttachments, attachments)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateNamedFramebufferData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateNamedFramebufferSubData.xhtml>
	#[inline(always)]
	fn glInvalidateNamedFramebufferSubData(&self, framebuffer: GLuint, numAttachments: GLsizei, attachments: *const GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glInvalidateNamedFramebufferSubData", catch_unwind(||(self.invalidatenamedframebuffersubdata)(framebuffer, numAttachments, attachments, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateNamedFramebufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearNamedFramebufferiv.xhtml>
	#[inline(always)]
	fn glClearNamedFramebufferiv(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLint) -> Result<()> {
		let ret = process_catch("glClearNamedFramebufferiv", catch_unwind(||(self.clearnamedframebufferiv)(framebuffer, buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedFramebufferiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearNamedFramebufferuiv.xhtml>
	#[inline(always)]
	fn glClearNamedFramebufferuiv(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glClearNamedFramebufferuiv", catch_unwind(||(self.clearnamedframebufferuiv)(framebuffer, buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedFramebufferuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearNamedFramebufferfv.xhtml>
	#[inline(always)]
	fn glClearNamedFramebufferfv(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glClearNamedFramebufferfv", catch_unwind(||(self.clearnamedframebufferfv)(framebuffer, buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedFramebufferfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearNamedFramebufferfi.xhtml>
	#[inline(always)]
	fn glClearNamedFramebufferfi(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint) -> Result<()> {
		let ret = process_catch("glClearNamedFramebufferfi", catch_unwind(||(self.clearnamedframebufferfi)(framebuffer, buffer, drawbuffer, depth, stencil)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedFramebufferfi", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlitNamedFramebuffer.xhtml>
	#[inline(always)]
	fn glBlitNamedFramebuffer(&self, readFramebuffer: GLuint, drawFramebuffer: GLuint, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum) -> Result<()> {
		let ret = process_catch("glBlitNamedFramebuffer", catch_unwind(||(self.blitnamedframebuffer)(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlitNamedFramebuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCheckNamedFramebufferStatus.xhtml>
	#[inline(always)]
	fn glCheckNamedFramebufferStatus(&self, framebuffer: GLuint, target: GLenum) -> Result<GLenum> {
		let ret = process_catch("glCheckNamedFramebufferStatus", catch_unwind(||(self.checknamedframebufferstatus)(framebuffer, target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCheckNamedFramebufferStatus", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedFramebufferParameteriv.xhtml>
	#[inline(always)]
	fn glGetNamedFramebufferParameteriv(&self, framebuffer: GLuint, pname: GLenum, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetNamedFramebufferParameteriv", catch_unwind(||(self.getnamedframebufferparameteriv)(framebuffer, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedFramebufferParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedFramebufferAttachmentParameteriv.xhtml>
	#[inline(always)]
	fn glGetNamedFramebufferAttachmentParameteriv(&self, framebuffer: GLuint, attachment: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetNamedFramebufferAttachmentParameteriv", catch_unwind(||(self.getnamedframebufferattachmentparameteriv)(framebuffer, attachment, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedFramebufferAttachmentParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateRenderbuffers.xhtml>
	#[inline(always)]
	fn glCreateRenderbuffers(&self, n: GLsizei, renderbuffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateRenderbuffers", catch_unwind(||(self.createrenderbuffers)(n, renderbuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateRenderbuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedRenderbufferStorage.xhtml>
	#[inline(always)]
	fn glNamedRenderbufferStorage(&self, renderbuffer: GLuint, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glNamedRenderbufferStorage", catch_unwind(||(self.namedrenderbufferstorage)(renderbuffer, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedRenderbufferStorage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedRenderbufferStorageMultisample.xhtml>
	#[inline(always)]
	fn glNamedRenderbufferStorageMultisample(&self, renderbuffer: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glNamedRenderbufferStorageMultisample", catch_unwind(||(self.namedrenderbufferstoragemultisample)(renderbuffer, samples, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedRenderbufferStorageMultisample", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedRenderbufferParameteriv.xhtml>
	#[inline(always)]
	fn glGetNamedRenderbufferParameteriv(&self, renderbuffer: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetNamedRenderbufferParameteriv", catch_unwind(||(self.getnamedrenderbufferparameteriv)(renderbuffer, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedRenderbufferParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateTextures.xhtml>
	#[inline(always)]
	fn glCreateTextures(&self, target: GLenum, n: GLsizei, textures: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateTextures", catch_unwind(||(self.createtextures)(target, n, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateTextures", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureBuffer.xhtml>
	#[inline(always)]
	fn glTextureBuffer(&self, texture: GLuint, internalformat: GLenum, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glTextureBuffer", catch_unwind(||(self.texturebuffer)(texture, internalformat, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureBufferRange.xhtml>
	#[inline(always)]
	fn glTextureBufferRange(&self, texture: GLuint, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glTextureBufferRange", catch_unwind(||(self.texturebufferrange)(texture, internalformat, buffer, offset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureBufferRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureStorage1D.xhtml>
	#[inline(always)]
	fn glTextureStorage1D(&self, texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei) -> Result<()> {
		let ret = process_catch("glTextureStorage1D", catch_unwind(||(self.texturestorage1d)(texture, levels, internalformat, width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureStorage2D.xhtml>
	#[inline(always)]
	fn glTextureStorage2D(&self, texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glTextureStorage2D", catch_unwind(||(self.texturestorage2d)(texture, levels, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureStorage3D.xhtml>
	#[inline(always)]
	fn glTextureStorage3D(&self, texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei) -> Result<()> {
		let ret = process_catch("glTextureStorage3D", catch_unwind(||(self.texturestorage3d)(texture, levels, internalformat, width, height, depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureStorage2DMultisample.xhtml>
	#[inline(always)]
	fn glTextureStorage2DMultisample(&self, texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTextureStorage2DMultisample", catch_unwind(||(self.texturestorage2dmultisample)(texture, samples, internalformat, width, height, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage2DMultisample", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureStorage3DMultisample.xhtml>
	#[inline(always)]
	fn glTextureStorage3DMultisample(&self, texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTextureStorage3DMultisample", catch_unwind(||(self.texturestorage3dmultisample)(texture, samples, internalformat, width, height, depth, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage3DMultisample", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureSubImage1D.xhtml>
	#[inline(always)]
	fn glTextureSubImage1D(&self, texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTextureSubImage1D", catch_unwind(||(self.texturesubimage1d)(texture, level, xoffset, width, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureSubImage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureSubImage2D.xhtml>
	#[inline(always)]
	fn glTextureSubImage2D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTextureSubImage2D", catch_unwind(||(self.texturesubimage2d)(texture, level, xoffset, yoffset, width, height, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureSubImage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureSubImage3D.xhtml>
	#[inline(always)]
	fn glTextureSubImage3D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTextureSubImage3D", catch_unwind(||(self.texturesubimage3d)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureSubImage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTextureSubImage1D.xhtml>
	#[inline(always)]
	fn glCompressedTextureSubImage1D(&self, texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTextureSubImage1D", catch_unwind(||(self.compressedtexturesubimage1d)(texture, level, xoffset, width, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTextureSubImage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTextureSubImage2D.xhtml>
	#[inline(always)]
	fn glCompressedTextureSubImage2D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTextureSubImage2D", catch_unwind(||(self.compressedtexturesubimage2d)(texture, level, xoffset, yoffset, width, height, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTextureSubImage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTextureSubImage3D.xhtml>
	#[inline(always)]
	fn glCompressedTextureSubImage3D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTextureSubImage3D", catch_unwind(||(self.compressedtexturesubimage3d)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTextureSubImage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTextureSubImage1D.xhtml>
	#[inline(always)]
	fn glCopyTextureSubImage1D(&self, texture: GLuint, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTextureSubImage1D", catch_unwind(||(self.copytexturesubimage1d)(texture, level, xoffset, x, y, width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTextureSubImage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTextureSubImage2D.xhtml>
	#[inline(always)]
	fn glCopyTextureSubImage2D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTextureSubImage2D", catch_unwind(||(self.copytexturesubimage2d)(texture, level, xoffset, yoffset, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTextureSubImage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTextureSubImage3D.xhtml>
	#[inline(always)]
	fn glCopyTextureSubImage3D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTextureSubImage3D", catch_unwind(||(self.copytexturesubimage3d)(texture, level, xoffset, yoffset, zoffset, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTextureSubImage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureParameterf.xhtml>
	#[inline(always)]
	fn glTextureParameterf(&self, texture: GLuint, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glTextureParameterf", catch_unwind(||(self.textureparameterf)(texture, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameterf", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureParameterfv.xhtml>
	#[inline(always)]
	fn glTextureParameterfv(&self, texture: GLuint, pname: GLenum, param: *const GLfloat) -> Result<()> {
		let ret = process_catch("glTextureParameterfv", catch_unwind(||(self.textureparameterfv)(texture, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureParameteri.xhtml>
	#[inline(always)]
	fn glTextureParameteri(&self, texture: GLuint, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glTextureParameteri", catch_unwind(||(self.textureparameteri)(texture, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameteri", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureParameterIiv.xhtml>
	#[inline(always)]
	fn glTextureParameterIiv(&self, texture: GLuint, pname: GLenum, params: *const GLint) -> Result<()> {
		let ret = process_catch("glTextureParameterIiv", catch_unwind(||(self.textureparameteriiv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameterIiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureParameterIuiv.xhtml>
	#[inline(always)]
	fn glTextureParameterIuiv(&self, texture: GLuint, pname: GLenum, params: *const GLuint) -> Result<()> {
		let ret = process_catch("glTextureParameterIuiv", catch_unwind(||(self.textureparameteriuiv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameterIuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureParameteriv.xhtml>
	#[inline(always)]
	fn glTextureParameteriv(&self, texture: GLuint, pname: GLenum, param: *const GLint) -> Result<()> {
		let ret = process_catch("glTextureParameteriv", catch_unwind(||(self.textureparameteriv)(texture, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenerateTextureMipmap.xhtml>
	#[inline(always)]
	fn glGenerateTextureMipmap(&self, texture: GLuint) -> Result<()> {
		let ret = process_catch("glGenerateTextureMipmap", catch_unwind(||(self.generatetexturemipmap)(texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenerateTextureMipmap", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindTextureUnit.xhtml>
	#[inline(always)]
	fn glBindTextureUnit(&self, unit: GLuint, texture: GLuint) -> Result<()> {
		let ret = process_catch("glBindTextureUnit", catch_unwind(||(self.bindtextureunit)(unit, texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindTextureUnit", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureImage.xhtml>
	#[inline(always)]
	fn glGetTextureImage(&self, texture: GLuint, level: GLint, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetTextureImage", catch_unwind(||(self.gettextureimage)(texture, level, format, type_, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetCompressedTextureImage.xhtml>
	#[inline(always)]
	fn glGetCompressedTextureImage(&self, texture: GLuint, level: GLint, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetCompressedTextureImage", catch_unwind(||(self.getcompressedtextureimage)(texture, level, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetCompressedTextureImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureLevelParameterfv.xhtml>
	#[inline(always)]
	fn glGetTextureLevelParameterfv(&self, texture: GLuint, level: GLint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetTextureLevelParameterfv", catch_unwind(||(self.gettexturelevelparameterfv)(texture, level, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureLevelParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureLevelParameteriv.xhtml>
	#[inline(always)]
	fn glGetTextureLevelParameteriv(&self, texture: GLuint, level: GLint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTextureLevelParameteriv", catch_unwind(||(self.gettexturelevelparameteriv)(texture, level, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureLevelParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureParameterfv.xhtml>
	#[inline(always)]
	fn glGetTextureParameterfv(&self, texture: GLuint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetTextureParameterfv", catch_unwind(||(self.gettextureparameterfv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureParameterIiv.xhtml>
	#[inline(always)]
	fn glGetTextureParameterIiv(&self, texture: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTextureParameterIiv", catch_unwind(||(self.gettextureparameteriiv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureParameterIiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureParameterIuiv.xhtml>
	#[inline(always)]
	fn glGetTextureParameterIuiv(&self, texture: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetTextureParameterIuiv", catch_unwind(||(self.gettextureparameteriuiv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureParameterIuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureParameteriv.xhtml>
	#[inline(always)]
	fn glGetTextureParameteriv(&self, texture: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTextureParameteriv", catch_unwind(||(self.gettextureparameteriv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateVertexArrays.xhtml>
	#[inline(always)]
	fn glCreateVertexArrays(&self, n: GLsizei, arrays: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateVertexArrays", catch_unwind(||(self.createvertexarrays)(n, arrays)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateVertexArrays", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDisableVertexArrayAttrib.xhtml>
	#[inline(always)]
	fn glDisableVertexArrayAttrib(&self, vaobj: GLuint, index: GLuint) -> Result<()> {
		let ret = process_catch("glDisableVertexArrayAttrib", catch_unwind(||(self.disablevertexarrayattrib)(vaobj, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDisableVertexArrayAttrib", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEnableVertexArrayAttrib.xhtml>
	#[inline(always)]
	fn glEnableVertexArrayAttrib(&self, vaobj: GLuint, index: GLuint) -> Result<()> {
		let ret = process_catch("glEnableVertexArrayAttrib", catch_unwind(||(self.enablevertexarrayattrib)(vaobj, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEnableVertexArrayAttrib", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayElementBuffer.xhtml>
	#[inline(always)]
	fn glVertexArrayElementBuffer(&self, vaobj: GLuint, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayElementBuffer", catch_unwind(||(self.vertexarrayelementbuffer)(vaobj, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayElementBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayVertexBuffer.xhtml>
	#[inline(always)]
	fn glVertexArrayVertexBuffer(&self, vaobj: GLuint, bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glVertexArrayVertexBuffer", catch_unwind(||(self.vertexarrayvertexbuffer)(vaobj, bindingindex, buffer, offset, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayVertexBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayVertexBuffers.xhtml>
	#[inline(always)]
	fn glVertexArrayVertexBuffers(&self, vaobj: GLuint, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, strides: *const GLsizei) -> Result<()> {
		let ret = process_catch("glVertexArrayVertexBuffers", catch_unwind(||(self.vertexarrayvertexbuffers)(vaobj, first, count, buffers, offsets, strides)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayVertexBuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayAttribBinding.xhtml>
	#[inline(always)]
	fn glVertexArrayAttribBinding(&self, vaobj: GLuint, attribindex: GLuint, bindingindex: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayAttribBinding", catch_unwind(||(self.vertexarrayattribbinding)(vaobj, attribindex, bindingindex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayAttribBinding", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayAttribFormat.xhtml>
	#[inline(always)]
	fn glVertexArrayAttribFormat(&self, vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayAttribFormat", catch_unwind(||(self.vertexarrayattribformat)(vaobj, attribindex, size, type_, normalized, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayAttribFormat", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayAttribIFormat.xhtml>
	#[inline(always)]
	fn glVertexArrayAttribIFormat(&self, vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayAttribIFormat", catch_unwind(||(self.vertexarrayattribiformat)(vaobj, attribindex, size, type_, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayAttribIFormat", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayAttribLFormat.xhtml>
	#[inline(always)]
	fn glVertexArrayAttribLFormat(&self, vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayAttribLFormat", catch_unwind(||(self.vertexarrayattriblformat)(vaobj, attribindex, size, type_, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayAttribLFormat", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayBindingDivisor.xhtml>
	#[inline(always)]
	fn glVertexArrayBindingDivisor(&self, vaobj: GLuint, bindingindex: GLuint, divisor: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayBindingDivisor", catch_unwind(||(self.vertexarraybindingdivisor)(vaobj, bindingindex, divisor)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayBindingDivisor", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexArrayiv.xhtml>
	#[inline(always)]
	fn glGetVertexArrayiv(&self, vaobj: GLuint, pname: GLenum, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetVertexArrayiv", catch_unwind(||(self.getvertexarrayiv)(vaobj, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexArrayiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexediv.xhtml>
	#[inline(always)]
	fn glGetVertexArrayIndexediv(&self, vaobj: GLuint, index: GLuint, pname: GLenum, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetVertexArrayIndexediv", catch_unwind(||(self.getvertexarrayindexediv)(vaobj, index, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexArrayIndexediv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed64iv.xhtml>
	#[inline(always)]
	fn glGetVertexArrayIndexed64iv(&self, vaobj: GLuint, index: GLuint, pname: GLenum, param: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetVertexArrayIndexed64iv", catch_unwind(||(self.getvertexarrayindexed64iv)(vaobj, index, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexArrayIndexed64iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateSamplers.xhtml>
	#[inline(always)]
	fn glCreateSamplers(&self, n: GLsizei, samplers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateSamplers", catch_unwind(||(self.createsamplers)(n, samplers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateSamplers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateProgramPipelines.xhtml>
	#[inline(always)]
	fn glCreateProgramPipelines(&self, n: GLsizei, pipelines: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateProgramPipelines", catch_unwind(||(self.createprogrampipelines)(n, pipelines)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateProgramPipelines", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateQueries.xhtml>
	#[inline(always)]
	fn glCreateQueries(&self, target: GLenum, n: GLsizei, ids: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateQueries", catch_unwind(||(self.createqueries)(target, n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateQueries", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryBufferObjecti64v.xhtml>
	#[inline(always)]
	fn glGetQueryBufferObjecti64v(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()> {
		let ret = process_catch("glGetQueryBufferObjecti64v", catch_unwind(||(self.getquerybufferobjecti64v)(id, buffer, pname, offset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryBufferObjecti64v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryBufferObjectiv.xhtml>
	#[inline(always)]
	fn glGetQueryBufferObjectiv(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()> {
		let ret = process_catch("glGetQueryBufferObjectiv", catch_unwind(||(self.getquerybufferobjectiv)(id, buffer, pname, offset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryBufferObjectiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryBufferObjectui64v.xhtml>
	#[inline(always)]
	fn glGetQueryBufferObjectui64v(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()> {
		let ret = process_catch("glGetQueryBufferObjectui64v", catch_unwind(||(self.getquerybufferobjectui64v)(id, buffer, pname, offset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryBufferObjectui64v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryBufferObjectuiv.xhtml>
	#[inline(always)]
	fn glGetQueryBufferObjectuiv(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()> {
		let ret = process_catch("glGetQueryBufferObjectuiv", catch_unwind(||(self.getquerybufferobjectuiv)(id, buffer, pname, offset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryBufferObjectuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMemoryBarrierByRegion.xhtml>
	#[inline(always)]
	fn glMemoryBarrierByRegion(&self, barriers: GLbitfield) -> Result<()> {
		let ret = process_catch("glMemoryBarrierByRegion", catch_unwind(||(self.memorybarrierbyregion)(barriers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMemoryBarrierByRegion", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureSubImage.xhtml>
	#[inline(always)]
	fn glGetTextureSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetTextureSubImage", catch_unwind(||(self.gettexturesubimage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureSubImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetCompressedTextureSubImage.xhtml>
	#[inline(always)]
	fn glGetCompressedTextureSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetCompressedTextureSubImage", catch_unwind(||(self.getcompressedtexturesubimage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetCompressedTextureSubImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetGraphicsResetStatus.xhtml>
	#[inline(always)]
	fn glGetGraphicsResetStatus(&self) -> Result<GLenum> {
		let ret = process_catch("glGetGraphicsResetStatus", catch_unwind(||(self.getgraphicsresetstatus)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetGraphicsResetStatus", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnCompressedTexImage.xhtml>
	#[inline(always)]
	fn glGetnCompressedTexImage(&self, target: GLenum, lod: GLint, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnCompressedTexImage", catch_unwind(||(self.getncompressedteximage)(target, lod, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnCompressedTexImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnTexImage.xhtml>
	#[inline(always)]
	fn glGetnTexImage(&self, target: GLenum, level: GLint, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnTexImage", catch_unwind(||(self.getnteximage)(target, level, format, type_, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnTexImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnUniformdv.xhtml>
	#[inline(always)]
	fn glGetnUniformdv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetnUniformdv", catch_unwind(||(self.getnuniformdv)(program, location, bufSize, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnUniformdv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnUniformfv.xhtml>
	#[inline(always)]
	fn glGetnUniformfv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetnUniformfv", catch_unwind(||(self.getnuniformfv)(program, location, bufSize, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnUniformfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnUniformiv.xhtml>
	#[inline(always)]
	fn glGetnUniformiv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetnUniformiv", catch_unwind(||(self.getnuniformiv)(program, location, bufSize, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnUniformiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnUniformuiv.xhtml>
	#[inline(always)]
	fn glGetnUniformuiv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetnUniformuiv", catch_unwind(||(self.getnuniformuiv)(program, location, bufSize, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnUniformuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glReadnPixels.xhtml>
	#[inline(always)]
	fn glReadnPixels(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, bufSize: GLsizei, data: *mut c_void) -> Result<()> {
		let ret = process_catch("glReadnPixels", catch_unwind(||(self.readnpixels)(x, y, width, height, format, type_, bufSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glReadnPixels", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnMapdv.xhtml>
	#[inline(always)]
	fn glGetnMapdv(&self, target: GLenum, query: GLenum, bufSize: GLsizei, v: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetnMapdv", catch_unwind(||(self.getnmapdv)(target, query, bufSize, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnMapdv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnMapfv.xhtml>
	#[inline(always)]
	fn glGetnMapfv(&self, target: GLenum, query: GLenum, bufSize: GLsizei, v: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetnMapfv", catch_unwind(||(self.getnmapfv)(target, query, bufSize, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnMapfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnMapiv.xhtml>
	#[inline(always)]
	fn glGetnMapiv(&self, target: GLenum, query: GLenum, bufSize: GLsizei, v: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetnMapiv", catch_unwind(||(self.getnmapiv)(target, query, bufSize, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnMapiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnPixelMapfv.xhtml>
	#[inline(always)]
	fn glGetnPixelMapfv(&self, map: GLenum, bufSize: GLsizei, values: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetnPixelMapfv", catch_unwind(||(self.getnpixelmapfv)(map, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnPixelMapfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnPixelMapuiv.xhtml>
	#[inline(always)]
	fn glGetnPixelMapuiv(&self, map: GLenum, bufSize: GLsizei, values: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetnPixelMapuiv", catch_unwind(||(self.getnpixelmapuiv)(map, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnPixelMapuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnPixelMapusv.xhtml>
	#[inline(always)]
	fn glGetnPixelMapusv(&self, map: GLenum, bufSize: GLsizei, values: *mut GLushort) -> Result<()> {
		let ret = process_catch("glGetnPixelMapusv", catch_unwind(||(self.getnpixelmapusv)(map, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnPixelMapusv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnPolygonStipple.xhtml>
	#[inline(always)]
	fn glGetnPolygonStipple(&self, bufSize: GLsizei, pattern: *mut GLubyte) -> Result<()> {
		let ret = process_catch("glGetnPolygonStipple", catch_unwind(||(self.getnpolygonstipple)(bufSize, pattern)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnPolygonStipple", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnColorTable.xhtml>
	#[inline(always)]
	fn glGetnColorTable(&self, target: GLenum, format: GLenum, type_: GLenum, bufSize: GLsizei, table: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnColorTable", catch_unwind(||(self.getncolortable)(target, format, type_, bufSize, table)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnColorTable", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnConvolutionFilter.xhtml>
	#[inline(always)]
	fn glGetnConvolutionFilter(&self, target: GLenum, format: GLenum, type_: GLenum, bufSize: GLsizei, image: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnConvolutionFilter", catch_unwind(||(self.getnconvolutionfilter)(target, format, type_, bufSize, image)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnConvolutionFilter", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnSeparableFilter.xhtml>
	#[inline(always)]
	fn glGetnSeparableFilter(&self, target: GLenum, format: GLenum, type_: GLenum, rowBufSize: GLsizei, row: *mut c_void, columnBufSize: GLsizei, column: *mut c_void, span: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnSeparableFilter", catch_unwind(||(self.getnseparablefilter)(target, format, type_, rowBufSize, row, columnBufSize, column, span)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnSeparableFilter", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnHistogram.xhtml>
	#[inline(always)]
	fn glGetnHistogram(&self, target: GLenum, reset: GLboolean, format: GLenum, type_: GLenum, bufSize: GLsizei, values: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnHistogram", catch_unwind(||(self.getnhistogram)(target, reset, format, type_, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnHistogram", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnMinmax.xhtml>
	#[inline(always)]
	fn glGetnMinmax(&self, target: GLenum, reset: GLboolean, format: GLenum, type_: GLenum, bufSize: GLsizei, values: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnMinmax", catch_unwind(||(self.getnminmax)(target, reset, format, type_, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnMinmax", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureBarrier.xhtml>
	#[inline(always)]
	fn glTextureBarrier(&self) -> Result<()> {
		let ret = process_catch("glTextureBarrier", catch_unwind(||(self.texturebarrier)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureBarrier", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version45 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (4, 5, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			clipcontrol: {let proc = get_proc_address("glClipControl"); if proc == null() {dummy_pfnglclipcontrolproc} else {unsafe{transmute(proc)}}},
			createtransformfeedbacks: {let proc = get_proc_address("glCreateTransformFeedbacks"); if proc == null() {dummy_pfnglcreatetransformfeedbacksproc} else {unsafe{transmute(proc)}}},
			transformfeedbackbufferbase: {let proc = get_proc_address("glTransformFeedbackBufferBase"); if proc == null() {dummy_pfngltransformfeedbackbufferbaseproc} else {unsafe{transmute(proc)}}},
			transformfeedbackbufferrange: {let proc = get_proc_address("glTransformFeedbackBufferRange"); if proc == null() {dummy_pfngltransformfeedbackbufferrangeproc} else {unsafe{transmute(proc)}}},
			gettransformfeedbackiv: {let proc = get_proc_address("glGetTransformFeedbackiv"); if proc == null() {dummy_pfnglgettransformfeedbackivproc} else {unsafe{transmute(proc)}}},
			gettransformfeedbacki_v: {let proc = get_proc_address("glGetTransformFeedbacki_v"); if proc == null() {dummy_pfnglgettransformfeedbacki_vproc} else {unsafe{transmute(proc)}}},
			gettransformfeedbacki64_v: {let proc = get_proc_address("glGetTransformFeedbacki64_v"); if proc == null() {dummy_pfnglgettransformfeedbacki64_vproc} else {unsafe{transmute(proc)}}},
			createbuffers: {let proc = get_proc_address("glCreateBuffers"); if proc == null() {dummy_pfnglcreatebuffersproc} else {unsafe{transmute(proc)}}},
			namedbufferstorage: {let proc = get_proc_address("glNamedBufferStorage"); if proc == null() {dummy_pfnglnamedbufferstorageproc} else {unsafe{transmute(proc)}}},
			namedbufferdata: {let proc = get_proc_address("glNamedBufferData"); if proc == null() {dummy_pfnglnamedbufferdataproc} else {unsafe{transmute(proc)}}},
			namedbuffersubdata: {let proc = get_proc_address("glNamedBufferSubData"); if proc == null() {dummy_pfnglnamedbuffersubdataproc} else {unsafe{transmute(proc)}}},
			copynamedbuffersubdata: {let proc = get_proc_address("glCopyNamedBufferSubData"); if proc == null() {dummy_pfnglcopynamedbuffersubdataproc} else {unsafe{transmute(proc)}}},
			clearnamedbufferdata: {let proc = get_proc_address("glClearNamedBufferData"); if proc == null() {dummy_pfnglclearnamedbufferdataproc} else {unsafe{transmute(proc)}}},
			clearnamedbuffersubdata: {let proc = get_proc_address("glClearNamedBufferSubData"); if proc == null() {dummy_pfnglclearnamedbuffersubdataproc} else {unsafe{transmute(proc)}}},
			mapnamedbuffer: {let proc = get_proc_address("glMapNamedBuffer"); if proc == null() {dummy_pfnglmapnamedbufferproc} else {unsafe{transmute(proc)}}},
			mapnamedbufferrange: {let proc = get_proc_address("glMapNamedBufferRange"); if proc == null() {dummy_pfnglmapnamedbufferrangeproc} else {unsafe{transmute(proc)}}},
			unmapnamedbuffer: {let proc = get_proc_address("glUnmapNamedBuffer"); if proc == null() {dummy_pfnglunmapnamedbufferproc} else {unsafe{transmute(proc)}}},
			flushmappednamedbufferrange: {let proc = get_proc_address("glFlushMappedNamedBufferRange"); if proc == null() {dummy_pfnglflushmappednamedbufferrangeproc} else {unsafe{transmute(proc)}}},
			getnamedbufferparameteriv: {let proc = get_proc_address("glGetNamedBufferParameteriv"); if proc == null() {dummy_pfnglgetnamedbufferparameterivproc} else {unsafe{transmute(proc)}}},
			getnamedbufferparameteri64v: {let proc = get_proc_address("glGetNamedBufferParameteri64v"); if proc == null() {dummy_pfnglgetnamedbufferparameteri64vproc} else {unsafe{transmute(proc)}}},
			getnamedbufferpointerv: {let proc = get_proc_address("glGetNamedBufferPointerv"); if proc == null() {dummy_pfnglgetnamedbufferpointervproc} else {unsafe{transmute(proc)}}},
			getnamedbuffersubdata: {let proc = get_proc_address("glGetNamedBufferSubData"); if proc == null() {dummy_pfnglgetnamedbuffersubdataproc} else {unsafe{transmute(proc)}}},
			createframebuffers: {let proc = get_proc_address("glCreateFramebuffers"); if proc == null() {dummy_pfnglcreateframebuffersproc} else {unsafe{transmute(proc)}}},
			namedframebufferrenderbuffer: {let proc = get_proc_address("glNamedFramebufferRenderbuffer"); if proc == null() {dummy_pfnglnamedframebufferrenderbufferproc} else {unsafe{transmute(proc)}}},
			namedframebufferparameteri: {let proc = get_proc_address("glNamedFramebufferParameteri"); if proc == null() {dummy_pfnglnamedframebufferparameteriproc} else {unsafe{transmute(proc)}}},
			namedframebuffertexture: {let proc = get_proc_address("glNamedFramebufferTexture"); if proc == null() {dummy_pfnglnamedframebuffertextureproc} else {unsafe{transmute(proc)}}},
			namedframebuffertexturelayer: {let proc = get_proc_address("glNamedFramebufferTextureLayer"); if proc == null() {dummy_pfnglnamedframebuffertexturelayerproc} else {unsafe{transmute(proc)}}},
			namedframebufferdrawbuffer: {let proc = get_proc_address("glNamedFramebufferDrawBuffer"); if proc == null() {dummy_pfnglnamedframebufferdrawbufferproc} else {unsafe{transmute(proc)}}},
			namedframebufferdrawbuffers: {let proc = get_proc_address("glNamedFramebufferDrawBuffers"); if proc == null() {dummy_pfnglnamedframebufferdrawbuffersproc} else {unsafe{transmute(proc)}}},
			namedframebufferreadbuffer: {let proc = get_proc_address("glNamedFramebufferReadBuffer"); if proc == null() {dummy_pfnglnamedframebufferreadbufferproc} else {unsafe{transmute(proc)}}},
			invalidatenamedframebufferdata: {let proc = get_proc_address("glInvalidateNamedFramebufferData"); if proc == null() {dummy_pfnglinvalidatenamedframebufferdataproc} else {unsafe{transmute(proc)}}},
			invalidatenamedframebuffersubdata: {let proc = get_proc_address("glInvalidateNamedFramebufferSubData"); if proc == null() {dummy_pfnglinvalidatenamedframebuffersubdataproc} else {unsafe{transmute(proc)}}},
			clearnamedframebufferiv: {let proc = get_proc_address("glClearNamedFramebufferiv"); if proc == null() {dummy_pfnglclearnamedframebufferivproc} else {unsafe{transmute(proc)}}},
			clearnamedframebufferuiv: {let proc = get_proc_address("glClearNamedFramebufferuiv"); if proc == null() {dummy_pfnglclearnamedframebufferuivproc} else {unsafe{transmute(proc)}}},
			clearnamedframebufferfv: {let proc = get_proc_address("glClearNamedFramebufferfv"); if proc == null() {dummy_pfnglclearnamedframebufferfvproc} else {unsafe{transmute(proc)}}},
			clearnamedframebufferfi: {let proc = get_proc_address("glClearNamedFramebufferfi"); if proc == null() {dummy_pfnglclearnamedframebufferfiproc} else {unsafe{transmute(proc)}}},
			blitnamedframebuffer: {let proc = get_proc_address("glBlitNamedFramebuffer"); if proc == null() {dummy_pfnglblitnamedframebufferproc} else {unsafe{transmute(proc)}}},
			checknamedframebufferstatus: {let proc = get_proc_address("glCheckNamedFramebufferStatus"); if proc == null() {dummy_pfnglchecknamedframebufferstatusproc} else {unsafe{transmute(proc)}}},
			getnamedframebufferparameteriv: {let proc = get_proc_address("glGetNamedFramebufferParameteriv"); if proc == null() {dummy_pfnglgetnamedframebufferparameterivproc} else {unsafe{transmute(proc)}}},
			getnamedframebufferattachmentparameteriv: {let proc = get_proc_address("glGetNamedFramebufferAttachmentParameteriv"); if proc == null() {dummy_pfnglgetnamedframebufferattachmentparameterivproc} else {unsafe{transmute(proc)}}},
			createrenderbuffers: {let proc = get_proc_address("glCreateRenderbuffers"); if proc == null() {dummy_pfnglcreaterenderbuffersproc} else {unsafe{transmute(proc)}}},
			namedrenderbufferstorage: {let proc = get_proc_address("glNamedRenderbufferStorage"); if proc == null() {dummy_pfnglnamedrenderbufferstorageproc} else {unsafe{transmute(proc)}}},
			namedrenderbufferstoragemultisample: {let proc = get_proc_address("glNamedRenderbufferStorageMultisample"); if proc == null() {dummy_pfnglnamedrenderbufferstoragemultisampleproc} else {unsafe{transmute(proc)}}},
			getnamedrenderbufferparameteriv: {let proc = get_proc_address("glGetNamedRenderbufferParameteriv"); if proc == null() {dummy_pfnglgetnamedrenderbufferparameterivproc} else {unsafe{transmute(proc)}}},
			createtextures: {let proc = get_proc_address("glCreateTextures"); if proc == null() {dummy_pfnglcreatetexturesproc} else {unsafe{transmute(proc)}}},
			texturebuffer: {let proc = get_proc_address("glTextureBuffer"); if proc == null() {dummy_pfngltexturebufferproc} else {unsafe{transmute(proc)}}},
			texturebufferrange: {let proc = get_proc_address("glTextureBufferRange"); if proc == null() {dummy_pfngltexturebufferrangeproc} else {unsafe{transmute(proc)}}},
			texturestorage1d: {let proc = get_proc_address("glTextureStorage1D"); if proc == null() {dummy_pfngltexturestorage1dproc} else {unsafe{transmute(proc)}}},
			texturestorage2d: {let proc = get_proc_address("glTextureStorage2D"); if proc == null() {dummy_pfngltexturestorage2dproc} else {unsafe{transmute(proc)}}},
			texturestorage3d: {let proc = get_proc_address("glTextureStorage3D"); if proc == null() {dummy_pfngltexturestorage3dproc} else {unsafe{transmute(proc)}}},
			texturestorage2dmultisample: {let proc = get_proc_address("glTextureStorage2DMultisample"); if proc == null() {dummy_pfngltexturestorage2dmultisampleproc} else {unsafe{transmute(proc)}}},
			texturestorage3dmultisample: {let proc = get_proc_address("glTextureStorage3DMultisample"); if proc == null() {dummy_pfngltexturestorage3dmultisampleproc} else {unsafe{transmute(proc)}}},
			texturesubimage1d: {let proc = get_proc_address("glTextureSubImage1D"); if proc == null() {dummy_pfngltexturesubimage1dproc} else {unsafe{transmute(proc)}}},
			texturesubimage2d: {let proc = get_proc_address("glTextureSubImage2D"); if proc == null() {dummy_pfngltexturesubimage2dproc} else {unsafe{transmute(proc)}}},
			texturesubimage3d: {let proc = get_proc_address("glTextureSubImage3D"); if proc == null() {dummy_pfngltexturesubimage3dproc} else {unsafe{transmute(proc)}}},
			compressedtexturesubimage1d: {let proc = get_proc_address("glCompressedTextureSubImage1D"); if proc == null() {dummy_pfnglcompressedtexturesubimage1dproc} else {unsafe{transmute(proc)}}},
			compressedtexturesubimage2d: {let proc = get_proc_address("glCompressedTextureSubImage2D"); if proc == null() {dummy_pfnglcompressedtexturesubimage2dproc} else {unsafe{transmute(proc)}}},
			compressedtexturesubimage3d: {let proc = get_proc_address("glCompressedTextureSubImage3D"); if proc == null() {dummy_pfnglcompressedtexturesubimage3dproc} else {unsafe{transmute(proc)}}},
			copytexturesubimage1d: {let proc = get_proc_address("glCopyTextureSubImage1D"); if proc == null() {dummy_pfnglcopytexturesubimage1dproc} else {unsafe{transmute(proc)}}},
			copytexturesubimage2d: {let proc = get_proc_address("glCopyTextureSubImage2D"); if proc == null() {dummy_pfnglcopytexturesubimage2dproc} else {unsafe{transmute(proc)}}},
			copytexturesubimage3d: {let proc = get_proc_address("glCopyTextureSubImage3D"); if proc == null() {dummy_pfnglcopytexturesubimage3dproc} else {unsafe{transmute(proc)}}},
			textureparameterf: {let proc = get_proc_address("glTextureParameterf"); if proc == null() {dummy_pfngltextureparameterfproc} else {unsafe{transmute(proc)}}},
			textureparameterfv: {let proc = get_proc_address("glTextureParameterfv"); if proc == null() {dummy_pfngltextureparameterfvproc} else {unsafe{transmute(proc)}}},
			textureparameteri: {let proc = get_proc_address("glTextureParameteri"); if proc == null() {dummy_pfngltextureparameteriproc} else {unsafe{transmute(proc)}}},
			textureparameteriiv: {let proc = get_proc_address("glTextureParameterIiv"); if proc == null() {dummy_pfngltextureparameteriivproc} else {unsafe{transmute(proc)}}},
			textureparameteriuiv: {let proc = get_proc_address("glTextureParameterIuiv"); if proc == null() {dummy_pfngltextureparameteriuivproc} else {unsafe{transmute(proc)}}},
			textureparameteriv: {let proc = get_proc_address("glTextureParameteriv"); if proc == null() {dummy_pfngltextureparameterivproc} else {unsafe{transmute(proc)}}},
			generatetexturemipmap: {let proc = get_proc_address("glGenerateTextureMipmap"); if proc == null() {dummy_pfnglgeneratetexturemipmapproc} else {unsafe{transmute(proc)}}},
			bindtextureunit: {let proc = get_proc_address("glBindTextureUnit"); if proc == null() {dummy_pfnglbindtextureunitproc} else {unsafe{transmute(proc)}}},
			gettextureimage: {let proc = get_proc_address("glGetTextureImage"); if proc == null() {dummy_pfnglgettextureimageproc} else {unsafe{transmute(proc)}}},
			getcompressedtextureimage: {let proc = get_proc_address("glGetCompressedTextureImage"); if proc == null() {dummy_pfnglgetcompressedtextureimageproc} else {unsafe{transmute(proc)}}},
			gettexturelevelparameterfv: {let proc = get_proc_address("glGetTextureLevelParameterfv"); if proc == null() {dummy_pfnglgettexturelevelparameterfvproc} else {unsafe{transmute(proc)}}},
			gettexturelevelparameteriv: {let proc = get_proc_address("glGetTextureLevelParameteriv"); if proc == null() {dummy_pfnglgettexturelevelparameterivproc} else {unsafe{transmute(proc)}}},
			gettextureparameterfv: {let proc = get_proc_address("glGetTextureParameterfv"); if proc == null() {dummy_pfnglgettextureparameterfvproc} else {unsafe{transmute(proc)}}},
			gettextureparameteriiv: {let proc = get_proc_address("glGetTextureParameterIiv"); if proc == null() {dummy_pfnglgettextureparameteriivproc} else {unsafe{transmute(proc)}}},
			gettextureparameteriuiv: {let proc = get_proc_address("glGetTextureParameterIuiv"); if proc == null() {dummy_pfnglgettextureparameteriuivproc} else {unsafe{transmute(proc)}}},
			gettextureparameteriv: {let proc = get_proc_address("glGetTextureParameteriv"); if proc == null() {dummy_pfnglgettextureparameterivproc} else {unsafe{transmute(proc)}}},
			createvertexarrays: {let proc = get_proc_address("glCreateVertexArrays"); if proc == null() {dummy_pfnglcreatevertexarraysproc} else {unsafe{transmute(proc)}}},
			disablevertexarrayattrib: {let proc = get_proc_address("glDisableVertexArrayAttrib"); if proc == null() {dummy_pfngldisablevertexarrayattribproc} else {unsafe{transmute(proc)}}},
			enablevertexarrayattrib: {let proc = get_proc_address("glEnableVertexArrayAttrib"); if proc == null() {dummy_pfnglenablevertexarrayattribproc} else {unsafe{transmute(proc)}}},
			vertexarrayelementbuffer: {let proc = get_proc_address("glVertexArrayElementBuffer"); if proc == null() {dummy_pfnglvertexarrayelementbufferproc} else {unsafe{transmute(proc)}}},
			vertexarrayvertexbuffer: {let proc = get_proc_address("glVertexArrayVertexBuffer"); if proc == null() {dummy_pfnglvertexarrayvertexbufferproc} else {unsafe{transmute(proc)}}},
			vertexarrayvertexbuffers: {let proc = get_proc_address("glVertexArrayVertexBuffers"); if proc == null() {dummy_pfnglvertexarrayvertexbuffersproc} else {unsafe{transmute(proc)}}},
			vertexarrayattribbinding: {let proc = get_proc_address("glVertexArrayAttribBinding"); if proc == null() {dummy_pfnglvertexarrayattribbindingproc} else {unsafe{transmute(proc)}}},
			vertexarrayattribformat: {let proc = get_proc_address("glVertexArrayAttribFormat"); if proc == null() {dummy_pfnglvertexarrayattribformatproc} else {unsafe{transmute(proc)}}},
			vertexarrayattribiformat: {let proc = get_proc_address("glVertexArrayAttribIFormat"); if proc == null() {dummy_pfnglvertexarrayattribiformatproc} else {unsafe{transmute(proc)}}},
			vertexarrayattriblformat: {let proc = get_proc_address("glVertexArrayAttribLFormat"); if proc == null() {dummy_pfnglvertexarrayattriblformatproc} else {unsafe{transmute(proc)}}},
			vertexarraybindingdivisor: {let proc = get_proc_address("glVertexArrayBindingDivisor"); if proc == null() {dummy_pfnglvertexarraybindingdivisorproc} else {unsafe{transmute(proc)}}},
			getvertexarrayiv: {let proc = get_proc_address("glGetVertexArrayiv"); if proc == null() {dummy_pfnglgetvertexarrayivproc} else {unsafe{transmute(proc)}}},
			getvertexarrayindexediv: {let proc = get_proc_address("glGetVertexArrayIndexediv"); if proc == null() {dummy_pfnglgetvertexarrayindexedivproc} else {unsafe{transmute(proc)}}},
			getvertexarrayindexed64iv: {let proc = get_proc_address("glGetVertexArrayIndexed64iv"); if proc == null() {dummy_pfnglgetvertexarrayindexed64ivproc} else {unsafe{transmute(proc)}}},
			createsamplers: {let proc = get_proc_address("glCreateSamplers"); if proc == null() {dummy_pfnglcreatesamplersproc} else {unsafe{transmute(proc)}}},
			createprogrampipelines: {let proc = get_proc_address("glCreateProgramPipelines"); if proc == null() {dummy_pfnglcreateprogrampipelinesproc} else {unsafe{transmute(proc)}}},
			createqueries: {let proc = get_proc_address("glCreateQueries"); if proc == null() {dummy_pfnglcreatequeriesproc} else {unsafe{transmute(proc)}}},
			getquerybufferobjecti64v: {let proc = get_proc_address("glGetQueryBufferObjecti64v"); if proc == null() {dummy_pfnglgetquerybufferobjecti64vproc} else {unsafe{transmute(proc)}}},
			getquerybufferobjectiv: {let proc = get_proc_address("glGetQueryBufferObjectiv"); if proc == null() {dummy_pfnglgetquerybufferobjectivproc} else {unsafe{transmute(proc)}}},
			getquerybufferobjectui64v: {let proc = get_proc_address("glGetQueryBufferObjectui64v"); if proc == null() {dummy_pfnglgetquerybufferobjectui64vproc} else {unsafe{transmute(proc)}}},
			getquerybufferobjectuiv: {let proc = get_proc_address("glGetQueryBufferObjectuiv"); if proc == null() {dummy_pfnglgetquerybufferobjectuivproc} else {unsafe{transmute(proc)}}},
			memorybarrierbyregion: {let proc = get_proc_address("glMemoryBarrierByRegion"); if proc == null() {dummy_pfnglmemorybarrierbyregionproc} else {unsafe{transmute(proc)}}},
			gettexturesubimage: {let proc = get_proc_address("glGetTextureSubImage"); if proc == null() {dummy_pfnglgettexturesubimageproc} else {unsafe{transmute(proc)}}},
			getcompressedtexturesubimage: {let proc = get_proc_address("glGetCompressedTextureSubImage"); if proc == null() {dummy_pfnglgetcompressedtexturesubimageproc} else {unsafe{transmute(proc)}}},
			getgraphicsresetstatus: {let proc = get_proc_address("glGetGraphicsResetStatus"); if proc == null() {dummy_pfnglgetgraphicsresetstatusproc} else {unsafe{transmute(proc)}}},
			getncompressedteximage: {let proc = get_proc_address("glGetnCompressedTexImage"); if proc == null() {dummy_pfnglgetncompressedteximageproc} else {unsafe{transmute(proc)}}},
			getnteximage: {let proc = get_proc_address("glGetnTexImage"); if proc == null() {dummy_pfnglgetnteximageproc} else {unsafe{transmute(proc)}}},
			getnuniformdv: {let proc = get_proc_address("glGetnUniformdv"); if proc == null() {dummy_pfnglgetnuniformdvproc} else {unsafe{transmute(proc)}}},
			getnuniformfv: {let proc = get_proc_address("glGetnUniformfv"); if proc == null() {dummy_pfnglgetnuniformfvproc} else {unsafe{transmute(proc)}}},
			getnuniformiv: {let proc = get_proc_address("glGetnUniformiv"); if proc == null() {dummy_pfnglgetnuniformivproc} else {unsafe{transmute(proc)}}},
			getnuniformuiv: {let proc = get_proc_address("glGetnUniformuiv"); if proc == null() {dummy_pfnglgetnuniformuivproc} else {unsafe{transmute(proc)}}},
			readnpixels: {let proc = get_proc_address("glReadnPixels"); if proc == null() {dummy_pfnglreadnpixelsproc} else {unsafe{transmute(proc)}}},
			getnmapdv: {let proc = get_proc_address("glGetnMapdv"); if proc == null() {dummy_pfnglgetnmapdvproc} else {unsafe{transmute(proc)}}},
			getnmapfv: {let proc = get_proc_address("glGetnMapfv"); if proc == null() {dummy_pfnglgetnmapfvproc} else {unsafe{transmute(proc)}}},
			getnmapiv: {let proc = get_proc_address("glGetnMapiv"); if proc == null() {dummy_pfnglgetnmapivproc} else {unsafe{transmute(proc)}}},
			getnpixelmapfv: {let proc = get_proc_address("glGetnPixelMapfv"); if proc == null() {dummy_pfnglgetnpixelmapfvproc} else {unsafe{transmute(proc)}}},
			getnpixelmapuiv: {let proc = get_proc_address("glGetnPixelMapuiv"); if proc == null() {dummy_pfnglgetnpixelmapuivproc} else {unsafe{transmute(proc)}}},
			getnpixelmapusv: {let proc = get_proc_address("glGetnPixelMapusv"); if proc == null() {dummy_pfnglgetnpixelmapusvproc} else {unsafe{transmute(proc)}}},
			getnpolygonstipple: {let proc = get_proc_address("glGetnPolygonStipple"); if proc == null() {dummy_pfnglgetnpolygonstippleproc} else {unsafe{transmute(proc)}}},
			getncolortable: {let proc = get_proc_address("glGetnColorTable"); if proc == null() {dummy_pfnglgetncolortableproc} else {unsafe{transmute(proc)}}},
			getnconvolutionfilter: {let proc = get_proc_address("glGetnConvolutionFilter"); if proc == null() {dummy_pfnglgetnconvolutionfilterproc} else {unsafe{transmute(proc)}}},
			getnseparablefilter: {let proc = get_proc_address("glGetnSeparableFilter"); if proc == null() {dummy_pfnglgetnseparablefilterproc} else {unsafe{transmute(proc)}}},
			getnhistogram: {let proc = get_proc_address("glGetnHistogram"); if proc == null() {dummy_pfnglgetnhistogramproc} else {unsafe{transmute(proc)}}},
			getnminmax: {let proc = get_proc_address("glGetnMinmax"); if proc == null() {dummy_pfnglgetnminmaxproc} else {unsafe{transmute(proc)}}},
			texturebarrier: {let proc = get_proc_address("glTextureBarrier"); if proc == null() {dummy_pfngltexturebarrierproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version45 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			clipcontrol: dummy_pfnglclipcontrolproc,
			createtransformfeedbacks: dummy_pfnglcreatetransformfeedbacksproc,
			transformfeedbackbufferbase: dummy_pfngltransformfeedbackbufferbaseproc,
			transformfeedbackbufferrange: dummy_pfngltransformfeedbackbufferrangeproc,
			gettransformfeedbackiv: dummy_pfnglgettransformfeedbackivproc,
			gettransformfeedbacki_v: dummy_pfnglgettransformfeedbacki_vproc,
			gettransformfeedbacki64_v: dummy_pfnglgettransformfeedbacki64_vproc,
			createbuffers: dummy_pfnglcreatebuffersproc,
			namedbufferstorage: dummy_pfnglnamedbufferstorageproc,
			namedbufferdata: dummy_pfnglnamedbufferdataproc,
			namedbuffersubdata: dummy_pfnglnamedbuffersubdataproc,
			copynamedbuffersubdata: dummy_pfnglcopynamedbuffersubdataproc,
			clearnamedbufferdata: dummy_pfnglclearnamedbufferdataproc,
			clearnamedbuffersubdata: dummy_pfnglclearnamedbuffersubdataproc,
			mapnamedbuffer: dummy_pfnglmapnamedbufferproc,
			mapnamedbufferrange: dummy_pfnglmapnamedbufferrangeproc,
			unmapnamedbuffer: dummy_pfnglunmapnamedbufferproc,
			flushmappednamedbufferrange: dummy_pfnglflushmappednamedbufferrangeproc,
			getnamedbufferparameteriv: dummy_pfnglgetnamedbufferparameterivproc,
			getnamedbufferparameteri64v: dummy_pfnglgetnamedbufferparameteri64vproc,
			getnamedbufferpointerv: dummy_pfnglgetnamedbufferpointervproc,
			getnamedbuffersubdata: dummy_pfnglgetnamedbuffersubdataproc,
			createframebuffers: dummy_pfnglcreateframebuffersproc,
			namedframebufferrenderbuffer: dummy_pfnglnamedframebufferrenderbufferproc,
			namedframebufferparameteri: dummy_pfnglnamedframebufferparameteriproc,
			namedframebuffertexture: dummy_pfnglnamedframebuffertextureproc,
			namedframebuffertexturelayer: dummy_pfnglnamedframebuffertexturelayerproc,
			namedframebufferdrawbuffer: dummy_pfnglnamedframebufferdrawbufferproc,
			namedframebufferdrawbuffers: dummy_pfnglnamedframebufferdrawbuffersproc,
			namedframebufferreadbuffer: dummy_pfnglnamedframebufferreadbufferproc,
			invalidatenamedframebufferdata: dummy_pfnglinvalidatenamedframebufferdataproc,
			invalidatenamedframebuffersubdata: dummy_pfnglinvalidatenamedframebuffersubdataproc,
			clearnamedframebufferiv: dummy_pfnglclearnamedframebufferivproc,
			clearnamedframebufferuiv: dummy_pfnglclearnamedframebufferuivproc,
			clearnamedframebufferfv: dummy_pfnglclearnamedframebufferfvproc,
			clearnamedframebufferfi: dummy_pfnglclearnamedframebufferfiproc,
			blitnamedframebuffer: dummy_pfnglblitnamedframebufferproc,
			checknamedframebufferstatus: dummy_pfnglchecknamedframebufferstatusproc,
			getnamedframebufferparameteriv: dummy_pfnglgetnamedframebufferparameterivproc,
			getnamedframebufferattachmentparameteriv: dummy_pfnglgetnamedframebufferattachmentparameterivproc,
			createrenderbuffers: dummy_pfnglcreaterenderbuffersproc,
			namedrenderbufferstorage: dummy_pfnglnamedrenderbufferstorageproc,
			namedrenderbufferstoragemultisample: dummy_pfnglnamedrenderbufferstoragemultisampleproc,
			getnamedrenderbufferparameteriv: dummy_pfnglgetnamedrenderbufferparameterivproc,
			createtextures: dummy_pfnglcreatetexturesproc,
			texturebuffer: dummy_pfngltexturebufferproc,
			texturebufferrange: dummy_pfngltexturebufferrangeproc,
			texturestorage1d: dummy_pfngltexturestorage1dproc,
			texturestorage2d: dummy_pfngltexturestorage2dproc,
			texturestorage3d: dummy_pfngltexturestorage3dproc,
			texturestorage2dmultisample: dummy_pfngltexturestorage2dmultisampleproc,
			texturestorage3dmultisample: dummy_pfngltexturestorage3dmultisampleproc,
			texturesubimage1d: dummy_pfngltexturesubimage1dproc,
			texturesubimage2d: dummy_pfngltexturesubimage2dproc,
			texturesubimage3d: dummy_pfngltexturesubimage3dproc,
			compressedtexturesubimage1d: dummy_pfnglcompressedtexturesubimage1dproc,
			compressedtexturesubimage2d: dummy_pfnglcompressedtexturesubimage2dproc,
			compressedtexturesubimage3d: dummy_pfnglcompressedtexturesubimage3dproc,
			copytexturesubimage1d: dummy_pfnglcopytexturesubimage1dproc,
			copytexturesubimage2d: dummy_pfnglcopytexturesubimage2dproc,
			copytexturesubimage3d: dummy_pfnglcopytexturesubimage3dproc,
			textureparameterf: dummy_pfngltextureparameterfproc,
			textureparameterfv: dummy_pfngltextureparameterfvproc,
			textureparameteri: dummy_pfngltextureparameteriproc,
			textureparameteriiv: dummy_pfngltextureparameteriivproc,
			textureparameteriuiv: dummy_pfngltextureparameteriuivproc,
			textureparameteriv: dummy_pfngltextureparameterivproc,
			generatetexturemipmap: dummy_pfnglgeneratetexturemipmapproc,
			bindtextureunit: dummy_pfnglbindtextureunitproc,
			gettextureimage: dummy_pfnglgettextureimageproc,
			getcompressedtextureimage: dummy_pfnglgetcompressedtextureimageproc,
			gettexturelevelparameterfv: dummy_pfnglgettexturelevelparameterfvproc,
			gettexturelevelparameteriv: dummy_pfnglgettexturelevelparameterivproc,
			gettextureparameterfv: dummy_pfnglgettextureparameterfvproc,
			gettextureparameteriiv: dummy_pfnglgettextureparameteriivproc,
			gettextureparameteriuiv: dummy_pfnglgettextureparameteriuivproc,
			gettextureparameteriv: dummy_pfnglgettextureparameterivproc,
			createvertexarrays: dummy_pfnglcreatevertexarraysproc,
			disablevertexarrayattrib: dummy_pfngldisablevertexarrayattribproc,
			enablevertexarrayattrib: dummy_pfnglenablevertexarrayattribproc,
			vertexarrayelementbuffer: dummy_pfnglvertexarrayelementbufferproc,
			vertexarrayvertexbuffer: dummy_pfnglvertexarrayvertexbufferproc,
			vertexarrayvertexbuffers: dummy_pfnglvertexarrayvertexbuffersproc,
			vertexarrayattribbinding: dummy_pfnglvertexarrayattribbindingproc,
			vertexarrayattribformat: dummy_pfnglvertexarrayattribformatproc,
			vertexarrayattribiformat: dummy_pfnglvertexarrayattribiformatproc,
			vertexarrayattriblformat: dummy_pfnglvertexarrayattriblformatproc,
			vertexarraybindingdivisor: dummy_pfnglvertexarraybindingdivisorproc,
			getvertexarrayiv: dummy_pfnglgetvertexarrayivproc,
			getvertexarrayindexediv: dummy_pfnglgetvertexarrayindexedivproc,
			getvertexarrayindexed64iv: dummy_pfnglgetvertexarrayindexed64ivproc,
			createsamplers: dummy_pfnglcreatesamplersproc,
			createprogrampipelines: dummy_pfnglcreateprogrampipelinesproc,
			createqueries: dummy_pfnglcreatequeriesproc,
			getquerybufferobjecti64v: dummy_pfnglgetquerybufferobjecti64vproc,
			getquerybufferobjectiv: dummy_pfnglgetquerybufferobjectivproc,
			getquerybufferobjectui64v: dummy_pfnglgetquerybufferobjectui64vproc,
			getquerybufferobjectuiv: dummy_pfnglgetquerybufferobjectuivproc,
			memorybarrierbyregion: dummy_pfnglmemorybarrierbyregionproc,
			gettexturesubimage: dummy_pfnglgettexturesubimageproc,
			getcompressedtexturesubimage: dummy_pfnglgetcompressedtexturesubimageproc,
			getgraphicsresetstatus: dummy_pfnglgetgraphicsresetstatusproc,
			getncompressedteximage: dummy_pfnglgetncompressedteximageproc,
			getnteximage: dummy_pfnglgetnteximageproc,
			getnuniformdv: dummy_pfnglgetnuniformdvproc,
			getnuniformfv: dummy_pfnglgetnuniformfvproc,
			getnuniformiv: dummy_pfnglgetnuniformivproc,
			getnuniformuiv: dummy_pfnglgetnuniformuivproc,
			readnpixels: dummy_pfnglreadnpixelsproc,
			getnmapdv: dummy_pfnglgetnmapdvproc,
			getnmapfv: dummy_pfnglgetnmapfvproc,
			getnmapiv: dummy_pfnglgetnmapivproc,
			getnpixelmapfv: dummy_pfnglgetnpixelmapfvproc,
			getnpixelmapuiv: dummy_pfnglgetnpixelmapuivproc,
			getnpixelmapusv: dummy_pfnglgetnpixelmapusvproc,
			getnpolygonstipple: dummy_pfnglgetnpolygonstippleproc,
			getncolortable: dummy_pfnglgetncolortableproc,
			getnconvolutionfilter: dummy_pfnglgetnconvolutionfilterproc,
			getnseparablefilter: dummy_pfnglgetnseparablefilterproc,
			getnhistogram: dummy_pfnglgetnhistogramproc,
			getnminmax: dummy_pfnglgetnminmaxproc,
			texturebarrier: dummy_pfngltexturebarrierproc,
		}
	}
}
impl Debug for Version45 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version45")
			.field("available", &self.available)
			.field("clipcontrol", unsafe{if transmute::<_, *const c_void>(self.clipcontrol) == (dummy_pfnglclipcontrolproc as *const c_void) {&null::<PFNGLCLIPCONTROLPROC>()} else {&self.clipcontrol}})
			.field("createtransformfeedbacks", unsafe{if transmute::<_, *const c_void>(self.createtransformfeedbacks) == (dummy_pfnglcreatetransformfeedbacksproc as *const c_void) {&null::<PFNGLCREATETRANSFORMFEEDBACKSPROC>()} else {&self.createtransformfeedbacks}})
			.field("transformfeedbackbufferbase", unsafe{if transmute::<_, *const c_void>(self.transformfeedbackbufferbase) == (dummy_pfngltransformfeedbackbufferbaseproc as *const c_void) {&null::<PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC>()} else {&self.transformfeedbackbufferbase}})
			.field("transformfeedbackbufferrange", unsafe{if transmute::<_, *const c_void>(self.transformfeedbackbufferrange) == (dummy_pfngltransformfeedbackbufferrangeproc as *const c_void) {&null::<PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC>()} else {&self.transformfeedbackbufferrange}})
			.field("gettransformfeedbackiv", unsafe{if transmute::<_, *const c_void>(self.gettransformfeedbackiv) == (dummy_pfnglgettransformfeedbackivproc as *const c_void) {&null::<PFNGLGETTRANSFORMFEEDBACKIVPROC>()} else {&self.gettransformfeedbackiv}})
			.field("gettransformfeedbacki_v", unsafe{if transmute::<_, *const c_void>(self.gettransformfeedbacki_v) == (dummy_pfnglgettransformfeedbacki_vproc as *const c_void) {&null::<PFNGLGETTRANSFORMFEEDBACKI_VPROC>()} else {&self.gettransformfeedbacki_v}})
			.field("gettransformfeedbacki64_v", unsafe{if transmute::<_, *const c_void>(self.gettransformfeedbacki64_v) == (dummy_pfnglgettransformfeedbacki64_vproc as *const c_void) {&null::<PFNGLGETTRANSFORMFEEDBACKI64_VPROC>()} else {&self.gettransformfeedbacki64_v}})
			.field("createbuffers", unsafe{if transmute::<_, *const c_void>(self.createbuffers) == (dummy_pfnglcreatebuffersproc as *const c_void) {&null::<PFNGLCREATEBUFFERSPROC>()} else {&self.createbuffers}})
			.field("namedbufferstorage", unsafe{if transmute::<_, *const c_void>(self.namedbufferstorage) == (dummy_pfnglnamedbufferstorageproc as *const c_void) {&null::<PFNGLNAMEDBUFFERSTORAGEPROC>()} else {&self.namedbufferstorage}})
			.field("namedbufferdata", unsafe{if transmute::<_, *const c_void>(self.namedbufferdata) == (dummy_pfnglnamedbufferdataproc as *const c_void) {&null::<PFNGLNAMEDBUFFERDATAPROC>()} else {&self.namedbufferdata}})
			.field("namedbuffersubdata", unsafe{if transmute::<_, *const c_void>(self.namedbuffersubdata) == (dummy_pfnglnamedbuffersubdataproc as *const c_void) {&null::<PFNGLNAMEDBUFFERSUBDATAPROC>()} else {&self.namedbuffersubdata}})
			.field("copynamedbuffersubdata", unsafe{if transmute::<_, *const c_void>(self.copynamedbuffersubdata) == (dummy_pfnglcopynamedbuffersubdataproc as *const c_void) {&null::<PFNGLCOPYNAMEDBUFFERSUBDATAPROC>()} else {&self.copynamedbuffersubdata}})
			.field("clearnamedbufferdata", unsafe{if transmute::<_, *const c_void>(self.clearnamedbufferdata) == (dummy_pfnglclearnamedbufferdataproc as *const c_void) {&null::<PFNGLCLEARNAMEDBUFFERDATAPROC>()} else {&self.clearnamedbufferdata}})
			.field("clearnamedbuffersubdata", unsafe{if transmute::<_, *const c_void>(self.clearnamedbuffersubdata) == (dummy_pfnglclearnamedbuffersubdataproc as *const c_void) {&null::<PFNGLCLEARNAMEDBUFFERSUBDATAPROC>()} else {&self.clearnamedbuffersubdata}})
			.field("mapnamedbuffer", unsafe{if transmute::<_, *const c_void>(self.mapnamedbuffer) == (dummy_pfnglmapnamedbufferproc as *const c_void) {&null::<PFNGLMAPNAMEDBUFFERPROC>()} else {&self.mapnamedbuffer}})
			.field("mapnamedbufferrange", unsafe{if transmute::<_, *const c_void>(self.mapnamedbufferrange) == (dummy_pfnglmapnamedbufferrangeproc as *const c_void) {&null::<PFNGLMAPNAMEDBUFFERRANGEPROC>()} else {&self.mapnamedbufferrange}})
			.field("unmapnamedbuffer", unsafe{if transmute::<_, *const c_void>(self.unmapnamedbuffer) == (dummy_pfnglunmapnamedbufferproc as *const c_void) {&null::<PFNGLUNMAPNAMEDBUFFERPROC>()} else {&self.unmapnamedbuffer}})
			.field("flushmappednamedbufferrange", unsafe{if transmute::<_, *const c_void>(self.flushmappednamedbufferrange) == (dummy_pfnglflushmappednamedbufferrangeproc as *const c_void) {&null::<PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC>()} else {&self.flushmappednamedbufferrange}})
			.field("getnamedbufferparameteriv", unsafe{if transmute::<_, *const c_void>(self.getnamedbufferparameteriv) == (dummy_pfnglgetnamedbufferparameterivproc as *const c_void) {&null::<PFNGLGETNAMEDBUFFERPARAMETERIVPROC>()} else {&self.getnamedbufferparameteriv}})
			.field("getnamedbufferparameteri64v", unsafe{if transmute::<_, *const c_void>(self.getnamedbufferparameteri64v) == (dummy_pfnglgetnamedbufferparameteri64vproc as *const c_void) {&null::<PFNGLGETNAMEDBUFFERPARAMETERI64VPROC>()} else {&self.getnamedbufferparameteri64v}})
			.field("getnamedbufferpointerv", unsafe{if transmute::<_, *const c_void>(self.getnamedbufferpointerv) == (dummy_pfnglgetnamedbufferpointervproc as *const c_void) {&null::<PFNGLGETNAMEDBUFFERPOINTERVPROC>()} else {&self.getnamedbufferpointerv}})
			.field("getnamedbuffersubdata", unsafe{if transmute::<_, *const c_void>(self.getnamedbuffersubdata) == (dummy_pfnglgetnamedbuffersubdataproc as *const c_void) {&null::<PFNGLGETNAMEDBUFFERSUBDATAPROC>()} else {&self.getnamedbuffersubdata}})
			.field("createframebuffers", unsafe{if transmute::<_, *const c_void>(self.createframebuffers) == (dummy_pfnglcreateframebuffersproc as *const c_void) {&null::<PFNGLCREATEFRAMEBUFFERSPROC>()} else {&self.createframebuffers}})
			.field("namedframebufferrenderbuffer", unsafe{if transmute::<_, *const c_void>(self.namedframebufferrenderbuffer) == (dummy_pfnglnamedframebufferrenderbufferproc as *const c_void) {&null::<PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC>()} else {&self.namedframebufferrenderbuffer}})
			.field("namedframebufferparameteri", unsafe{if transmute::<_, *const c_void>(self.namedframebufferparameteri) == (dummy_pfnglnamedframebufferparameteriproc as *const c_void) {&null::<PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC>()} else {&self.namedframebufferparameteri}})
			.field("namedframebuffertexture", unsafe{if transmute::<_, *const c_void>(self.namedframebuffertexture) == (dummy_pfnglnamedframebuffertextureproc as *const c_void) {&null::<PFNGLNAMEDFRAMEBUFFERTEXTUREPROC>()} else {&self.namedframebuffertexture}})
			.field("namedframebuffertexturelayer", unsafe{if transmute::<_, *const c_void>(self.namedframebuffertexturelayer) == (dummy_pfnglnamedframebuffertexturelayerproc as *const c_void) {&null::<PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC>()} else {&self.namedframebuffertexturelayer}})
			.field("namedframebufferdrawbuffer", unsafe{if transmute::<_, *const c_void>(self.namedframebufferdrawbuffer) == (dummy_pfnglnamedframebufferdrawbufferproc as *const c_void) {&null::<PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC>()} else {&self.namedframebufferdrawbuffer}})
			.field("namedframebufferdrawbuffers", unsafe{if transmute::<_, *const c_void>(self.namedframebufferdrawbuffers) == (dummy_pfnglnamedframebufferdrawbuffersproc as *const c_void) {&null::<PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC>()} else {&self.namedframebufferdrawbuffers}})
			.field("namedframebufferreadbuffer", unsafe{if transmute::<_, *const c_void>(self.namedframebufferreadbuffer) == (dummy_pfnglnamedframebufferreadbufferproc as *const c_void) {&null::<PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC>()} else {&self.namedframebufferreadbuffer}})
			.field("invalidatenamedframebufferdata", unsafe{if transmute::<_, *const c_void>(self.invalidatenamedframebufferdata) == (dummy_pfnglinvalidatenamedframebufferdataproc as *const c_void) {&null::<PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC>()} else {&self.invalidatenamedframebufferdata}})
			.field("invalidatenamedframebuffersubdata", unsafe{if transmute::<_, *const c_void>(self.invalidatenamedframebuffersubdata) == (dummy_pfnglinvalidatenamedframebuffersubdataproc as *const c_void) {&null::<PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC>()} else {&self.invalidatenamedframebuffersubdata}})
			.field("clearnamedframebufferiv", unsafe{if transmute::<_, *const c_void>(self.clearnamedframebufferiv) == (dummy_pfnglclearnamedframebufferivproc as *const c_void) {&null::<PFNGLCLEARNAMEDFRAMEBUFFERIVPROC>()} else {&self.clearnamedframebufferiv}})
			.field("clearnamedframebufferuiv", unsafe{if transmute::<_, *const c_void>(self.clearnamedframebufferuiv) == (dummy_pfnglclearnamedframebufferuivproc as *const c_void) {&null::<PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC>()} else {&self.clearnamedframebufferuiv}})
			.field("clearnamedframebufferfv", unsafe{if transmute::<_, *const c_void>(self.clearnamedframebufferfv) == (dummy_pfnglclearnamedframebufferfvproc as *const c_void) {&null::<PFNGLCLEARNAMEDFRAMEBUFFERFVPROC>()} else {&self.clearnamedframebufferfv}})
			.field("clearnamedframebufferfi", unsafe{if transmute::<_, *const c_void>(self.clearnamedframebufferfi) == (dummy_pfnglclearnamedframebufferfiproc as *const c_void) {&null::<PFNGLCLEARNAMEDFRAMEBUFFERFIPROC>()} else {&self.clearnamedframebufferfi}})
			.field("blitnamedframebuffer", unsafe{if transmute::<_, *const c_void>(self.blitnamedframebuffer) == (dummy_pfnglblitnamedframebufferproc as *const c_void) {&null::<PFNGLBLITNAMEDFRAMEBUFFERPROC>()} else {&self.blitnamedframebuffer}})
			.field("checknamedframebufferstatus", unsafe{if transmute::<_, *const c_void>(self.checknamedframebufferstatus) == (dummy_pfnglchecknamedframebufferstatusproc as *const c_void) {&null::<PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC>()} else {&self.checknamedframebufferstatus}})
			.field("getnamedframebufferparameteriv", unsafe{if transmute::<_, *const c_void>(self.getnamedframebufferparameteriv) == (dummy_pfnglgetnamedframebufferparameterivproc as *const c_void) {&null::<PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC>()} else {&self.getnamedframebufferparameteriv}})
			.field("getnamedframebufferattachmentparameteriv", unsafe{if transmute::<_, *const c_void>(self.getnamedframebufferattachmentparameteriv) == (dummy_pfnglgetnamedframebufferattachmentparameterivproc as *const c_void) {&null::<PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC>()} else {&self.getnamedframebufferattachmentparameteriv}})
			.field("createrenderbuffers", unsafe{if transmute::<_, *const c_void>(self.createrenderbuffers) == (dummy_pfnglcreaterenderbuffersproc as *const c_void) {&null::<PFNGLCREATERENDERBUFFERSPROC>()} else {&self.createrenderbuffers}})
			.field("namedrenderbufferstorage", unsafe{if transmute::<_, *const c_void>(self.namedrenderbufferstorage) == (dummy_pfnglnamedrenderbufferstorageproc as *const c_void) {&null::<PFNGLNAMEDRENDERBUFFERSTORAGEPROC>()} else {&self.namedrenderbufferstorage}})
			.field("namedrenderbufferstoragemultisample", unsafe{if transmute::<_, *const c_void>(self.namedrenderbufferstoragemultisample) == (dummy_pfnglnamedrenderbufferstoragemultisampleproc as *const c_void) {&null::<PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC>()} else {&self.namedrenderbufferstoragemultisample}})
			.field("getnamedrenderbufferparameteriv", unsafe{if transmute::<_, *const c_void>(self.getnamedrenderbufferparameteriv) == (dummy_pfnglgetnamedrenderbufferparameterivproc as *const c_void) {&null::<PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC>()} else {&self.getnamedrenderbufferparameteriv}})
			.field("createtextures", unsafe{if transmute::<_, *const c_void>(self.createtextures) == (dummy_pfnglcreatetexturesproc as *const c_void) {&null::<PFNGLCREATETEXTURESPROC>()} else {&self.createtextures}})
			.field("texturebuffer", unsafe{if transmute::<_, *const c_void>(self.texturebuffer) == (dummy_pfngltexturebufferproc as *const c_void) {&null::<PFNGLTEXTUREBUFFERPROC>()} else {&self.texturebuffer}})
			.field("texturebufferrange", unsafe{if transmute::<_, *const c_void>(self.texturebufferrange) == (dummy_pfngltexturebufferrangeproc as *const c_void) {&null::<PFNGLTEXTUREBUFFERRANGEPROC>()} else {&self.texturebufferrange}})
			.field("texturestorage1d", unsafe{if transmute::<_, *const c_void>(self.texturestorage1d) == (dummy_pfngltexturestorage1dproc as *const c_void) {&null::<PFNGLTEXTURESTORAGE1DPROC>()} else {&self.texturestorage1d}})
			.field("texturestorage2d", unsafe{if transmute::<_, *const c_void>(self.texturestorage2d) == (dummy_pfngltexturestorage2dproc as *const c_void) {&null::<PFNGLTEXTURESTORAGE2DPROC>()} else {&self.texturestorage2d}})
			.field("texturestorage3d", unsafe{if transmute::<_, *const c_void>(self.texturestorage3d) == (dummy_pfngltexturestorage3dproc as *const c_void) {&null::<PFNGLTEXTURESTORAGE3DPROC>()} else {&self.texturestorage3d}})
			.field("texturestorage2dmultisample", unsafe{if transmute::<_, *const c_void>(self.texturestorage2dmultisample) == (dummy_pfngltexturestorage2dmultisampleproc as *const c_void) {&null::<PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC>()} else {&self.texturestorage2dmultisample}})
			.field("texturestorage3dmultisample", unsafe{if transmute::<_, *const c_void>(self.texturestorage3dmultisample) == (dummy_pfngltexturestorage3dmultisampleproc as *const c_void) {&null::<PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC>()} else {&self.texturestorage3dmultisample}})
			.field("texturesubimage1d", unsafe{if transmute::<_, *const c_void>(self.texturesubimage1d) == (dummy_pfngltexturesubimage1dproc as *const c_void) {&null::<PFNGLTEXTURESUBIMAGE1DPROC>()} else {&self.texturesubimage1d}})
			.field("texturesubimage2d", unsafe{if transmute::<_, *const c_void>(self.texturesubimage2d) == (dummy_pfngltexturesubimage2dproc as *const c_void) {&null::<PFNGLTEXTURESUBIMAGE2DPROC>()} else {&self.texturesubimage2d}})
			.field("texturesubimage3d", unsafe{if transmute::<_, *const c_void>(self.texturesubimage3d) == (dummy_pfngltexturesubimage3dproc as *const c_void) {&null::<PFNGLTEXTURESUBIMAGE3DPROC>()} else {&self.texturesubimage3d}})
			.field("compressedtexturesubimage1d", unsafe{if transmute::<_, *const c_void>(self.compressedtexturesubimage1d) == (dummy_pfnglcompressedtexturesubimage1dproc as *const c_void) {&null::<PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC>()} else {&self.compressedtexturesubimage1d}})
			.field("compressedtexturesubimage2d", unsafe{if transmute::<_, *const c_void>(self.compressedtexturesubimage2d) == (dummy_pfnglcompressedtexturesubimage2dproc as *const c_void) {&null::<PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC>()} else {&self.compressedtexturesubimage2d}})
			.field("compressedtexturesubimage3d", unsafe{if transmute::<_, *const c_void>(self.compressedtexturesubimage3d) == (dummy_pfnglcompressedtexturesubimage3dproc as *const c_void) {&null::<PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC>()} else {&self.compressedtexturesubimage3d}})
			.field("copytexturesubimage1d", unsafe{if transmute::<_, *const c_void>(self.copytexturesubimage1d) == (dummy_pfnglcopytexturesubimage1dproc as *const c_void) {&null::<PFNGLCOPYTEXTURESUBIMAGE1DPROC>()} else {&self.copytexturesubimage1d}})
			.field("copytexturesubimage2d", unsafe{if transmute::<_, *const c_void>(self.copytexturesubimage2d) == (dummy_pfnglcopytexturesubimage2dproc as *const c_void) {&null::<PFNGLCOPYTEXTURESUBIMAGE2DPROC>()} else {&self.copytexturesubimage2d}})
			.field("copytexturesubimage3d", unsafe{if transmute::<_, *const c_void>(self.copytexturesubimage3d) == (dummy_pfnglcopytexturesubimage3dproc as *const c_void) {&null::<PFNGLCOPYTEXTURESUBIMAGE3DPROC>()} else {&self.copytexturesubimage3d}})
			.field("textureparameterf", unsafe{if transmute::<_, *const c_void>(self.textureparameterf) == (dummy_pfngltextureparameterfproc as *const c_void) {&null::<PFNGLTEXTUREPARAMETERFPROC>()} else {&self.textureparameterf}})
			.field("textureparameterfv", unsafe{if transmute::<_, *const c_void>(self.textureparameterfv) == (dummy_pfngltextureparameterfvproc as *const c_void) {&null::<PFNGLTEXTUREPARAMETERFVPROC>()} else {&self.textureparameterfv}})
			.field("textureparameteri", unsafe{if transmute::<_, *const c_void>(self.textureparameteri) == (dummy_pfngltextureparameteriproc as *const c_void) {&null::<PFNGLTEXTUREPARAMETERIPROC>()} else {&self.textureparameteri}})
			.field("textureparameteriiv", unsafe{if transmute::<_, *const c_void>(self.textureparameteriiv) == (dummy_pfngltextureparameteriivproc as *const c_void) {&null::<PFNGLTEXTUREPARAMETERIIVPROC>()} else {&self.textureparameteriiv}})
			.field("textureparameteriuiv", unsafe{if transmute::<_, *const c_void>(self.textureparameteriuiv) == (dummy_pfngltextureparameteriuivproc as *const c_void) {&null::<PFNGLTEXTUREPARAMETERIUIVPROC>()} else {&self.textureparameteriuiv}})
			.field("textureparameteriv", unsafe{if transmute::<_, *const c_void>(self.textureparameteriv) == (dummy_pfngltextureparameterivproc as *const c_void) {&null::<PFNGLTEXTUREPARAMETERIVPROC>()} else {&self.textureparameteriv}})
			.field("generatetexturemipmap", unsafe{if transmute::<_, *const c_void>(self.generatetexturemipmap) == (dummy_pfnglgeneratetexturemipmapproc as *const c_void) {&null::<PFNGLGENERATETEXTUREMIPMAPPROC>()} else {&self.generatetexturemipmap}})
			.field("bindtextureunit", unsafe{if transmute::<_, *const c_void>(self.bindtextureunit) == (dummy_pfnglbindtextureunitproc as *const c_void) {&null::<PFNGLBINDTEXTUREUNITPROC>()} else {&self.bindtextureunit}})
			.field("gettextureimage", unsafe{if transmute::<_, *const c_void>(self.gettextureimage) == (dummy_pfnglgettextureimageproc as *const c_void) {&null::<PFNGLGETTEXTUREIMAGEPROC>()} else {&self.gettextureimage}})
			.field("getcompressedtextureimage", unsafe{if transmute::<_, *const c_void>(self.getcompressedtextureimage) == (dummy_pfnglgetcompressedtextureimageproc as *const c_void) {&null::<PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC>()} else {&self.getcompressedtextureimage}})
			.field("gettexturelevelparameterfv", unsafe{if transmute::<_, *const c_void>(self.gettexturelevelparameterfv) == (dummy_pfnglgettexturelevelparameterfvproc as *const c_void) {&null::<PFNGLGETTEXTURELEVELPARAMETERFVPROC>()} else {&self.gettexturelevelparameterfv}})
			.field("gettexturelevelparameteriv", unsafe{if transmute::<_, *const c_void>(self.gettexturelevelparameteriv) == (dummy_pfnglgettexturelevelparameterivproc as *const c_void) {&null::<PFNGLGETTEXTURELEVELPARAMETERIVPROC>()} else {&self.gettexturelevelparameteriv}})
			.field("gettextureparameterfv", unsafe{if transmute::<_, *const c_void>(self.gettextureparameterfv) == (dummy_pfnglgettextureparameterfvproc as *const c_void) {&null::<PFNGLGETTEXTUREPARAMETERFVPROC>()} else {&self.gettextureparameterfv}})
			.field("gettextureparameteriiv", unsafe{if transmute::<_, *const c_void>(self.gettextureparameteriiv) == (dummy_pfnglgettextureparameteriivproc as *const c_void) {&null::<PFNGLGETTEXTUREPARAMETERIIVPROC>()} else {&self.gettextureparameteriiv}})
			.field("gettextureparameteriuiv", unsafe{if transmute::<_, *const c_void>(self.gettextureparameteriuiv) == (dummy_pfnglgettextureparameteriuivproc as *const c_void) {&null::<PFNGLGETTEXTUREPARAMETERIUIVPROC>()} else {&self.gettextureparameteriuiv}})
			.field("gettextureparameteriv", unsafe{if transmute::<_, *const c_void>(self.gettextureparameteriv) == (dummy_pfnglgettextureparameterivproc as *const c_void) {&null::<PFNGLGETTEXTUREPARAMETERIVPROC>()} else {&self.gettextureparameteriv}})
			.field("createvertexarrays", unsafe{if transmute::<_, *const c_void>(self.createvertexarrays) == (dummy_pfnglcreatevertexarraysproc as *const c_void) {&null::<PFNGLCREATEVERTEXARRAYSPROC>()} else {&self.createvertexarrays}})
			.field("disablevertexarrayattrib", unsafe{if transmute::<_, *const c_void>(self.disablevertexarrayattrib) == (dummy_pfngldisablevertexarrayattribproc as *const c_void) {&null::<PFNGLDISABLEVERTEXARRAYATTRIBPROC>()} else {&self.disablevertexarrayattrib}})
			.field("enablevertexarrayattrib", unsafe{if transmute::<_, *const c_void>(self.enablevertexarrayattrib) == (dummy_pfnglenablevertexarrayattribproc as *const c_void) {&null::<PFNGLENABLEVERTEXARRAYATTRIBPROC>()} else {&self.enablevertexarrayattrib}})
			.field("vertexarrayelementbuffer", unsafe{if transmute::<_, *const c_void>(self.vertexarrayelementbuffer) == (dummy_pfnglvertexarrayelementbufferproc as *const c_void) {&null::<PFNGLVERTEXARRAYELEMENTBUFFERPROC>()} else {&self.vertexarrayelementbuffer}})
			.field("vertexarrayvertexbuffer", unsafe{if transmute::<_, *const c_void>(self.vertexarrayvertexbuffer) == (dummy_pfnglvertexarrayvertexbufferproc as *const c_void) {&null::<PFNGLVERTEXARRAYVERTEXBUFFERPROC>()} else {&self.vertexarrayvertexbuffer}})
			.field("vertexarrayvertexbuffers", unsafe{if transmute::<_, *const c_void>(self.vertexarrayvertexbuffers) == (dummy_pfnglvertexarrayvertexbuffersproc as *const c_void) {&null::<PFNGLVERTEXARRAYVERTEXBUFFERSPROC>()} else {&self.vertexarrayvertexbuffers}})
			.field("vertexarrayattribbinding", unsafe{if transmute::<_, *const c_void>(self.vertexarrayattribbinding) == (dummy_pfnglvertexarrayattribbindingproc as *const c_void) {&null::<PFNGLVERTEXARRAYATTRIBBINDINGPROC>()} else {&self.vertexarrayattribbinding}})
			.field("vertexarrayattribformat", unsafe{if transmute::<_, *const c_void>(self.vertexarrayattribformat) == (dummy_pfnglvertexarrayattribformatproc as *const c_void) {&null::<PFNGLVERTEXARRAYATTRIBFORMATPROC>()} else {&self.vertexarrayattribformat}})
			.field("vertexarrayattribiformat", unsafe{if transmute::<_, *const c_void>(self.vertexarrayattribiformat) == (dummy_pfnglvertexarrayattribiformatproc as *const c_void) {&null::<PFNGLVERTEXARRAYATTRIBIFORMATPROC>()} else {&self.vertexarrayattribiformat}})
			.field("vertexarrayattriblformat", unsafe{if transmute::<_, *const c_void>(self.vertexarrayattriblformat) == (dummy_pfnglvertexarrayattriblformatproc as *const c_void) {&null::<PFNGLVERTEXARRAYATTRIBLFORMATPROC>()} else {&self.vertexarrayattriblformat}})
			.field("vertexarraybindingdivisor", unsafe{if transmute::<_, *const c_void>(self.vertexarraybindingdivisor) == (dummy_pfnglvertexarraybindingdivisorproc as *const c_void) {&null::<PFNGLVERTEXARRAYBINDINGDIVISORPROC>()} else {&self.vertexarraybindingdivisor}})
			.field("getvertexarrayiv", unsafe{if transmute::<_, *const c_void>(self.getvertexarrayiv) == (dummy_pfnglgetvertexarrayivproc as *const c_void) {&null::<PFNGLGETVERTEXARRAYIVPROC>()} else {&self.getvertexarrayiv}})
			.field("getvertexarrayindexediv", unsafe{if transmute::<_, *const c_void>(self.getvertexarrayindexediv) == (dummy_pfnglgetvertexarrayindexedivproc as *const c_void) {&null::<PFNGLGETVERTEXARRAYINDEXEDIVPROC>()} else {&self.getvertexarrayindexediv}})
			.field("getvertexarrayindexed64iv", unsafe{if transmute::<_, *const c_void>(self.getvertexarrayindexed64iv) == (dummy_pfnglgetvertexarrayindexed64ivproc as *const c_void) {&null::<PFNGLGETVERTEXARRAYINDEXED64IVPROC>()} else {&self.getvertexarrayindexed64iv}})
			.field("createsamplers", unsafe{if transmute::<_, *const c_void>(self.createsamplers) == (dummy_pfnglcreatesamplersproc as *const c_void) {&null::<PFNGLCREATESAMPLERSPROC>()} else {&self.createsamplers}})
			.field("createprogrampipelines", unsafe{if transmute::<_, *const c_void>(self.createprogrampipelines) == (dummy_pfnglcreateprogrampipelinesproc as *const c_void) {&null::<PFNGLCREATEPROGRAMPIPELINESPROC>()} else {&self.createprogrampipelines}})
			.field("createqueries", unsafe{if transmute::<_, *const c_void>(self.createqueries) == (dummy_pfnglcreatequeriesproc as *const c_void) {&null::<PFNGLCREATEQUERIESPROC>()} else {&self.createqueries}})
			.field("getquerybufferobjecti64v", unsafe{if transmute::<_, *const c_void>(self.getquerybufferobjecti64v) == (dummy_pfnglgetquerybufferobjecti64vproc as *const c_void) {&null::<PFNGLGETQUERYBUFFEROBJECTI64VPROC>()} else {&self.getquerybufferobjecti64v}})
			.field("getquerybufferobjectiv", unsafe{if transmute::<_, *const c_void>(self.getquerybufferobjectiv) == (dummy_pfnglgetquerybufferobjectivproc as *const c_void) {&null::<PFNGLGETQUERYBUFFEROBJECTIVPROC>()} else {&self.getquerybufferobjectiv}})
			.field("getquerybufferobjectui64v", unsafe{if transmute::<_, *const c_void>(self.getquerybufferobjectui64v) == (dummy_pfnglgetquerybufferobjectui64vproc as *const c_void) {&null::<PFNGLGETQUERYBUFFEROBJECTUI64VPROC>()} else {&self.getquerybufferobjectui64v}})
			.field("getquerybufferobjectuiv", unsafe{if transmute::<_, *const c_void>(self.getquerybufferobjectuiv) == (dummy_pfnglgetquerybufferobjectuivproc as *const c_void) {&null::<PFNGLGETQUERYBUFFEROBJECTUIVPROC>()} else {&self.getquerybufferobjectuiv}})
			.field("memorybarrierbyregion", unsafe{if transmute::<_, *const c_void>(self.memorybarrierbyregion) == (dummy_pfnglmemorybarrierbyregionproc as *const c_void) {&null::<PFNGLMEMORYBARRIERBYREGIONPROC>()} else {&self.memorybarrierbyregion}})
			.field("gettexturesubimage", unsafe{if transmute::<_, *const c_void>(self.gettexturesubimage) == (dummy_pfnglgettexturesubimageproc as *const c_void) {&null::<PFNGLGETTEXTURESUBIMAGEPROC>()} else {&self.gettexturesubimage}})
			.field("getcompressedtexturesubimage", unsafe{if transmute::<_, *const c_void>(self.getcompressedtexturesubimage) == (dummy_pfnglgetcompressedtexturesubimageproc as *const c_void) {&null::<PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC>()} else {&self.getcompressedtexturesubimage}})
			.field("getgraphicsresetstatus", unsafe{if transmute::<_, *const c_void>(self.getgraphicsresetstatus) == (dummy_pfnglgetgraphicsresetstatusproc as *const c_void) {&null::<PFNGLGETGRAPHICSRESETSTATUSPROC>()} else {&self.getgraphicsresetstatus}})
			.field("getncompressedteximage", unsafe{if transmute::<_, *const c_void>(self.getncompressedteximage) == (dummy_pfnglgetncompressedteximageproc as *const c_void) {&null::<PFNGLGETNCOMPRESSEDTEXIMAGEPROC>()} else {&self.getncompressedteximage}})
			.field("getnteximage", unsafe{if transmute::<_, *const c_void>(self.getnteximage) == (dummy_pfnglgetnteximageproc as *const c_void) {&null::<PFNGLGETNTEXIMAGEPROC>()} else {&self.getnteximage}})
			.field("getnuniformdv", unsafe{if transmute::<_, *const c_void>(self.getnuniformdv) == (dummy_pfnglgetnuniformdvproc as *const c_void) {&null::<PFNGLGETNUNIFORMDVPROC>()} else {&self.getnuniformdv}})
			.field("getnuniformfv", unsafe{if transmute::<_, *const c_void>(self.getnuniformfv) == (dummy_pfnglgetnuniformfvproc as *const c_void) {&null::<PFNGLGETNUNIFORMFVPROC>()} else {&self.getnuniformfv}})
			.field("getnuniformiv", unsafe{if transmute::<_, *const c_void>(self.getnuniformiv) == (dummy_pfnglgetnuniformivproc as *const c_void) {&null::<PFNGLGETNUNIFORMIVPROC>()} else {&self.getnuniformiv}})
			.field("getnuniformuiv", unsafe{if transmute::<_, *const c_void>(self.getnuniformuiv) == (dummy_pfnglgetnuniformuivproc as *const c_void) {&null::<PFNGLGETNUNIFORMUIVPROC>()} else {&self.getnuniformuiv}})
			.field("readnpixels", unsafe{if transmute::<_, *const c_void>(self.readnpixels) == (dummy_pfnglreadnpixelsproc as *const c_void) {&null::<PFNGLREADNPIXELSPROC>()} else {&self.readnpixels}})
			.field("getnmapdv", unsafe{if transmute::<_, *const c_void>(self.getnmapdv) == (dummy_pfnglgetnmapdvproc as *const c_void) {&null::<PFNGLGETNMAPDVPROC>()} else {&self.getnmapdv}})
			.field("getnmapfv", unsafe{if transmute::<_, *const c_void>(self.getnmapfv) == (dummy_pfnglgetnmapfvproc as *const c_void) {&null::<PFNGLGETNMAPFVPROC>()} else {&self.getnmapfv}})
			.field("getnmapiv", unsafe{if transmute::<_, *const c_void>(self.getnmapiv) == (dummy_pfnglgetnmapivproc as *const c_void) {&null::<PFNGLGETNMAPIVPROC>()} else {&self.getnmapiv}})
			.field("getnpixelmapfv", unsafe{if transmute::<_, *const c_void>(self.getnpixelmapfv) == (dummy_pfnglgetnpixelmapfvproc as *const c_void) {&null::<PFNGLGETNPIXELMAPFVPROC>()} else {&self.getnpixelmapfv}})
			.field("getnpixelmapuiv", unsafe{if transmute::<_, *const c_void>(self.getnpixelmapuiv) == (dummy_pfnglgetnpixelmapuivproc as *const c_void) {&null::<PFNGLGETNPIXELMAPUIVPROC>()} else {&self.getnpixelmapuiv}})
			.field("getnpixelmapusv", unsafe{if transmute::<_, *const c_void>(self.getnpixelmapusv) == (dummy_pfnglgetnpixelmapusvproc as *const c_void) {&null::<PFNGLGETNPIXELMAPUSVPROC>()} else {&self.getnpixelmapusv}})
			.field("getnpolygonstipple", unsafe{if transmute::<_, *const c_void>(self.getnpolygonstipple) == (dummy_pfnglgetnpolygonstippleproc as *const c_void) {&null::<PFNGLGETNPOLYGONSTIPPLEPROC>()} else {&self.getnpolygonstipple}})
			.field("getncolortable", unsafe{if transmute::<_, *const c_void>(self.getncolortable) == (dummy_pfnglgetncolortableproc as *const c_void) {&null::<PFNGLGETNCOLORTABLEPROC>()} else {&self.getncolortable}})
			.field("getnconvolutionfilter", unsafe{if transmute::<_, *const c_void>(self.getnconvolutionfilter) == (dummy_pfnglgetnconvolutionfilterproc as *const c_void) {&null::<PFNGLGETNCONVOLUTIONFILTERPROC>()} else {&self.getnconvolutionfilter}})
			.field("getnseparablefilter", unsafe{if transmute::<_, *const c_void>(self.getnseparablefilter) == (dummy_pfnglgetnseparablefilterproc as *const c_void) {&null::<PFNGLGETNSEPARABLEFILTERPROC>()} else {&self.getnseparablefilter}})
			.field("getnhistogram", unsafe{if transmute::<_, *const c_void>(self.getnhistogram) == (dummy_pfnglgetnhistogramproc as *const c_void) {&null::<PFNGLGETNHISTOGRAMPROC>()} else {&self.getnhistogram}})
			.field("getnminmax", unsafe{if transmute::<_, *const c_void>(self.getnminmax) == (dummy_pfnglgetnminmaxproc as *const c_void) {&null::<PFNGLGETNMINMAXPROC>()} else {&self.getnminmax}})
			.field("texturebarrier", unsafe{if transmute::<_, *const c_void>(self.texturebarrier) == (dummy_pfngltexturebarrierproc as *const c_void) {&null::<PFNGLTEXTUREBARRIERPROC>()} else {&self.texturebarrier}})
			.finish()
		} else {
			f.debug_struct("Version45")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

/// The prototype to the OpenGL function `SpecializeShader`
type PFNGLSPECIALIZESHADERPROC = extern "system" fn(GLuint, *const GLchar, GLuint, *const GLuint, *const GLuint);

/// The prototype to the OpenGL function `MultiDrawArraysIndirectCount`
type PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC = extern "system" fn(GLenum, *const c_void, GLintptr, GLsizei, GLsizei);

/// The prototype to the OpenGL function `MultiDrawElementsIndirectCount`
type PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC = extern "system" fn(GLenum, GLenum, *const c_void, GLintptr, GLsizei, GLsizei);

/// The prototype to the OpenGL function `PolygonOffsetClamp`
type PFNGLPOLYGONOFFSETCLAMPPROC = extern "system" fn(GLfloat, GLfloat, GLfloat);

/// The dummy function of `SpecializeShader()`
extern "system" fn dummy_pfnglspecializeshaderproc (_: GLuint, _: *const GLchar, _: GLuint, _: *const GLuint, _: *const GLuint) {
	panic!("OpenGL function pointer `glSpecializeShader()` is null.")
}

/// The dummy function of `MultiDrawArraysIndirectCount()`
extern "system" fn dummy_pfnglmultidrawarraysindirectcountproc (_: GLenum, _: *const c_void, _: GLintptr, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glMultiDrawArraysIndirectCount()` is null.")
}

/// The dummy function of `MultiDrawElementsIndirectCount()`
extern "system" fn dummy_pfnglmultidrawelementsindirectcountproc (_: GLenum, _: GLenum, _: *const c_void, _: GLintptr, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glMultiDrawElementsIndirectCount()` is null.")
}

/// The dummy function of `PolygonOffsetClamp()`
extern "system" fn dummy_pfnglpolygonoffsetclampproc (_: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glPolygonOffsetClamp()` is null.")
}
/// Constant value defined from OpenGL 4.6
pub const GL_SHADER_BINARY_FORMAT_SPIR_V: GLenum = 0x9551;

/// Constant value defined from OpenGL 4.6
pub const GL_SPIR_V_BINARY: GLenum = 0x9552;

/// Constant value defined from OpenGL 4.6
pub const GL_PARAMETER_BUFFER: GLenum = 0x80EE;

/// Constant value defined from OpenGL 4.6
pub const GL_PARAMETER_BUFFER_BINDING: GLenum = 0x80EF;

/// Constant value defined from OpenGL 4.6
pub const GL_CONTEXT_FLAG_NO_ERROR_BIT: GLbitfield = 0x00000008;

/// Constant value defined from OpenGL 4.6
pub const GL_VERTICES_SUBMITTED: GLenum = 0x82EE;

/// Constant value defined from OpenGL 4.6
pub const GL_PRIMITIVES_SUBMITTED: GLenum = 0x82EF;

/// Constant value defined from OpenGL 4.6
pub const GL_VERTEX_SHADER_INVOCATIONS: GLenum = 0x82F0;

/// Constant value defined from OpenGL 4.6
pub const GL_TESS_CONTROL_SHADER_PATCHES: GLenum = 0x82F1;

/// Constant value defined from OpenGL 4.6
pub const GL_TESS_EVALUATION_SHADER_INVOCATIONS: GLenum = 0x82F2;

/// Constant value defined from OpenGL 4.6
pub const GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED: GLenum = 0x82F3;

/// Constant value defined from OpenGL 4.6
pub const GL_FRAGMENT_SHADER_INVOCATIONS: GLenum = 0x82F4;

/// Constant value defined from OpenGL 4.6
pub const GL_COMPUTE_SHADER_INVOCATIONS: GLenum = 0x82F5;

/// Constant value defined from OpenGL 4.6
pub const GL_CLIPPING_INPUT_PRIMITIVES: GLenum = 0x82F6;

/// Constant value defined from OpenGL 4.6
pub const GL_CLIPPING_OUTPUT_PRIMITIVES: GLenum = 0x82F7;

/// Constant value defined from OpenGL 4.6
pub const GL_POLYGON_OFFSET_CLAMP: GLenum = 0x8E1B;

/// Constant value defined from OpenGL 4.6
pub const GL_SPIR_V_EXTENSIONS: GLenum = 0x9553;

/// Constant value defined from OpenGL 4.6
pub const GL_NUM_SPIR_V_EXTENSIONS: GLenum = 0x9554;

/// Constant value defined from OpenGL 4.6
pub const GL_TEXTURE_MAX_ANISOTROPY: GLenum = 0x84FE;

/// Constant value defined from OpenGL 4.6
pub const GL_MAX_TEXTURE_MAX_ANISOTROPY: GLenum = 0x84FF;

/// Constant value defined from OpenGL 4.6
pub const GL_TRANSFORM_FEEDBACK_OVERFLOW: GLenum = 0x82EC;

/// Constant value defined from OpenGL 4.6
pub const GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW: GLenum = 0x82ED;

/// Functions from OpenGL version 4.6
pub trait GL_4_6 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	fn glGetError(&self) -> GLenum;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSpecializeShader.xhtml>
	fn glSpecializeShader(&self, shader: GLuint, pEntryPoint: *const GLchar, numSpecializationConstants: GLuint, pConstantIndex: *const GLuint, pConstantValue: *const GLuint) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawArraysIndirectCount.xhtml>
	fn glMultiDrawArraysIndirectCount(&self, mode: GLenum, indirect: *const c_void, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawElementsIndirectCount.xhtml>
	fn glMultiDrawElementsIndirectCount(&self, mode: GLenum, type_: GLenum, indirect: *const c_void, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei) -> Result<()>;

	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPolygonOffsetClamp.xhtml>
	fn glPolygonOffsetClamp(&self, factor: GLfloat, units: GLfloat, clamp: GLfloat) -> Result<()>;
}
/// Functions from OpenGL version 4.6
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version46 {
	/// Is OpenGL version 4.6 available
	available: bool,

	/// The function pointer to `glGetError()`
	pub geterror: PFNGLGETERRORPROC,

	/// The function pointer to `glSpecializeShader()`
	pub specializeshader: PFNGLSPECIALIZESHADERPROC,

	/// The function pointer to `glMultiDrawArraysIndirectCount()`
	pub multidrawarraysindirectcount: PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC,

	/// The function pointer to `glMultiDrawElementsIndirectCount()`
	pub multidrawelementsindirectcount: PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC,

	/// The function pointer to `glPolygonOffsetClamp()`
	pub polygonoffsetclamp: PFNGLPOLYGONOFFSETCLAMPPROC,
}

impl GL_4_6 for Version46 {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSpecializeShader.xhtml>
	#[inline(always)]
	fn glSpecializeShader(&self, shader: GLuint, pEntryPoint: *const GLchar, numSpecializationConstants: GLuint, pConstantIndex: *const GLuint, pConstantValue: *const GLuint) -> Result<()> {
		let ret = process_catch("glSpecializeShader", catch_unwind(||(self.specializeshader)(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSpecializeShader", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawArraysIndirectCount.xhtml>
	#[inline(always)]
	fn glMultiDrawArraysIndirectCount(&self, mode: GLenum, indirect: *const c_void, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawArraysIndirectCount", catch_unwind(||(self.multidrawarraysindirectcount)(mode, indirect, drawcount, maxdrawcount, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawArraysIndirectCount", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawElementsIndirectCount.xhtml>
	#[inline(always)]
	fn glMultiDrawElementsIndirectCount(&self, mode: GLenum, type_: GLenum, indirect: *const c_void, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawElementsIndirectCount", catch_unwind(||(self.multidrawelementsindirectcount)(mode, type_, indirect, drawcount, maxdrawcount, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawElementsIndirectCount", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPolygonOffsetClamp.xhtml>
	#[inline(always)]
	fn glPolygonOffsetClamp(&self, factor: GLfloat, units: GLfloat, clamp: GLfloat) -> Result<()> {
		let ret = process_catch("glPolygonOffsetClamp", catch_unwind(||(self.polygonoffsetclamp)(factor, units, clamp)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPolygonOffsetClamp", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version46 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (4, 6, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			specializeshader: {let proc = get_proc_address("glSpecializeShader"); if proc == null() {dummy_pfnglspecializeshaderproc} else {unsafe{transmute(proc)}}},
			multidrawarraysindirectcount: {let proc = get_proc_address("glMultiDrawArraysIndirectCount"); if proc == null() {dummy_pfnglmultidrawarraysindirectcountproc} else {unsafe{transmute(proc)}}},
			multidrawelementsindirectcount: {let proc = get_proc_address("glMultiDrawElementsIndirectCount"); if proc == null() {dummy_pfnglmultidrawelementsindirectcountproc} else {unsafe{transmute(proc)}}},
			polygonoffsetclamp: {let proc = get_proc_address("glPolygonOffsetClamp"); if proc == null() {dummy_pfnglpolygonoffsetclampproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version46 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			specializeshader: dummy_pfnglspecializeshaderproc,
			multidrawarraysindirectcount: dummy_pfnglmultidrawarraysindirectcountproc,
			multidrawelementsindirectcount: dummy_pfnglmultidrawelementsindirectcountproc,
			polygonoffsetclamp: dummy_pfnglpolygonoffsetclampproc,
		}
	}
}
impl Debug for Version46 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version46")
			.field("available", &self.available)
			.field("specializeshader", unsafe{if transmute::<_, *const c_void>(self.specializeshader) == (dummy_pfnglspecializeshaderproc as *const c_void) {&null::<PFNGLSPECIALIZESHADERPROC>()} else {&self.specializeshader}})
			.field("multidrawarraysindirectcount", unsafe{if transmute::<_, *const c_void>(self.multidrawarraysindirectcount) == (dummy_pfnglmultidrawarraysindirectcountproc as *const c_void) {&null::<PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC>()} else {&self.multidrawarraysindirectcount}})
			.field("multidrawelementsindirectcount", unsafe{if transmute::<_, *const c_void>(self.multidrawelementsindirectcount) == (dummy_pfnglmultidrawelementsindirectcountproc as *const c_void) {&null::<PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC>()} else {&self.multidrawelementsindirectcount}})
			.field("polygonoffsetclamp", unsafe{if transmute::<_, *const c_void>(self.polygonoffsetclamp) == (dummy_pfnglpolygonoffsetclampproc as *const c_void) {&null::<PFNGLPOLYGONOFFSETCLAMPPROC>()} else {&self.polygonoffsetclamp}})
			.finish()
		} else {
			f.debug_struct("Version46")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

/// All of the OpenGL functions
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct GLCore {
	/// Functions from OpenGL version 1.0
	pub version_1_0: Version10,

	/// Functions from OpenGL version 1.1
	pub version_1_1: Version11,

	/// Functions from OpenGL version 1.2
	pub version_1_2: Version12,

	/// Functions from OpenGL version 1.3
	pub version_1_3: Version13,

	/// Functions from OpenGL version 1.4
	pub version_1_4: Version14,

	/// Functions from OpenGL version 1.5
	pub version_1_5: Version15,

	/// Functions from OpenGL version 2.0
	pub version_2_0: Version20,

	/// Functions from OpenGL version 2.1
	pub version_2_1: Version21,

	/// Functions from OpenGL version 3.0
	pub version_3_0: Version30,

	/// Functions from OpenGL version 3.1
	pub version_3_1: Version31,

	/// Functions from OpenGL version 3.2
	pub version_3_2: Version32,

	/// Functions from OpenGL version 3.3
	pub version_3_3: Version33,

	/// Functions from OpenGL version 4.0
	pub version_4_0: Version40,

	/// Functions from OpenGL version 4.1
	pub version_4_1: Version41,

	/// Functions from OpenGL version 4.2
	pub version_4_2: Version42,

	/// Functions from OpenGL version 4.3
	pub version_4_3: Version43,

	/// Functions from OpenGL version 4.4
	pub version_4_4: Version44,

	/// Functions from OpenGL version 4.5
	pub version_4_5: Version45,

	/// Functions from OpenGL version 4.6
	pub version_4_6: Version46,

}

impl GL_1_0 for GLCore {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCullFace.xhtml>
	#[inline(always)]
	fn glCullFace(&self, mode: GLenum) -> Result<()> {
		let ret = process_catch("glCullFace", catch_unwind(||(self.version_1_0.cullface)(mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCullFace", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFrontFace.xhtml>
	#[inline(always)]
	fn glFrontFace(&self, mode: GLenum) -> Result<()> {
		let ret = process_catch("glFrontFace", catch_unwind(||(self.version_1_0.frontface)(mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFrontFace", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glHint.xhtml>
	#[inline(always)]
	fn glHint(&self, target: GLenum, mode: GLenum) -> Result<()> {
		let ret = process_catch("glHint", catch_unwind(||(self.version_1_0.hint)(target, mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glHint", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLineWidth.xhtml>
	#[inline(always)]
	fn glLineWidth(&self, width: GLfloat) -> Result<()> {
		let ret = process_catch("glLineWidth", catch_unwind(||(self.version_1_0.linewidth)(width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLineWidth", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPointSize.xhtml>
	#[inline(always)]
	fn glPointSize(&self, size: GLfloat) -> Result<()> {
		let ret = process_catch("glPointSize", catch_unwind(||(self.version_1_0.pointsize)(size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointSize", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPolygonMode.xhtml>
	#[inline(always)]
	fn glPolygonMode(&self, face: GLenum, mode: GLenum) -> Result<()> {
		let ret = process_catch("glPolygonMode", catch_unwind(||(self.version_1_0.polygonmode)(face, mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPolygonMode", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glScissor.xhtml>
	#[inline(always)]
	fn glScissor(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glScissor", catch_unwind(||(self.version_1_0.scissor)(x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glScissor", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameterf.xhtml>
	#[inline(always)]
	fn glTexParameterf(&self, target: GLenum, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glTexParameterf", catch_unwind(||(self.version_1_0.texparameterf)(target, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameterf", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameterfv.xhtml>
	#[inline(always)]
	fn glTexParameterfv(&self, target: GLenum, pname: GLenum, params: *const GLfloat) -> Result<()> {
		let ret = process_catch("glTexParameterfv", catch_unwind(||(self.version_1_0.texparameterfv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameterfv", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameteri.xhtml>
	#[inline(always)]
	fn glTexParameteri(&self, target: GLenum, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glTexParameteri", catch_unwind(||(self.version_1_0.texparameteri)(target, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameteri", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameteriv.xhtml>
	#[inline(always)]
	fn glTexParameteriv(&self, target: GLenum, pname: GLenum, params: *const GLint) -> Result<()> {
		let ret = process_catch("glTexParameteriv", catch_unwind(||(self.version_1_0.texparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameteriv", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexImage1D.xhtml>
	#[inline(always)]
	fn glTexImage1D(&self, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexImage1D", catch_unwind(||(self.version_1_0.teximage1d)(target, level, internalformat, width, border, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage1D", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml>
	#[inline(always)]
	fn glTexImage2D(&self, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexImage2D", catch_unwind(||(self.version_1_0.teximage2d)(target, level, internalformat, width, height, border, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage2D", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawBuffer.xhtml>
	#[inline(always)]
	fn glDrawBuffer(&self, buf: GLenum) -> Result<()> {
		let ret = process_catch("glDrawBuffer", catch_unwind(||(self.version_1_0.drawbuffer)(buf)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawBuffer", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClear.xhtml>
	#[inline(always)]
	fn glClear(&self, mask: GLbitfield) -> Result<()> {
		let ret = process_catch("glClear", catch_unwind(||(self.version_1_0.clear)(mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClear", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearColor.xhtml>
	#[inline(always)]
	fn glClearColor(&self, red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) -> Result<()> {
		let ret = process_catch("glClearColor", catch_unwind(||(self.version_1_0.clearcolor)(red, green, blue, alpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearColor", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearStencil.xhtml>
	#[inline(always)]
	fn glClearStencil(&self, s: GLint) -> Result<()> {
		let ret = process_catch("glClearStencil", catch_unwind(||(self.version_1_0.clearstencil)(s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearStencil", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearDepth.xhtml>
	#[inline(always)]
	fn glClearDepth(&self, depth: GLdouble) -> Result<()> {
		let ret = process_catch("glClearDepth", catch_unwind(||(self.version_1_0.cleardepth)(depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearDepth", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilMask.xhtml>
	#[inline(always)]
	fn glStencilMask(&self, mask: GLuint) -> Result<()> {
		let ret = process_catch("glStencilMask", catch_unwind(||(self.version_1_0.stencilmask)(mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilMask", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glColorMask.xhtml>
	#[inline(always)]
	fn glColorMask(&self, red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean) -> Result<()> {
		let ret = process_catch("glColorMask", catch_unwind(||(self.version_1_0.colormask)(red, green, blue, alpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorMask", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDepthMask.xhtml>
	#[inline(always)]
	fn glDepthMask(&self, flag: GLboolean) -> Result<()> {
		let ret = process_catch("glDepthMask", catch_unwind(||(self.version_1_0.depthmask)(flag)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthMask", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDisable.xhtml>
	#[inline(always)]
	fn glDisable(&self, cap: GLenum) -> Result<()> {
		let ret = process_catch("glDisable", catch_unwind(||(self.version_1_0.disable)(cap)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDisable", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEnable.xhtml>
	#[inline(always)]
	fn glEnable(&self, cap: GLenum) -> Result<()> {
		let ret = process_catch("glEnable", catch_unwind(||(self.version_1_0.enable)(cap)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEnable", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFinish.xhtml>
	#[inline(always)]
	fn glFinish(&self) -> Result<()> {
		let ret = process_catch("glFinish", catch_unwind(||(self.version_1_0.finish)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFinish", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFlush.xhtml>
	#[inline(always)]
	fn glFlush(&self) -> Result<()> {
		let ret = process_catch("glFlush", catch_unwind(||(self.version_1_0.flush)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFlush", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml>
	#[inline(always)]
	fn glBlendFunc(&self, sfactor: GLenum, dfactor: GLenum) -> Result<()> {
		let ret = process_catch("glBlendFunc", catch_unwind(||(self.version_1_0.blendfunc)(sfactor, dfactor)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendFunc", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLogicOp.xhtml>
	#[inline(always)]
	fn glLogicOp(&self, opcode: GLenum) -> Result<()> {
		let ret = process_catch("glLogicOp", catch_unwind(||(self.version_1_0.logicop)(opcode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLogicOp", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilFunc.xhtml>
	#[inline(always)]
	fn glStencilFunc(&self, func: GLenum, ref_: GLint, mask: GLuint) -> Result<()> {
		let ret = process_catch("glStencilFunc", catch_unwind(||(self.version_1_0.stencilfunc)(func, ref_, mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilFunc", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilOp.xhtml>
	#[inline(always)]
	fn glStencilOp(&self, fail: GLenum, zfail: GLenum, zpass: GLenum) -> Result<()> {
		let ret = process_catch("glStencilOp", catch_unwind(||(self.version_1_0.stencilop)(fail, zfail, zpass)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilOp", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDepthFunc.xhtml>
	#[inline(always)]
	fn glDepthFunc(&self, func: GLenum) -> Result<()> {
		let ret = process_catch("glDepthFunc", catch_unwind(||(self.version_1_0.depthfunc)(func)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthFunc", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPixelStoref.xhtml>
	#[inline(always)]
	fn glPixelStoref(&self, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glPixelStoref", catch_unwind(||(self.version_1_0.pixelstoref)(pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPixelStoref", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPixelStorei.xhtml>
	#[inline(always)]
	fn glPixelStorei(&self, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glPixelStorei", catch_unwind(||(self.version_1_0.pixelstorei)(pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPixelStorei", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glReadBuffer.xhtml>
	#[inline(always)]
	fn glReadBuffer(&self, src: GLenum) -> Result<()> {
		let ret = process_catch("glReadBuffer", catch_unwind(||(self.version_1_0.readbuffer)(src)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glReadBuffer", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glReadPixels.xhtml>
	#[inline(always)]
	fn glReadPixels(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glReadPixels", catch_unwind(||(self.version_1_0.readpixels)(x, y, width, height, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glReadPixels", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetBooleanv.xhtml>
	#[inline(always)]
	fn glGetBooleanv(&self, pname: GLenum, data: *mut GLboolean) -> Result<()> {
		let ret = process_catch("glGetBooleanv", catch_unwind(||(self.version_1_0.getbooleanv)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBooleanv", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetDoublev.xhtml>
	#[inline(always)]
	fn glGetDoublev(&self, pname: GLenum, data: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetDoublev", catch_unwind(||(self.version_1_0.getdoublev)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetDoublev", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_1_0.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetFloatv.xhtml>
	#[inline(always)]
	fn glGetFloatv(&self, pname: GLenum, data: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetFloatv", catch_unwind(||(self.version_1_0.getfloatv)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFloatv", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetIntegerv.xhtml>
	#[inline(always)]
	fn glGetIntegerv(&self, pname: GLenum, data: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetIntegerv", catch_unwind(||(self.version_1_0.getintegerv)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetIntegerv", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetString.xhtml>
	#[inline(always)]
	fn glGetString(&self, name: GLenum) -> Result<&'static str> {
		let ret = process_catch("glGetString", catch_unwind(||unsafe{CStr::from_ptr((self.version_1_0.getstring)(name) as *const i8)}.to_str().unwrap()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetString", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexImage.xhtml>
	#[inline(always)]
	fn glGetTexImage(&self, target: GLenum, level: GLint, format: GLenum, type_: GLenum, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetTexImage", catch_unwind(||(self.version_1_0.getteximage)(target, level, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexImage", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexParameterfv.xhtml>
	#[inline(always)]
	fn glGetTexParameterfv(&self, target: GLenum, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetTexParameterfv", catch_unwind(||(self.version_1_0.gettexparameterfv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexParameterfv", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexParameteriv.xhtml>
	#[inline(always)]
	fn glGetTexParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTexParameteriv", catch_unwind(||(self.version_1_0.gettexparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexParameteriv", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexLevelParameterfv.xhtml>
	#[inline(always)]
	fn glGetTexLevelParameterfv(&self, target: GLenum, level: GLint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetTexLevelParameterfv", catch_unwind(||(self.version_1_0.gettexlevelparameterfv)(target, level, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexLevelParameterfv", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexLevelParameteriv.xhtml>
	#[inline(always)]
	fn glGetTexLevelParameteriv(&self, target: GLenum, level: GLint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTexLevelParameteriv", catch_unwind(||(self.version_1_0.gettexlevelparameteriv)(target, level, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexLevelParameteriv", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsEnabled.xhtml>
	#[inline(always)]
	fn glIsEnabled(&self, cap: GLenum) -> Result<GLboolean> {
		let ret = process_catch("glIsEnabled", catch_unwind(||(self.version_1_0.isenabled)(cap)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsEnabled", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDepthRange.xhtml>
	#[inline(always)]
	fn glDepthRange(&self, n: GLdouble, f: GLdouble) -> Result<()> {
		let ret = process_catch("glDepthRange", catch_unwind(||(self.version_1_0.depthrange)(n, f)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthRange", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glViewport.xhtml>
	#[inline(always)]
	fn glViewport(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glViewport", catch_unwind(||(self.version_1_0.viewport)(x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glViewport", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn get_version(&self) -> (&'static str, u32, u32, u32) {
		self.version_1_0.get_version()
	}
	#[inline(always)]
	fn get_vendor(&self) -> &'static str {
		self.version_1_0.get_vendor()
	}
	#[inline(always)]
	fn get_renderer(&self) -> &'static str {
		self.version_1_0.get_renderer()
	}
	#[inline(always)]
	fn get_versionstr(&self) -> &'static str {
		self.version_1_0.get_versionstr()
	}
}

impl GL_1_1 for GLCore {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_1_1.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml>
	#[inline(always)]
	fn glDrawArrays(&self, mode: GLenum, first: GLint, count: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawArrays", catch_unwind(||(self.version_1_1.drawarrays)(mode, first, count)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawArrays", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElements.xhtml>
	#[inline(always)]
	fn glDrawElements(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void) -> Result<()> {
		let ret = process_catch("glDrawElements", catch_unwind(||(self.version_1_1.drawelements)(mode, count, type_, indices)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElements", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetPointerv.xhtml>
	#[inline(always)]
	fn glGetPointerv(&self, pname: GLenum, params: *mut *mut c_void) -> Result<()> {
		let ret = process_catch("glGetPointerv", catch_unwind(||(self.version_1_1.getpointerv)(pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetPointerv", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPolygonOffset.xhtml>
	#[inline(always)]
	fn glPolygonOffset(&self, factor: GLfloat, units: GLfloat) -> Result<()> {
		let ret = process_catch("glPolygonOffset", catch_unwind(||(self.version_1_1.polygonoffset)(factor, units)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPolygonOffset", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTexImage1D.xhtml>
	#[inline(always)]
	fn glCopyTexImage1D(&self, target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, border: GLint) -> Result<()> {
		let ret = process_catch("glCopyTexImage1D", catch_unwind(||(self.version_1_1.copyteximage1d)(target, level, internalformat, x, y, width, border)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexImage1D", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTexImage2D.xhtml>
	#[inline(always)]
	fn glCopyTexImage2D(&self, target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint) -> Result<()> {
		let ret = process_catch("glCopyTexImage2D", catch_unwind(||(self.version_1_1.copyteximage2d)(target, level, internalformat, x, y, width, height, border)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexImage2D", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTexSubImage1D.xhtml>
	#[inline(always)]
	fn glCopyTexSubImage1D(&self, target: GLenum, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTexSubImage1D", catch_unwind(||(self.version_1_1.copytexsubimage1d)(target, level, xoffset, x, y, width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexSubImage1D", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTexSubImage2D.xhtml>
	#[inline(always)]
	fn glCopyTexSubImage2D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTexSubImage2D", catch_unwind(||(self.version_1_1.copytexsubimage2d)(target, level, xoffset, yoffset, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexSubImage2D", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexSubImage1D.xhtml>
	#[inline(always)]
	fn glTexSubImage1D(&self, target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexSubImage1D", catch_unwind(||(self.version_1_1.texsubimage1d)(target, level, xoffset, width, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexSubImage1D", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexSubImage2D.xhtml>
	#[inline(always)]
	fn glTexSubImage2D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexSubImage2D", catch_unwind(||(self.version_1_1.texsubimage2d)(target, level, xoffset, yoffset, width, height, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexSubImage2D", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindTexture.xhtml>
	#[inline(always)]
	fn glBindTexture(&self, target: GLenum, texture: GLuint) -> Result<()> {
		let ret = process_catch("glBindTexture", catch_unwind(||(self.version_1_1.bindtexture)(target, texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindTexture", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteTextures.xhtml>
	#[inline(always)]
	fn glDeleteTextures(&self, n: GLsizei, textures: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteTextures", catch_unwind(||(self.version_1_1.deletetextures)(n, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteTextures", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenTextures.xhtml>
	#[inline(always)]
	fn glGenTextures(&self, n: GLsizei, textures: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenTextures", catch_unwind(||(self.version_1_1.gentextures)(n, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenTextures", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsTexture.xhtml>
	#[inline(always)]
	fn glIsTexture(&self, texture: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsTexture", catch_unwind(||(self.version_1_1.istexture)(texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsTexture", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_1_2 for GLCore {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_1_2.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawRangeElements.xhtml>
	#[inline(always)]
	fn glDrawRangeElements(&self, mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type_: GLenum, indices: *const c_void) -> Result<()> {
		let ret = process_catch("glDrawRangeElements", catch_unwind(||(self.version_1_2.drawrangeelements)(mode, start, end, count, type_, indices)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawRangeElements", ret, (self.version_1_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexImage3D.xhtml>
	#[inline(always)]
	fn glTexImage3D(&self, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexImage3D", catch_unwind(||(self.version_1_2.teximage3d)(target, level, internalformat, width, height, depth, border, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage3D", ret, (self.version_1_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexSubImage3D.xhtml>
	#[inline(always)]
	fn glTexSubImage3D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexSubImage3D", catch_unwind(||(self.version_1_2.texsubimage3d)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexSubImage3D", ret, (self.version_1_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTexSubImage3D.xhtml>
	#[inline(always)]
	fn glCopyTexSubImage3D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTexSubImage3D", catch_unwind(||(self.version_1_2.copytexsubimage3d)(target, level, xoffset, yoffset, zoffset, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexSubImage3D", ret, (self.version_1_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_1_3 for GLCore {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_1_3.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glActiveTexture.xhtml>
	#[inline(always)]
	fn glActiveTexture(&self, texture: GLenum) -> Result<()> {
		let ret = process_catch("glActiveTexture", catch_unwind(||(self.version_1_3.activetexture)(texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glActiveTexture", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSampleCoverage.xhtml>
	#[inline(always)]
	fn glSampleCoverage(&self, value: GLfloat, invert: GLboolean) -> Result<()> {
		let ret = process_catch("glSampleCoverage", catch_unwind(||(self.version_1_3.samplecoverage)(value, invert)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSampleCoverage", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTexImage3D.xhtml>
	#[inline(always)]
	fn glCompressedTexImage3D(&self, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexImage3D", catch_unwind(||(self.version_1_3.compressedteximage3d)(target, level, internalformat, width, height, depth, border, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexImage3D", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTexImage2D.xhtml>
	#[inline(always)]
	fn glCompressedTexImage2D(&self, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexImage2D", catch_unwind(||(self.version_1_3.compressedteximage2d)(target, level, internalformat, width, height, border, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexImage2D", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTexImage1D.xhtml>
	#[inline(always)]
	fn glCompressedTexImage1D(&self, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexImage1D", catch_unwind(||(self.version_1_3.compressedteximage1d)(target, level, internalformat, width, border, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexImage1D", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTexSubImage3D.xhtml>
	#[inline(always)]
	fn glCompressedTexSubImage3D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexSubImage3D", catch_unwind(||(self.version_1_3.compressedtexsubimage3d)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexSubImage3D", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTexSubImage2D.xhtml>
	#[inline(always)]
	fn glCompressedTexSubImage2D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexSubImage2D", catch_unwind(||(self.version_1_3.compressedtexsubimage2d)(target, level, xoffset, yoffset, width, height, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexSubImage2D", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTexSubImage1D.xhtml>
	#[inline(always)]
	fn glCompressedTexSubImage1D(&self, target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexSubImage1D", catch_unwind(||(self.version_1_3.compressedtexsubimage1d)(target, level, xoffset, width, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexSubImage1D", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetCompressedTexImage.xhtml>
	#[inline(always)]
	fn glGetCompressedTexImage(&self, target: GLenum, level: GLint, img: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetCompressedTexImage", catch_unwind(||(self.version_1_3.getcompressedteximage)(target, level, img)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetCompressedTexImage", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClientActiveTexture.xhtml>
	#[inline(always)]
	fn glClientActiveTexture(&self, texture: GLenum) -> Result<()> {
		let ret = process_catch("glClientActiveTexture", catch_unwind(||(self.version_1_3.clientactivetexture)(texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClientActiveTexture", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1d.xhtml>
	#[inline(always)]
	fn glMultiTexCoord1d(&self, target: GLenum, s: GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1d", catch_unwind(||(self.version_1_3.multitexcoord1d)(target, s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1d", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1dv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord1dv(&self, target: GLenum, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1dv", catch_unwind(||(self.version_1_3.multitexcoord1dv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1dv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1f.xhtml>
	#[inline(always)]
	fn glMultiTexCoord1f(&self, target: GLenum, s: GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1f", catch_unwind(||(self.version_1_3.multitexcoord1f)(target, s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1f", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1fv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord1fv(&self, target: GLenum, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1fv", catch_unwind(||(self.version_1_3.multitexcoord1fv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1fv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1i.xhtml>
	#[inline(always)]
	fn glMultiTexCoord1i(&self, target: GLenum, s: GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1i", catch_unwind(||(self.version_1_3.multitexcoord1i)(target, s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1i", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1iv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord1iv(&self, target: GLenum, v: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1iv", catch_unwind(||(self.version_1_3.multitexcoord1iv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1iv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1s.xhtml>
	#[inline(always)]
	fn glMultiTexCoord1s(&self, target: GLenum, s: GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1s", catch_unwind(||(self.version_1_3.multitexcoord1s)(target, s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1s", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord1sv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord1sv(&self, target: GLenum, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1sv", catch_unwind(||(self.version_1_3.multitexcoord1sv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1sv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2d.xhtml>
	#[inline(always)]
	fn glMultiTexCoord2d(&self, target: GLenum, s: GLdouble, t: GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2d", catch_unwind(||(self.version_1_3.multitexcoord2d)(target, s, t)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2d", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2dv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord2dv(&self, target: GLenum, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2dv", catch_unwind(||(self.version_1_3.multitexcoord2dv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2dv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2f.xhtml>
	#[inline(always)]
	fn glMultiTexCoord2f(&self, target: GLenum, s: GLfloat, t: GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2f", catch_unwind(||(self.version_1_3.multitexcoord2f)(target, s, t)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2f", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2fv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord2fv(&self, target: GLenum, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2fv", catch_unwind(||(self.version_1_3.multitexcoord2fv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2fv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2i.xhtml>
	#[inline(always)]
	fn glMultiTexCoord2i(&self, target: GLenum, s: GLint, t: GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2i", catch_unwind(||(self.version_1_3.multitexcoord2i)(target, s, t)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2i", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2iv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord2iv(&self, target: GLenum, v: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2iv", catch_unwind(||(self.version_1_3.multitexcoord2iv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2iv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2s.xhtml>
	#[inline(always)]
	fn glMultiTexCoord2s(&self, target: GLenum, s: GLshort, t: GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2s", catch_unwind(||(self.version_1_3.multitexcoord2s)(target, s, t)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2s", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord2sv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord2sv(&self, target: GLenum, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2sv", catch_unwind(||(self.version_1_3.multitexcoord2sv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2sv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3d.xhtml>
	#[inline(always)]
	fn glMultiTexCoord3d(&self, target: GLenum, s: GLdouble, t: GLdouble, r: GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3d", catch_unwind(||(self.version_1_3.multitexcoord3d)(target, s, t, r)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3d", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3dv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord3dv(&self, target: GLenum, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3dv", catch_unwind(||(self.version_1_3.multitexcoord3dv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3dv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3f.xhtml>
	#[inline(always)]
	fn glMultiTexCoord3f(&self, target: GLenum, s: GLfloat, t: GLfloat, r: GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3f", catch_unwind(||(self.version_1_3.multitexcoord3f)(target, s, t, r)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3f", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3fv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord3fv(&self, target: GLenum, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3fv", catch_unwind(||(self.version_1_3.multitexcoord3fv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3fv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3i.xhtml>
	#[inline(always)]
	fn glMultiTexCoord3i(&self, target: GLenum, s: GLint, t: GLint, r: GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3i", catch_unwind(||(self.version_1_3.multitexcoord3i)(target, s, t, r)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3i", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3iv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord3iv(&self, target: GLenum, v: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3iv", catch_unwind(||(self.version_1_3.multitexcoord3iv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3iv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3s.xhtml>
	#[inline(always)]
	fn glMultiTexCoord3s(&self, target: GLenum, s: GLshort, t: GLshort, r: GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3s", catch_unwind(||(self.version_1_3.multitexcoord3s)(target, s, t, r)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3s", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord3sv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord3sv(&self, target: GLenum, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3sv", catch_unwind(||(self.version_1_3.multitexcoord3sv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3sv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4d.xhtml>
	#[inline(always)]
	fn glMultiTexCoord4d(&self, target: GLenum, s: GLdouble, t: GLdouble, r: GLdouble, q: GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4d", catch_unwind(||(self.version_1_3.multitexcoord4d)(target, s, t, r, q)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4d", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4dv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord4dv(&self, target: GLenum, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4dv", catch_unwind(||(self.version_1_3.multitexcoord4dv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4dv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4f.xhtml>
	#[inline(always)]
	fn glMultiTexCoord4f(&self, target: GLenum, s: GLfloat, t: GLfloat, r: GLfloat, q: GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4f", catch_unwind(||(self.version_1_3.multitexcoord4f)(target, s, t, r, q)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4f", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4fv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord4fv(&self, target: GLenum, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4fv", catch_unwind(||(self.version_1_3.multitexcoord4fv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4fv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4i.xhtml>
	#[inline(always)]
	fn glMultiTexCoord4i(&self, target: GLenum, s: GLint, t: GLint, r: GLint, q: GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4i", catch_unwind(||(self.version_1_3.multitexcoord4i)(target, s, t, r, q)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4i", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4iv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord4iv(&self, target: GLenum, v: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4iv", catch_unwind(||(self.version_1_3.multitexcoord4iv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4iv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4s.xhtml>
	#[inline(always)]
	fn glMultiTexCoord4s(&self, target: GLenum, s: GLshort, t: GLshort, r: GLshort, q: GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4s", catch_unwind(||(self.version_1_3.multitexcoord4s)(target, s, t, r, q)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4s", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoord4sv.xhtml>
	#[inline(always)]
	fn glMultiTexCoord4sv(&self, target: GLenum, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4sv", catch_unwind(||(self.version_1_3.multitexcoord4sv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4sv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLoadTransposeMatrixf.xhtml>
	#[inline(always)]
	fn glLoadTransposeMatrixf(&self, m: *const GLfloat) -> Result<()> {
		let ret = process_catch("glLoadTransposeMatrixf", catch_unwind(||(self.version_1_3.loadtransposematrixf)(m)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLoadTransposeMatrixf", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLoadTransposeMatrixd.xhtml>
	#[inline(always)]
	fn glLoadTransposeMatrixd(&self, m: *const GLdouble) -> Result<()> {
		let ret = process_catch("glLoadTransposeMatrixd", catch_unwind(||(self.version_1_3.loadtransposematrixd)(m)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLoadTransposeMatrixd", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultTransposeMatrixf.xhtml>
	#[inline(always)]
	fn glMultTransposeMatrixf(&self, m: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultTransposeMatrixf", catch_unwind(||(self.version_1_3.multtransposematrixf)(m)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultTransposeMatrixf", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultTransposeMatrixd.xhtml>
	#[inline(always)]
	fn glMultTransposeMatrixd(&self, m: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultTransposeMatrixd", catch_unwind(||(self.version_1_3.multtransposematrixd)(m)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultTransposeMatrixd", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_1_4 for GLCore {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_1_4.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendFuncSeparate.xhtml>
	#[inline(always)]
	fn glBlendFuncSeparate(&self, sfactorRGB: GLenum, dfactorRGB: GLenum, sfactorAlpha: GLenum, dfactorAlpha: GLenum) -> Result<()> {
		let ret = process_catch("glBlendFuncSeparate", catch_unwind(||(self.version_1_4.blendfuncseparate)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendFuncSeparate", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawArrays.xhtml>
	#[inline(always)]
	fn glMultiDrawArrays(&self, mode: GLenum, first: *const GLint, count: *const GLsizei, drawcount: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawArrays", catch_unwind(||(self.version_1_4.multidrawarrays)(mode, first, count, drawcount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawArrays", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawElements.xhtml>
	#[inline(always)]
	fn glMultiDrawElements(&self, mode: GLenum, count: *const GLsizei, type_: GLenum, indices: *const *const c_void, drawcount: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawElements", catch_unwind(||(self.version_1_4.multidrawelements)(mode, count, type_, indices, drawcount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawElements", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPointParameterf.xhtml>
	#[inline(always)]
	fn glPointParameterf(&self, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glPointParameterf", catch_unwind(||(self.version_1_4.pointparameterf)(pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointParameterf", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPointParameterfv.xhtml>
	#[inline(always)]
	fn glPointParameterfv(&self, pname: GLenum, params: *const GLfloat) -> Result<()> {
		let ret = process_catch("glPointParameterfv", catch_unwind(||(self.version_1_4.pointparameterfv)(pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointParameterfv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPointParameteri.xhtml>
	#[inline(always)]
	fn glPointParameteri(&self, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glPointParameteri", catch_unwind(||(self.version_1_4.pointparameteri)(pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointParameteri", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPointParameteriv.xhtml>
	#[inline(always)]
	fn glPointParameteriv(&self, pname: GLenum, params: *const GLint) -> Result<()> {
		let ret = process_catch("glPointParameteriv", catch_unwind(||(self.version_1_4.pointparameteriv)(pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointParameteriv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFogCoordf.xhtml>
	#[inline(always)]
	fn glFogCoordf(&self, coord: GLfloat) -> Result<()> {
		let ret = process_catch("glFogCoordf", catch_unwind(||(self.version_1_4.fogcoordf)(coord)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoordf", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFogCoordfv.xhtml>
	#[inline(always)]
	fn glFogCoordfv(&self, coord: *const GLfloat) -> Result<()> {
		let ret = process_catch("glFogCoordfv", catch_unwind(||(self.version_1_4.fogcoordfv)(coord)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoordfv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFogCoordd.xhtml>
	#[inline(always)]
	fn glFogCoordd(&self, coord: GLdouble) -> Result<()> {
		let ret = process_catch("glFogCoordd", catch_unwind(||(self.version_1_4.fogcoordd)(coord)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoordd", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFogCoorddv.xhtml>
	#[inline(always)]
	fn glFogCoorddv(&self, coord: *const GLdouble) -> Result<()> {
		let ret = process_catch("glFogCoorddv", catch_unwind(||(self.version_1_4.fogcoorddv)(coord)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoorddv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFogCoordPointer.xhtml>
	#[inline(always)]
	fn glFogCoordPointer(&self, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glFogCoordPointer", catch_unwind(||(self.version_1_4.fogcoordpointer)(type_, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoordPointer", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3b.xhtml>
	#[inline(always)]
	fn glSecondaryColor3b(&self, red: GLbyte, green: GLbyte, blue: GLbyte) -> Result<()> {
		let ret = process_catch("glSecondaryColor3b", catch_unwind(||(self.version_1_4.secondarycolor3b)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3b", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3bv.xhtml>
	#[inline(always)]
	fn glSecondaryColor3bv(&self, v: *const GLbyte) -> Result<()> {
		let ret = process_catch("glSecondaryColor3bv", catch_unwind(||(self.version_1_4.secondarycolor3bv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3bv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3d.xhtml>
	#[inline(always)]
	fn glSecondaryColor3d(&self, red: GLdouble, green: GLdouble, blue: GLdouble) -> Result<()> {
		let ret = process_catch("glSecondaryColor3d", catch_unwind(||(self.version_1_4.secondarycolor3d)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3d", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3dv.xhtml>
	#[inline(always)]
	fn glSecondaryColor3dv(&self, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glSecondaryColor3dv", catch_unwind(||(self.version_1_4.secondarycolor3dv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3dv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3f.xhtml>
	#[inline(always)]
	fn glSecondaryColor3f(&self, red: GLfloat, green: GLfloat, blue: GLfloat) -> Result<()> {
		let ret = process_catch("glSecondaryColor3f", catch_unwind(||(self.version_1_4.secondarycolor3f)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3f", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3fv.xhtml>
	#[inline(always)]
	fn glSecondaryColor3fv(&self, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glSecondaryColor3fv", catch_unwind(||(self.version_1_4.secondarycolor3fv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3fv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3i.xhtml>
	#[inline(always)]
	fn glSecondaryColor3i(&self, red: GLint, green: GLint, blue: GLint) -> Result<()> {
		let ret = process_catch("glSecondaryColor3i", catch_unwind(||(self.version_1_4.secondarycolor3i)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3i", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3iv.xhtml>
	#[inline(always)]
	fn glSecondaryColor3iv(&self, v: *const GLint) -> Result<()> {
		let ret = process_catch("glSecondaryColor3iv", catch_unwind(||(self.version_1_4.secondarycolor3iv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3iv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3s.xhtml>
	#[inline(always)]
	fn glSecondaryColor3s(&self, red: GLshort, green: GLshort, blue: GLshort) -> Result<()> {
		let ret = process_catch("glSecondaryColor3s", catch_unwind(||(self.version_1_4.secondarycolor3s)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3s", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3sv.xhtml>
	#[inline(always)]
	fn glSecondaryColor3sv(&self, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glSecondaryColor3sv", catch_unwind(||(self.version_1_4.secondarycolor3sv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3sv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3ub.xhtml>
	#[inline(always)]
	fn glSecondaryColor3ub(&self, red: GLubyte, green: GLubyte, blue: GLubyte) -> Result<()> {
		let ret = process_catch("glSecondaryColor3ub", catch_unwind(||(self.version_1_4.secondarycolor3ub)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3ub", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3ubv.xhtml>
	#[inline(always)]
	fn glSecondaryColor3ubv(&self, v: *const GLubyte) -> Result<()> {
		let ret = process_catch("glSecondaryColor3ubv", catch_unwind(||(self.version_1_4.secondarycolor3ubv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3ubv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3ui.xhtml>
	#[inline(always)]
	fn glSecondaryColor3ui(&self, red: GLuint, green: GLuint, blue: GLuint) -> Result<()> {
		let ret = process_catch("glSecondaryColor3ui", catch_unwind(||(self.version_1_4.secondarycolor3ui)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3ui", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3uiv.xhtml>
	#[inline(always)]
	fn glSecondaryColor3uiv(&self, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glSecondaryColor3uiv", catch_unwind(||(self.version_1_4.secondarycolor3uiv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3uiv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3us.xhtml>
	#[inline(always)]
	fn glSecondaryColor3us(&self, red: GLushort, green: GLushort, blue: GLushort) -> Result<()> {
		let ret = process_catch("glSecondaryColor3us", catch_unwind(||(self.version_1_4.secondarycolor3us)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3us", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColor3usv.xhtml>
	#[inline(always)]
	fn glSecondaryColor3usv(&self, v: *const GLushort) -> Result<()> {
		let ret = process_catch("glSecondaryColor3usv", catch_unwind(||(self.version_1_4.secondarycolor3usv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3usv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColorPointer.xhtml>
	#[inline(always)]
	fn glSecondaryColorPointer(&self, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glSecondaryColorPointer", catch_unwind(||(self.version_1_4.secondarycolorpointer)(size, type_, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColorPointer", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2d.xhtml>
	#[inline(always)]
	fn glWindowPos2d(&self, x: GLdouble, y: GLdouble) -> Result<()> {
		let ret = process_catch("glWindowPos2d", catch_unwind(||(self.version_1_4.windowpos2d)(x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2d", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2dv.xhtml>
	#[inline(always)]
	fn glWindowPos2dv(&self, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glWindowPos2dv", catch_unwind(||(self.version_1_4.windowpos2dv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2dv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2f.xhtml>
	#[inline(always)]
	fn glWindowPos2f(&self, x: GLfloat, y: GLfloat) -> Result<()> {
		let ret = process_catch("glWindowPos2f", catch_unwind(||(self.version_1_4.windowpos2f)(x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2f", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2fv.xhtml>
	#[inline(always)]
	fn glWindowPos2fv(&self, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glWindowPos2fv", catch_unwind(||(self.version_1_4.windowpos2fv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2fv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2i.xhtml>
	#[inline(always)]
	fn glWindowPos2i(&self, x: GLint, y: GLint) -> Result<()> {
		let ret = process_catch("glWindowPos2i", catch_unwind(||(self.version_1_4.windowpos2i)(x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2i", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2iv.xhtml>
	#[inline(always)]
	fn glWindowPos2iv(&self, v: *const GLint) -> Result<()> {
		let ret = process_catch("glWindowPos2iv", catch_unwind(||(self.version_1_4.windowpos2iv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2iv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2s.xhtml>
	#[inline(always)]
	fn glWindowPos2s(&self, x: GLshort, y: GLshort) -> Result<()> {
		let ret = process_catch("glWindowPos2s", catch_unwind(||(self.version_1_4.windowpos2s)(x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2s", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos2sv.xhtml>
	#[inline(always)]
	fn glWindowPos2sv(&self, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glWindowPos2sv", catch_unwind(||(self.version_1_4.windowpos2sv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2sv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3d.xhtml>
	#[inline(always)]
	fn glWindowPos3d(&self, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()> {
		let ret = process_catch("glWindowPos3d", catch_unwind(||(self.version_1_4.windowpos3d)(x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3d", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3dv.xhtml>
	#[inline(always)]
	fn glWindowPos3dv(&self, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glWindowPos3dv", catch_unwind(||(self.version_1_4.windowpos3dv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3dv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3f.xhtml>
	#[inline(always)]
	fn glWindowPos3f(&self, x: GLfloat, y: GLfloat, z: GLfloat) -> Result<()> {
		let ret = process_catch("glWindowPos3f", catch_unwind(||(self.version_1_4.windowpos3f)(x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3f", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3fv.xhtml>
	#[inline(always)]
	fn glWindowPos3fv(&self, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glWindowPos3fv", catch_unwind(||(self.version_1_4.windowpos3fv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3fv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3i.xhtml>
	#[inline(always)]
	fn glWindowPos3i(&self, x: GLint, y: GLint, z: GLint) -> Result<()> {
		let ret = process_catch("glWindowPos3i", catch_unwind(||(self.version_1_4.windowpos3i)(x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3i", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3iv.xhtml>
	#[inline(always)]
	fn glWindowPos3iv(&self, v: *const GLint) -> Result<()> {
		let ret = process_catch("glWindowPos3iv", catch_unwind(||(self.version_1_4.windowpos3iv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3iv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3s.xhtml>
	#[inline(always)]
	fn glWindowPos3s(&self, x: GLshort, y: GLshort, z: GLshort) -> Result<()> {
		let ret = process_catch("glWindowPos3s", catch_unwind(||(self.version_1_4.windowpos3s)(x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3s", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWindowPos3sv.xhtml>
	#[inline(always)]
	fn glWindowPos3sv(&self, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glWindowPos3sv", catch_unwind(||(self.version_1_4.windowpos3sv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3sv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendColor.xhtml>
	#[inline(always)]
	fn glBlendColor(&self, red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) -> Result<()> {
		let ret = process_catch("glBlendColor", catch_unwind(||(self.version_1_4.blendcolor)(red, green, blue, alpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendColor", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendEquation.xhtml>
	#[inline(always)]
	fn glBlendEquation(&self, mode: GLenum) -> Result<()> {
		let ret = process_catch("glBlendEquation", catch_unwind(||(self.version_1_4.blendequation)(mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendEquation", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_1_5 for GLCore {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_1_5.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenQueries.xhtml>
	#[inline(always)]
	fn glGenQueries(&self, n: GLsizei, ids: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenQueries", catch_unwind(||(self.version_1_5.genqueries)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenQueries", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteQueries.xhtml>
	#[inline(always)]
	fn glDeleteQueries(&self, n: GLsizei, ids: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteQueries", catch_unwind(||(self.version_1_5.deletequeries)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteQueries", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsQuery.xhtml>
	#[inline(always)]
	fn glIsQuery(&self, id: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsQuery", catch_unwind(||(self.version_1_5.isquery)(id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsQuery", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBeginQuery.xhtml>
	#[inline(always)]
	fn glBeginQuery(&self, target: GLenum, id: GLuint) -> Result<()> {
		let ret = process_catch("glBeginQuery", catch_unwind(||(self.version_1_5.beginquery)(target, id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBeginQuery", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEndQuery.xhtml>
	#[inline(always)]
	fn glEndQuery(&self, target: GLenum) -> Result<()> {
		let ret = process_catch("glEndQuery", catch_unwind(||(self.version_1_5.endquery)(target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEndQuery", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryiv.xhtml>
	#[inline(always)]
	fn glGetQueryiv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetQueryiv", catch_unwind(||(self.version_1_5.getqueryiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryiv", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryObjectiv.xhtml>
	#[inline(always)]
	fn glGetQueryObjectiv(&self, id: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetQueryObjectiv", catch_unwind(||(self.version_1_5.getqueryobjectiv)(id, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryObjectiv", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryObjectuiv.xhtml>
	#[inline(always)]
	fn glGetQueryObjectuiv(&self, id: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetQueryObjectuiv", catch_unwind(||(self.version_1_5.getqueryobjectuiv)(id, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryObjectuiv", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml>
	#[inline(always)]
	fn glBindBuffer(&self, target: GLenum, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glBindBuffer", catch_unwind(||(self.version_1_5.bindbuffer)(target, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBuffer", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteBuffers.xhtml>
	#[inline(always)]
	fn glDeleteBuffers(&self, n: GLsizei, buffers: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteBuffers", catch_unwind(||(self.version_1_5.deletebuffers)(n, buffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteBuffers", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml>
	#[inline(always)]
	fn glGenBuffers(&self, n: GLsizei, buffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenBuffers", catch_unwind(||(self.version_1_5.genbuffers)(n, buffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenBuffers", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsBuffer.xhtml>
	#[inline(always)]
	fn glIsBuffer(&self, buffer: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsBuffer", catch_unwind(||(self.version_1_5.isbuffer)(buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsBuffer", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBufferData.xhtml>
	#[inline(always)]
	fn glBufferData(&self, target: GLenum, size: GLsizeiptr, data: *const c_void, usage: GLenum) -> Result<()> {
		let ret = process_catch("glBufferData", catch_unwind(||(self.version_1_5.bufferdata)(target, size, data, usage)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBufferData", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml>
	#[inline(always)]
	fn glBufferSubData(&self, target: GLenum, offset: GLintptr, size: GLsizeiptr, data: *const c_void) -> Result<()> {
		let ret = process_catch("glBufferSubData", catch_unwind(||(self.version_1_5.buffersubdata)(target, offset, size, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBufferSubData", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetBufferSubData.xhtml>
	#[inline(always)]
	fn glGetBufferSubData(&self, target: GLenum, offset: GLintptr, size: GLsizeiptr, data: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetBufferSubData", catch_unwind(||(self.version_1_5.getbuffersubdata)(target, offset, size, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBufferSubData", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMapBuffer.xhtml>
	#[inline(always)]
	fn glMapBuffer(&self, target: GLenum, access: GLenum) -> Result<*mut c_void> {
		let ret = process_catch("glMapBuffer", catch_unwind(||(self.version_1_5.mapbuffer)(target, access)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMapBuffer", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUnmapBuffer.xhtml>
	#[inline(always)]
	fn glUnmapBuffer(&self, target: GLenum) -> Result<GLboolean> {
		let ret = process_catch("glUnmapBuffer", catch_unwind(||(self.version_1_5.unmapbuffer)(target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUnmapBuffer", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetBufferParameteriv.xhtml>
	#[inline(always)]
	fn glGetBufferParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetBufferParameteriv", catch_unwind(||(self.version_1_5.getbufferparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBufferParameteriv", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetBufferPointerv.xhtml>
	#[inline(always)]
	fn glGetBufferPointerv(&self, target: GLenum, pname: GLenum, params: *mut *mut c_void) -> Result<()> {
		let ret = process_catch("glGetBufferPointerv", catch_unwind(||(self.version_1_5.getbufferpointerv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBufferPointerv", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_2_0 for GLCore {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_2_0.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendEquationSeparate.xhtml>
	#[inline(always)]
	fn glBlendEquationSeparate(&self, modeRGB: GLenum, modeAlpha: GLenum) -> Result<()> {
		let ret = process_catch("glBlendEquationSeparate", catch_unwind(||(self.version_2_0.blendequationseparate)(modeRGB, modeAlpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendEquationSeparate", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawBuffers.xhtml>
	#[inline(always)]
	fn glDrawBuffers(&self, n: GLsizei, bufs: *const GLenum) -> Result<()> {
		let ret = process_catch("glDrawBuffers", catch_unwind(||(self.version_2_0.drawbuffers)(n, bufs)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawBuffers", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilOpSeparate.xhtml>
	#[inline(always)]
	fn glStencilOpSeparate(&self, face: GLenum, sfail: GLenum, dpfail: GLenum, dppass: GLenum) -> Result<()> {
		let ret = process_catch("glStencilOpSeparate", catch_unwind(||(self.version_2_0.stencilopseparate)(face, sfail, dpfail, dppass)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilOpSeparate", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilFuncSeparate.xhtml>
	#[inline(always)]
	fn glStencilFuncSeparate(&self, face: GLenum, func: GLenum, ref_: GLint, mask: GLuint) -> Result<()> {
		let ret = process_catch("glStencilFuncSeparate", catch_unwind(||(self.version_2_0.stencilfuncseparate)(face, func, ref_, mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilFuncSeparate", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilMaskSeparate.xhtml>
	#[inline(always)]
	fn glStencilMaskSeparate(&self, face: GLenum, mask: GLuint) -> Result<()> {
		let ret = process_catch("glStencilMaskSeparate", catch_unwind(||(self.version_2_0.stencilmaskseparate)(face, mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilMaskSeparate", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glAttachShader.xhtml>
	#[inline(always)]
	fn glAttachShader(&self, program: GLuint, shader: GLuint) -> Result<()> {
		let ret = process_catch("glAttachShader", catch_unwind(||(self.version_2_0.attachshader)(program, shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glAttachShader", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindAttribLocation.xhtml>
	#[inline(always)]
	fn glBindAttribLocation(&self, program: GLuint, index: GLuint, name: *const GLchar) -> Result<()> {
		let ret = process_catch("glBindAttribLocation", catch_unwind(||(self.version_2_0.bindattriblocation)(program, index, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindAttribLocation", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompileShader.xhtml>
	#[inline(always)]
	fn glCompileShader(&self, shader: GLuint) -> Result<()> {
		let ret = process_catch("glCompileShader", catch_unwind(||(self.version_2_0.compileshader)(shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompileShader", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateProgram.xhtml>
	#[inline(always)]
	fn glCreateProgram(&self) -> Result<GLuint> {
		let ret = process_catch("glCreateProgram", catch_unwind(||(self.version_2_0.createprogram)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateProgram", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateShader.xhtml>
	#[inline(always)]
	fn glCreateShader(&self, type_: GLenum) -> Result<GLuint> {
		let ret = process_catch("glCreateShader", catch_unwind(||(self.version_2_0.createshader)(type_)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateShader", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteProgram.xhtml>
	#[inline(always)]
	fn glDeleteProgram(&self, program: GLuint) -> Result<()> {
		let ret = process_catch("glDeleteProgram", catch_unwind(||(self.version_2_0.deleteprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteProgram", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteShader.xhtml>
	#[inline(always)]
	fn glDeleteShader(&self, shader: GLuint) -> Result<()> {
		let ret = process_catch("glDeleteShader", catch_unwind(||(self.version_2_0.deleteshader)(shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteShader", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDetachShader.xhtml>
	#[inline(always)]
	fn glDetachShader(&self, program: GLuint, shader: GLuint) -> Result<()> {
		let ret = process_catch("glDetachShader", catch_unwind(||(self.version_2_0.detachshader)(program, shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDetachShader", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDisableVertexAttribArray.xhtml>
	#[inline(always)]
	fn glDisableVertexAttribArray(&self, index: GLuint) -> Result<()> {
		let ret = process_catch("glDisableVertexAttribArray", catch_unwind(||(self.version_2_0.disablevertexattribarray)(index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDisableVertexAttribArray", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEnableVertexAttribArray.xhtml>
	#[inline(always)]
	fn glEnableVertexAttribArray(&self, index: GLuint) -> Result<()> {
		let ret = process_catch("glEnableVertexAttribArray", catch_unwind(||(self.version_2_0.enablevertexattribarray)(index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEnableVertexAttribArray", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveAttrib.xhtml>
	#[inline(always)]
	fn glGetActiveAttrib(&self, program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLint, type_: *mut GLenum, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveAttrib", catch_unwind(||(self.version_2_0.getactiveattrib)(program, index, bufSize, length, size, type_, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveAttrib", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveUniform.xhtml>
	#[inline(always)]
	fn glGetActiveUniform(&self, program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLint, type_: *mut GLenum, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveUniform", catch_unwind(||(self.version_2_0.getactiveuniform)(program, index, bufSize, length, size, type_, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniform", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetAttachedShaders.xhtml>
	#[inline(always)]
	fn glGetAttachedShaders(&self, program: GLuint, maxCount: GLsizei, count: *mut GLsizei, shaders: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetAttachedShaders", catch_unwind(||(self.version_2_0.getattachedshaders)(program, maxCount, count, shaders)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetAttachedShaders", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetAttribLocation.xhtml>
	#[inline(always)]
	fn glGetAttribLocation(&self, program: GLuint, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetAttribLocation", catch_unwind(||(self.version_2_0.getattriblocation)(program, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetAttribLocation", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramiv.xhtml>
	#[inline(always)]
	fn glGetProgramiv(&self, program: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramiv", catch_unwind(||(self.version_2_0.getprogramiv)(program, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramiv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramInfoLog.xhtml>
	#[inline(always)]
	fn glGetProgramInfoLog(&self, program: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetProgramInfoLog", catch_unwind(||(self.version_2_0.getprograminfolog)(program, bufSize, length, infoLog)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramInfoLog", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShaderiv.xhtml>
	#[inline(always)]
	fn glGetShaderiv(&self, shader: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetShaderiv", catch_unwind(||(self.version_2_0.getshaderiv)(shader, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetShaderiv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShaderInfoLog.xhtml>
	#[inline(always)]
	fn glGetShaderInfoLog(&self, shader: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetShaderInfoLog", catch_unwind(||(self.version_2_0.getshaderinfolog)(shader, bufSize, length, infoLog)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetShaderInfoLog", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShaderSource.xhtml>
	#[inline(always)]
	fn glGetShaderSource(&self, shader: GLuint, bufSize: GLsizei, length: *mut GLsizei, source: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetShaderSource", catch_unwind(||(self.version_2_0.getshadersource)(shader, bufSize, length, source)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetShaderSource", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformLocation.xhtml>
	#[inline(always)]
	fn glGetUniformLocation(&self, program: GLuint, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetUniformLocation", catch_unwind(||(self.version_2_0.getuniformlocation)(program, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformLocation", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformfv.xhtml>
	#[inline(always)]
	fn glGetUniformfv(&self, program: GLuint, location: GLint, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetUniformfv", catch_unwind(||(self.version_2_0.getuniformfv)(program, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformfv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformiv.xhtml>
	#[inline(always)]
	fn glGetUniformiv(&self, program: GLuint, location: GLint, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetUniformiv", catch_unwind(||(self.version_2_0.getuniformiv)(program, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformiv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribdv.xhtml>
	#[inline(always)]
	fn glGetVertexAttribdv(&self, index: GLuint, pname: GLenum, params: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetVertexAttribdv", catch_unwind(||(self.version_2_0.getvertexattribdv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribdv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribfv.xhtml>
	#[inline(always)]
	fn glGetVertexAttribfv(&self, index: GLuint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetVertexAttribfv", catch_unwind(||(self.version_2_0.getvertexattribfv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribfv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribiv.xhtml>
	#[inline(always)]
	fn glGetVertexAttribiv(&self, index: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetVertexAttribiv", catch_unwind(||(self.version_2_0.getvertexattribiv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribiv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribPointerv.xhtml>
	#[inline(always)]
	fn glGetVertexAttribPointerv(&self, index: GLuint, pname: GLenum, pointer: *mut *mut c_void) -> Result<()> {
		let ret = process_catch("glGetVertexAttribPointerv", catch_unwind(||(self.version_2_0.getvertexattribpointerv)(index, pname, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribPointerv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsProgram.xhtml>
	#[inline(always)]
	fn glIsProgram(&self, program: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsProgram", catch_unwind(||(self.version_2_0.isprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsProgram", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsShader.xhtml>
	#[inline(always)]
	fn glIsShader(&self, shader: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsShader", catch_unwind(||(self.version_2_0.isshader)(shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsShader", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLinkProgram.xhtml>
	#[inline(always)]
	fn glLinkProgram(&self, program: GLuint) -> Result<()> {
		let ret = process_catch("glLinkProgram", catch_unwind(||(self.version_2_0.linkprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLinkProgram", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glShaderSource.xhtml>
	#[inline(always)]
	fn glShaderSource(&self, shader: GLuint, count: GLsizei, string_: *const *const GLchar, length: *const GLint) -> Result<()> {
		let ret = process_catch("glShaderSource", catch_unwind(||(self.version_2_0.shadersource)(shader, count, string_, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glShaderSource", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUseProgram.xhtml>
	#[inline(always)]
	fn glUseProgram(&self, program: GLuint) -> Result<()> {
		let ret = process_catch("glUseProgram", catch_unwind(||(self.version_2_0.useprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUseProgram", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1f.xhtml>
	#[inline(always)]
	fn glUniform1f(&self, location: GLint, v0: GLfloat) -> Result<()> {
		let ret = process_catch("glUniform1f", catch_unwind(||(self.version_2_0.uniform1f)(location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1f", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2f.xhtml>
	#[inline(always)]
	fn glUniform2f(&self, location: GLint, v0: GLfloat, v1: GLfloat) -> Result<()> {
		let ret = process_catch("glUniform2f", catch_unwind(||(self.version_2_0.uniform2f)(location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2f", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3f.xhtml>
	#[inline(always)]
	fn glUniform3f(&self, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat) -> Result<()> {
		let ret = process_catch("glUniform3f", catch_unwind(||(self.version_2_0.uniform3f)(location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3f", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4f.xhtml>
	#[inline(always)]
	fn glUniform4f(&self, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat) -> Result<()> {
		let ret = process_catch("glUniform4f", catch_unwind(||(self.version_2_0.uniform4f)(location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4f", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1i.xhtml>
	#[inline(always)]
	fn glUniform1i(&self, location: GLint, v0: GLint) -> Result<()> {
		let ret = process_catch("glUniform1i", catch_unwind(||(self.version_2_0.uniform1i)(location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1i", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2i.xhtml>
	#[inline(always)]
	fn glUniform2i(&self, location: GLint, v0: GLint, v1: GLint) -> Result<()> {
		let ret = process_catch("glUniform2i", catch_unwind(||(self.version_2_0.uniform2i)(location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2i", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3i.xhtml>
	#[inline(always)]
	fn glUniform3i(&self, location: GLint, v0: GLint, v1: GLint, v2: GLint) -> Result<()> {
		let ret = process_catch("glUniform3i", catch_unwind(||(self.version_2_0.uniform3i)(location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3i", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4i.xhtml>
	#[inline(always)]
	fn glUniform4i(&self, location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint) -> Result<()> {
		let ret = process_catch("glUniform4i", catch_unwind(||(self.version_2_0.uniform4i)(location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4i", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1fv.xhtml>
	#[inline(always)]
	fn glUniform1fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniform1fv", catch_unwind(||(self.version_2_0.uniform1fv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2fv.xhtml>
	#[inline(always)]
	fn glUniform2fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniform2fv", catch_unwind(||(self.version_2_0.uniform2fv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3fv.xhtml>
	#[inline(always)]
	fn glUniform3fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniform3fv", catch_unwind(||(self.version_2_0.uniform3fv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4fv.xhtml>
	#[inline(always)]
	fn glUniform4fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniform4fv", catch_unwind(||(self.version_2_0.uniform4fv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1iv.xhtml>
	#[inline(always)]
	fn glUniform1iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glUniform1iv", catch_unwind(||(self.version_2_0.uniform1iv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1iv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2iv.xhtml>
	#[inline(always)]
	fn glUniform2iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glUniform2iv", catch_unwind(||(self.version_2_0.uniform2iv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2iv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3iv.xhtml>
	#[inline(always)]
	fn glUniform3iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glUniform3iv", catch_unwind(||(self.version_2_0.uniform3iv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3iv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4iv.xhtml>
	#[inline(always)]
	fn glUniform4iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glUniform4iv", catch_unwind(||(self.version_2_0.uniform4iv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4iv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix2fv.xhtml>
	#[inline(always)]
	fn glUniformMatrix2fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix2fv", catch_unwind(||(self.version_2_0.uniformmatrix2fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix3fv.xhtml>
	#[inline(always)]
	fn glUniformMatrix3fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix3fv", catch_unwind(||(self.version_2_0.uniformmatrix3fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix4fv.xhtml>
	#[inline(always)]
	fn glUniformMatrix4fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix4fv", catch_unwind(||(self.version_2_0.uniformmatrix4fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glValidateProgram.xhtml>
	#[inline(always)]
	fn glValidateProgram(&self, program: GLuint) -> Result<()> {
		let ret = process_catch("glValidateProgram", catch_unwind(||(self.version_2_0.validateprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glValidateProgram", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib1d.xhtml>
	#[inline(always)]
	fn glVertexAttrib1d(&self, index: GLuint, x: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib1d", catch_unwind(||(self.version_2_0.vertexattrib1d)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1d", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib1dv.xhtml>
	#[inline(always)]
	fn glVertexAttrib1dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib1dv", catch_unwind(||(self.version_2_0.vertexattrib1dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1dv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib1f.xhtml>
	#[inline(always)]
	fn glVertexAttrib1f(&self, index: GLuint, x: GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib1f", catch_unwind(||(self.version_2_0.vertexattrib1f)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1f", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib1fv.xhtml>
	#[inline(always)]
	fn glVertexAttrib1fv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib1fv", catch_unwind(||(self.version_2_0.vertexattrib1fv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib1s.xhtml>
	#[inline(always)]
	fn glVertexAttrib1s(&self, index: GLuint, x: GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib1s", catch_unwind(||(self.version_2_0.vertexattrib1s)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1s", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib1sv.xhtml>
	#[inline(always)]
	fn glVertexAttrib1sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib1sv", catch_unwind(||(self.version_2_0.vertexattrib1sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1sv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib2d.xhtml>
	#[inline(always)]
	fn glVertexAttrib2d(&self, index: GLuint, x: GLdouble, y: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib2d", catch_unwind(||(self.version_2_0.vertexattrib2d)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2d", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib2dv.xhtml>
	#[inline(always)]
	fn glVertexAttrib2dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib2dv", catch_unwind(||(self.version_2_0.vertexattrib2dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2dv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib2f.xhtml>
	#[inline(always)]
	fn glVertexAttrib2f(&self, index: GLuint, x: GLfloat, y: GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib2f", catch_unwind(||(self.version_2_0.vertexattrib2f)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2f", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib2fv.xhtml>
	#[inline(always)]
	fn glVertexAttrib2fv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib2fv", catch_unwind(||(self.version_2_0.vertexattrib2fv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib2s.xhtml>
	#[inline(always)]
	fn glVertexAttrib2s(&self, index: GLuint, x: GLshort, y: GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib2s", catch_unwind(||(self.version_2_0.vertexattrib2s)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2s", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib2sv.xhtml>
	#[inline(always)]
	fn glVertexAttrib2sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib2sv", catch_unwind(||(self.version_2_0.vertexattrib2sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2sv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib3d.xhtml>
	#[inline(always)]
	fn glVertexAttrib3d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib3d", catch_unwind(||(self.version_2_0.vertexattrib3d)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3d", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib3dv.xhtml>
	#[inline(always)]
	fn glVertexAttrib3dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib3dv", catch_unwind(||(self.version_2_0.vertexattrib3dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3dv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib3f.xhtml>
	#[inline(always)]
	fn glVertexAttrib3f(&self, index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib3f", catch_unwind(||(self.version_2_0.vertexattrib3f)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3f", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib3fv.xhtml>
	#[inline(always)]
	fn glVertexAttrib3fv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib3fv", catch_unwind(||(self.version_2_0.vertexattrib3fv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib3s.xhtml>
	#[inline(always)]
	fn glVertexAttrib3s(&self, index: GLuint, x: GLshort, y: GLshort, z: GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib3s", catch_unwind(||(self.version_2_0.vertexattrib3s)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3s", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib3sv.xhtml>
	#[inline(always)]
	fn glVertexAttrib3sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib3sv", catch_unwind(||(self.version_2_0.vertexattrib3sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3sv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Nbv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4Nbv(&self, index: GLuint, v: *const GLbyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nbv", catch_unwind(||(self.version_2_0.vertexattrib4nbv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nbv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Niv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4Niv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Niv", catch_unwind(||(self.version_2_0.vertexattrib4niv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Niv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Nsv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4Nsv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nsv", catch_unwind(||(self.version_2_0.vertexattrib4nsv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nsv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Nub.xhtml>
	#[inline(always)]
	fn glVertexAttrib4Nub(&self, index: GLuint, x: GLubyte, y: GLubyte, z: GLubyte, w: GLubyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nub", catch_unwind(||(self.version_2_0.vertexattrib4nub)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nub", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Nubv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4Nubv(&self, index: GLuint, v: *const GLubyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nubv", catch_unwind(||(self.version_2_0.vertexattrib4nubv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nubv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Nuiv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4Nuiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nuiv", catch_unwind(||(self.version_2_0.vertexattrib4nuiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nuiv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4Nusv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4Nusv(&self, index: GLuint, v: *const GLushort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nusv", catch_unwind(||(self.version_2_0.vertexattrib4nusv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nusv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4bv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4bv(&self, index: GLuint, v: *const GLbyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4bv", catch_unwind(||(self.version_2_0.vertexattrib4bv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4bv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4d.xhtml>
	#[inline(always)]
	fn glVertexAttrib4d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib4d", catch_unwind(||(self.version_2_0.vertexattrib4d)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4d", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4dv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib4dv", catch_unwind(||(self.version_2_0.vertexattrib4dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4dv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4f.xhtml>
	#[inline(always)]
	fn glVertexAttrib4f(&self, index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib4f", catch_unwind(||(self.version_2_0.vertexattrib4f)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4f", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4fv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4fv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib4fv", catch_unwind(||(self.version_2_0.vertexattrib4fv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4iv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttrib4iv", catch_unwind(||(self.version_2_0.vertexattrib4iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4iv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4s.xhtml>
	#[inline(always)]
	fn glVertexAttrib4s(&self, index: GLuint, x: GLshort, y: GLshort, z: GLshort, w: GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4s", catch_unwind(||(self.version_2_0.vertexattrib4s)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4s", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4sv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4sv", catch_unwind(||(self.version_2_0.vertexattrib4sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4sv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4ubv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4ubv(&self, index: GLuint, v: *const GLubyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4ubv", catch_unwind(||(self.version_2_0.vertexattrib4ubv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4ubv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4uiv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttrib4uiv", catch_unwind(||(self.version_2_0.vertexattrib4uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4uiv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttrib4usv.xhtml>
	#[inline(always)]
	fn glVertexAttrib4usv(&self, index: GLuint, v: *const GLushort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4usv", catch_unwind(||(self.version_2_0.vertexattrib4usv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4usv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml>
	#[inline(always)]
	fn glVertexAttribPointer(&self, index: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glVertexAttribPointer", catch_unwind(||(self.version_2_0.vertexattribpointer)(index, size, type_, normalized, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribPointer", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn get_shading_language_version(&self) -> &'static str {
		self.version_2_0.shading_language_version
	}
}

impl GL_2_1 for GLCore {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_2_1.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix2x3fv.xhtml>
	#[inline(always)]
	fn glUniformMatrix2x3fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix2x3fv", catch_unwind(||(self.version_2_1.uniformmatrix2x3fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2x3fv", ret, (self.version_2_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix3x2fv.xhtml>
	#[inline(always)]
	fn glUniformMatrix3x2fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix3x2fv", catch_unwind(||(self.version_2_1.uniformmatrix3x2fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3x2fv", ret, (self.version_2_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix2x4fv.xhtml>
	#[inline(always)]
	fn glUniformMatrix2x4fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix2x4fv", catch_unwind(||(self.version_2_1.uniformmatrix2x4fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2x4fv", ret, (self.version_2_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix4x2fv.xhtml>
	#[inline(always)]
	fn glUniformMatrix4x2fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix4x2fv", catch_unwind(||(self.version_2_1.uniformmatrix4x2fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4x2fv", ret, (self.version_2_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix3x4fv.xhtml>
	#[inline(always)]
	fn glUniformMatrix3x4fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix3x4fv", catch_unwind(||(self.version_2_1.uniformmatrix3x4fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3x4fv", ret, (self.version_2_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix4x3fv.xhtml>
	#[inline(always)]
	fn glUniformMatrix4x3fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix4x3fv", catch_unwind(||(self.version_2_1.uniformmatrix4x3fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4x3fv", ret, (self.version_2_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_3_0 for GLCore {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_3_0.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glColorMaski.xhtml>
	#[inline(always)]
	fn glColorMaski(&self, index: GLuint, r: GLboolean, g: GLboolean, b: GLboolean, a: GLboolean) -> Result<()> {
		let ret = process_catch("glColorMaski", catch_unwind(||(self.version_3_0.colormaski)(index, r, g, b, a)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorMaski", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetBooleani_v.xhtml>
	#[inline(always)]
	fn glGetBooleani_v(&self, target: GLenum, index: GLuint, data: *mut GLboolean) -> Result<()> {
		let ret = process_catch("glGetBooleani_v", catch_unwind(||(self.version_3_0.getbooleani_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBooleani_v", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetIntegeri_v.xhtml>
	#[inline(always)]
	fn glGetIntegeri_v(&self, target: GLenum, index: GLuint, data: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetIntegeri_v", catch_unwind(||(self.version_3_0.getintegeri_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetIntegeri_v", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEnablei.xhtml>
	#[inline(always)]
	fn glEnablei(&self, target: GLenum, index: GLuint) -> Result<()> {
		let ret = process_catch("glEnablei", catch_unwind(||(self.version_3_0.enablei)(target, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEnablei", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDisablei.xhtml>
	#[inline(always)]
	fn glDisablei(&self, target: GLenum, index: GLuint) -> Result<()> {
		let ret = process_catch("glDisablei", catch_unwind(||(self.version_3_0.disablei)(target, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDisablei", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsEnabledi.xhtml>
	#[inline(always)]
	fn glIsEnabledi(&self, target: GLenum, index: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsEnabledi", catch_unwind(||(self.version_3_0.isenabledi)(target, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsEnabledi", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBeginTransformFeedback.xhtml>
	#[inline(always)]
	fn glBeginTransformFeedback(&self, primitiveMode: GLenum) -> Result<()> {
		let ret = process_catch("glBeginTransformFeedback", catch_unwind(||(self.version_3_0.begintransformfeedback)(primitiveMode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBeginTransformFeedback", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEndTransformFeedback.xhtml>
	#[inline(always)]
	fn glEndTransformFeedback(&self) -> Result<()> {
		let ret = process_catch("glEndTransformFeedback", catch_unwind(||(self.version_3_0.endtransformfeedback)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEndTransformFeedback", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindBufferRange.xhtml>
	#[inline(always)]
	fn glBindBufferRange(&self, target: GLenum, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glBindBufferRange", catch_unwind(||(self.version_3_0.bindbufferrange)(target, index, buffer, offset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBufferRange", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindBufferBase.xhtml>
	#[inline(always)]
	fn glBindBufferBase(&self, target: GLenum, index: GLuint, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glBindBufferBase", catch_unwind(||(self.version_3_0.bindbufferbase)(target, index, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBufferBase", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTransformFeedbackVaryings.xhtml>
	#[inline(always)]
	fn glTransformFeedbackVaryings(&self, program: GLuint, count: GLsizei, varyings: *const *const GLchar, bufferMode: GLenum) -> Result<()> {
		let ret = process_catch("glTransformFeedbackVaryings", catch_unwind(||(self.version_3_0.transformfeedbackvaryings)(program, count, varyings, bufferMode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTransformFeedbackVaryings", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTransformFeedbackVarying.xhtml>
	#[inline(always)]
	fn glGetTransformFeedbackVarying(&self, program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLsizei, type_: *mut GLenum, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetTransformFeedbackVarying", catch_unwind(||(self.version_3_0.gettransformfeedbackvarying)(program, index, bufSize, length, size, type_, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTransformFeedbackVarying", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClampColor.xhtml>
	#[inline(always)]
	fn glClampColor(&self, target: GLenum, clamp: GLenum) -> Result<()> {
		let ret = process_catch("glClampColor", catch_unwind(||(self.version_3_0.clampcolor)(target, clamp)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClampColor", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBeginConditionalRender.xhtml>
	#[inline(always)]
	fn glBeginConditionalRender(&self, id: GLuint, mode: GLenum) -> Result<()> {
		let ret = process_catch("glBeginConditionalRender", catch_unwind(||(self.version_3_0.beginconditionalrender)(id, mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBeginConditionalRender", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEndConditionalRender.xhtml>
	#[inline(always)]
	fn glEndConditionalRender(&self) -> Result<()> {
		let ret = process_catch("glEndConditionalRender", catch_unwind(||(self.version_3_0.endconditionalrender)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEndConditionalRender", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribIPointer.xhtml>
	#[inline(always)]
	fn glVertexAttribIPointer(&self, index: GLuint, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glVertexAttribIPointer", catch_unwind(||(self.version_3_0.vertexattribipointer)(index, size, type_, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribIPointer", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribIiv.xhtml>
	#[inline(always)]
	fn glGetVertexAttribIiv(&self, index: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetVertexAttribIiv", catch_unwind(||(self.version_3_0.getvertexattribiiv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribIiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribIuiv.xhtml>
	#[inline(always)]
	fn glGetVertexAttribIuiv(&self, index: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetVertexAttribIuiv", catch_unwind(||(self.version_3_0.getvertexattribiuiv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribIuiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI1i.xhtml>
	#[inline(always)]
	fn glVertexAttribI1i(&self, index: GLuint, x: GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI1i", catch_unwind(||(self.version_3_0.vertexattribi1i)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI1i", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI2i.xhtml>
	#[inline(always)]
	fn glVertexAttribI2i(&self, index: GLuint, x: GLint, y: GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI2i", catch_unwind(||(self.version_3_0.vertexattribi2i)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI2i", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI3i.xhtml>
	#[inline(always)]
	fn glVertexAttribI3i(&self, index: GLuint, x: GLint, y: GLint, z: GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI3i", catch_unwind(||(self.version_3_0.vertexattribi3i)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI3i", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4i.xhtml>
	#[inline(always)]
	fn glVertexAttribI4i(&self, index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI4i", catch_unwind(||(self.version_3_0.vertexattribi4i)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4i", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI1ui.xhtml>
	#[inline(always)]
	fn glVertexAttribI1ui(&self, index: GLuint, x: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI1ui", catch_unwind(||(self.version_3_0.vertexattribi1ui)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI1ui", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI2ui.xhtml>
	#[inline(always)]
	fn glVertexAttribI2ui(&self, index: GLuint, x: GLuint, y: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI2ui", catch_unwind(||(self.version_3_0.vertexattribi2ui)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI2ui", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI3ui.xhtml>
	#[inline(always)]
	fn glVertexAttribI3ui(&self, index: GLuint, x: GLuint, y: GLuint, z: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI3ui", catch_unwind(||(self.version_3_0.vertexattribi3ui)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI3ui", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4ui.xhtml>
	#[inline(always)]
	fn glVertexAttribI4ui(&self, index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI4ui", catch_unwind(||(self.version_3_0.vertexattribi4ui)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4ui", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI1iv.xhtml>
	#[inline(always)]
	fn glVertexAttribI1iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI1iv", catch_unwind(||(self.version_3_0.vertexattribi1iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI1iv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI2iv.xhtml>
	#[inline(always)]
	fn glVertexAttribI2iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI2iv", catch_unwind(||(self.version_3_0.vertexattribi2iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI2iv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI3iv.xhtml>
	#[inline(always)]
	fn glVertexAttribI3iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI3iv", catch_unwind(||(self.version_3_0.vertexattribi3iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI3iv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4iv.xhtml>
	#[inline(always)]
	fn glVertexAttribI4iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI4iv", catch_unwind(||(self.version_3_0.vertexattribi4iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4iv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI1uiv.xhtml>
	#[inline(always)]
	fn glVertexAttribI1uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI1uiv", catch_unwind(||(self.version_3_0.vertexattribi1uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI1uiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI2uiv.xhtml>
	#[inline(always)]
	fn glVertexAttribI2uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI2uiv", catch_unwind(||(self.version_3_0.vertexattribi2uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI2uiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI3uiv.xhtml>
	#[inline(always)]
	fn glVertexAttribI3uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI3uiv", catch_unwind(||(self.version_3_0.vertexattribi3uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI3uiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4uiv.xhtml>
	#[inline(always)]
	fn glVertexAttribI4uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI4uiv", catch_unwind(||(self.version_3_0.vertexattribi4uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4uiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4bv.xhtml>
	#[inline(always)]
	fn glVertexAttribI4bv(&self, index: GLuint, v: *const GLbyte) -> Result<()> {
		let ret = process_catch("glVertexAttribI4bv", catch_unwind(||(self.version_3_0.vertexattribi4bv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4bv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4sv.xhtml>
	#[inline(always)]
	fn glVertexAttribI4sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttribI4sv", catch_unwind(||(self.version_3_0.vertexattribi4sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4sv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4ubv.xhtml>
	#[inline(always)]
	fn glVertexAttribI4ubv(&self, index: GLuint, v: *const GLubyte) -> Result<()> {
		let ret = process_catch("glVertexAttribI4ubv", catch_unwind(||(self.version_3_0.vertexattribi4ubv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4ubv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribI4usv.xhtml>
	#[inline(always)]
	fn glVertexAttribI4usv(&self, index: GLuint, v: *const GLushort) -> Result<()> {
		let ret = process_catch("glVertexAttribI4usv", catch_unwind(||(self.version_3_0.vertexattribi4usv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4usv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformuiv.xhtml>
	#[inline(always)]
	fn glGetUniformuiv(&self, program: GLuint, location: GLint, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetUniformuiv", catch_unwind(||(self.version_3_0.getuniformuiv)(program, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformuiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindFragDataLocation.xhtml>
	#[inline(always)]
	fn glBindFragDataLocation(&self, program: GLuint, color: GLuint, name: *const GLchar) -> Result<()> {
		let ret = process_catch("glBindFragDataLocation", catch_unwind(||(self.version_3_0.bindfragdatalocation)(program, color, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindFragDataLocation", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetFragDataLocation.xhtml>
	#[inline(always)]
	fn glGetFragDataLocation(&self, program: GLuint, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetFragDataLocation", catch_unwind(||(self.version_3_0.getfragdatalocation)(program, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFragDataLocation", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1ui.xhtml>
	#[inline(always)]
	fn glUniform1ui(&self, location: GLint, v0: GLuint) -> Result<()> {
		let ret = process_catch("glUniform1ui", catch_unwind(||(self.version_3_0.uniform1ui)(location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1ui", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2ui.xhtml>
	#[inline(always)]
	fn glUniform2ui(&self, location: GLint, v0: GLuint, v1: GLuint) -> Result<()> {
		let ret = process_catch("glUniform2ui", catch_unwind(||(self.version_3_0.uniform2ui)(location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2ui", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3ui.xhtml>
	#[inline(always)]
	fn glUniform3ui(&self, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint) -> Result<()> {
		let ret = process_catch("glUniform3ui", catch_unwind(||(self.version_3_0.uniform3ui)(location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3ui", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4ui.xhtml>
	#[inline(always)]
	fn glUniform4ui(&self, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint) -> Result<()> {
		let ret = process_catch("glUniform4ui", catch_unwind(||(self.version_3_0.uniform4ui)(location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4ui", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1uiv.xhtml>
	#[inline(always)]
	fn glUniform1uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniform1uiv", catch_unwind(||(self.version_3_0.uniform1uiv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1uiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2uiv.xhtml>
	#[inline(always)]
	fn glUniform2uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniform2uiv", catch_unwind(||(self.version_3_0.uniform2uiv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2uiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3uiv.xhtml>
	#[inline(always)]
	fn glUniform3uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniform3uiv", catch_unwind(||(self.version_3_0.uniform3uiv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3uiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4uiv.xhtml>
	#[inline(always)]
	fn glUniform4uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniform4uiv", catch_unwind(||(self.version_3_0.uniform4uiv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4uiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameterIiv.xhtml>
	#[inline(always)]
	fn glTexParameterIiv(&self, target: GLenum, pname: GLenum, params: *const GLint) -> Result<()> {
		let ret = process_catch("glTexParameterIiv", catch_unwind(||(self.version_3_0.texparameteriiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameterIiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexParameterIuiv.xhtml>
	#[inline(always)]
	fn glTexParameterIuiv(&self, target: GLenum, pname: GLenum, params: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexParameterIuiv", catch_unwind(||(self.version_3_0.texparameteriuiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameterIuiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexParameterIiv.xhtml>
	#[inline(always)]
	fn glGetTexParameterIiv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTexParameterIiv", catch_unwind(||(self.version_3_0.gettexparameteriiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexParameterIiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTexParameterIuiv.xhtml>
	#[inline(always)]
	fn glGetTexParameterIuiv(&self, target: GLenum, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetTexParameterIuiv", catch_unwind(||(self.version_3_0.gettexparameteriuiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexParameterIuiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearBufferiv.xhtml>
	#[inline(always)]
	fn glClearBufferiv(&self, buffer: GLenum, drawbuffer: GLint, value: *const GLint) -> Result<()> {
		let ret = process_catch("glClearBufferiv", catch_unwind(||(self.version_3_0.clearbufferiv)(buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearBufferuiv.xhtml>
	#[inline(always)]
	fn glClearBufferuiv(&self, buffer: GLenum, drawbuffer: GLint, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glClearBufferuiv", catch_unwind(||(self.version_3_0.clearbufferuiv)(buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferuiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearBufferfv.xhtml>
	#[inline(always)]
	fn glClearBufferfv(&self, buffer: GLenum, drawbuffer: GLint, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glClearBufferfv", catch_unwind(||(self.version_3_0.clearbufferfv)(buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferfv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearBufferfi.xhtml>
	#[inline(always)]
	fn glClearBufferfi(&self, buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint) -> Result<()> {
		let ret = process_catch("glClearBufferfi", catch_unwind(||(self.version_3_0.clearbufferfi)(buffer, drawbuffer, depth, stencil)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferfi", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetStringi.xhtml>
	#[inline(always)]
	fn glGetStringi(&self, name: GLenum, index: GLuint) -> Result<&'static str> {
		let ret = process_catch("glGetStringi", catch_unwind(||unsafe{CStr::from_ptr((self.version_3_0.getstringi)(name, index) as *const i8)}.to_str().unwrap()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetStringi", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsRenderbuffer.xhtml>
	#[inline(always)]
	fn glIsRenderbuffer(&self, renderbuffer: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsRenderbuffer", catch_unwind(||(self.version_3_0.isrenderbuffer)(renderbuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsRenderbuffer", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindRenderbuffer.xhtml>
	#[inline(always)]
	fn glBindRenderbuffer(&self, target: GLenum, renderbuffer: GLuint) -> Result<()> {
		let ret = process_catch("glBindRenderbuffer", catch_unwind(||(self.version_3_0.bindrenderbuffer)(target, renderbuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindRenderbuffer", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteRenderbuffers.xhtml>
	#[inline(always)]
	fn glDeleteRenderbuffers(&self, n: GLsizei, renderbuffers: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteRenderbuffers", catch_unwind(||(self.version_3_0.deleterenderbuffers)(n, renderbuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteRenderbuffers", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenRenderbuffers.xhtml>
	#[inline(always)]
	fn glGenRenderbuffers(&self, n: GLsizei, renderbuffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenRenderbuffers", catch_unwind(||(self.version_3_0.genrenderbuffers)(n, renderbuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenRenderbuffers", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glRenderbufferStorage.xhtml>
	#[inline(always)]
	fn glRenderbufferStorage(&self, target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glRenderbufferStorage", catch_unwind(||(self.version_3_0.renderbufferstorage)(target, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glRenderbufferStorage", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetRenderbufferParameteriv.xhtml>
	#[inline(always)]
	fn glGetRenderbufferParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetRenderbufferParameteriv", catch_unwind(||(self.version_3_0.getrenderbufferparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetRenderbufferParameteriv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsFramebuffer.xhtml>
	#[inline(always)]
	fn glIsFramebuffer(&self, framebuffer: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsFramebuffer", catch_unwind(||(self.version_3_0.isframebuffer)(framebuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsFramebuffer", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindFramebuffer.xhtml>
	#[inline(always)]
	fn glBindFramebuffer(&self, target: GLenum, framebuffer: GLuint) -> Result<()> {
		let ret = process_catch("glBindFramebuffer", catch_unwind(||(self.version_3_0.bindframebuffer)(target, framebuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindFramebuffer", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteFramebuffers.xhtml>
	#[inline(always)]
	fn glDeleteFramebuffers(&self, n: GLsizei, framebuffers: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteFramebuffers", catch_unwind(||(self.version_3_0.deleteframebuffers)(n, framebuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteFramebuffers", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenFramebuffers.xhtml>
	#[inline(always)]
	fn glGenFramebuffers(&self, n: GLsizei, framebuffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenFramebuffers", catch_unwind(||(self.version_3_0.genframebuffers)(n, framebuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenFramebuffers", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCheckFramebufferStatus.xhtml>
	#[inline(always)]
	fn glCheckFramebufferStatus(&self, target: GLenum) -> Result<GLenum> {
		let ret = process_catch("glCheckFramebufferStatus", catch_unwind(||(self.version_3_0.checkframebufferstatus)(target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCheckFramebufferStatus", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferTexture1D.xhtml>
	#[inline(always)]
	fn glFramebufferTexture1D(&self, target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTexture1D", catch_unwind(||(self.version_3_0.framebuffertexture1d)(target, attachment, textarget, texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTexture1D", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferTexture2D.xhtml>
	#[inline(always)]
	fn glFramebufferTexture2D(&self, target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTexture2D", catch_unwind(||(self.version_3_0.framebuffertexture2d)(target, attachment, textarget, texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTexture2D", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferTexture3D.xhtml>
	#[inline(always)]
	fn glFramebufferTexture3D(&self, target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint, zoffset: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTexture3D", catch_unwind(||(self.version_3_0.framebuffertexture3d)(target, attachment, textarget, texture, level, zoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTexture3D", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferRenderbuffer.xhtml>
	#[inline(always)]
	fn glFramebufferRenderbuffer(&self, target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint) -> Result<()> {
		let ret = process_catch("glFramebufferRenderbuffer", catch_unwind(||(self.version_3_0.framebufferrenderbuffer)(target, attachment, renderbuffertarget, renderbuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferRenderbuffer", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetFramebufferAttachmentParameteriv.xhtml>
	#[inline(always)]
	fn glGetFramebufferAttachmentParameteriv(&self, target: GLenum, attachment: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetFramebufferAttachmentParameteriv", catch_unwind(||(self.version_3_0.getframebufferattachmentparameteriv)(target, attachment, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFramebufferAttachmentParameteriv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml>
	#[inline(always)]
	fn glGenerateMipmap(&self, target: GLenum) -> Result<()> {
		let ret = process_catch("glGenerateMipmap", catch_unwind(||(self.version_3_0.generatemipmap)(target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenerateMipmap", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml>
	#[inline(always)]
	fn glBlitFramebuffer(&self, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum) -> Result<()> {
		let ret = process_catch("glBlitFramebuffer", catch_unwind(||(self.version_3_0.blitframebuffer)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlitFramebuffer", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glRenderbufferStorageMultisample.xhtml>
	#[inline(always)]
	fn glRenderbufferStorageMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glRenderbufferStorageMultisample", catch_unwind(||(self.version_3_0.renderbufferstoragemultisample)(target, samples, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glRenderbufferStorageMultisample", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferTextureLayer.xhtml>
	#[inline(always)]
	fn glFramebufferTextureLayer(&self, target: GLenum, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTextureLayer", catch_unwind(||(self.version_3_0.framebuffertexturelayer)(target, attachment, texture, level, layer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTextureLayer", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMapBufferRange.xhtml>
	#[inline(always)]
	fn glMapBufferRange(&self, target: GLenum, offset: GLintptr, length: GLsizeiptr, access: GLbitfield) -> Result<*mut c_void> {
		let ret = process_catch("glMapBufferRange", catch_unwind(||(self.version_3_0.mapbufferrange)(target, offset, length, access)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMapBufferRange", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFlushMappedBufferRange.xhtml>
	#[inline(always)]
	fn glFlushMappedBufferRange(&self, target: GLenum, offset: GLintptr, length: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glFlushMappedBufferRange", catch_unwind(||(self.version_3_0.flushmappedbufferrange)(target, offset, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFlushMappedBufferRange", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml>
	#[inline(always)]
	fn glBindVertexArray(&self, array: GLuint) -> Result<()> {
		let ret = process_catch("glBindVertexArray", catch_unwind(||(self.version_3_0.bindvertexarray)(array)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindVertexArray", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteVertexArrays.xhtml>
	#[inline(always)]
	fn glDeleteVertexArrays(&self, n: GLsizei, arrays: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteVertexArrays", catch_unwind(||(self.version_3_0.deletevertexarrays)(n, arrays)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteVertexArrays", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml>
	#[inline(always)]
	fn glGenVertexArrays(&self, n: GLsizei, arrays: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenVertexArrays", catch_unwind(||(self.version_3_0.genvertexarrays)(n, arrays)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenVertexArrays", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsVertexArray.xhtml>
	#[inline(always)]
	fn glIsVertexArray(&self, array: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsVertexArray", catch_unwind(||(self.version_3_0.isvertexarray)(array)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsVertexArray", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_3_1 for GLCore {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_3_1.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawArraysInstanced.xhtml>
	#[inline(always)]
	fn glDrawArraysInstanced(&self, mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawArraysInstanced", catch_unwind(||(self.version_3_1.drawarraysinstanced)(mode, first, count, instancecount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawArraysInstanced", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsInstanced.xhtml>
	#[inline(always)]
	fn glDrawElementsInstanced(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawElementsInstanced", catch_unwind(||(self.version_3_1.drawelementsinstanced)(mode, count, type_, indices, instancecount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsInstanced", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexBuffer.xhtml>
	#[inline(always)]
	fn glTexBuffer(&self, target: GLenum, internalformat: GLenum, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glTexBuffer", catch_unwind(||(self.version_3_1.texbuffer)(target, internalformat, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexBuffer", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPrimitiveRestartIndex.xhtml>
	#[inline(always)]
	fn glPrimitiveRestartIndex(&self, index: GLuint) -> Result<()> {
		let ret = process_catch("glPrimitiveRestartIndex", catch_unwind(||(self.version_3_1.primitiverestartindex)(index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPrimitiveRestartIndex", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyBufferSubData.xhtml>
	#[inline(always)]
	fn glCopyBufferSubData(&self, readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glCopyBufferSubData", catch_unwind(||(self.version_3_1.copybuffersubdata)(readTarget, writeTarget, readOffset, writeOffset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyBufferSubData", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformIndices.xhtml>
	#[inline(always)]
	fn glGetUniformIndices(&self, program: GLuint, uniformCount: GLsizei, uniformNames: *const *const GLchar, uniformIndices: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetUniformIndices", catch_unwind(||(self.version_3_1.getuniformindices)(program, uniformCount, uniformNames, uniformIndices)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformIndices", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveUniformsiv.xhtml>
	#[inline(always)]
	fn glGetActiveUniformsiv(&self, program: GLuint, uniformCount: GLsizei, uniformIndices: *const GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetActiveUniformsiv", catch_unwind(||(self.version_3_1.getactiveuniformsiv)(program, uniformCount, uniformIndices, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniformsiv", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveUniformName.xhtml>
	#[inline(always)]
	fn glGetActiveUniformName(&self, program: GLuint, uniformIndex: GLuint, bufSize: GLsizei, length: *mut GLsizei, uniformName: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveUniformName", catch_unwind(||(self.version_3_1.getactiveuniformname)(program, uniformIndex, bufSize, length, uniformName)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniformName", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformBlockIndex.xhtml>
	#[inline(always)]
	fn glGetUniformBlockIndex(&self, program: GLuint, uniformBlockName: *const GLchar) -> Result<GLuint> {
		let ret = process_catch("glGetUniformBlockIndex", catch_unwind(||(self.version_3_1.getuniformblockindex)(program, uniformBlockName)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformBlockIndex", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveUniformBlockiv.xhtml>
	#[inline(always)]
	fn glGetActiveUniformBlockiv(&self, program: GLuint, uniformBlockIndex: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetActiveUniformBlockiv", catch_unwind(||(self.version_3_1.getactiveuniformblockiv)(program, uniformBlockIndex, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniformBlockiv", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveUniformBlockName.xhtml>
	#[inline(always)]
	fn glGetActiveUniformBlockName(&self, program: GLuint, uniformBlockIndex: GLuint, bufSize: GLsizei, length: *mut GLsizei, uniformBlockName: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveUniformBlockName", catch_unwind(||(self.version_3_1.getactiveuniformblockname)(program, uniformBlockIndex, bufSize, length, uniformBlockName)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniformBlockName", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformBlockBinding.xhtml>
	#[inline(always)]
	fn glUniformBlockBinding(&self, program: GLuint, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint) -> Result<()> {
		let ret = process_catch("glUniformBlockBinding", catch_unwind(||(self.version_3_1.uniformblockbinding)(program, uniformBlockIndex, uniformBlockBinding)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformBlockBinding", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_3_2 for GLCore {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_3_2.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsBaseVertex.xhtml>
	#[inline(always)]
	fn glDrawElementsBaseVertex(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, basevertex: GLint) -> Result<()> {
		let ret = process_catch("glDrawElementsBaseVertex", catch_unwind(||(self.version_3_2.drawelementsbasevertex)(mode, count, type_, indices, basevertex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsBaseVertex", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawRangeElementsBaseVertex.xhtml>
	#[inline(always)]
	fn glDrawRangeElementsBaseVertex(&self, mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type_: GLenum, indices: *const c_void, basevertex: GLint) -> Result<()> {
		let ret = process_catch("glDrawRangeElementsBaseVertex", catch_unwind(||(self.version_3_2.drawrangeelementsbasevertex)(mode, start, end, count, type_, indices, basevertex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawRangeElementsBaseVertex", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertex.xhtml>
	#[inline(always)]
	fn glDrawElementsInstancedBaseVertex(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei, basevertex: GLint) -> Result<()> {
		let ret = process_catch("glDrawElementsInstancedBaseVertex", catch_unwind(||(self.version_3_2.drawelementsinstancedbasevertex)(mode, count, type_, indices, instancecount, basevertex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsInstancedBaseVertex", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawElementsBaseVertex.xhtml>
	#[inline(always)]
	fn glMultiDrawElementsBaseVertex(&self, mode: GLenum, count: *const GLsizei, type_: GLenum, indices: *const *const c_void, drawcount: GLsizei, basevertex: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiDrawElementsBaseVertex", catch_unwind(||(self.version_3_2.multidrawelementsbasevertex)(mode, count, type_, indices, drawcount, basevertex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawElementsBaseVertex", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProvokingVertex.xhtml>
	#[inline(always)]
	fn glProvokingVertex(&self, mode: GLenum) -> Result<()> {
		let ret = process_catch("glProvokingVertex", catch_unwind(||(self.version_3_2.provokingvertex)(mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProvokingVertex", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFenceSync.xhtml>
	#[inline(always)]
	fn glFenceSync(&self, condition: GLenum, flags: GLbitfield) -> Result<GLsync> {
		let ret = process_catch("glFenceSync", catch_unwind(||(self.version_3_2.fencesync)(condition, flags)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFenceSync", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsSync.xhtml>
	#[inline(always)]
	fn glIsSync(&self, sync: GLsync) -> Result<GLboolean> {
		let ret = process_catch("glIsSync", catch_unwind(||(self.version_3_2.issync)(sync)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsSync", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteSync.xhtml>
	#[inline(always)]
	fn glDeleteSync(&self, sync: GLsync) -> Result<()> {
		let ret = process_catch("glDeleteSync", catch_unwind(||(self.version_3_2.deletesync)(sync)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteSync", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClientWaitSync.xhtml>
	#[inline(always)]
	fn glClientWaitSync(&self, sync: GLsync, flags: GLbitfield, timeout: GLuint64) -> Result<GLenum> {
		let ret = process_catch("glClientWaitSync", catch_unwind(||(self.version_3_2.clientwaitsync)(sync, flags, timeout)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClientWaitSync", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glWaitSync.xhtml>
	#[inline(always)]
	fn glWaitSync(&self, sync: GLsync, flags: GLbitfield, timeout: GLuint64) -> Result<()> {
		let ret = process_catch("glWaitSync", catch_unwind(||(self.version_3_2.waitsync)(sync, flags, timeout)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWaitSync", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetInteger64v.xhtml>
	#[inline(always)]
	fn glGetInteger64v(&self, pname: GLenum, data: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetInteger64v", catch_unwind(||(self.version_3_2.getinteger64v)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetInteger64v", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSynciv.xhtml>
	#[inline(always)]
	fn glGetSynciv(&self, sync: GLsync, pname: GLenum, count: GLsizei, length: *mut GLsizei, values: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetSynciv", catch_unwind(||(self.version_3_2.getsynciv)(sync, pname, count, length, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSynciv", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetInteger64i_v.xhtml>
	#[inline(always)]
	fn glGetInteger64i_v(&self, target: GLenum, index: GLuint, data: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetInteger64i_v", catch_unwind(||(self.version_3_2.getinteger64i_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetInteger64i_v", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetBufferParameteri64v.xhtml>
	#[inline(always)]
	fn glGetBufferParameteri64v(&self, target: GLenum, pname: GLenum, params: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetBufferParameteri64v", catch_unwind(||(self.version_3_2.getbufferparameteri64v)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBufferParameteri64v", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferTexture.xhtml>
	#[inline(always)]
	fn glFramebufferTexture(&self, target: GLenum, attachment: GLenum, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTexture", catch_unwind(||(self.version_3_2.framebuffertexture)(target, attachment, texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTexture", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexImage2DMultisample.xhtml>
	#[inline(always)]
	fn glTexImage2DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTexImage2DMultisample", catch_unwind(||(self.version_3_2.teximage2dmultisample)(target, samples, internalformat, width, height, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage2DMultisample", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexImage3DMultisample.xhtml>
	#[inline(always)]
	fn glTexImage3DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTexImage3DMultisample", catch_unwind(||(self.version_3_2.teximage3dmultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage3DMultisample", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetMultisamplefv.xhtml>
	#[inline(always)]
	fn glGetMultisamplefv(&self, pname: GLenum, index: GLuint, val: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetMultisamplefv", catch_unwind(||(self.version_3_2.getmultisamplefv)(pname, index, val)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetMultisamplefv", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSampleMaski.xhtml>
	#[inline(always)]
	fn glSampleMaski(&self, maskNumber: GLuint, mask: GLbitfield) -> Result<()> {
		let ret = process_catch("glSampleMaski", catch_unwind(||(self.version_3_2.samplemaski)(maskNumber, mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSampleMaski", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_3_3 for GLCore {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_3_3.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindFragDataLocationIndexed.xhtml>
	#[inline(always)]
	fn glBindFragDataLocationIndexed(&self, program: GLuint, colorNumber: GLuint, index: GLuint, name: *const GLchar) -> Result<()> {
		let ret = process_catch("glBindFragDataLocationIndexed", catch_unwind(||(self.version_3_3.bindfragdatalocationindexed)(program, colorNumber, index, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindFragDataLocationIndexed", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetFragDataIndex.xhtml>
	#[inline(always)]
	fn glGetFragDataIndex(&self, program: GLuint, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetFragDataIndex", catch_unwind(||(self.version_3_3.getfragdataindex)(program, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFragDataIndex", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenSamplers.xhtml>
	#[inline(always)]
	fn glGenSamplers(&self, count: GLsizei, samplers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenSamplers", catch_unwind(||(self.version_3_3.gensamplers)(count, samplers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenSamplers", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteSamplers.xhtml>
	#[inline(always)]
	fn glDeleteSamplers(&self, count: GLsizei, samplers: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteSamplers", catch_unwind(||(self.version_3_3.deletesamplers)(count, samplers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteSamplers", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsSampler.xhtml>
	#[inline(always)]
	fn glIsSampler(&self, sampler: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsSampler", catch_unwind(||(self.version_3_3.issampler)(sampler)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsSampler", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindSampler.xhtml>
	#[inline(always)]
	fn glBindSampler(&self, unit: GLuint, sampler: GLuint) -> Result<()> {
		let ret = process_catch("glBindSampler", catch_unwind(||(self.version_3_3.bindsampler)(unit, sampler)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindSampler", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSamplerParameteri.xhtml>
	#[inline(always)]
	fn glSamplerParameteri(&self, sampler: GLuint, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glSamplerParameteri", catch_unwind(||(self.version_3_3.samplerparameteri)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameteri", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSamplerParameteriv.xhtml>
	#[inline(always)]
	fn glSamplerParameteriv(&self, sampler: GLuint, pname: GLenum, param: *const GLint) -> Result<()> {
		let ret = process_catch("glSamplerParameteriv", catch_unwind(||(self.version_3_3.samplerparameteriv)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameteriv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSamplerParameterf.xhtml>
	#[inline(always)]
	fn glSamplerParameterf(&self, sampler: GLuint, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glSamplerParameterf", catch_unwind(||(self.version_3_3.samplerparameterf)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameterf", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSamplerParameterfv.xhtml>
	#[inline(always)]
	fn glSamplerParameterfv(&self, sampler: GLuint, pname: GLenum, param: *const GLfloat) -> Result<()> {
		let ret = process_catch("glSamplerParameterfv", catch_unwind(||(self.version_3_3.samplerparameterfv)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameterfv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSamplerParameterIiv.xhtml>
	#[inline(always)]
	fn glSamplerParameterIiv(&self, sampler: GLuint, pname: GLenum, param: *const GLint) -> Result<()> {
		let ret = process_catch("glSamplerParameterIiv", catch_unwind(||(self.version_3_3.samplerparameteriiv)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameterIiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSamplerParameterIuiv.xhtml>
	#[inline(always)]
	fn glSamplerParameterIuiv(&self, sampler: GLuint, pname: GLenum, param: *const GLuint) -> Result<()> {
		let ret = process_catch("glSamplerParameterIuiv", catch_unwind(||(self.version_3_3.samplerparameteriuiv)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameterIuiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSamplerParameteriv.xhtml>
	#[inline(always)]
	fn glGetSamplerParameteriv(&self, sampler: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetSamplerParameteriv", catch_unwind(||(self.version_3_3.getsamplerparameteriv)(sampler, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSamplerParameteriv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSamplerParameterIiv.xhtml>
	#[inline(always)]
	fn glGetSamplerParameterIiv(&self, sampler: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetSamplerParameterIiv", catch_unwind(||(self.version_3_3.getsamplerparameteriiv)(sampler, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSamplerParameterIiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSamplerParameterfv.xhtml>
	#[inline(always)]
	fn glGetSamplerParameterfv(&self, sampler: GLuint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetSamplerParameterfv", catch_unwind(||(self.version_3_3.getsamplerparameterfv)(sampler, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSamplerParameterfv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSamplerParameterIuiv.xhtml>
	#[inline(always)]
	fn glGetSamplerParameterIuiv(&self, sampler: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetSamplerParameterIuiv", catch_unwind(||(self.version_3_3.getsamplerparameteriuiv)(sampler, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSamplerParameterIuiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glQueryCounter.xhtml>
	#[inline(always)]
	fn glQueryCounter(&self, id: GLuint, target: GLenum) -> Result<()> {
		let ret = process_catch("glQueryCounter", catch_unwind(||(self.version_3_3.querycounter)(id, target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glQueryCounter", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryObjecti64v.xhtml>
	#[inline(always)]
	fn glGetQueryObjecti64v(&self, id: GLuint, pname: GLenum, params: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetQueryObjecti64v", catch_unwind(||(self.version_3_3.getqueryobjecti64v)(id, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryObjecti64v", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryObjectui64v.xhtml>
	#[inline(always)]
	fn glGetQueryObjectui64v(&self, id: GLuint, pname: GLenum, params: *mut GLuint64) -> Result<()> {
		let ret = process_catch("glGetQueryObjectui64v", catch_unwind(||(self.version_3_3.getqueryobjectui64v)(id, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryObjectui64v", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribDivisor.xhtml>
	#[inline(always)]
	fn glVertexAttribDivisor(&self, index: GLuint, divisor: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribDivisor", catch_unwind(||(self.version_3_3.vertexattribdivisor)(index, divisor)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribDivisor", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP1ui.xhtml>
	#[inline(always)]
	fn glVertexAttribP1ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP1ui", catch_unwind(||(self.version_3_3.vertexattribp1ui)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP1ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP1uiv.xhtml>
	#[inline(always)]
	fn glVertexAttribP1uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP1uiv", catch_unwind(||(self.version_3_3.vertexattribp1uiv)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP1uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP2ui.xhtml>
	#[inline(always)]
	fn glVertexAttribP2ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP2ui", catch_unwind(||(self.version_3_3.vertexattribp2ui)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP2ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP2uiv.xhtml>
	#[inline(always)]
	fn glVertexAttribP2uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP2uiv", catch_unwind(||(self.version_3_3.vertexattribp2uiv)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP2uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP3ui.xhtml>
	#[inline(always)]
	fn glVertexAttribP3ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP3ui", catch_unwind(||(self.version_3_3.vertexattribp3ui)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP3ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP3uiv.xhtml>
	#[inline(always)]
	fn glVertexAttribP3uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP3uiv", catch_unwind(||(self.version_3_3.vertexattribp3uiv)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP3uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP4ui.xhtml>
	#[inline(always)]
	fn glVertexAttribP4ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP4ui", catch_unwind(||(self.version_3_3.vertexattribp4ui)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP4ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribP4uiv.xhtml>
	#[inline(always)]
	fn glVertexAttribP4uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP4uiv", catch_unwind(||(self.version_3_3.vertexattribp4uiv)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP4uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexP2ui.xhtml>
	#[inline(always)]
	fn glVertexP2ui(&self, type_: GLenum, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexP2ui", catch_unwind(||(self.version_3_3.vertexp2ui)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP2ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexP2uiv.xhtml>
	#[inline(always)]
	fn glVertexP2uiv(&self, type_: GLenum, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexP2uiv", catch_unwind(||(self.version_3_3.vertexp2uiv)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP2uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexP3ui.xhtml>
	#[inline(always)]
	fn glVertexP3ui(&self, type_: GLenum, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexP3ui", catch_unwind(||(self.version_3_3.vertexp3ui)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP3ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexP3uiv.xhtml>
	#[inline(always)]
	fn glVertexP3uiv(&self, type_: GLenum, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexP3uiv", catch_unwind(||(self.version_3_3.vertexp3uiv)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP3uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexP4ui.xhtml>
	#[inline(always)]
	fn glVertexP4ui(&self, type_: GLenum, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexP4ui", catch_unwind(||(self.version_3_3.vertexp4ui)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP4ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexP4uiv.xhtml>
	#[inline(always)]
	fn glVertexP4uiv(&self, type_: GLenum, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexP4uiv", catch_unwind(||(self.version_3_3.vertexp4uiv)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP4uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP1ui.xhtml>
	#[inline(always)]
	fn glTexCoordP1ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP1ui", catch_unwind(||(self.version_3_3.texcoordp1ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP1ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP1uiv.xhtml>
	#[inline(always)]
	fn glTexCoordP1uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP1uiv", catch_unwind(||(self.version_3_3.texcoordp1uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP1uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP2ui.xhtml>
	#[inline(always)]
	fn glTexCoordP2ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP2ui", catch_unwind(||(self.version_3_3.texcoordp2ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP2ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP2uiv.xhtml>
	#[inline(always)]
	fn glTexCoordP2uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP2uiv", catch_unwind(||(self.version_3_3.texcoordp2uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP2uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP3ui.xhtml>
	#[inline(always)]
	fn glTexCoordP3ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP3ui", catch_unwind(||(self.version_3_3.texcoordp3ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP3ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP3uiv.xhtml>
	#[inline(always)]
	fn glTexCoordP3uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP3uiv", catch_unwind(||(self.version_3_3.texcoordp3uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP3uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP4ui.xhtml>
	#[inline(always)]
	fn glTexCoordP4ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP4ui", catch_unwind(||(self.version_3_3.texcoordp4ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP4ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexCoordP4uiv.xhtml>
	#[inline(always)]
	fn glTexCoordP4uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP4uiv", catch_unwind(||(self.version_3_3.texcoordp4uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP4uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP1ui.xhtml>
	#[inline(always)]
	fn glMultiTexCoordP1ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP1ui", catch_unwind(||(self.version_3_3.multitexcoordp1ui)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP1ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP1uiv.xhtml>
	#[inline(always)]
	fn glMultiTexCoordP1uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP1uiv", catch_unwind(||(self.version_3_3.multitexcoordp1uiv)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP1uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP2ui.xhtml>
	#[inline(always)]
	fn glMultiTexCoordP2ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP2ui", catch_unwind(||(self.version_3_3.multitexcoordp2ui)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP2ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP2uiv.xhtml>
	#[inline(always)]
	fn glMultiTexCoordP2uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP2uiv", catch_unwind(||(self.version_3_3.multitexcoordp2uiv)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP2uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP3ui.xhtml>
	#[inline(always)]
	fn glMultiTexCoordP3ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP3ui", catch_unwind(||(self.version_3_3.multitexcoordp3ui)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP3ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP3uiv.xhtml>
	#[inline(always)]
	fn glMultiTexCoordP3uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP3uiv", catch_unwind(||(self.version_3_3.multitexcoordp3uiv)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP3uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP4ui.xhtml>
	#[inline(always)]
	fn glMultiTexCoordP4ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP4ui", catch_unwind(||(self.version_3_3.multitexcoordp4ui)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP4ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiTexCoordP4uiv.xhtml>
	#[inline(always)]
	fn glMultiTexCoordP4uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP4uiv", catch_unwind(||(self.version_3_3.multitexcoordp4uiv)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP4uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNormalP3ui.xhtml>
	#[inline(always)]
	fn glNormalP3ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glNormalP3ui", catch_unwind(||(self.version_3_3.normalp3ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNormalP3ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNormalP3uiv.xhtml>
	#[inline(always)]
	fn glNormalP3uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glNormalP3uiv", catch_unwind(||(self.version_3_3.normalp3uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNormalP3uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glColorP3ui.xhtml>
	#[inline(always)]
	fn glColorP3ui(&self, type_: GLenum, color: GLuint) -> Result<()> {
		let ret = process_catch("glColorP3ui", catch_unwind(||(self.version_3_3.colorp3ui)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorP3ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glColorP3uiv.xhtml>
	#[inline(always)]
	fn glColorP3uiv(&self, type_: GLenum, color: *const GLuint) -> Result<()> {
		let ret = process_catch("glColorP3uiv", catch_unwind(||(self.version_3_3.colorp3uiv)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorP3uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glColorP4ui.xhtml>
	#[inline(always)]
	fn glColorP4ui(&self, type_: GLenum, color: GLuint) -> Result<()> {
		let ret = process_catch("glColorP4ui", catch_unwind(||(self.version_3_3.colorp4ui)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorP4ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glColorP4uiv.xhtml>
	#[inline(always)]
	fn glColorP4uiv(&self, type_: GLenum, color: *const GLuint) -> Result<()> {
		let ret = process_catch("glColorP4uiv", catch_unwind(||(self.version_3_3.colorp4uiv)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorP4uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColorP3ui.xhtml>
	#[inline(always)]
	fn glSecondaryColorP3ui(&self, type_: GLenum, color: GLuint) -> Result<()> {
		let ret = process_catch("glSecondaryColorP3ui", catch_unwind(||(self.version_3_3.secondarycolorp3ui)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColorP3ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSecondaryColorP3uiv.xhtml>
	#[inline(always)]
	fn glSecondaryColorP3uiv(&self, type_: GLenum, color: *const GLuint) -> Result<()> {
		let ret = process_catch("glSecondaryColorP3uiv", catch_unwind(||(self.version_3_3.secondarycolorp3uiv)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColorP3uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_4_0 for GLCore {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_4_0.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMinSampleShading.xhtml>
	#[inline(always)]
	fn glMinSampleShading(&self, value: GLfloat) -> Result<()> {
		let ret = process_catch("glMinSampleShading", catch_unwind(||(self.version_4_0.minsampleshading)(value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMinSampleShading", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendEquationi.xhtml>
	#[inline(always)]
	fn glBlendEquationi(&self, buf: GLuint, mode: GLenum) -> Result<()> {
		let ret = process_catch("glBlendEquationi", catch_unwind(||(self.version_4_0.blendequationi)(buf, mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendEquationi", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendEquationSeparatei.xhtml>
	#[inline(always)]
	fn glBlendEquationSeparatei(&self, buf: GLuint, modeRGB: GLenum, modeAlpha: GLenum) -> Result<()> {
		let ret = process_catch("glBlendEquationSeparatei", catch_unwind(||(self.version_4_0.blendequationseparatei)(buf, modeRGB, modeAlpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendEquationSeparatei", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendFunci.xhtml>
	#[inline(always)]
	fn glBlendFunci(&self, buf: GLuint, src: GLenum, dst: GLenum) -> Result<()> {
		let ret = process_catch("glBlendFunci", catch_unwind(||(self.version_4_0.blendfunci)(buf, src, dst)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendFunci", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendFuncSeparatei.xhtml>
	#[inline(always)]
	fn glBlendFuncSeparatei(&self, buf: GLuint, srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum) -> Result<()> {
		let ret = process_catch("glBlendFuncSeparatei", catch_unwind(||(self.version_4_0.blendfuncseparatei)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendFuncSeparatei", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawArraysIndirect.xhtml>
	#[inline(always)]
	fn glDrawArraysIndirect(&self, mode: GLenum, indirect: *const c_void) -> Result<()> {
		let ret = process_catch("glDrawArraysIndirect", catch_unwind(||(self.version_4_0.drawarraysindirect)(mode, indirect)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawArraysIndirect", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsIndirect.xhtml>
	#[inline(always)]
	fn glDrawElementsIndirect(&self, mode: GLenum, type_: GLenum, indirect: *const c_void) -> Result<()> {
		let ret = process_catch("glDrawElementsIndirect", catch_unwind(||(self.version_4_0.drawelementsindirect)(mode, type_, indirect)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsIndirect", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1d.xhtml>
	#[inline(always)]
	fn glUniform1d(&self, location: GLint, x: GLdouble) -> Result<()> {
		let ret = process_catch("glUniform1d", catch_unwind(||(self.version_4_0.uniform1d)(location, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1d", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2d.xhtml>
	#[inline(always)]
	fn glUniform2d(&self, location: GLint, x: GLdouble, y: GLdouble) -> Result<()> {
		let ret = process_catch("glUniform2d", catch_unwind(||(self.version_4_0.uniform2d)(location, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2d", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3d.xhtml>
	#[inline(always)]
	fn glUniform3d(&self, location: GLint, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()> {
		let ret = process_catch("glUniform3d", catch_unwind(||(self.version_4_0.uniform3d)(location, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3d", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4d.xhtml>
	#[inline(always)]
	fn glUniform4d(&self, location: GLint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble) -> Result<()> {
		let ret = process_catch("glUniform4d", catch_unwind(||(self.version_4_0.uniform4d)(location, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4d", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform1dv.xhtml>
	#[inline(always)]
	fn glUniform1dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniform1dv", catch_unwind(||(self.version_4_0.uniform1dv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform2dv.xhtml>
	#[inline(always)]
	fn glUniform2dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniform2dv", catch_unwind(||(self.version_4_0.uniform2dv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform3dv.xhtml>
	#[inline(always)]
	fn glUniform3dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniform3dv", catch_unwind(||(self.version_4_0.uniform3dv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniform4dv.xhtml>
	#[inline(always)]
	fn glUniform4dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniform4dv", catch_unwind(||(self.version_4_0.uniform4dv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix2dv.xhtml>
	#[inline(always)]
	fn glUniformMatrix2dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix2dv", catch_unwind(||(self.version_4_0.uniformmatrix2dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix3dv.xhtml>
	#[inline(always)]
	fn glUniformMatrix3dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix3dv", catch_unwind(||(self.version_4_0.uniformmatrix3dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix4dv.xhtml>
	#[inline(always)]
	fn glUniformMatrix4dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix4dv", catch_unwind(||(self.version_4_0.uniformmatrix4dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix2x3dv.xhtml>
	#[inline(always)]
	fn glUniformMatrix2x3dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix2x3dv", catch_unwind(||(self.version_4_0.uniformmatrix2x3dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2x3dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix2x4dv.xhtml>
	#[inline(always)]
	fn glUniformMatrix2x4dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix2x4dv", catch_unwind(||(self.version_4_0.uniformmatrix2x4dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2x4dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix3x2dv.xhtml>
	#[inline(always)]
	fn glUniformMatrix3x2dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix3x2dv", catch_unwind(||(self.version_4_0.uniformmatrix3x2dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3x2dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix3x4dv.xhtml>
	#[inline(always)]
	fn glUniformMatrix3x4dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix3x4dv", catch_unwind(||(self.version_4_0.uniformmatrix3x4dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3x4dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix4x2dv.xhtml>
	#[inline(always)]
	fn glUniformMatrix4x2dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix4x2dv", catch_unwind(||(self.version_4_0.uniformmatrix4x2dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4x2dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformMatrix4x3dv.xhtml>
	#[inline(always)]
	fn glUniformMatrix4x3dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix4x3dv", catch_unwind(||(self.version_4_0.uniformmatrix4x3dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4x3dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformdv.xhtml>
	#[inline(always)]
	fn glGetUniformdv(&self, program: GLuint, location: GLint, params: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetUniformdv", catch_unwind(||(self.version_4_0.getuniformdv)(program, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformdv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSubroutineUniformLocation.xhtml>
	#[inline(always)]
	fn glGetSubroutineUniformLocation(&self, program: GLuint, shadertype: GLenum, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetSubroutineUniformLocation", catch_unwind(||(self.version_4_0.getsubroutineuniformlocation)(program, shadertype, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSubroutineUniformLocation", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetSubroutineIndex.xhtml>
	#[inline(always)]
	fn glGetSubroutineIndex(&self, program: GLuint, shadertype: GLenum, name: *const GLchar) -> Result<GLuint> {
		let ret = process_catch("glGetSubroutineIndex", catch_unwind(||(self.version_4_0.getsubroutineindex)(program, shadertype, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSubroutineIndex", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniformiv.xhtml>
	#[inline(always)]
	fn glGetActiveSubroutineUniformiv(&self, program: GLuint, shadertype: GLenum, index: GLuint, pname: GLenum, values: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetActiveSubroutineUniformiv", catch_unwind(||(self.version_4_0.getactivesubroutineuniformiv)(program, shadertype, index, pname, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveSubroutineUniformiv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveSubroutineUniformName.xhtml>
	#[inline(always)]
	fn glGetActiveSubroutineUniformName(&self, program: GLuint, shadertype: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveSubroutineUniformName", catch_unwind(||(self.version_4_0.getactivesubroutineuniformname)(program, shadertype, index, bufSize, length, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveSubroutineUniformName", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveSubroutineName.xhtml>
	#[inline(always)]
	fn glGetActiveSubroutineName(&self, program: GLuint, shadertype: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveSubroutineName", catch_unwind(||(self.version_4_0.getactivesubroutinename)(program, shadertype, index, bufSize, length, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveSubroutineName", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUniformSubroutinesuiv.xhtml>
	#[inline(always)]
	fn glUniformSubroutinesuiv(&self, shadertype: GLenum, count: GLsizei, indices: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniformSubroutinesuiv", catch_unwind(||(self.version_4_0.uniformsubroutinesuiv)(shadertype, count, indices)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformSubroutinesuiv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetUniformSubroutineuiv.xhtml>
	#[inline(always)]
	fn glGetUniformSubroutineuiv(&self, shadertype: GLenum, location: GLint, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetUniformSubroutineuiv", catch_unwind(||(self.version_4_0.getuniformsubroutineuiv)(shadertype, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformSubroutineuiv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramStageiv.xhtml>
	#[inline(always)]
	fn glGetProgramStageiv(&self, program: GLuint, shadertype: GLenum, pname: GLenum, values: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramStageiv", catch_unwind(||(self.version_4_0.getprogramstageiv)(program, shadertype, pname, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramStageiv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPatchParameteri.xhtml>
	#[inline(always)]
	fn glPatchParameteri(&self, pname: GLenum, value: GLint) -> Result<()> {
		let ret = process_catch("glPatchParameteri", catch_unwind(||(self.version_4_0.patchparameteri)(pname, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPatchParameteri", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPatchParameterfv.xhtml>
	#[inline(always)]
	fn glPatchParameterfv(&self, pname: GLenum, values: *const GLfloat) -> Result<()> {
		let ret = process_catch("glPatchParameterfv", catch_unwind(||(self.version_4_0.patchparameterfv)(pname, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPatchParameterfv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindTransformFeedback.xhtml>
	#[inline(always)]
	fn glBindTransformFeedback(&self, target: GLenum, id: GLuint) -> Result<()> {
		let ret = process_catch("glBindTransformFeedback", catch_unwind(||(self.version_4_0.bindtransformfeedback)(target, id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindTransformFeedback", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteTransformFeedbacks.xhtml>
	#[inline(always)]
	fn glDeleteTransformFeedbacks(&self, n: GLsizei, ids: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteTransformFeedbacks", catch_unwind(||(self.version_4_0.deletetransformfeedbacks)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteTransformFeedbacks", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenTransformFeedbacks.xhtml>
	#[inline(always)]
	fn glGenTransformFeedbacks(&self, n: GLsizei, ids: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenTransformFeedbacks", catch_unwind(||(self.version_4_0.gentransformfeedbacks)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenTransformFeedbacks", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsTransformFeedback.xhtml>
	#[inline(always)]
	fn glIsTransformFeedback(&self, id: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsTransformFeedback", catch_unwind(||(self.version_4_0.istransformfeedback)(id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsTransformFeedback", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPauseTransformFeedback.xhtml>
	#[inline(always)]
	fn glPauseTransformFeedback(&self) -> Result<()> {
		let ret = process_catch("glPauseTransformFeedback", catch_unwind(||(self.version_4_0.pausetransformfeedback)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPauseTransformFeedback", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glResumeTransformFeedback.xhtml>
	#[inline(always)]
	fn glResumeTransformFeedback(&self) -> Result<()> {
		let ret = process_catch("glResumeTransformFeedback", catch_unwind(||(self.version_4_0.resumetransformfeedback)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glResumeTransformFeedback", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawTransformFeedback.xhtml>
	#[inline(always)]
	fn glDrawTransformFeedback(&self, mode: GLenum, id: GLuint) -> Result<()> {
		let ret = process_catch("glDrawTransformFeedback", catch_unwind(||(self.version_4_0.drawtransformfeedback)(mode, id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawTransformFeedback", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStream.xhtml>
	#[inline(always)]
	fn glDrawTransformFeedbackStream(&self, mode: GLenum, id: GLuint, stream: GLuint) -> Result<()> {
		let ret = process_catch("glDrawTransformFeedbackStream", catch_unwind(||(self.version_4_0.drawtransformfeedbackstream)(mode, id, stream)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawTransformFeedbackStream", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBeginQueryIndexed.xhtml>
	#[inline(always)]
	fn glBeginQueryIndexed(&self, target: GLenum, index: GLuint, id: GLuint) -> Result<()> {
		let ret = process_catch("glBeginQueryIndexed", catch_unwind(||(self.version_4_0.beginqueryindexed)(target, index, id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBeginQueryIndexed", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEndQueryIndexed.xhtml>
	#[inline(always)]
	fn glEndQueryIndexed(&self, target: GLenum, index: GLuint) -> Result<()> {
		let ret = process_catch("glEndQueryIndexed", catch_unwind(||(self.version_4_0.endqueryindexed)(target, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEndQueryIndexed", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryIndexediv.xhtml>
	#[inline(always)]
	fn glGetQueryIndexediv(&self, target: GLenum, index: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetQueryIndexediv", catch_unwind(||(self.version_4_0.getqueryindexediv)(target, index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryIndexediv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_4_1 for GLCore {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_4_1.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glReleaseShaderCompiler.xhtml>
	#[inline(always)]
	fn glReleaseShaderCompiler(&self) -> Result<()> {
		let ret = process_catch("glReleaseShaderCompiler", catch_unwind(||(self.version_4_1.releaseshadercompiler)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glReleaseShaderCompiler", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glShaderBinary.xhtml>
	#[inline(always)]
	fn glShaderBinary(&self, count: GLsizei, shaders: *const GLuint, binaryFormat: GLenum, binary: *const c_void, length: GLsizei) -> Result<()> {
		let ret = process_catch("glShaderBinary", catch_unwind(||(self.version_4_1.shaderbinary)(count, shaders, binaryFormat, binary, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glShaderBinary", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShaderPrecisionFormat.xhtml>
	#[inline(always)]
	fn glGetShaderPrecisionFormat(&self, shadertype: GLenum, precisiontype: GLenum, range: *mut GLint, precision: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetShaderPrecisionFormat", catch_unwind(||(self.version_4_1.getshaderprecisionformat)(shadertype, precisiontype, range, precision)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetShaderPrecisionFormat", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDepthRangef.xhtml>
	#[inline(always)]
	fn glDepthRangef(&self, n: GLfloat, f: GLfloat) -> Result<()> {
		let ret = process_catch("glDepthRangef", catch_unwind(||(self.version_4_1.depthrangef)(n, f)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthRangef", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearDepthf.xhtml>
	#[inline(always)]
	fn glClearDepthf(&self, d: GLfloat) -> Result<()> {
		let ret = process_catch("glClearDepthf", catch_unwind(||(self.version_4_1.cleardepthf)(d)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearDepthf", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramBinary.xhtml>
	#[inline(always)]
	fn glGetProgramBinary(&self, program: GLuint, bufSize: GLsizei, length: *mut GLsizei, binaryFormat: *mut GLenum, binary: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetProgramBinary", catch_unwind(||(self.version_4_1.getprogrambinary)(program, bufSize, length, binaryFormat, binary)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramBinary", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramBinary.xhtml>
	#[inline(always)]
	fn glProgramBinary(&self, program: GLuint, binaryFormat: GLenum, binary: *const c_void, length: GLsizei) -> Result<()> {
		let ret = process_catch("glProgramBinary", catch_unwind(||(self.version_4_1.programbinary)(program, binaryFormat, binary, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramBinary", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramParameteri.xhtml>
	#[inline(always)]
	fn glProgramParameteri(&self, program: GLuint, pname: GLenum, value: GLint) -> Result<()> {
		let ret = process_catch("glProgramParameteri", catch_unwind(||(self.version_4_1.programparameteri)(program, pname, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramParameteri", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUseProgramStages.xhtml>
	#[inline(always)]
	fn glUseProgramStages(&self, pipeline: GLuint, stages: GLbitfield, program: GLuint) -> Result<()> {
		let ret = process_catch("glUseProgramStages", catch_unwind(||(self.version_4_1.useprogramstages)(pipeline, stages, program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUseProgramStages", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glActiveShaderProgram.xhtml>
	#[inline(always)]
	fn glActiveShaderProgram(&self, pipeline: GLuint, program: GLuint) -> Result<()> {
		let ret = process_catch("glActiveShaderProgram", catch_unwind(||(self.version_4_1.activeshaderprogram)(pipeline, program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glActiveShaderProgram", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateShaderProgramv.xhtml>
	#[inline(always)]
	fn glCreateShaderProgramv(&self, type_: GLenum, count: GLsizei, strings: *const *const GLchar) -> Result<GLuint> {
		let ret = process_catch("glCreateShaderProgramv", catch_unwind(||(self.version_4_1.createshaderprogramv)(type_, count, strings)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateShaderProgramv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindProgramPipeline.xhtml>
	#[inline(always)]
	fn glBindProgramPipeline(&self, pipeline: GLuint) -> Result<()> {
		let ret = process_catch("glBindProgramPipeline", catch_unwind(||(self.version_4_1.bindprogrampipeline)(pipeline)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindProgramPipeline", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteProgramPipelines.xhtml>
	#[inline(always)]
	fn glDeleteProgramPipelines(&self, n: GLsizei, pipelines: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteProgramPipelines", catch_unwind(||(self.version_4_1.deleteprogrampipelines)(n, pipelines)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteProgramPipelines", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenProgramPipelines.xhtml>
	#[inline(always)]
	fn glGenProgramPipelines(&self, n: GLsizei, pipelines: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenProgramPipelines", catch_unwind(||(self.version_4_1.genprogrampipelines)(n, pipelines)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenProgramPipelines", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsProgramPipeline.xhtml>
	#[inline(always)]
	fn glIsProgramPipeline(&self, pipeline: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsProgramPipeline", catch_unwind(||(self.version_4_1.isprogrampipeline)(pipeline)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsProgramPipeline", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramPipelineiv.xhtml>
	#[inline(always)]
	fn glGetProgramPipelineiv(&self, pipeline: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramPipelineiv", catch_unwind(||(self.version_4_1.getprogrampipelineiv)(pipeline, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramPipelineiv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1i.xhtml>
	#[inline(always)]
	fn glProgramUniform1i(&self, program: GLuint, location: GLint, v0: GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform1i", catch_unwind(||(self.version_4_1.programuniform1i)(program, location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1i", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1iv.xhtml>
	#[inline(always)]
	fn glProgramUniform1iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform1iv", catch_unwind(||(self.version_4_1.programuniform1iv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1iv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1f.xhtml>
	#[inline(always)]
	fn glProgramUniform1f(&self, program: GLuint, location: GLint, v0: GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform1f", catch_unwind(||(self.version_4_1.programuniform1f)(program, location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1f", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1fv.xhtml>
	#[inline(always)]
	fn glProgramUniform1fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform1fv", catch_unwind(||(self.version_4_1.programuniform1fv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1d.xhtml>
	#[inline(always)]
	fn glProgramUniform1d(&self, program: GLuint, location: GLint, v0: GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform1d", catch_unwind(||(self.version_4_1.programuniform1d)(program, location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1d", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1dv.xhtml>
	#[inline(always)]
	fn glProgramUniform1dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform1dv", catch_unwind(||(self.version_4_1.programuniform1dv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1ui.xhtml>
	#[inline(always)]
	fn glProgramUniform1ui(&self, program: GLuint, location: GLint, v0: GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform1ui", catch_unwind(||(self.version_4_1.programuniform1ui)(program, location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1ui", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform1uiv.xhtml>
	#[inline(always)]
	fn glProgramUniform1uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform1uiv", catch_unwind(||(self.version_4_1.programuniform1uiv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1uiv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2i.xhtml>
	#[inline(always)]
	fn glProgramUniform2i(&self, program: GLuint, location: GLint, v0: GLint, v1: GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform2i", catch_unwind(||(self.version_4_1.programuniform2i)(program, location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2i", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2iv.xhtml>
	#[inline(always)]
	fn glProgramUniform2iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform2iv", catch_unwind(||(self.version_4_1.programuniform2iv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2iv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2f.xhtml>
	#[inline(always)]
	fn glProgramUniform2f(&self, program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform2f", catch_unwind(||(self.version_4_1.programuniform2f)(program, location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2f", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2fv.xhtml>
	#[inline(always)]
	fn glProgramUniform2fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform2fv", catch_unwind(||(self.version_4_1.programuniform2fv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2d.xhtml>
	#[inline(always)]
	fn glProgramUniform2d(&self, program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform2d", catch_unwind(||(self.version_4_1.programuniform2d)(program, location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2d", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2dv.xhtml>
	#[inline(always)]
	fn glProgramUniform2dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform2dv", catch_unwind(||(self.version_4_1.programuniform2dv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2ui.xhtml>
	#[inline(always)]
	fn glProgramUniform2ui(&self, program: GLuint, location: GLint, v0: GLuint, v1: GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform2ui", catch_unwind(||(self.version_4_1.programuniform2ui)(program, location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2ui", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform2uiv.xhtml>
	#[inline(always)]
	fn glProgramUniform2uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform2uiv", catch_unwind(||(self.version_4_1.programuniform2uiv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2uiv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3i.xhtml>
	#[inline(always)]
	fn glProgramUniform3i(&self, program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform3i", catch_unwind(||(self.version_4_1.programuniform3i)(program, location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3i", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3iv.xhtml>
	#[inline(always)]
	fn glProgramUniform3iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform3iv", catch_unwind(||(self.version_4_1.programuniform3iv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3iv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3f.xhtml>
	#[inline(always)]
	fn glProgramUniform3f(&self, program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform3f", catch_unwind(||(self.version_4_1.programuniform3f)(program, location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3f", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3fv.xhtml>
	#[inline(always)]
	fn glProgramUniform3fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform3fv", catch_unwind(||(self.version_4_1.programuniform3fv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3d.xhtml>
	#[inline(always)]
	fn glProgramUniform3d(&self, program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform3d", catch_unwind(||(self.version_4_1.programuniform3d)(program, location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3d", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3dv.xhtml>
	#[inline(always)]
	fn glProgramUniform3dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform3dv", catch_unwind(||(self.version_4_1.programuniform3dv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3ui.xhtml>
	#[inline(always)]
	fn glProgramUniform3ui(&self, program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform3ui", catch_unwind(||(self.version_4_1.programuniform3ui)(program, location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3ui", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform3uiv.xhtml>
	#[inline(always)]
	fn glProgramUniform3uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform3uiv", catch_unwind(||(self.version_4_1.programuniform3uiv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3uiv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4i.xhtml>
	#[inline(always)]
	fn glProgramUniform4i(&self, program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform4i", catch_unwind(||(self.version_4_1.programuniform4i)(program, location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4i", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4iv.xhtml>
	#[inline(always)]
	fn glProgramUniform4iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform4iv", catch_unwind(||(self.version_4_1.programuniform4iv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4iv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4f.xhtml>
	#[inline(always)]
	fn glProgramUniform4f(&self, program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform4f", catch_unwind(||(self.version_4_1.programuniform4f)(program, location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4f", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4fv.xhtml>
	#[inline(always)]
	fn glProgramUniform4fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform4fv", catch_unwind(||(self.version_4_1.programuniform4fv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4d.xhtml>
	#[inline(always)]
	fn glProgramUniform4d(&self, program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble, v3: GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform4d", catch_unwind(||(self.version_4_1.programuniform4d)(program, location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4d", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4dv.xhtml>
	#[inline(always)]
	fn glProgramUniform4dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform4dv", catch_unwind(||(self.version_4_1.programuniform4dv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4ui.xhtml>
	#[inline(always)]
	fn glProgramUniform4ui(&self, program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform4ui", catch_unwind(||(self.version_4_1.programuniform4ui)(program, location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4ui", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniform4uiv.xhtml>
	#[inline(always)]
	fn glProgramUniform4uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform4uiv", catch_unwind(||(self.version_4_1.programuniform4uiv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4uiv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix2fv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix2fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2fv", catch_unwind(||(self.version_4_1.programuniformmatrix2fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix3fv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix3fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3fv", catch_unwind(||(self.version_4_1.programuniformmatrix3fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix4fv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix4fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4fv", catch_unwind(||(self.version_4_1.programuniformmatrix4fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix2dv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix2dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2dv", catch_unwind(||(self.version_4_1.programuniformmatrix2dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix3dv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix3dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3dv", catch_unwind(||(self.version_4_1.programuniformmatrix3dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix4dv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix4dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4dv", catch_unwind(||(self.version_4_1.programuniformmatrix4dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix2x3fv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix2x3fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2x3fv", catch_unwind(||(self.version_4_1.programuniformmatrix2x3fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2x3fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix3x2fv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix3x2fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3x2fv", catch_unwind(||(self.version_4_1.programuniformmatrix3x2fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3x2fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix2x4fv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix2x4fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2x4fv", catch_unwind(||(self.version_4_1.programuniformmatrix2x4fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2x4fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix4x2fv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix4x2fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4x2fv", catch_unwind(||(self.version_4_1.programuniformmatrix4x2fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4x2fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix3x4fv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix3x4fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3x4fv", catch_unwind(||(self.version_4_1.programuniformmatrix3x4fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3x4fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix4x3fv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix4x3fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4x3fv", catch_unwind(||(self.version_4_1.programuniformmatrix4x3fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4x3fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix2x3dv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix2x3dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2x3dv", catch_unwind(||(self.version_4_1.programuniformmatrix2x3dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2x3dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix3x2dv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix3x2dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3x2dv", catch_unwind(||(self.version_4_1.programuniformmatrix3x2dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3x2dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix2x4dv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix2x4dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2x4dv", catch_unwind(||(self.version_4_1.programuniformmatrix2x4dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2x4dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix4x2dv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix4x2dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4x2dv", catch_unwind(||(self.version_4_1.programuniformmatrix4x2dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4x2dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix3x4dv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix3x4dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3x4dv", catch_unwind(||(self.version_4_1.programuniformmatrix3x4dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3x4dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glProgramUniformMatrix4x3dv.xhtml>
	#[inline(always)]
	fn glProgramUniformMatrix4x3dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4x3dv", catch_unwind(||(self.version_4_1.programuniformmatrix4x3dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4x3dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glValidateProgramPipeline.xhtml>
	#[inline(always)]
	fn glValidateProgramPipeline(&self, pipeline: GLuint) -> Result<()> {
		let ret = process_catch("glValidateProgramPipeline", catch_unwind(||(self.version_4_1.validateprogrampipeline)(pipeline)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glValidateProgramPipeline", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramPipelineInfoLog.xhtml>
	#[inline(always)]
	fn glGetProgramPipelineInfoLog(&self, pipeline: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetProgramPipelineInfoLog", catch_unwind(||(self.version_4_1.getprogrampipelineinfolog)(pipeline, bufSize, length, infoLog)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramPipelineInfoLog", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL1d.xhtml>
	#[inline(always)]
	fn glVertexAttribL1d(&self, index: GLuint, x: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL1d", catch_unwind(||(self.version_4_1.vertexattribl1d)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL1d", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL2d.xhtml>
	#[inline(always)]
	fn glVertexAttribL2d(&self, index: GLuint, x: GLdouble, y: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL2d", catch_unwind(||(self.version_4_1.vertexattribl2d)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL2d", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL3d.xhtml>
	#[inline(always)]
	fn glVertexAttribL3d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL3d", catch_unwind(||(self.version_4_1.vertexattribl3d)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL3d", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL4d.xhtml>
	#[inline(always)]
	fn glVertexAttribL4d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL4d", catch_unwind(||(self.version_4_1.vertexattribl4d)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL4d", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL1dv.xhtml>
	#[inline(always)]
	fn glVertexAttribL1dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL1dv", catch_unwind(||(self.version_4_1.vertexattribl1dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL1dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL2dv.xhtml>
	#[inline(always)]
	fn glVertexAttribL2dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL2dv", catch_unwind(||(self.version_4_1.vertexattribl2dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL2dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL3dv.xhtml>
	#[inline(always)]
	fn glVertexAttribL3dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL3dv", catch_unwind(||(self.version_4_1.vertexattribl3dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL3dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribL4dv.xhtml>
	#[inline(always)]
	fn glVertexAttribL4dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL4dv", catch_unwind(||(self.version_4_1.vertexattribl4dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL4dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribLPointer.xhtml>
	#[inline(always)]
	fn glVertexAttribLPointer(&self, index: GLuint, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glVertexAttribLPointer", catch_unwind(||(self.version_4_1.vertexattriblpointer)(index, size, type_, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribLPointer", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexAttribLdv.xhtml>
	#[inline(always)]
	fn glGetVertexAttribLdv(&self, index: GLuint, pname: GLenum, params: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetVertexAttribLdv", catch_unwind(||(self.version_4_1.getvertexattribldv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribLdv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glViewportArrayv.xhtml>
	#[inline(always)]
	fn glViewportArrayv(&self, first: GLuint, count: GLsizei, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glViewportArrayv", catch_unwind(||(self.version_4_1.viewportarrayv)(first, count, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glViewportArrayv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glViewportIndexedf.xhtml>
	#[inline(always)]
	fn glViewportIndexedf(&self, index: GLuint, x: GLfloat, y: GLfloat, w: GLfloat, h: GLfloat) -> Result<()> {
		let ret = process_catch("glViewportIndexedf", catch_unwind(||(self.version_4_1.viewportindexedf)(index, x, y, w, h)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glViewportIndexedf", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glViewportIndexedfv.xhtml>
	#[inline(always)]
	fn glViewportIndexedfv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glViewportIndexedfv", catch_unwind(||(self.version_4_1.viewportindexedfv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glViewportIndexedfv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glScissorArrayv.xhtml>
	#[inline(always)]
	fn glScissorArrayv(&self, first: GLuint, count: GLsizei, v: *const GLint) -> Result<()> {
		let ret = process_catch("glScissorArrayv", catch_unwind(||(self.version_4_1.scissorarrayv)(first, count, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glScissorArrayv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glScissorIndexed.xhtml>
	#[inline(always)]
	fn glScissorIndexed(&self, index: GLuint, left: GLint, bottom: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glScissorIndexed", catch_unwind(||(self.version_4_1.scissorindexed)(index, left, bottom, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glScissorIndexed", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glScissorIndexedv.xhtml>
	#[inline(always)]
	fn glScissorIndexedv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glScissorIndexedv", catch_unwind(||(self.version_4_1.scissorindexedv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glScissorIndexedv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDepthRangeArrayv.xhtml>
	#[inline(always)]
	fn glDepthRangeArrayv(&self, first: GLuint, count: GLsizei, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glDepthRangeArrayv", catch_unwind(||(self.version_4_1.depthrangearrayv)(first, count, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthRangeArrayv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDepthRangeIndexed.xhtml>
	#[inline(always)]
	fn glDepthRangeIndexed(&self, index: GLuint, n: GLdouble, f: GLdouble) -> Result<()> {
		let ret = process_catch("glDepthRangeIndexed", catch_unwind(||(self.version_4_1.depthrangeindexed)(index, n, f)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthRangeIndexed", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetFloati_v.xhtml>
	#[inline(always)]
	fn glGetFloati_v(&self, target: GLenum, index: GLuint, data: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetFloati_v", catch_unwind(||(self.version_4_1.getfloati_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFloati_v", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetDoublei_v.xhtml>
	#[inline(always)]
	fn glGetDoublei_v(&self, target: GLenum, index: GLuint, data: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetDoublei_v", catch_unwind(||(self.version_4_1.getdoublei_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetDoublei_v", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_4_2 for GLCore {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_4_2.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawArraysInstancedBaseInstance.xhtml>
	#[inline(always)]
	fn glDrawArraysInstancedBaseInstance(&self, mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei, baseinstance: GLuint) -> Result<()> {
		let ret = process_catch("glDrawArraysInstancedBaseInstance", catch_unwind(||(self.version_4_2.drawarraysinstancedbaseinstance)(mode, first, count, instancecount, baseinstance)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawArraysInstancedBaseInstance", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseInstance.xhtml>
	#[inline(always)]
	fn glDrawElementsInstancedBaseInstance(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei, baseinstance: GLuint) -> Result<()> {
		let ret = process_catch("glDrawElementsInstancedBaseInstance", catch_unwind(||(self.version_4_2.drawelementsinstancedbaseinstance)(mode, count, type_, indices, instancecount, baseinstance)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsInstancedBaseInstance", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElementsInstancedBaseVertexBaseInstance.xhtml>
	#[inline(always)]
	fn glDrawElementsInstancedBaseVertexBaseInstance(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei, basevertex: GLint, baseinstance: GLuint) -> Result<()> {
		let ret = process_catch("glDrawElementsInstancedBaseVertexBaseInstance", catch_unwind(||(self.version_4_2.drawelementsinstancedbasevertexbaseinstance)(mode, count, type_, indices, instancecount, basevertex, baseinstance)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsInstancedBaseVertexBaseInstance", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetInternalformativ.xhtml>
	#[inline(always)]
	fn glGetInternalformativ(&self, target: GLenum, internalformat: GLenum, pname: GLenum, count: GLsizei, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetInternalformativ", catch_unwind(||(self.version_4_2.getinternalformativ)(target, internalformat, pname, count, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetInternalformativ", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveAtomicCounterBufferiv.xhtml>
	#[inline(always)]
	fn glGetActiveAtomicCounterBufferiv(&self, program: GLuint, bufferIndex: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetActiveAtomicCounterBufferiv", catch_unwind(||(self.version_4_2.getactiveatomiccounterbufferiv)(program, bufferIndex, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveAtomicCounterBufferiv", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindImageTexture.xhtml>
	#[inline(always)]
	fn glBindImageTexture(&self, unit: GLuint, texture: GLuint, level: GLint, layered: GLboolean, layer: GLint, access: GLenum, format: GLenum) -> Result<()> {
		let ret = process_catch("glBindImageTexture", catch_unwind(||(self.version_4_2.bindimagetexture)(unit, texture, level, layered, layer, access, format)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindImageTexture", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMemoryBarrier.xhtml>
	#[inline(always)]
	fn glMemoryBarrier(&self, barriers: GLbitfield) -> Result<()> {
		let ret = process_catch("glMemoryBarrier", catch_unwind(||(self.version_4_2.memorybarrier)(barriers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMemoryBarrier", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexStorage1D.xhtml>
	#[inline(always)]
	fn glTexStorage1D(&self, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei) -> Result<()> {
		let ret = process_catch("glTexStorage1D", catch_unwind(||(self.version_4_2.texstorage1d)(target, levels, internalformat, width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage1D", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexStorage2D.xhtml>
	#[inline(always)]
	fn glTexStorage2D(&self, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glTexStorage2D", catch_unwind(||(self.version_4_2.texstorage2d)(target, levels, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage2D", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexStorage3D.xhtml>
	#[inline(always)]
	fn glTexStorage3D(&self, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei) -> Result<()> {
		let ret = process_catch("glTexStorage3D", catch_unwind(||(self.version_4_2.texstorage3d)(target, levels, internalformat, width, height, depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage3D", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackInstanced.xhtml>
	#[inline(always)]
	fn glDrawTransformFeedbackInstanced(&self, mode: GLenum, id: GLuint, instancecount: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawTransformFeedbackInstanced", catch_unwind(||(self.version_4_2.drawtransformfeedbackinstanced)(mode, id, instancecount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawTransformFeedbackInstanced", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawTransformFeedbackStreamInstanced.xhtml>
	#[inline(always)]
	fn glDrawTransformFeedbackStreamInstanced(&self, mode: GLenum, id: GLuint, stream: GLuint, instancecount: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawTransformFeedbackStreamInstanced", catch_unwind(||(self.version_4_2.drawtransformfeedbackstreaminstanced)(mode, id, stream, instancecount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawTransformFeedbackStreamInstanced", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_4_3 for GLCore {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_4_3.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearBufferData.xhtml>
	#[inline(always)]
	fn glClearBufferData(&self, target: GLenum, internalformat: GLenum, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearBufferData", catch_unwind(||(self.version_4_3.clearbufferdata)(target, internalformat, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferData", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearBufferSubData.xhtml>
	#[inline(always)]
	fn glClearBufferSubData(&self, target: GLenum, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearBufferSubData", catch_unwind(||(self.version_4_3.clearbuffersubdata)(target, internalformat, offset, size, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferSubData", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDispatchCompute.xhtml>
	#[inline(always)]
	fn glDispatchCompute(&self, num_groups_x: GLuint, num_groups_y: GLuint, num_groups_z: GLuint) -> Result<()> {
		let ret = process_catch("glDispatchCompute", catch_unwind(||(self.version_4_3.dispatchcompute)(num_groups_x, num_groups_y, num_groups_z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDispatchCompute", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDispatchComputeIndirect.xhtml>
	#[inline(always)]
	fn glDispatchComputeIndirect(&self, indirect: GLintptr) -> Result<()> {
		let ret = process_catch("glDispatchComputeIndirect", catch_unwind(||(self.version_4_3.dispatchcomputeindirect)(indirect)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDispatchComputeIndirect", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyImageSubData.xhtml>
	#[inline(always)]
	fn glCopyImageSubData(&self, srcName: GLuint, srcTarget: GLenum, srcLevel: GLint, srcX: GLint, srcY: GLint, srcZ: GLint, dstName: GLuint, dstTarget: GLenum, dstLevel: GLint, dstX: GLint, dstY: GLint, dstZ: GLint, srcWidth: GLsizei, srcHeight: GLsizei, srcDepth: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyImageSubData", catch_unwind(||(self.version_4_3.copyimagesubdata)(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyImageSubData", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFramebufferParameteri.xhtml>
	#[inline(always)]
	fn glFramebufferParameteri(&self, target: GLenum, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferParameteri", catch_unwind(||(self.version_4_3.framebufferparameteri)(target, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferParameteri", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetFramebufferParameteriv.xhtml>
	#[inline(always)]
	fn glGetFramebufferParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetFramebufferParameteriv", catch_unwind(||(self.version_4_3.getframebufferparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFramebufferParameteriv", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetInternalformati64v.xhtml>
	#[inline(always)]
	fn glGetInternalformati64v(&self, target: GLenum, internalformat: GLenum, pname: GLenum, count: GLsizei, params: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetInternalformati64v", catch_unwind(||(self.version_4_3.getinternalformati64v)(target, internalformat, pname, count, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetInternalformati64v", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateTexSubImage.xhtml>
	#[inline(always)]
	fn glInvalidateTexSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei) -> Result<()> {
		let ret = process_catch("glInvalidateTexSubImage", catch_unwind(||(self.version_4_3.invalidatetexsubimage)(texture, level, xoffset, yoffset, zoffset, width, height, depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateTexSubImage", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateTexImage.xhtml>
	#[inline(always)]
	fn glInvalidateTexImage(&self, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glInvalidateTexImage", catch_unwind(||(self.version_4_3.invalidateteximage)(texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateTexImage", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateBufferSubData.xhtml>
	#[inline(always)]
	fn glInvalidateBufferSubData(&self, buffer: GLuint, offset: GLintptr, length: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glInvalidateBufferSubData", catch_unwind(||(self.version_4_3.invalidatebuffersubdata)(buffer, offset, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateBufferSubData", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateBufferData.xhtml>
	#[inline(always)]
	fn glInvalidateBufferData(&self, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glInvalidateBufferData", catch_unwind(||(self.version_4_3.invalidatebufferdata)(buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateBufferData", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateFramebuffer.xhtml>
	#[inline(always)]
	fn glInvalidateFramebuffer(&self, target: GLenum, numAttachments: GLsizei, attachments: *const GLenum) -> Result<()> {
		let ret = process_catch("glInvalidateFramebuffer", catch_unwind(||(self.version_4_3.invalidateframebuffer)(target, numAttachments, attachments)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateFramebuffer", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateSubFramebuffer.xhtml>
	#[inline(always)]
	fn glInvalidateSubFramebuffer(&self, target: GLenum, numAttachments: GLsizei, attachments: *const GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glInvalidateSubFramebuffer", catch_unwind(||(self.version_4_3.invalidatesubframebuffer)(target, numAttachments, attachments, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateSubFramebuffer", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawArraysIndirect.xhtml>
	#[inline(always)]
	fn glMultiDrawArraysIndirect(&self, mode: GLenum, indirect: *const c_void, drawcount: GLsizei, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawArraysIndirect", catch_unwind(||(self.version_4_3.multidrawarraysindirect)(mode, indirect, drawcount, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawArraysIndirect", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawElementsIndirect.xhtml>
	#[inline(always)]
	fn glMultiDrawElementsIndirect(&self, mode: GLenum, type_: GLenum, indirect: *const c_void, drawcount: GLsizei, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawElementsIndirect", catch_unwind(||(self.version_4_3.multidrawelementsindirect)(mode, type_, indirect, drawcount, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawElementsIndirect", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramInterfaceiv.xhtml>
	#[inline(always)]
	fn glGetProgramInterfaceiv(&self, program: GLuint, programInterface: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramInterfaceiv", catch_unwind(||(self.version_4_3.getprograminterfaceiv)(program, programInterface, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramInterfaceiv", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramResourceIndex.xhtml>
	#[inline(always)]
	fn glGetProgramResourceIndex(&self, program: GLuint, programInterface: GLenum, name: *const GLchar) -> Result<GLuint> {
		let ret = process_catch("glGetProgramResourceIndex", catch_unwind(||(self.version_4_3.getprogramresourceindex)(program, programInterface, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceIndex", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramResourceName.xhtml>
	#[inline(always)]
	fn glGetProgramResourceName(&self, program: GLuint, programInterface: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetProgramResourceName", catch_unwind(||(self.version_4_3.getprogramresourcename)(program, programInterface, index, bufSize, length, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceName", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramResourceiv.xhtml>
	#[inline(always)]
	fn glGetProgramResourceiv(&self, program: GLuint, programInterface: GLenum, index: GLuint, propCount: GLsizei, props: *const GLenum, count: GLsizei, length: *mut GLsizei, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramResourceiv", catch_unwind(||(self.version_4_3.getprogramresourceiv)(program, programInterface, index, propCount, props, count, length, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceiv", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramResourceLocation.xhtml>
	#[inline(always)]
	fn glGetProgramResourceLocation(&self, program: GLuint, programInterface: GLenum, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetProgramResourceLocation", catch_unwind(||(self.version_4_3.getprogramresourcelocation)(program, programInterface, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceLocation", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramResourceLocationIndex.xhtml>
	#[inline(always)]
	fn glGetProgramResourceLocationIndex(&self, program: GLuint, programInterface: GLenum, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetProgramResourceLocationIndex", catch_unwind(||(self.version_4_3.getprogramresourcelocationindex)(program, programInterface, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceLocationIndex", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glShaderStorageBlockBinding.xhtml>
	#[inline(always)]
	fn glShaderStorageBlockBinding(&self, program: GLuint, storageBlockIndex: GLuint, storageBlockBinding: GLuint) -> Result<()> {
		let ret = process_catch("glShaderStorageBlockBinding", catch_unwind(||(self.version_4_3.shaderstorageblockbinding)(program, storageBlockIndex, storageBlockBinding)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glShaderStorageBlockBinding", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexBufferRange.xhtml>
	#[inline(always)]
	fn glTexBufferRange(&self, target: GLenum, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glTexBufferRange", catch_unwind(||(self.version_4_3.texbufferrange)(target, internalformat, buffer, offset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexBufferRange", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexStorage2DMultisample.xhtml>
	#[inline(always)]
	fn glTexStorage2DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTexStorage2DMultisample", catch_unwind(||(self.version_4_3.texstorage2dmultisample)(target, samples, internalformat, width, height, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage2DMultisample", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexStorage3DMultisample.xhtml>
	#[inline(always)]
	fn glTexStorage3DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTexStorage3DMultisample", catch_unwind(||(self.version_4_3.texstorage3dmultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage3DMultisample", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureView.xhtml>
	#[inline(always)]
	fn glTextureView(&self, texture: GLuint, target: GLenum, origtexture: GLuint, internalformat: GLenum, minlevel: GLuint, numlevels: GLuint, minlayer: GLuint, numlayers: GLuint) -> Result<()> {
		let ret = process_catch("glTextureView", catch_unwind(||(self.version_4_3.textureview)(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureView", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindVertexBuffer.xhtml>
	#[inline(always)]
	fn glBindVertexBuffer(&self, bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glBindVertexBuffer", catch_unwind(||(self.version_4_3.bindvertexbuffer)(bindingindex, buffer, offset, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindVertexBuffer", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribFormat.xhtml>
	#[inline(always)]
	fn glVertexAttribFormat(&self, attribindex: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribFormat", catch_unwind(||(self.version_4_3.vertexattribformat)(attribindex, size, type_, normalized, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribFormat", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribIFormat.xhtml>
	#[inline(always)]
	fn glVertexAttribIFormat(&self, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribIFormat", catch_unwind(||(self.version_4_3.vertexattribiformat)(attribindex, size, type_, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribIFormat", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribLFormat.xhtml>
	#[inline(always)]
	fn glVertexAttribLFormat(&self, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribLFormat", catch_unwind(||(self.version_4_3.vertexattriblformat)(attribindex, size, type_, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribLFormat", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribBinding.xhtml>
	#[inline(always)]
	fn glVertexAttribBinding(&self, attribindex: GLuint, bindingindex: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribBinding", catch_unwind(||(self.version_4_3.vertexattribbinding)(attribindex, bindingindex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribBinding", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexBindingDivisor.xhtml>
	#[inline(always)]
	fn glVertexBindingDivisor(&self, bindingindex: GLuint, divisor: GLuint) -> Result<()> {
		let ret = process_catch("glVertexBindingDivisor", catch_unwind(||(self.version_4_3.vertexbindingdivisor)(bindingindex, divisor)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexBindingDivisor", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDebugMessageControl.xhtml>
	#[inline(always)]
	fn glDebugMessageControl(&self, source: GLenum, type_: GLenum, severity: GLenum, count: GLsizei, ids: *const GLuint, enabled: GLboolean) -> Result<()> {
		let ret = process_catch("glDebugMessageControl", catch_unwind(||(self.version_4_3.debugmessagecontrol)(source, type_, severity, count, ids, enabled)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDebugMessageControl", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDebugMessageInsert.xhtml>
	#[inline(always)]
	fn glDebugMessageInsert(&self, source: GLenum, type_: GLenum, id: GLuint, severity: GLenum, length: GLsizei, buf: *const GLchar) -> Result<()> {
		let ret = process_catch("glDebugMessageInsert", catch_unwind(||(self.version_4_3.debugmessageinsert)(source, type_, id, severity, length, buf)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDebugMessageInsert", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDebugMessageCallback.xhtml>
	#[inline(always)]
	fn glDebugMessageCallback(&self, callback: GLDEBUGPROC, userParam: *const c_void) -> Result<()> {
		let ret = process_catch("glDebugMessageCallback", catch_unwind(||(self.version_4_3.debugmessagecallback)(callback, userParam)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDebugMessageCallback", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetDebugMessageLog.xhtml>
	#[inline(always)]
	fn glGetDebugMessageLog(&self, count: GLuint, bufSize: GLsizei, sources: *mut GLenum, types: *mut GLenum, ids: *mut GLuint, severities: *mut GLenum, lengths: *mut GLsizei, messageLog: *mut GLchar) -> Result<GLuint> {
		let ret = process_catch("glGetDebugMessageLog", catch_unwind(||(self.version_4_3.getdebugmessagelog)(count, bufSize, sources, types, ids, severities, lengths, messageLog)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetDebugMessageLog", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPushDebugGroup.xhtml>
	#[inline(always)]
	fn glPushDebugGroup(&self, source: GLenum, id: GLuint, length: GLsizei, message: *const GLchar) -> Result<()> {
		let ret = process_catch("glPushDebugGroup", catch_unwind(||(self.version_4_3.pushdebuggroup)(source, id, length, message)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPushDebugGroup", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPopDebugGroup.xhtml>
	#[inline(always)]
	fn glPopDebugGroup(&self) -> Result<()> {
		let ret = process_catch("glPopDebugGroup", catch_unwind(||(self.version_4_3.popdebuggroup)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPopDebugGroup", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glObjectLabel.xhtml>
	#[inline(always)]
	fn glObjectLabel(&self, identifier: GLenum, name: GLuint, length: GLsizei, label: *const GLchar) -> Result<()> {
		let ret = process_catch("glObjectLabel", catch_unwind(||(self.version_4_3.objectlabel)(identifier, name, length, label)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glObjectLabel", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetObjectLabel.xhtml>
	#[inline(always)]
	fn glGetObjectLabel(&self, identifier: GLenum, name: GLuint, bufSize: GLsizei, length: *mut GLsizei, label: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetObjectLabel", catch_unwind(||(self.version_4_3.getobjectlabel)(identifier, name, bufSize, length, label)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetObjectLabel", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glObjectPtrLabel.xhtml>
	#[inline(always)]
	fn glObjectPtrLabel(&self, ptr: *const c_void, length: GLsizei, label: *const GLchar) -> Result<()> {
		let ret = process_catch("glObjectPtrLabel", catch_unwind(||(self.version_4_3.objectptrlabel)(ptr, length, label)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glObjectPtrLabel", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetObjectPtrLabel.xhtml>
	#[inline(always)]
	fn glGetObjectPtrLabel(&self, ptr: *const c_void, bufSize: GLsizei, length: *mut GLsizei, label: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetObjectPtrLabel", catch_unwind(||(self.version_4_3.getobjectptrlabel)(ptr, bufSize, length, label)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetObjectPtrLabel", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_4_4 for GLCore {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_4_4.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBufferStorage.xhtml>
	#[inline(always)]
	fn glBufferStorage(&self, target: GLenum, size: GLsizeiptr, data: *const c_void, flags: GLbitfield) -> Result<()> {
		let ret = process_catch("glBufferStorage", catch_unwind(||(self.version_4_4.bufferstorage)(target, size, data, flags)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBufferStorage", ret, (self.version_4_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearTexImage.xhtml>
	#[inline(always)]
	fn glClearTexImage(&self, texture: GLuint, level: GLint, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearTexImage", catch_unwind(||(self.version_4_4.clearteximage)(texture, level, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearTexImage", ret, (self.version_4_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearTexSubImage.xhtml>
	#[inline(always)]
	fn glClearTexSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearTexSubImage", catch_unwind(||(self.version_4_4.cleartexsubimage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearTexSubImage", ret, (self.version_4_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindBuffersBase.xhtml>
	#[inline(always)]
	fn glBindBuffersBase(&self, target: GLenum, first: GLuint, count: GLsizei, buffers: *const GLuint) -> Result<()> {
		let ret = process_catch("glBindBuffersBase", catch_unwind(||(self.version_4_4.bindbuffersbase)(target, first, count, buffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBuffersBase", ret, (self.version_4_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindBuffersRange.xhtml>
	#[inline(always)]
	fn glBindBuffersRange(&self, target: GLenum, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, sizes: *const GLsizeiptr) -> Result<()> {
		let ret = process_catch("glBindBuffersRange", catch_unwind(||(self.version_4_4.bindbuffersrange)(target, first, count, buffers, offsets, sizes)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBuffersRange", ret, (self.version_4_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindTextures.xhtml>
	#[inline(always)]
	fn glBindTextures(&self, first: GLuint, count: GLsizei, textures: *const GLuint) -> Result<()> {
		let ret = process_catch("glBindTextures", catch_unwind(||(self.version_4_4.bindtextures)(first, count, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindTextures", ret, (self.version_4_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindSamplers.xhtml>
	#[inline(always)]
	fn glBindSamplers(&self, first: GLuint, count: GLsizei, samplers: *const GLuint) -> Result<()> {
		let ret = process_catch("glBindSamplers", catch_unwind(||(self.version_4_4.bindsamplers)(first, count, samplers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindSamplers", ret, (self.version_4_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindImageTextures.xhtml>
	#[inline(always)]
	fn glBindImageTextures(&self, first: GLuint, count: GLsizei, textures: *const GLuint) -> Result<()> {
		let ret = process_catch("glBindImageTextures", catch_unwind(||(self.version_4_4.bindimagetextures)(first, count, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindImageTextures", ret, (self.version_4_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindVertexBuffers.xhtml>
	#[inline(always)]
	fn glBindVertexBuffers(&self, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, strides: *const GLsizei) -> Result<()> {
		let ret = process_catch("glBindVertexBuffers", catch_unwind(||(self.version_4_4.bindvertexbuffers)(first, count, buffers, offsets, strides)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindVertexBuffers", ret, (self.version_4_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_4_5 for GLCore {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_4_5.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClipControl.xhtml>
	#[inline(always)]
	fn glClipControl(&self, origin: GLenum, depth: GLenum) -> Result<()> {
		let ret = process_catch("glClipControl", catch_unwind(||(self.version_4_5.clipcontrol)(origin, depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClipControl", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateTransformFeedbacks.xhtml>
	#[inline(always)]
	fn glCreateTransformFeedbacks(&self, n: GLsizei, ids: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateTransformFeedbacks", catch_unwind(||(self.version_4_5.createtransformfeedbacks)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateTransformFeedbacks", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferBase.xhtml>
	#[inline(always)]
	fn glTransformFeedbackBufferBase(&self, xfb: GLuint, index: GLuint, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glTransformFeedbackBufferBase", catch_unwind(||(self.version_4_5.transformfeedbackbufferbase)(xfb, index, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTransformFeedbackBufferBase", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTransformFeedbackBufferRange.xhtml>
	#[inline(always)]
	fn glTransformFeedbackBufferRange(&self, xfb: GLuint, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glTransformFeedbackBufferRange", catch_unwind(||(self.version_4_5.transformfeedbackbufferrange)(xfb, index, buffer, offset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTransformFeedbackBufferRange", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTransformFeedbackiv.xhtml>
	#[inline(always)]
	fn glGetTransformFeedbackiv(&self, xfb: GLuint, pname: GLenum, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTransformFeedbackiv", catch_unwind(||(self.version_4_5.gettransformfeedbackiv)(xfb, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTransformFeedbackiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTransformFeedbacki_v.xhtml>
	#[inline(always)]
	fn glGetTransformFeedbacki_v(&self, xfb: GLuint, pname: GLenum, index: GLuint, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTransformFeedbacki_v", catch_unwind(||(self.version_4_5.gettransformfeedbacki_v)(xfb, pname, index, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTransformFeedbacki_v", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTransformFeedbacki64_v.xhtml>
	#[inline(always)]
	fn glGetTransformFeedbacki64_v(&self, xfb: GLuint, pname: GLenum, index: GLuint, param: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetTransformFeedbacki64_v", catch_unwind(||(self.version_4_5.gettransformfeedbacki64_v)(xfb, pname, index, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTransformFeedbacki64_v", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateBuffers.xhtml>
	#[inline(always)]
	fn glCreateBuffers(&self, n: GLsizei, buffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateBuffers", catch_unwind(||(self.version_4_5.createbuffers)(n, buffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateBuffers", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedBufferStorage.xhtml>
	#[inline(always)]
	fn glNamedBufferStorage(&self, buffer: GLuint, size: GLsizeiptr, data: *const c_void, flags: GLbitfield) -> Result<()> {
		let ret = process_catch("glNamedBufferStorage", catch_unwind(||(self.version_4_5.namedbufferstorage)(buffer, size, data, flags)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedBufferStorage", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedBufferData.xhtml>
	#[inline(always)]
	fn glNamedBufferData(&self, buffer: GLuint, size: GLsizeiptr, data: *const c_void, usage: GLenum) -> Result<()> {
		let ret = process_catch("glNamedBufferData", catch_unwind(||(self.version_4_5.namedbufferdata)(buffer, size, data, usage)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedBufferData", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedBufferSubData.xhtml>
	#[inline(always)]
	fn glNamedBufferSubData(&self, buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: *const c_void) -> Result<()> {
		let ret = process_catch("glNamedBufferSubData", catch_unwind(||(self.version_4_5.namedbuffersubdata)(buffer, offset, size, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedBufferSubData", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyNamedBufferSubData.xhtml>
	#[inline(always)]
	fn glCopyNamedBufferSubData(&self, readBuffer: GLuint, writeBuffer: GLuint, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glCopyNamedBufferSubData", catch_unwind(||(self.version_4_5.copynamedbuffersubdata)(readBuffer, writeBuffer, readOffset, writeOffset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyNamedBufferSubData", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearNamedBufferData.xhtml>
	#[inline(always)]
	fn glClearNamedBufferData(&self, buffer: GLuint, internalformat: GLenum, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearNamedBufferData", catch_unwind(||(self.version_4_5.clearnamedbufferdata)(buffer, internalformat, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedBufferData", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearNamedBufferSubData.xhtml>
	#[inline(always)]
	fn glClearNamedBufferSubData(&self, buffer: GLuint, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearNamedBufferSubData", catch_unwind(||(self.version_4_5.clearnamedbuffersubdata)(buffer, internalformat, offset, size, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedBufferSubData", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMapNamedBuffer.xhtml>
	#[inline(always)]
	fn glMapNamedBuffer(&self, buffer: GLuint, access: GLenum) -> Result<*mut c_void> {
		let ret = process_catch("glMapNamedBuffer", catch_unwind(||(self.version_4_5.mapnamedbuffer)(buffer, access)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMapNamedBuffer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMapNamedBufferRange.xhtml>
	#[inline(always)]
	fn glMapNamedBufferRange(&self, buffer: GLuint, offset: GLintptr, length: GLsizeiptr, access: GLbitfield) -> Result<*mut c_void> {
		let ret = process_catch("glMapNamedBufferRange", catch_unwind(||(self.version_4_5.mapnamedbufferrange)(buffer, offset, length, access)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMapNamedBufferRange", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glUnmapNamedBuffer.xhtml>
	#[inline(always)]
	fn glUnmapNamedBuffer(&self, buffer: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glUnmapNamedBuffer", catch_unwind(||(self.version_4_5.unmapnamedbuffer)(buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUnmapNamedBuffer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glFlushMappedNamedBufferRange.xhtml>
	#[inline(always)]
	fn glFlushMappedNamedBufferRange(&self, buffer: GLuint, offset: GLintptr, length: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glFlushMappedNamedBufferRange", catch_unwind(||(self.version_4_5.flushmappednamedbufferrange)(buffer, offset, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFlushMappedNamedBufferRange", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedBufferParameteriv.xhtml>
	#[inline(always)]
	fn glGetNamedBufferParameteriv(&self, buffer: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetNamedBufferParameteriv", catch_unwind(||(self.version_4_5.getnamedbufferparameteriv)(buffer, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedBufferParameteriv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedBufferParameteri64v.xhtml>
	#[inline(always)]
	fn glGetNamedBufferParameteri64v(&self, buffer: GLuint, pname: GLenum, params: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetNamedBufferParameteri64v", catch_unwind(||(self.version_4_5.getnamedbufferparameteri64v)(buffer, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedBufferParameteri64v", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedBufferPointerv.xhtml>
	#[inline(always)]
	fn glGetNamedBufferPointerv(&self, buffer: GLuint, pname: GLenum, params: *mut *mut c_void) -> Result<()> {
		let ret = process_catch("glGetNamedBufferPointerv", catch_unwind(||(self.version_4_5.getnamedbufferpointerv)(buffer, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedBufferPointerv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedBufferSubData.xhtml>
	#[inline(always)]
	fn glGetNamedBufferSubData(&self, buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetNamedBufferSubData", catch_unwind(||(self.version_4_5.getnamedbuffersubdata)(buffer, offset, size, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedBufferSubData", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateFramebuffers.xhtml>
	#[inline(always)]
	fn glCreateFramebuffers(&self, n: GLsizei, framebuffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateFramebuffers", catch_unwind(||(self.version_4_5.createframebuffers)(n, framebuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateFramebuffers", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferRenderbuffer.xhtml>
	#[inline(always)]
	fn glNamedFramebufferRenderbuffer(&self, framebuffer: GLuint, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint) -> Result<()> {
		let ret = process_catch("glNamedFramebufferRenderbuffer", catch_unwind(||(self.version_4_5.namedframebufferrenderbuffer)(framebuffer, attachment, renderbuffertarget, renderbuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferRenderbuffer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferParameteri.xhtml>
	#[inline(always)]
	fn glNamedFramebufferParameteri(&self, framebuffer: GLuint, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glNamedFramebufferParameteri", catch_unwind(||(self.version_4_5.namedframebufferparameteri)(framebuffer, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferParameteri", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferTexture.xhtml>
	#[inline(always)]
	fn glNamedFramebufferTexture(&self, framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glNamedFramebufferTexture", catch_unwind(||(self.version_4_5.namedframebuffertexture)(framebuffer, attachment, texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferTexture", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferTextureLayer.xhtml>
	#[inline(always)]
	fn glNamedFramebufferTextureLayer(&self, framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint) -> Result<()> {
		let ret = process_catch("glNamedFramebufferTextureLayer", catch_unwind(||(self.version_4_5.namedframebuffertexturelayer)(framebuffer, attachment, texture, level, layer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferTextureLayer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferDrawBuffer.xhtml>
	#[inline(always)]
	fn glNamedFramebufferDrawBuffer(&self, framebuffer: GLuint, buf: GLenum) -> Result<()> {
		let ret = process_catch("glNamedFramebufferDrawBuffer", catch_unwind(||(self.version_4_5.namedframebufferdrawbuffer)(framebuffer, buf)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferDrawBuffer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferDrawBuffers.xhtml>
	#[inline(always)]
	fn glNamedFramebufferDrawBuffers(&self, framebuffer: GLuint, n: GLsizei, bufs: *const GLenum) -> Result<()> {
		let ret = process_catch("glNamedFramebufferDrawBuffers", catch_unwind(||(self.version_4_5.namedframebufferdrawbuffers)(framebuffer, n, bufs)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferDrawBuffers", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedFramebufferReadBuffer.xhtml>
	#[inline(always)]
	fn glNamedFramebufferReadBuffer(&self, framebuffer: GLuint, src: GLenum) -> Result<()> {
		let ret = process_catch("glNamedFramebufferReadBuffer", catch_unwind(||(self.version_4_5.namedframebufferreadbuffer)(framebuffer, src)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferReadBuffer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateNamedFramebufferData.xhtml>
	#[inline(always)]
	fn glInvalidateNamedFramebufferData(&self, framebuffer: GLuint, numAttachments: GLsizei, attachments: *const GLenum) -> Result<()> {
		let ret = process_catch("glInvalidateNamedFramebufferData", catch_unwind(||(self.version_4_5.invalidatenamedframebufferdata)(framebuffer, numAttachments, attachments)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateNamedFramebufferData", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glInvalidateNamedFramebufferSubData.xhtml>
	#[inline(always)]
	fn glInvalidateNamedFramebufferSubData(&self, framebuffer: GLuint, numAttachments: GLsizei, attachments: *const GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glInvalidateNamedFramebufferSubData", catch_unwind(||(self.version_4_5.invalidatenamedframebuffersubdata)(framebuffer, numAttachments, attachments, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateNamedFramebufferSubData", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearNamedFramebufferiv.xhtml>
	#[inline(always)]
	fn glClearNamedFramebufferiv(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLint) -> Result<()> {
		let ret = process_catch("glClearNamedFramebufferiv", catch_unwind(||(self.version_4_5.clearnamedframebufferiv)(framebuffer, buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedFramebufferiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearNamedFramebufferuiv.xhtml>
	#[inline(always)]
	fn glClearNamedFramebufferuiv(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glClearNamedFramebufferuiv", catch_unwind(||(self.version_4_5.clearnamedframebufferuiv)(framebuffer, buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedFramebufferuiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearNamedFramebufferfv.xhtml>
	#[inline(always)]
	fn glClearNamedFramebufferfv(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glClearNamedFramebufferfv", catch_unwind(||(self.version_4_5.clearnamedframebufferfv)(framebuffer, buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedFramebufferfv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClearNamedFramebufferfi.xhtml>
	#[inline(always)]
	fn glClearNamedFramebufferfi(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint) -> Result<()> {
		let ret = process_catch("glClearNamedFramebufferfi", catch_unwind(||(self.version_4_5.clearnamedframebufferfi)(framebuffer, buffer, drawbuffer, depth, stencil)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedFramebufferfi", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlitNamedFramebuffer.xhtml>
	#[inline(always)]
	fn glBlitNamedFramebuffer(&self, readFramebuffer: GLuint, drawFramebuffer: GLuint, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum) -> Result<()> {
		let ret = process_catch("glBlitNamedFramebuffer", catch_unwind(||(self.version_4_5.blitnamedframebuffer)(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlitNamedFramebuffer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCheckNamedFramebufferStatus.xhtml>
	#[inline(always)]
	fn glCheckNamedFramebufferStatus(&self, framebuffer: GLuint, target: GLenum) -> Result<GLenum> {
		let ret = process_catch("glCheckNamedFramebufferStatus", catch_unwind(||(self.version_4_5.checknamedframebufferstatus)(framebuffer, target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCheckNamedFramebufferStatus", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedFramebufferParameteriv.xhtml>
	#[inline(always)]
	fn glGetNamedFramebufferParameteriv(&self, framebuffer: GLuint, pname: GLenum, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetNamedFramebufferParameteriv", catch_unwind(||(self.version_4_5.getnamedframebufferparameteriv)(framebuffer, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedFramebufferParameteriv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedFramebufferAttachmentParameteriv.xhtml>
	#[inline(always)]
	fn glGetNamedFramebufferAttachmentParameteriv(&self, framebuffer: GLuint, attachment: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetNamedFramebufferAttachmentParameteriv", catch_unwind(||(self.version_4_5.getnamedframebufferattachmentparameteriv)(framebuffer, attachment, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedFramebufferAttachmentParameteriv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateRenderbuffers.xhtml>
	#[inline(always)]
	fn glCreateRenderbuffers(&self, n: GLsizei, renderbuffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateRenderbuffers", catch_unwind(||(self.version_4_5.createrenderbuffers)(n, renderbuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateRenderbuffers", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedRenderbufferStorage.xhtml>
	#[inline(always)]
	fn glNamedRenderbufferStorage(&self, renderbuffer: GLuint, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glNamedRenderbufferStorage", catch_unwind(||(self.version_4_5.namedrenderbufferstorage)(renderbuffer, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedRenderbufferStorage", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glNamedRenderbufferStorageMultisample.xhtml>
	#[inline(always)]
	fn glNamedRenderbufferStorageMultisample(&self, renderbuffer: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glNamedRenderbufferStorageMultisample", catch_unwind(||(self.version_4_5.namedrenderbufferstoragemultisample)(renderbuffer, samples, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedRenderbufferStorageMultisample", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetNamedRenderbufferParameteriv.xhtml>
	#[inline(always)]
	fn glGetNamedRenderbufferParameteriv(&self, renderbuffer: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetNamedRenderbufferParameteriv", catch_unwind(||(self.version_4_5.getnamedrenderbufferparameteriv)(renderbuffer, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedRenderbufferParameteriv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateTextures.xhtml>
	#[inline(always)]
	fn glCreateTextures(&self, target: GLenum, n: GLsizei, textures: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateTextures", catch_unwind(||(self.version_4_5.createtextures)(target, n, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateTextures", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureBuffer.xhtml>
	#[inline(always)]
	fn glTextureBuffer(&self, texture: GLuint, internalformat: GLenum, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glTextureBuffer", catch_unwind(||(self.version_4_5.texturebuffer)(texture, internalformat, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureBuffer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureBufferRange.xhtml>
	#[inline(always)]
	fn glTextureBufferRange(&self, texture: GLuint, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glTextureBufferRange", catch_unwind(||(self.version_4_5.texturebufferrange)(texture, internalformat, buffer, offset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureBufferRange", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureStorage1D.xhtml>
	#[inline(always)]
	fn glTextureStorage1D(&self, texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei) -> Result<()> {
		let ret = process_catch("glTextureStorage1D", catch_unwind(||(self.version_4_5.texturestorage1d)(texture, levels, internalformat, width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage1D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureStorage2D.xhtml>
	#[inline(always)]
	fn glTextureStorage2D(&self, texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glTextureStorage2D", catch_unwind(||(self.version_4_5.texturestorage2d)(texture, levels, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage2D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureStorage3D.xhtml>
	#[inline(always)]
	fn glTextureStorage3D(&self, texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei) -> Result<()> {
		let ret = process_catch("glTextureStorage3D", catch_unwind(||(self.version_4_5.texturestorage3d)(texture, levels, internalformat, width, height, depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage3D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureStorage2DMultisample.xhtml>
	#[inline(always)]
	fn glTextureStorage2DMultisample(&self, texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTextureStorage2DMultisample", catch_unwind(||(self.version_4_5.texturestorage2dmultisample)(texture, samples, internalformat, width, height, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage2DMultisample", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureStorage3DMultisample.xhtml>
	#[inline(always)]
	fn glTextureStorage3DMultisample(&self, texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTextureStorage3DMultisample", catch_unwind(||(self.version_4_5.texturestorage3dmultisample)(texture, samples, internalformat, width, height, depth, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage3DMultisample", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureSubImage1D.xhtml>
	#[inline(always)]
	fn glTextureSubImage1D(&self, texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTextureSubImage1D", catch_unwind(||(self.version_4_5.texturesubimage1d)(texture, level, xoffset, width, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureSubImage1D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureSubImage2D.xhtml>
	#[inline(always)]
	fn glTextureSubImage2D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTextureSubImage2D", catch_unwind(||(self.version_4_5.texturesubimage2d)(texture, level, xoffset, yoffset, width, height, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureSubImage2D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureSubImage3D.xhtml>
	#[inline(always)]
	fn glTextureSubImage3D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTextureSubImage3D", catch_unwind(||(self.version_4_5.texturesubimage3d)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureSubImage3D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTextureSubImage1D.xhtml>
	#[inline(always)]
	fn glCompressedTextureSubImage1D(&self, texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTextureSubImage1D", catch_unwind(||(self.version_4_5.compressedtexturesubimage1d)(texture, level, xoffset, width, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTextureSubImage1D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTextureSubImage2D.xhtml>
	#[inline(always)]
	fn glCompressedTextureSubImage2D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTextureSubImage2D", catch_unwind(||(self.version_4_5.compressedtexturesubimage2d)(texture, level, xoffset, yoffset, width, height, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTextureSubImage2D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompressedTextureSubImage3D.xhtml>
	#[inline(always)]
	fn glCompressedTextureSubImage3D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTextureSubImage3D", catch_unwind(||(self.version_4_5.compressedtexturesubimage3d)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTextureSubImage3D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTextureSubImage1D.xhtml>
	#[inline(always)]
	fn glCopyTextureSubImage1D(&self, texture: GLuint, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTextureSubImage1D", catch_unwind(||(self.version_4_5.copytexturesubimage1d)(texture, level, xoffset, x, y, width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTextureSubImage1D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTextureSubImage2D.xhtml>
	#[inline(always)]
	fn glCopyTextureSubImage2D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTextureSubImage2D", catch_unwind(||(self.version_4_5.copytexturesubimage2d)(texture, level, xoffset, yoffset, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTextureSubImage2D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCopyTextureSubImage3D.xhtml>
	#[inline(always)]
	fn glCopyTextureSubImage3D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTextureSubImage3D", catch_unwind(||(self.version_4_5.copytexturesubimage3d)(texture, level, xoffset, yoffset, zoffset, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTextureSubImage3D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureParameterf.xhtml>
	#[inline(always)]
	fn glTextureParameterf(&self, texture: GLuint, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glTextureParameterf", catch_unwind(||(self.version_4_5.textureparameterf)(texture, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameterf", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureParameterfv.xhtml>
	#[inline(always)]
	fn glTextureParameterfv(&self, texture: GLuint, pname: GLenum, param: *const GLfloat) -> Result<()> {
		let ret = process_catch("glTextureParameterfv", catch_unwind(||(self.version_4_5.textureparameterfv)(texture, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameterfv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureParameteri.xhtml>
	#[inline(always)]
	fn glTextureParameteri(&self, texture: GLuint, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glTextureParameteri", catch_unwind(||(self.version_4_5.textureparameteri)(texture, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameteri", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureParameterIiv.xhtml>
	#[inline(always)]
	fn glTextureParameterIiv(&self, texture: GLuint, pname: GLenum, params: *const GLint) -> Result<()> {
		let ret = process_catch("glTextureParameterIiv", catch_unwind(||(self.version_4_5.textureparameteriiv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameterIiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureParameterIuiv.xhtml>
	#[inline(always)]
	fn glTextureParameterIuiv(&self, texture: GLuint, pname: GLenum, params: *const GLuint) -> Result<()> {
		let ret = process_catch("glTextureParameterIuiv", catch_unwind(||(self.version_4_5.textureparameteriuiv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameterIuiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureParameteriv.xhtml>
	#[inline(always)]
	fn glTextureParameteriv(&self, texture: GLuint, pname: GLenum, param: *const GLint) -> Result<()> {
		let ret = process_catch("glTextureParameteriv", catch_unwind(||(self.version_4_5.textureparameteriv)(texture, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameteriv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenerateTextureMipmap.xhtml>
	#[inline(always)]
	fn glGenerateTextureMipmap(&self, texture: GLuint) -> Result<()> {
		let ret = process_catch("glGenerateTextureMipmap", catch_unwind(||(self.version_4_5.generatetexturemipmap)(texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenerateTextureMipmap", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindTextureUnit.xhtml>
	#[inline(always)]
	fn glBindTextureUnit(&self, unit: GLuint, texture: GLuint) -> Result<()> {
		let ret = process_catch("glBindTextureUnit", catch_unwind(||(self.version_4_5.bindtextureunit)(unit, texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindTextureUnit", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureImage.xhtml>
	#[inline(always)]
	fn glGetTextureImage(&self, texture: GLuint, level: GLint, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetTextureImage", catch_unwind(||(self.version_4_5.gettextureimage)(texture, level, format, type_, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureImage", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetCompressedTextureImage.xhtml>
	#[inline(always)]
	fn glGetCompressedTextureImage(&self, texture: GLuint, level: GLint, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetCompressedTextureImage", catch_unwind(||(self.version_4_5.getcompressedtextureimage)(texture, level, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetCompressedTextureImage", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureLevelParameterfv.xhtml>
	#[inline(always)]
	fn glGetTextureLevelParameterfv(&self, texture: GLuint, level: GLint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetTextureLevelParameterfv", catch_unwind(||(self.version_4_5.gettexturelevelparameterfv)(texture, level, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureLevelParameterfv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureLevelParameteriv.xhtml>
	#[inline(always)]
	fn glGetTextureLevelParameteriv(&self, texture: GLuint, level: GLint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTextureLevelParameteriv", catch_unwind(||(self.version_4_5.gettexturelevelparameteriv)(texture, level, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureLevelParameteriv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureParameterfv.xhtml>
	#[inline(always)]
	fn glGetTextureParameterfv(&self, texture: GLuint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetTextureParameterfv", catch_unwind(||(self.version_4_5.gettextureparameterfv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureParameterfv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureParameterIiv.xhtml>
	#[inline(always)]
	fn glGetTextureParameterIiv(&self, texture: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTextureParameterIiv", catch_unwind(||(self.version_4_5.gettextureparameteriiv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureParameterIiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureParameterIuiv.xhtml>
	#[inline(always)]
	fn glGetTextureParameterIuiv(&self, texture: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetTextureParameterIuiv", catch_unwind(||(self.version_4_5.gettextureparameteriuiv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureParameterIuiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureParameteriv.xhtml>
	#[inline(always)]
	fn glGetTextureParameteriv(&self, texture: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTextureParameteriv", catch_unwind(||(self.version_4_5.gettextureparameteriv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureParameteriv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateVertexArrays.xhtml>
	#[inline(always)]
	fn glCreateVertexArrays(&self, n: GLsizei, arrays: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateVertexArrays", catch_unwind(||(self.version_4_5.createvertexarrays)(n, arrays)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateVertexArrays", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDisableVertexArrayAttrib.xhtml>
	#[inline(always)]
	fn glDisableVertexArrayAttrib(&self, vaobj: GLuint, index: GLuint) -> Result<()> {
		let ret = process_catch("glDisableVertexArrayAttrib", catch_unwind(||(self.version_4_5.disablevertexarrayattrib)(vaobj, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDisableVertexArrayAttrib", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEnableVertexArrayAttrib.xhtml>
	#[inline(always)]
	fn glEnableVertexArrayAttrib(&self, vaobj: GLuint, index: GLuint) -> Result<()> {
		let ret = process_catch("glEnableVertexArrayAttrib", catch_unwind(||(self.version_4_5.enablevertexarrayattrib)(vaobj, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEnableVertexArrayAttrib", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayElementBuffer.xhtml>
	#[inline(always)]
	fn glVertexArrayElementBuffer(&self, vaobj: GLuint, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayElementBuffer", catch_unwind(||(self.version_4_5.vertexarrayelementbuffer)(vaobj, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayElementBuffer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayVertexBuffer.xhtml>
	#[inline(always)]
	fn glVertexArrayVertexBuffer(&self, vaobj: GLuint, bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glVertexArrayVertexBuffer", catch_unwind(||(self.version_4_5.vertexarrayvertexbuffer)(vaobj, bindingindex, buffer, offset, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayVertexBuffer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayVertexBuffers.xhtml>
	#[inline(always)]
	fn glVertexArrayVertexBuffers(&self, vaobj: GLuint, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, strides: *const GLsizei) -> Result<()> {
		let ret = process_catch("glVertexArrayVertexBuffers", catch_unwind(||(self.version_4_5.vertexarrayvertexbuffers)(vaobj, first, count, buffers, offsets, strides)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayVertexBuffers", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayAttribBinding.xhtml>
	#[inline(always)]
	fn glVertexArrayAttribBinding(&self, vaobj: GLuint, attribindex: GLuint, bindingindex: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayAttribBinding", catch_unwind(||(self.version_4_5.vertexarrayattribbinding)(vaobj, attribindex, bindingindex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayAttribBinding", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayAttribFormat.xhtml>
	#[inline(always)]
	fn glVertexArrayAttribFormat(&self, vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayAttribFormat", catch_unwind(||(self.version_4_5.vertexarrayattribformat)(vaobj, attribindex, size, type_, normalized, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayAttribFormat", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayAttribIFormat.xhtml>
	#[inline(always)]
	fn glVertexArrayAttribIFormat(&self, vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayAttribIFormat", catch_unwind(||(self.version_4_5.vertexarrayattribiformat)(vaobj, attribindex, size, type_, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayAttribIFormat", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayAttribLFormat.xhtml>
	#[inline(always)]
	fn glVertexArrayAttribLFormat(&self, vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayAttribLFormat", catch_unwind(||(self.version_4_5.vertexarrayattriblformat)(vaobj, attribindex, size, type_, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayAttribLFormat", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexArrayBindingDivisor.xhtml>
	#[inline(always)]
	fn glVertexArrayBindingDivisor(&self, vaobj: GLuint, bindingindex: GLuint, divisor: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayBindingDivisor", catch_unwind(||(self.version_4_5.vertexarraybindingdivisor)(vaobj, bindingindex, divisor)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayBindingDivisor", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexArrayiv.xhtml>
	#[inline(always)]
	fn glGetVertexArrayiv(&self, vaobj: GLuint, pname: GLenum, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetVertexArrayiv", catch_unwind(||(self.version_4_5.getvertexarrayiv)(vaobj, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexArrayiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexediv.xhtml>
	#[inline(always)]
	fn glGetVertexArrayIndexediv(&self, vaobj: GLuint, index: GLuint, pname: GLenum, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetVertexArrayIndexediv", catch_unwind(||(self.version_4_5.getvertexarrayindexediv)(vaobj, index, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexArrayIndexediv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetVertexArrayIndexed64iv.xhtml>
	#[inline(always)]
	fn glGetVertexArrayIndexed64iv(&self, vaobj: GLuint, index: GLuint, pname: GLenum, param: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetVertexArrayIndexed64iv", catch_unwind(||(self.version_4_5.getvertexarrayindexed64iv)(vaobj, index, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexArrayIndexed64iv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateSamplers.xhtml>
	#[inline(always)]
	fn glCreateSamplers(&self, n: GLsizei, samplers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateSamplers", catch_unwind(||(self.version_4_5.createsamplers)(n, samplers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateSamplers", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateProgramPipelines.xhtml>
	#[inline(always)]
	fn glCreateProgramPipelines(&self, n: GLsizei, pipelines: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateProgramPipelines", catch_unwind(||(self.version_4_5.createprogrampipelines)(n, pipelines)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateProgramPipelines", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateQueries.xhtml>
	#[inline(always)]
	fn glCreateQueries(&self, target: GLenum, n: GLsizei, ids: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateQueries", catch_unwind(||(self.version_4_5.createqueries)(target, n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateQueries", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryBufferObjecti64v.xhtml>
	#[inline(always)]
	fn glGetQueryBufferObjecti64v(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()> {
		let ret = process_catch("glGetQueryBufferObjecti64v", catch_unwind(||(self.version_4_5.getquerybufferobjecti64v)(id, buffer, pname, offset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryBufferObjecti64v", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryBufferObjectiv.xhtml>
	#[inline(always)]
	fn glGetQueryBufferObjectiv(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()> {
		let ret = process_catch("glGetQueryBufferObjectiv", catch_unwind(||(self.version_4_5.getquerybufferobjectiv)(id, buffer, pname, offset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryBufferObjectiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryBufferObjectui64v.xhtml>
	#[inline(always)]
	fn glGetQueryBufferObjectui64v(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()> {
		let ret = process_catch("glGetQueryBufferObjectui64v", catch_unwind(||(self.version_4_5.getquerybufferobjectui64v)(id, buffer, pname, offset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryBufferObjectui64v", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetQueryBufferObjectuiv.xhtml>
	#[inline(always)]
	fn glGetQueryBufferObjectuiv(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()> {
		let ret = process_catch("glGetQueryBufferObjectuiv", catch_unwind(||(self.version_4_5.getquerybufferobjectuiv)(id, buffer, pname, offset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryBufferObjectuiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMemoryBarrierByRegion.xhtml>
	#[inline(always)]
	fn glMemoryBarrierByRegion(&self, barriers: GLbitfield) -> Result<()> {
		let ret = process_catch("glMemoryBarrierByRegion", catch_unwind(||(self.version_4_5.memorybarrierbyregion)(barriers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMemoryBarrierByRegion", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetTextureSubImage.xhtml>
	#[inline(always)]
	fn glGetTextureSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetTextureSubImage", catch_unwind(||(self.version_4_5.gettexturesubimage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureSubImage", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetCompressedTextureSubImage.xhtml>
	#[inline(always)]
	fn glGetCompressedTextureSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetCompressedTextureSubImage", catch_unwind(||(self.version_4_5.getcompressedtexturesubimage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetCompressedTextureSubImage", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetGraphicsResetStatus.xhtml>
	#[inline(always)]
	fn glGetGraphicsResetStatus(&self) -> Result<GLenum> {
		let ret = process_catch("glGetGraphicsResetStatus", catch_unwind(||(self.version_4_5.getgraphicsresetstatus)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetGraphicsResetStatus", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnCompressedTexImage.xhtml>
	#[inline(always)]
	fn glGetnCompressedTexImage(&self, target: GLenum, lod: GLint, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnCompressedTexImage", catch_unwind(||(self.version_4_5.getncompressedteximage)(target, lod, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnCompressedTexImage", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnTexImage.xhtml>
	#[inline(always)]
	fn glGetnTexImage(&self, target: GLenum, level: GLint, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnTexImage", catch_unwind(||(self.version_4_5.getnteximage)(target, level, format, type_, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnTexImage", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnUniformdv.xhtml>
	#[inline(always)]
	fn glGetnUniformdv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetnUniformdv", catch_unwind(||(self.version_4_5.getnuniformdv)(program, location, bufSize, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnUniformdv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnUniformfv.xhtml>
	#[inline(always)]
	fn glGetnUniformfv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetnUniformfv", catch_unwind(||(self.version_4_5.getnuniformfv)(program, location, bufSize, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnUniformfv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnUniformiv.xhtml>
	#[inline(always)]
	fn glGetnUniformiv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetnUniformiv", catch_unwind(||(self.version_4_5.getnuniformiv)(program, location, bufSize, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnUniformiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnUniformuiv.xhtml>
	#[inline(always)]
	fn glGetnUniformuiv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetnUniformuiv", catch_unwind(||(self.version_4_5.getnuniformuiv)(program, location, bufSize, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnUniformuiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glReadnPixels.xhtml>
	#[inline(always)]
	fn glReadnPixels(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, bufSize: GLsizei, data: *mut c_void) -> Result<()> {
		let ret = process_catch("glReadnPixels", catch_unwind(||(self.version_4_5.readnpixels)(x, y, width, height, format, type_, bufSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glReadnPixels", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnMapdv.xhtml>
	#[inline(always)]
	fn glGetnMapdv(&self, target: GLenum, query: GLenum, bufSize: GLsizei, v: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetnMapdv", catch_unwind(||(self.version_4_5.getnmapdv)(target, query, bufSize, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnMapdv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnMapfv.xhtml>
	#[inline(always)]
	fn glGetnMapfv(&self, target: GLenum, query: GLenum, bufSize: GLsizei, v: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetnMapfv", catch_unwind(||(self.version_4_5.getnmapfv)(target, query, bufSize, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnMapfv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnMapiv.xhtml>
	#[inline(always)]
	fn glGetnMapiv(&self, target: GLenum, query: GLenum, bufSize: GLsizei, v: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetnMapiv", catch_unwind(||(self.version_4_5.getnmapiv)(target, query, bufSize, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnMapiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnPixelMapfv.xhtml>
	#[inline(always)]
	fn glGetnPixelMapfv(&self, map: GLenum, bufSize: GLsizei, values: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetnPixelMapfv", catch_unwind(||(self.version_4_5.getnpixelmapfv)(map, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnPixelMapfv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnPixelMapuiv.xhtml>
	#[inline(always)]
	fn glGetnPixelMapuiv(&self, map: GLenum, bufSize: GLsizei, values: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetnPixelMapuiv", catch_unwind(||(self.version_4_5.getnpixelmapuiv)(map, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnPixelMapuiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnPixelMapusv.xhtml>
	#[inline(always)]
	fn glGetnPixelMapusv(&self, map: GLenum, bufSize: GLsizei, values: *mut GLushort) -> Result<()> {
		let ret = process_catch("glGetnPixelMapusv", catch_unwind(||(self.version_4_5.getnpixelmapusv)(map, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnPixelMapusv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnPolygonStipple.xhtml>
	#[inline(always)]
	fn glGetnPolygonStipple(&self, bufSize: GLsizei, pattern: *mut GLubyte) -> Result<()> {
		let ret = process_catch("glGetnPolygonStipple", catch_unwind(||(self.version_4_5.getnpolygonstipple)(bufSize, pattern)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnPolygonStipple", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnColorTable.xhtml>
	#[inline(always)]
	fn glGetnColorTable(&self, target: GLenum, format: GLenum, type_: GLenum, bufSize: GLsizei, table: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnColorTable", catch_unwind(||(self.version_4_5.getncolortable)(target, format, type_, bufSize, table)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnColorTable", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnConvolutionFilter.xhtml>
	#[inline(always)]
	fn glGetnConvolutionFilter(&self, target: GLenum, format: GLenum, type_: GLenum, bufSize: GLsizei, image: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnConvolutionFilter", catch_unwind(||(self.version_4_5.getnconvolutionfilter)(target, format, type_, bufSize, image)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnConvolutionFilter", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnSeparableFilter.xhtml>
	#[inline(always)]
	fn glGetnSeparableFilter(&self, target: GLenum, format: GLenum, type_: GLenum, rowBufSize: GLsizei, row: *mut c_void, columnBufSize: GLsizei, column: *mut c_void, span: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnSeparableFilter", catch_unwind(||(self.version_4_5.getnseparablefilter)(target, format, type_, rowBufSize, row, columnBufSize, column, span)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnSeparableFilter", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnHistogram.xhtml>
	#[inline(always)]
	fn glGetnHistogram(&self, target: GLenum, reset: GLboolean, format: GLenum, type_: GLenum, bufSize: GLsizei, values: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnHistogram", catch_unwind(||(self.version_4_5.getnhistogram)(target, reset, format, type_, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnHistogram", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetnMinmax.xhtml>
	#[inline(always)]
	fn glGetnMinmax(&self, target: GLenum, reset: GLboolean, format: GLenum, type_: GLenum, bufSize: GLsizei, values: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnMinmax", catch_unwind(||(self.version_4_5.getnminmax)(target, reset, format, type_, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnMinmax", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTextureBarrier.xhtml>
	#[inline(always)]
	fn glTextureBarrier(&self) -> Result<()> {
		let ret = process_catch("glTextureBarrier", catch_unwind(||(self.version_4_5.texturebarrier)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureBarrier", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_4_6 for GLCore {
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml>
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_4_6.geterror)()
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glSpecializeShader.xhtml>
	#[inline(always)]
	fn glSpecializeShader(&self, shader: GLuint, pEntryPoint: *const GLchar, numSpecializationConstants: GLuint, pConstantIndex: *const GLuint, pConstantValue: *const GLuint) -> Result<()> {
		let ret = process_catch("glSpecializeShader", catch_unwind(||(self.version_4_6.specializeshader)(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSpecializeShader", ret, (self.version_4_6.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawArraysIndirectCount.xhtml>
	#[inline(always)]
	fn glMultiDrawArraysIndirectCount(&self, mode: GLenum, indirect: *const c_void, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawArraysIndirectCount", catch_unwind(||(self.version_4_6.multidrawarraysindirectcount)(mode, indirect, drawcount, maxdrawcount, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawArraysIndirectCount", ret, (self.version_4_6.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glMultiDrawElementsIndirectCount.xhtml>
	#[inline(always)]
	fn glMultiDrawElementsIndirectCount(&self, mode: GLenum, type_: GLenum, indirect: *const c_void, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawElementsIndirectCount", catch_unwind(||(self.version_4_6.multidrawelementsindirectcount)(mode, type_, indirect, drawcount, maxdrawcount, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawElementsIndirectCount", ret, (self.version_4_6.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	/// Reference: <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glPolygonOffsetClamp.xhtml>
	#[inline(always)]
	fn glPolygonOffsetClamp(&self, factor: GLfloat, units: GLfloat, clamp: GLfloat) -> Result<()> {
		let ret = process_catch("glPolygonOffsetClamp", catch_unwind(||(self.version_4_6.polygonoffsetclamp)(factor, units, clamp)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPolygonOffsetClamp", ret, (self.version_4_6.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GLCore {
	pub fn new(mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Result<Self> {
		let version_1_0 = Version10::new(&mut get_proc_address)?;
		if !version_1_0.available {
			return Ok(Self::default());
		}
		Ok(Self {
			version_1_0,
			version_1_1: Version11::new(version_1_0, &mut get_proc_address),
			version_1_2: Version12::new(version_1_0, &mut get_proc_address),
			version_1_3: Version13::new(version_1_0, &mut get_proc_address),
			version_1_4: Version14::new(version_1_0, &mut get_proc_address),
			version_1_5: Version15::new(version_1_0, &mut get_proc_address),
			version_2_0: Version20::new(version_1_0, &mut get_proc_address),
			version_2_1: Version21::new(version_1_0, &mut get_proc_address),
			version_3_0: Version30::new(version_1_0, &mut get_proc_address),
			version_3_1: Version31::new(version_1_0, &mut get_proc_address),
			version_3_2: Version32::new(version_1_0, &mut get_proc_address),
			version_3_3: Version33::new(version_1_0, &mut get_proc_address),
			version_4_0: Version40::new(version_1_0, &mut get_proc_address),
			version_4_1: Version41::new(version_1_0, &mut get_proc_address),
			version_4_2: Version42::new(version_1_0, &mut get_proc_address),
			version_4_3: Version43::new(version_1_0, &mut get_proc_address),
			version_4_4: Version44::new(version_1_0, &mut get_proc_address),
			version_4_5: Version45::new(version_1_0, &mut get_proc_address),
			version_4_6: Version46::new(version_1_0, &mut get_proc_address),
		})
	}
}

impl Default for GLCore {
	fn default() -> Self {
		Self {
			version_1_0: Version10::default(),
			version_1_1: Version11::default(),
			version_1_2: Version12::default(),
			version_1_3: Version13::default(),
			version_1_4: Version14::default(),
			version_1_5: Version15::default(),
			version_2_0: Version20::default(),
			version_2_1: Version21::default(),
			version_3_0: Version30::default(),
			version_3_1: Version31::default(),
			version_3_2: Version32::default(),
			version_3_3: Version33::default(),
			version_4_0: Version40::default(),
			version_4_1: Version41::default(),
			version_4_2: Version42::default(),
			version_4_3: Version43::default(),
			version_4_4: Version44::default(),
			version_4_5: Version45::default(),
			version_4_6: Version46::default(),
		}
	}
}

