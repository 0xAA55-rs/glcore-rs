
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(unpredictable_function_pointer_comparisons)]
use std::{
	mem::transmute,
	ffi::{c_void, CStr},
	fmt::{self, Debug, Formatter},
	panic::catch_unwind,
	ptr::null,
};

#[derive(Debug, Clone, Copy)]
pub enum GLCoreError {
	NullFunctionPointer(&'static str),
	InvalidEnum(&'static str),
	InvalidValue(&'static str),
	InvalidOperation(&'static str),
	InvalidFramebufferOperation(&'static str),
	OutOfMemory(&'static str),
	StackUnderflow(&'static str),
	StackOverflow(&'static str),
	UnknownError((GLenum, &'static str)),
}

pub type Result<T> = std::result::Result<T, GLCoreError>;
pub fn to_result<T>(funcname: &'static str, ret: T, gl_error: GLenum) -> Result<T> {
	match gl_error {
		GL_NO_ERROR => Ok(ret),
		GL_INVALID_ENUM => Err(GLCoreError::InvalidEnum(funcname)),
		GL_INVALID_VALUE => Err(GLCoreError::InvalidValue(funcname)),
		GL_INVALID_OPERATION => Err(GLCoreError::InvalidOperation(funcname)),
		GL_INVALID_FRAMEBUFFER_OPERATION => Err(GLCoreError::InvalidFramebufferOperation(funcname)),
		GL_OUT_OF_MEMORY => Err(GLCoreError::OutOfMemory(funcname)),
		GL_STACK_UNDERFLOW => Err(GLCoreError::StackUnderflow(funcname)),
		GL_STACK_OVERFLOW => Err(GLCoreError::StackOverflow(funcname)),
		_ => Err(GLCoreError::UnknownError((gl_error, funcname))),
	}
}

pub fn process_catch<T>(funcname: &'static str, ret: std::thread::Result<T>) -> Result<T> {
	match ret {
		Ok(ret) => Ok(ret),
		Err(_) => {
			Err(GLCoreError::NullFunctionPointer(funcname))
		}
	}
}

pub type khronos_float_t = f32;
pub type khronos_ssize_t = usize;
pub type khronos_intptr_t = usize;
pub type khronos_int16_t = i16;
pub type khronos_int8_t = i8;
pub type khronos_uint16_t = u16;
pub type khronos_int64_t = i64;
pub type khronos_uint64_t = u64;

pub type GLDEBUGPROC = extern "system" fn(GLenum, GLenum, GLuint, GLenum, GLsizei, *const GLchar, *const c_void);

pub type GLvoid = c_void;
pub type GLenum = u32;
pub type GLbitfield = u32;
pub type GLuint = u32;
pub type GLfloat = f32;
pub type GLint = i32;
pub type GLsizei = i32;
pub type GLdouble = f64;
pub type GLboolean = u8;
pub type GLubyte = u8;
pub type GLshort = i16;
pub type GLbyte = i8;
pub type GLushort = u16;
type PFNGLCULLFACEPROC = extern "system" fn(GLenum);
type PFNGLFRONTFACEPROC = extern "system" fn(GLenum);
type PFNGLHINTPROC = extern "system" fn(GLenum, GLenum);
type PFNGLLINEWIDTHPROC = extern "system" fn(GLfloat);
type PFNGLPOINTSIZEPROC = extern "system" fn(GLfloat);
type PFNGLPOLYGONMODEPROC = extern "system" fn(GLenum, GLenum);
type PFNGLSCISSORPROC = extern "system" fn(GLint, GLint, GLsizei, GLsizei);
type PFNGLTEXPARAMETERFPROC = extern "system" fn(GLenum, GLenum, GLfloat);
type PFNGLTEXPARAMETERFVPROC = extern "system" fn(GLenum, GLenum, *const GLfloat);
type PFNGLTEXPARAMETERIPROC = extern "system" fn(GLenum, GLenum, GLint);
type PFNGLTEXPARAMETERIVPROC = extern "system" fn(GLenum, GLenum, *const GLint);
type PFNGLTEXIMAGE1DPROC = extern "system" fn(GLenum, GLint, GLint, GLsizei, GLint, GLenum, GLenum, *const c_void);
type PFNGLTEXIMAGE2DPROC = extern "system" fn(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, *const c_void);
type PFNGLDRAWBUFFERPROC = extern "system" fn(GLenum);
type PFNGLCLEARPROC = extern "system" fn(GLbitfield);
type PFNGLCLEARCOLORPROC = extern "system" fn(GLfloat, GLfloat, GLfloat, GLfloat);
type PFNGLCLEARSTENCILPROC = extern "system" fn(GLint);
type PFNGLCLEARDEPTHPROC = extern "system" fn(GLdouble);
type PFNGLSTENCILMASKPROC = extern "system" fn(GLuint);
type PFNGLCOLORMASKPROC = extern "system" fn(GLboolean, GLboolean, GLboolean, GLboolean);
type PFNGLDEPTHMASKPROC = extern "system" fn(GLboolean);
type PFNGLDISABLEPROC = extern "system" fn(GLenum);
type PFNGLENABLEPROC = extern "system" fn(GLenum);
type PFNGLFINISHPROC = extern "system" fn();
type PFNGLFLUSHPROC = extern "system" fn();
type PFNGLBLENDFUNCPROC = extern "system" fn(GLenum, GLenum);
type PFNGLLOGICOPPROC = extern "system" fn(GLenum);
type PFNGLSTENCILFUNCPROC = extern "system" fn(GLenum, GLint, GLuint);
type PFNGLSTENCILOPPROC = extern "system" fn(GLenum, GLenum, GLenum);
type PFNGLDEPTHFUNCPROC = extern "system" fn(GLenum);
type PFNGLPIXELSTOREFPROC = extern "system" fn(GLenum, GLfloat);
type PFNGLPIXELSTOREIPROC = extern "system" fn(GLenum, GLint);
type PFNGLREADBUFFERPROC = extern "system" fn(GLenum);
type PFNGLREADPIXELSPROC = extern "system" fn(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, *mut c_void);
type PFNGLGETBOOLEANVPROC = extern "system" fn(GLenum, *mut GLboolean);
type PFNGLGETDOUBLEVPROC = extern "system" fn(GLenum, *mut GLdouble);
type PFNGLGETERRORPROC = extern "system" fn() -> GLenum;
type PFNGLGETFLOATVPROC = extern "system" fn(GLenum, *mut GLfloat);
type PFNGLGETINTEGERVPROC = extern "system" fn(GLenum, *mut GLint);
type PFNGLGETSTRINGPROC = extern "system" fn(GLenum) -> *const GLubyte;
type PFNGLGETTEXIMAGEPROC = extern "system" fn(GLenum, GLint, GLenum, GLenum, *mut c_void);
type PFNGLGETTEXPARAMETERFVPROC = extern "system" fn(GLenum, GLenum, *mut GLfloat);
type PFNGLGETTEXPARAMETERIVPROC = extern "system" fn(GLenum, GLenum, *mut GLint);
type PFNGLGETTEXLEVELPARAMETERFVPROC = extern "system" fn(GLenum, GLint, GLenum, *mut GLfloat);
type PFNGLGETTEXLEVELPARAMETERIVPROC = extern "system" fn(GLenum, GLint, GLenum, *mut GLint);
type PFNGLISENABLEDPROC = extern "system" fn(GLenum) -> GLboolean;
type PFNGLDEPTHRANGEPROC = extern "system" fn(GLdouble, GLdouble);
type PFNGLVIEWPORTPROC = extern "system" fn(GLint, GLint, GLsizei, GLsizei);
extern "system" fn dummy_pfnglcullfaceproc (_: GLenum) {
	panic!("OpenGL function pointer `glCullFace()` is null.")
}
extern "system" fn dummy_pfnglfrontfaceproc (_: GLenum) {
	panic!("OpenGL function pointer `glFrontFace()` is null.")
}
extern "system" fn dummy_pfnglhintproc (_: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glHint()` is null.")
}
extern "system" fn dummy_pfngllinewidthproc (_: GLfloat) {
	panic!("OpenGL function pointer `glLineWidth()` is null.")
}
extern "system" fn dummy_pfnglpointsizeproc (_: GLfloat) {
	panic!("OpenGL function pointer `glPointSize()` is null.")
}
extern "system" fn dummy_pfnglpolygonmodeproc (_: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glPolygonMode()` is null.")
}
extern "system" fn dummy_pfnglscissorproc (_: GLint, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glScissor()` is null.")
}
extern "system" fn dummy_pfngltexparameterfproc (_: GLenum, _: GLenum, _: GLfloat) {
	panic!("OpenGL function pointer `glTexParameterf()` is null.")
}
extern "system" fn dummy_pfngltexparameterfvproc (_: GLenum, _: GLenum, _: *const GLfloat) {
	panic!("OpenGL function pointer `glTexParameterfv()` is null.")
}
extern "system" fn dummy_pfngltexparameteriproc (_: GLenum, _: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glTexParameteri()` is null.")
}
extern "system" fn dummy_pfngltexparameterivproc (_: GLenum, _: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glTexParameteriv()` is null.")
}
extern "system" fn dummy_pfnglteximage1dproc (_: GLenum, _: GLint, _: GLint, _: GLsizei, _: GLint, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glTexImage1D()` is null.")
}
extern "system" fn dummy_pfnglteximage2dproc (_: GLenum, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLint, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glTexImage2D()` is null.")
}
extern "system" fn dummy_pfngldrawbufferproc (_: GLenum) {
	panic!("OpenGL function pointer `glDrawBuffer()` is null.")
}
extern "system" fn dummy_pfnglclearproc (_: GLbitfield) {
	panic!("OpenGL function pointer `glClear()` is null.")
}
extern "system" fn dummy_pfnglclearcolorproc (_: GLfloat, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glClearColor()` is null.")
}
extern "system" fn dummy_pfnglclearstencilproc (_: GLint) {
	panic!("OpenGL function pointer `glClearStencil()` is null.")
}
extern "system" fn dummy_pfnglcleardepthproc (_: GLdouble) {
	panic!("OpenGL function pointer `glClearDepth()` is null.")
}
extern "system" fn dummy_pfnglstencilmaskproc (_: GLuint) {
	panic!("OpenGL function pointer `glStencilMask()` is null.")
}
extern "system" fn dummy_pfnglcolormaskproc (_: GLboolean, _: GLboolean, _: GLboolean, _: GLboolean) {
	panic!("OpenGL function pointer `glColorMask()` is null.")
}
extern "system" fn dummy_pfngldepthmaskproc (_: GLboolean) {
	panic!("OpenGL function pointer `glDepthMask()` is null.")
}
extern "system" fn dummy_pfngldisableproc (_: GLenum) {
	panic!("OpenGL function pointer `glDisable()` is null.")
}
extern "system" fn dummy_pfnglenableproc (_: GLenum) {
	panic!("OpenGL function pointer `glEnable()` is null.")
}
extern "system" fn dummy_pfnglfinishproc () {
	panic!("OpenGL function pointer `glFinish()` is null.")
}
extern "system" fn dummy_pfnglflushproc () {
	panic!("OpenGL function pointer `glFlush()` is null.")
}
extern "system" fn dummy_pfnglblendfuncproc (_: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glBlendFunc()` is null.")
}
extern "system" fn dummy_pfngllogicopproc (_: GLenum) {
	panic!("OpenGL function pointer `glLogicOp()` is null.")
}
extern "system" fn dummy_pfnglstencilfuncproc (_: GLenum, _: GLint, _: GLuint) {
	panic!("OpenGL function pointer `glStencilFunc()` is null.")
}
extern "system" fn dummy_pfnglstencilopproc (_: GLenum, _: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glStencilOp()` is null.")
}
extern "system" fn dummy_pfngldepthfuncproc (_: GLenum) {
	panic!("OpenGL function pointer `glDepthFunc()` is null.")
}
extern "system" fn dummy_pfnglpixelstorefproc (_: GLenum, _: GLfloat) {
	panic!("OpenGL function pointer `glPixelStoref()` is null.")
}
extern "system" fn dummy_pfnglpixelstoreiproc (_: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glPixelStorei()` is null.")
}
extern "system" fn dummy_pfnglreadbufferproc (_: GLenum) {
	panic!("OpenGL function pointer `glReadBuffer()` is null.")
}
extern "system" fn dummy_pfnglreadpixelsproc (_: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLenum, _: GLenum, _: *mut c_void) {
	panic!("OpenGL function pointer `glReadPixels()` is null.")
}
extern "system" fn dummy_pfnglgetbooleanvproc (_: GLenum, _: *mut GLboolean) {
	panic!("OpenGL function pointer `glGetBooleanv()` is null.")
}
extern "system" fn dummy_pfnglgetdoublevproc (_: GLenum, _: *mut GLdouble) {
	panic!("OpenGL function pointer `glGetDoublev()` is null.")
}
extern "system" fn dummy_pfnglgeterrorproc () -> GLenum {
	panic!("OpenGL function pointer `glGetError()` is null.")
}
extern "system" fn dummy_pfnglgetfloatvproc (_: GLenum, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetFloatv()` is null.")
}
extern "system" fn dummy_pfnglgetintegervproc (_: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetIntegerv()` is null.")
}
extern "system" fn dummy_pfnglgetstringproc (_: GLenum) -> *const GLubyte {
	panic!("OpenGL function pointer `glGetString()` is null.")
}
extern "system" fn dummy_pfnglgetteximageproc (_: GLenum, _: GLint, _: GLenum, _: GLenum, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetTexImage()` is null.")
}
extern "system" fn dummy_pfnglgettexparameterfvproc (_: GLenum, _: GLenum, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetTexParameterfv()` is null.")
}
extern "system" fn dummy_pfnglgettexparameterivproc (_: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetTexParameteriv()` is null.")
}
extern "system" fn dummy_pfnglgettexlevelparameterfvproc (_: GLenum, _: GLint, _: GLenum, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetTexLevelParameterfv()` is null.")
}
extern "system" fn dummy_pfnglgettexlevelparameterivproc (_: GLenum, _: GLint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetTexLevelParameteriv()` is null.")
}
extern "system" fn dummy_pfnglisenabledproc (_: GLenum) -> GLboolean {
	panic!("OpenGL function pointer `glIsEnabled()` is null.")
}
extern "system" fn dummy_pfngldepthrangeproc (_: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glDepthRange()` is null.")
}
extern "system" fn dummy_pfnglviewportproc (_: GLint, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glViewport()` is null.")
}
pub const GL_DEPTH_BUFFER_BIT: GLbitfield = 0x00000100;
pub const GL_STENCIL_BUFFER_BIT: GLbitfield = 0x00000400;
pub const GL_COLOR_BUFFER_BIT: GLbitfield = 0x00004000;
pub const GL_FALSE: GLenum = 0;
pub const GL_TRUE: GLenum = 1;
pub const GL_POINTS: GLenum = 0x0000;
pub const GL_LINES: GLenum = 0x0001;
pub const GL_LINE_LOOP: GLenum = 0x0002;
pub const GL_LINE_STRIP: GLenum = 0x0003;
pub const GL_TRIANGLES: GLenum = 0x0004;
pub const GL_TRIANGLE_STRIP: GLenum = 0x0005;
pub const GL_TRIANGLE_FAN: GLenum = 0x0006;
pub const GL_QUADS: GLenum = 0x0007;
pub const GL_NEVER: GLenum = 0x0200;
pub const GL_LESS: GLenum = 0x0201;
pub const GL_EQUAL: GLenum = 0x0202;
pub const GL_LEQUAL: GLenum = 0x0203;
pub const GL_GREATER: GLenum = 0x0204;
pub const GL_NOTEQUAL: GLenum = 0x0205;
pub const GL_GEQUAL: GLenum = 0x0206;
pub const GL_ALWAYS: GLenum = 0x0207;
pub const GL_ZERO: GLenum = 0;
pub const GL_ONE: GLenum = 1;
pub const GL_SRC_COLOR: GLenum = 0x0300;
pub const GL_ONE_MINUS_SRC_COLOR: GLenum = 0x0301;
pub const GL_SRC_ALPHA: GLenum = 0x0302;
pub const GL_ONE_MINUS_SRC_ALPHA: GLenum = 0x0303;
pub const GL_DST_ALPHA: GLenum = 0x0304;
pub const GL_ONE_MINUS_DST_ALPHA: GLenum = 0x0305;
pub const GL_DST_COLOR: GLenum = 0x0306;
pub const GL_ONE_MINUS_DST_COLOR: GLenum = 0x0307;
pub const GL_SRC_ALPHA_SATURATE: GLenum = 0x0308;
pub const GL_NONE: GLenum = 0;
pub const GL_FRONT_LEFT: GLenum = 0x0400;
pub const GL_FRONT_RIGHT: GLenum = 0x0401;
pub const GL_BACK_LEFT: GLenum = 0x0402;
pub const GL_BACK_RIGHT: GLenum = 0x0403;
pub const GL_FRONT: GLenum = 0x0404;
pub const GL_BACK: GLenum = 0x0405;
pub const GL_LEFT: GLenum = 0x0406;
pub const GL_RIGHT: GLenum = 0x0407;
pub const GL_FRONT_AND_BACK: GLenum = 0x0408;
pub const GL_NO_ERROR: GLenum = 0;
pub const GL_INVALID_ENUM: GLenum = 0x0500;
pub const GL_INVALID_VALUE: GLenum = 0x0501;
pub const GL_INVALID_OPERATION: GLenum = 0x0502;
pub const GL_OUT_OF_MEMORY: GLenum = 0x0505;
pub const GL_CW: GLenum = 0x0900;
pub const GL_CCW: GLenum = 0x0901;
pub const GL_POINT_SIZE: GLenum = 0x0B11;
pub const GL_POINT_SIZE_RANGE: GLenum = 0x0B12;
pub const GL_POINT_SIZE_GRANULARITY: GLenum = 0x0B13;
pub const GL_LINE_SMOOTH: GLenum = 0x0B20;
pub const GL_LINE_WIDTH: GLenum = 0x0B21;
pub const GL_LINE_WIDTH_RANGE: GLenum = 0x0B22;
pub const GL_LINE_WIDTH_GRANULARITY: GLenum = 0x0B23;
pub const GL_POLYGON_MODE: GLenum = 0x0B40;
pub const GL_POLYGON_SMOOTH: GLenum = 0x0B41;
pub const GL_CULL_FACE: GLenum = 0x0B44;
pub const GL_CULL_FACE_MODE: GLenum = 0x0B45;
pub const GL_FRONT_FACE: GLenum = 0x0B46;
pub const GL_DEPTH_RANGE: GLenum = 0x0B70;
pub const GL_DEPTH_TEST: GLenum = 0x0B71;
pub const GL_DEPTH_WRITEMASK: GLenum = 0x0B72;
pub const GL_DEPTH_CLEAR_VALUE: GLenum = 0x0B73;
pub const GL_DEPTH_FUNC: GLenum = 0x0B74;
pub const GL_STENCIL_TEST: GLenum = 0x0B90;
pub const GL_STENCIL_CLEAR_VALUE: GLenum = 0x0B91;
pub const GL_STENCIL_FUNC: GLenum = 0x0B92;
pub const GL_STENCIL_VALUE_MASK: GLenum = 0x0B93;
pub const GL_STENCIL_FAIL: GLenum = 0x0B94;
pub const GL_STENCIL_PASS_DEPTH_FAIL: GLenum = 0x0B95;
pub const GL_STENCIL_PASS_DEPTH_PASS: GLenum = 0x0B96;
pub const GL_STENCIL_REF: GLenum = 0x0B97;
pub const GL_STENCIL_WRITEMASK: GLenum = 0x0B98;
pub const GL_VIEWPORT: GLenum = 0x0BA2;
pub const GL_DITHER: GLenum = 0x0BD0;
pub const GL_BLEND_DST: GLenum = 0x0BE0;
pub const GL_BLEND_SRC: GLenum = 0x0BE1;
pub const GL_BLEND: GLenum = 0x0BE2;
pub const GL_LOGIC_OP_MODE: GLenum = 0x0BF0;
pub const GL_DRAW_BUFFER: GLenum = 0x0C01;
pub const GL_READ_BUFFER: GLenum = 0x0C02;
pub const GL_SCISSOR_BOX: GLenum = 0x0C10;
pub const GL_SCISSOR_TEST: GLenum = 0x0C11;
pub const GL_COLOR_CLEAR_VALUE: GLenum = 0x0C22;
pub const GL_COLOR_WRITEMASK: GLenum = 0x0C23;
pub const GL_DOUBLEBUFFER: GLenum = 0x0C32;
pub const GL_STEREO: GLenum = 0x0C33;
pub const GL_LINE_SMOOTH_HINT: GLenum = 0x0C52;
pub const GL_POLYGON_SMOOTH_HINT: GLenum = 0x0C53;
pub const GL_UNPACK_SWAP_BYTES: GLenum = 0x0CF0;
pub const GL_UNPACK_LSB_FIRST: GLenum = 0x0CF1;
pub const GL_UNPACK_ROW_LENGTH: GLenum = 0x0CF2;
pub const GL_UNPACK_SKIP_ROWS: GLenum = 0x0CF3;
pub const GL_UNPACK_SKIP_PIXELS: GLenum = 0x0CF4;
pub const GL_UNPACK_ALIGNMENT: GLenum = 0x0CF5;
pub const GL_PACK_SWAP_BYTES: GLenum = 0x0D00;
pub const GL_PACK_LSB_FIRST: GLenum = 0x0D01;
pub const GL_PACK_ROW_LENGTH: GLenum = 0x0D02;
pub const GL_PACK_SKIP_ROWS: GLenum = 0x0D03;
pub const GL_PACK_SKIP_PIXELS: GLenum = 0x0D04;
pub const GL_PACK_ALIGNMENT: GLenum = 0x0D05;
pub const GL_MAX_TEXTURE_SIZE: GLenum = 0x0D33;
pub const GL_MAX_VIEWPORT_DIMS: GLenum = 0x0D3A;
pub const GL_SUBPIXEL_BITS: GLenum = 0x0D50;
pub const GL_TEXTURE_1D: GLenum = 0x0DE0;
pub const GL_TEXTURE_2D: GLenum = 0x0DE1;
pub const GL_TEXTURE_WIDTH: GLenum = 0x1000;
pub const GL_TEXTURE_HEIGHT: GLenum = 0x1001;
pub const GL_TEXTURE_BORDER_COLOR: GLenum = 0x1004;
pub const GL_DONT_CARE: GLenum = 0x1100;
pub const GL_FASTEST: GLenum = 0x1101;
pub const GL_NICEST: GLenum = 0x1102;
pub const GL_BYTE: GLenum = 0x1400;
pub const GL_UNSIGNED_BYTE: GLenum = 0x1401;
pub const GL_SHORT: GLenum = 0x1402;
pub const GL_UNSIGNED_SHORT: GLenum = 0x1403;
pub const GL_INT: GLenum = 0x1404;
pub const GL_UNSIGNED_INT: GLenum = 0x1405;
pub const GL_FLOAT: GLenum = 0x1406;
pub const GL_STACK_OVERFLOW: GLenum = 0x0503;
pub const GL_STACK_UNDERFLOW: GLenum = 0x0504;
pub const GL_CLEAR: GLenum = 0x1500;
pub const GL_AND: GLenum = 0x1501;
pub const GL_AND_REVERSE: GLenum = 0x1502;
pub const GL_COPY: GLenum = 0x1503;
pub const GL_AND_INVERTED: GLenum = 0x1504;
pub const GL_NOOP: GLenum = 0x1505;
pub const GL_XOR: GLenum = 0x1506;
pub const GL_OR: GLenum = 0x1507;
pub const GL_NOR: GLenum = 0x1508;
pub const GL_EQUIV: GLenum = 0x1509;
pub const GL_INVERT: GLenum = 0x150A;
pub const GL_OR_REVERSE: GLenum = 0x150B;
pub const GL_COPY_INVERTED: GLenum = 0x150C;
pub const GL_OR_INVERTED: GLenum = 0x150D;
pub const GL_NAND: GLenum = 0x150E;
pub const GL_SET: GLenum = 0x150F;
pub const GL_TEXTURE: GLenum = 0x1702;
pub const GL_COLOR: GLenum = 0x1800;
pub const GL_DEPTH: GLenum = 0x1801;
pub const GL_STENCIL: GLenum = 0x1802;
pub const GL_STENCIL_INDEX: GLenum = 0x1901;
pub const GL_DEPTH_COMPONENT: GLenum = 0x1902;
pub const GL_RED: GLenum = 0x1903;
pub const GL_GREEN: GLenum = 0x1904;
pub const GL_BLUE: GLenum = 0x1905;
pub const GL_ALPHA: GLenum = 0x1906;
pub const GL_RGB: GLenum = 0x1907;
pub const GL_RGBA: GLenum = 0x1908;
pub const GL_POINT: GLenum = 0x1B00;
pub const GL_LINE: GLenum = 0x1B01;
pub const GL_FILL: GLenum = 0x1B02;
pub const GL_KEEP: GLenum = 0x1E00;
pub const GL_REPLACE: GLenum = 0x1E01;
pub const GL_INCR: GLenum = 0x1E02;
pub const GL_DECR: GLenum = 0x1E03;
pub const GL_VENDOR: GLenum = 0x1F00;
pub const GL_RENDERER: GLenum = 0x1F01;
pub const GL_VERSION: GLenum = 0x1F02;
pub const GL_EXTENSIONS: GLenum = 0x1F03;
pub const GL_NEAREST: GLint = 0x2600;
pub const GL_LINEAR: GLint = 0x2601;
pub const GL_NEAREST_MIPMAP_NEAREST: GLint = 0x2700;
pub const GL_LINEAR_MIPMAP_NEAREST: GLint = 0x2701;
pub const GL_NEAREST_MIPMAP_LINEAR: GLint = 0x2702;
pub const GL_LINEAR_MIPMAP_LINEAR: GLint = 0x2703;
pub const GL_TEXTURE_MAG_FILTER: GLenum = 0x2800;
pub const GL_TEXTURE_MIN_FILTER: GLenum = 0x2801;
pub const GL_TEXTURE_WRAP_S: GLenum = 0x2802;
pub const GL_TEXTURE_WRAP_T: GLenum = 0x2803;
pub const GL_REPEAT: GLint = 0x2901;

pub trait GL_1_0 {
	fn glCullFace(&self, mode: GLenum) -> Result<()>;
	fn glFrontFace(&self, mode: GLenum) -> Result<()>;
	fn glHint(&self, target: GLenum, mode: GLenum) -> Result<()>;
	fn glLineWidth(&self, width: GLfloat) -> Result<()>;
	fn glPointSize(&self, size: GLfloat) -> Result<()>;
	fn glPolygonMode(&self, face: GLenum, mode: GLenum) -> Result<()>;
	fn glScissor(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()>;
	fn glTexParameterf(&self, target: GLenum, pname: GLenum, param: GLfloat) -> Result<()>;
	fn glTexParameterfv(&self, target: GLenum, pname: GLenum, params: *const GLfloat) -> Result<()>;
	fn glTexParameteri(&self, target: GLenum, pname: GLenum, param: GLint) -> Result<()>;
	fn glTexParameteriv(&self, target: GLenum, pname: GLenum, params: *const GLint) -> Result<()>;
	fn glTexImage1D(&self, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()>;
	fn glTexImage2D(&self, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()>;
	fn glDrawBuffer(&self, buf: GLenum) -> Result<()>;
	fn glClear(&self, mask: GLbitfield) -> Result<()>;
	fn glClearColor(&self, red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) -> Result<()>;
	fn glClearStencil(&self, s: GLint) -> Result<()>;
	fn glClearDepth(&self, depth: GLdouble) -> Result<()>;
	fn glStencilMask(&self, mask: GLuint) -> Result<()>;
	fn glColorMask(&self, red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean) -> Result<()>;
	fn glDepthMask(&self, flag: GLboolean) -> Result<()>;
	fn glDisable(&self, cap: GLenum) -> Result<()>;
	fn glEnable(&self, cap: GLenum) -> Result<()>;
	fn glFinish(&self) -> Result<()>;
	fn glFlush(&self) -> Result<()>;
	fn glBlendFunc(&self, sfactor: GLenum, dfactor: GLenum) -> Result<()>;
	fn glLogicOp(&self, opcode: GLenum) -> Result<()>;
	fn glStencilFunc(&self, func: GLenum, ref_: GLint, mask: GLuint) -> Result<()>;
	fn glStencilOp(&self, fail: GLenum, zfail: GLenum, zpass: GLenum) -> Result<()>;
	fn glDepthFunc(&self, func: GLenum) -> Result<()>;
	fn glPixelStoref(&self, pname: GLenum, param: GLfloat) -> Result<()>;
	fn glPixelStorei(&self, pname: GLenum, param: GLint) -> Result<()>;
	fn glReadBuffer(&self, src: GLenum) -> Result<()>;
	fn glReadPixels(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *mut c_void) -> Result<()>;
	fn glGetBooleanv(&self, pname: GLenum, data: *mut GLboolean) -> Result<()>;
	fn glGetDoublev(&self, pname: GLenum, data: *mut GLdouble) -> Result<()>;
	fn glGetError(&self) -> GLenum;
	fn glGetFloatv(&self, pname: GLenum, data: *mut GLfloat) -> Result<()>;
	fn glGetIntegerv(&self, pname: GLenum, data: *mut GLint) -> Result<()>;
	fn glGetString(&self, name: GLenum) -> Result<&'static str>;
	fn glGetTexImage(&self, target: GLenum, level: GLint, format: GLenum, type_: GLenum, pixels: *mut c_void) -> Result<()>;
	fn glGetTexParameterfv(&self, target: GLenum, pname: GLenum, params: *mut GLfloat) -> Result<()>;
	fn glGetTexParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glGetTexLevelParameterfv(&self, target: GLenum, level: GLint, pname: GLenum, params: *mut GLfloat) -> Result<()>;
	fn glGetTexLevelParameteriv(&self, target: GLenum, level: GLint, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glIsEnabled(&self, cap: GLenum) -> Result<GLboolean>;
	fn glDepthRange(&self, n: GLdouble, f: GLdouble) -> Result<()>;
	fn glViewport(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()>;
	fn get_version(&self) -> (&'static str, u32, u32, u32);
	fn get_vendor(&self) -> &'static str;
	fn get_renderer(&self) -> &'static str;
	fn get_versionstr(&self) -> &'static str;
}

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version10 {
	spec: &'static str,
	major_version: u32,
	minor_version: u32,
	release_version: u32,
	vendor: &'static str,
	renderer: &'static str,
	version: &'static str,
	available: bool,
	cullface: PFNGLCULLFACEPROC,
	frontface: PFNGLFRONTFACEPROC,
	hint: PFNGLHINTPROC,
	linewidth: PFNGLLINEWIDTHPROC,
	pointsize: PFNGLPOINTSIZEPROC,
	polygonmode: PFNGLPOLYGONMODEPROC,
	scissor: PFNGLSCISSORPROC,
	texparameterf: PFNGLTEXPARAMETERFPROC,
	texparameterfv: PFNGLTEXPARAMETERFVPROC,
	texparameteri: PFNGLTEXPARAMETERIPROC,
	texparameteriv: PFNGLTEXPARAMETERIVPROC,
	teximage1d: PFNGLTEXIMAGE1DPROC,
	teximage2d: PFNGLTEXIMAGE2DPROC,
	drawbuffer: PFNGLDRAWBUFFERPROC,
	clear: PFNGLCLEARPROC,
	clearcolor: PFNGLCLEARCOLORPROC,
	clearstencil: PFNGLCLEARSTENCILPROC,
	cleardepth: PFNGLCLEARDEPTHPROC,
	stencilmask: PFNGLSTENCILMASKPROC,
	colormask: PFNGLCOLORMASKPROC,
	depthmask: PFNGLDEPTHMASKPROC,
	disable: PFNGLDISABLEPROC,
	enable: PFNGLENABLEPROC,
	finish: PFNGLFINISHPROC,
	flush: PFNGLFLUSHPROC,
	blendfunc: PFNGLBLENDFUNCPROC,
	logicop: PFNGLLOGICOPPROC,
	stencilfunc: PFNGLSTENCILFUNCPROC,
	stencilop: PFNGLSTENCILOPPROC,
	depthfunc: PFNGLDEPTHFUNCPROC,
	pixelstoref: PFNGLPIXELSTOREFPROC,
	pixelstorei: PFNGLPIXELSTOREIPROC,
	readbuffer: PFNGLREADBUFFERPROC,
	readpixels: PFNGLREADPIXELSPROC,
	getbooleanv: PFNGLGETBOOLEANVPROC,
	getdoublev: PFNGLGETDOUBLEVPROC,
	geterror: PFNGLGETERRORPROC,
	getfloatv: PFNGLGETFLOATVPROC,
	getintegerv: PFNGLGETINTEGERVPROC,
	getstring: PFNGLGETSTRINGPROC,
	getteximage: PFNGLGETTEXIMAGEPROC,
	gettexparameterfv: PFNGLGETTEXPARAMETERFVPROC,
	gettexparameteriv: PFNGLGETTEXPARAMETERIVPROC,
	gettexlevelparameterfv: PFNGLGETTEXLEVELPARAMETERFVPROC,
	gettexlevelparameteriv: PFNGLGETTEXLEVELPARAMETERIVPROC,
	isenabled: PFNGLISENABLEDPROC,
	depthrange: PFNGLDEPTHRANGEPROC,
	viewport: PFNGLVIEWPORTPROC,
}

impl GL_1_0 for Version10 {
	#[inline(always)]
	fn glCullFace(&self, mode: GLenum) -> Result<()> {
		let ret = process_catch("glCullFace", catch_unwind(||(self.cullface)(mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCullFace", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFrontFace(&self, mode: GLenum) -> Result<()> {
		let ret = process_catch("glFrontFace", catch_unwind(||(self.frontface)(mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFrontFace", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glHint(&self, target: GLenum, mode: GLenum) -> Result<()> {
		let ret = process_catch("glHint", catch_unwind(||(self.hint)(target, mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glHint", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glLineWidth(&self, width: GLfloat) -> Result<()> {
		let ret = process_catch("glLineWidth", catch_unwind(||(self.linewidth)(width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLineWidth", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPointSize(&self, size: GLfloat) -> Result<()> {
		let ret = process_catch("glPointSize", catch_unwind(||(self.pointsize)(size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointSize", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPolygonMode(&self, face: GLenum, mode: GLenum) -> Result<()> {
		let ret = process_catch("glPolygonMode", catch_unwind(||(self.polygonmode)(face, mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPolygonMode", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glScissor(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glScissor", catch_unwind(||(self.scissor)(x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glScissor", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexParameterf(&self, target: GLenum, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glTexParameterf", catch_unwind(||(self.texparameterf)(target, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameterf", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexParameterfv(&self, target: GLenum, pname: GLenum, params: *const GLfloat) -> Result<()> {
		let ret = process_catch("glTexParameterfv", catch_unwind(||(self.texparameterfv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexParameteri(&self, target: GLenum, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glTexParameteri", catch_unwind(||(self.texparameteri)(target, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameteri", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexParameteriv(&self, target: GLenum, pname: GLenum, params: *const GLint) -> Result<()> {
		let ret = process_catch("glTexParameteriv", catch_unwind(||(self.texparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexImage1D(&self, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexImage1D", catch_unwind(||(self.teximage1d)(target, level, internalformat, width, border, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexImage2D(&self, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexImage2D", catch_unwind(||(self.teximage2d)(target, level, internalformat, width, height, border, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawBuffer(&self, buf: GLenum) -> Result<()> {
		let ret = process_catch("glDrawBuffer", catch_unwind(||(self.drawbuffer)(buf)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClear(&self, mask: GLbitfield) -> Result<()> {
		let ret = process_catch("glClear", catch_unwind(||(self.clear)(mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClear", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearColor(&self, red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) -> Result<()> {
		let ret = process_catch("glClearColor", catch_unwind(||(self.clearcolor)(red, green, blue, alpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearColor", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearStencil(&self, s: GLint) -> Result<()> {
		let ret = process_catch("glClearStencil", catch_unwind(||(self.clearstencil)(s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearStencil", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearDepth(&self, depth: GLdouble) -> Result<()> {
		let ret = process_catch("glClearDepth", catch_unwind(||(self.cleardepth)(depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearDepth", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glStencilMask(&self, mask: GLuint) -> Result<()> {
		let ret = process_catch("glStencilMask", catch_unwind(||(self.stencilmask)(mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilMask", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glColorMask(&self, red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean) -> Result<()> {
		let ret = process_catch("glColorMask", catch_unwind(||(self.colormask)(red, green, blue, alpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorMask", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDepthMask(&self, flag: GLboolean) -> Result<()> {
		let ret = process_catch("glDepthMask", catch_unwind(||(self.depthmask)(flag)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthMask", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDisable(&self, cap: GLenum) -> Result<()> {
		let ret = process_catch("glDisable", catch_unwind(||(self.disable)(cap)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDisable", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glEnable(&self, cap: GLenum) -> Result<()> {
		let ret = process_catch("glEnable", catch_unwind(||(self.enable)(cap)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEnable", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFinish(&self) -> Result<()> {
		let ret = process_catch("glFinish", catch_unwind(||(self.finish)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFinish", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFlush(&self) -> Result<()> {
		let ret = process_catch("glFlush", catch_unwind(||(self.flush)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFlush", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBlendFunc(&self, sfactor: GLenum, dfactor: GLenum) -> Result<()> {
		let ret = process_catch("glBlendFunc", catch_unwind(||(self.blendfunc)(sfactor, dfactor)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendFunc", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glLogicOp(&self, opcode: GLenum) -> Result<()> {
		let ret = process_catch("glLogicOp", catch_unwind(||(self.logicop)(opcode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLogicOp", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glStencilFunc(&self, func: GLenum, ref_: GLint, mask: GLuint) -> Result<()> {
		let ret = process_catch("glStencilFunc", catch_unwind(||(self.stencilfunc)(func, ref_, mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilFunc", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glStencilOp(&self, fail: GLenum, zfail: GLenum, zpass: GLenum) -> Result<()> {
		let ret = process_catch("glStencilOp", catch_unwind(||(self.stencilop)(fail, zfail, zpass)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilOp", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDepthFunc(&self, func: GLenum) -> Result<()> {
		let ret = process_catch("glDepthFunc", catch_unwind(||(self.depthfunc)(func)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthFunc", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPixelStoref(&self, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glPixelStoref", catch_unwind(||(self.pixelstoref)(pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPixelStoref", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPixelStorei(&self, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glPixelStorei", catch_unwind(||(self.pixelstorei)(pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPixelStorei", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glReadBuffer(&self, src: GLenum) -> Result<()> {
		let ret = process_catch("glReadBuffer", catch_unwind(||(self.readbuffer)(src)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glReadBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glReadPixels(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glReadPixels", catch_unwind(||(self.readpixels)(x, y, width, height, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glReadPixels", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetBooleanv(&self, pname: GLenum, data: *mut GLboolean) -> Result<()> {
		let ret = process_catch("glGetBooleanv", catch_unwind(||(self.getbooleanv)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBooleanv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetDoublev(&self, pname: GLenum, data: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetDoublev", catch_unwind(||(self.getdoublev)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetDoublev", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	#[inline(always)]
	fn glGetFloatv(&self, pname: GLenum, data: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetFloatv", catch_unwind(||(self.getfloatv)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFloatv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetIntegerv(&self, pname: GLenum, data: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetIntegerv", catch_unwind(||(self.getintegerv)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetIntegerv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetString(&self, name: GLenum) -> Result<&'static str> {
		let ret = process_catch("glGetString", catch_unwind(||unsafe{CStr::from_ptr((self.getstring)(name) as *const i8)}.to_str().unwrap()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetString", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTexImage(&self, target: GLenum, level: GLint, format: GLenum, type_: GLenum, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetTexImage", catch_unwind(||(self.getteximage)(target, level, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTexParameterfv(&self, target: GLenum, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetTexParameterfv", catch_unwind(||(self.gettexparameterfv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTexParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTexParameteriv", catch_unwind(||(self.gettexparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTexLevelParameterfv(&self, target: GLenum, level: GLint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetTexLevelParameterfv", catch_unwind(||(self.gettexlevelparameterfv)(target, level, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexLevelParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTexLevelParameteriv(&self, target: GLenum, level: GLint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTexLevelParameteriv", catch_unwind(||(self.gettexlevelparameteriv)(target, level, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexLevelParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsEnabled(&self, cap: GLenum) -> Result<GLboolean> {
		let ret = process_catch("glIsEnabled", catch_unwind(||(self.isenabled)(cap)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsEnabled", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDepthRange(&self, n: GLdouble, f: GLdouble) -> Result<()> {
		let ret = process_catch("glDepthRange", catch_unwind(||(self.depthrange)(n, f)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glViewport(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glViewport", catch_unwind(||(self.viewport)(x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glViewport", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn get_version(&self) -> (&'static str, u32, u32, u32) {
		(self.spec, self.major_version, self.minor_version, self.release_version)
	}
	#[inline(always)]
	fn get_vendor(&self) -> &'static str {
		self.vendor
	}
	#[inline(always)]
	fn get_renderer(&self) -> &'static str {
		self.renderer
	}
	#[inline(always)]
	fn get_versionstr(&self) -> &'static str {
		self.version
	}
}

impl Version10 {
	pub fn new(mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Result<Self> {
		let mut ret = Self {
			available: true,
			spec: "unknown",
			major_version: 0,
			minor_version: 0,
			release_version: 0,
			vendor: "unknown",
			renderer: "unknown",
			version: "unknown",
			cullface: {let proc = get_proc_address("glCullFace"); if proc == null() {dummy_pfnglcullfaceproc} else {unsafe{transmute(proc)}}},
			frontface: {let proc = get_proc_address("glFrontFace"); if proc == null() {dummy_pfnglfrontfaceproc} else {unsafe{transmute(proc)}}},
			hint: {let proc = get_proc_address("glHint"); if proc == null() {dummy_pfnglhintproc} else {unsafe{transmute(proc)}}},
			linewidth: {let proc = get_proc_address("glLineWidth"); if proc == null() {dummy_pfngllinewidthproc} else {unsafe{transmute(proc)}}},
			pointsize: {let proc = get_proc_address("glPointSize"); if proc == null() {dummy_pfnglpointsizeproc} else {unsafe{transmute(proc)}}},
			polygonmode: {let proc = get_proc_address("glPolygonMode"); if proc == null() {dummy_pfnglpolygonmodeproc} else {unsafe{transmute(proc)}}},
			scissor: {let proc = get_proc_address("glScissor"); if proc == null() {dummy_pfnglscissorproc} else {unsafe{transmute(proc)}}},
			texparameterf: {let proc = get_proc_address("glTexParameterf"); if proc == null() {dummy_pfngltexparameterfproc} else {unsafe{transmute(proc)}}},
			texparameterfv: {let proc = get_proc_address("glTexParameterfv"); if proc == null() {dummy_pfngltexparameterfvproc} else {unsafe{transmute(proc)}}},
			texparameteri: {let proc = get_proc_address("glTexParameteri"); if proc == null() {dummy_pfngltexparameteriproc} else {unsafe{transmute(proc)}}},
			texparameteriv: {let proc = get_proc_address("glTexParameteriv"); if proc == null() {dummy_pfngltexparameterivproc} else {unsafe{transmute(proc)}}},
			teximage1d: {let proc = get_proc_address("glTexImage1D"); if proc == null() {dummy_pfnglteximage1dproc} else {unsafe{transmute(proc)}}},
			teximage2d: {let proc = get_proc_address("glTexImage2D"); if proc == null() {dummy_pfnglteximage2dproc} else {unsafe{transmute(proc)}}},
			drawbuffer: {let proc = get_proc_address("glDrawBuffer"); if proc == null() {dummy_pfngldrawbufferproc} else {unsafe{transmute(proc)}}},
			clear: {let proc = get_proc_address("glClear"); if proc == null() {dummy_pfnglclearproc} else {unsafe{transmute(proc)}}},
			clearcolor: {let proc = get_proc_address("glClearColor"); if proc == null() {dummy_pfnglclearcolorproc} else {unsafe{transmute(proc)}}},
			clearstencil: {let proc = get_proc_address("glClearStencil"); if proc == null() {dummy_pfnglclearstencilproc} else {unsafe{transmute(proc)}}},
			cleardepth: {let proc = get_proc_address("glClearDepth"); if proc == null() {dummy_pfnglcleardepthproc} else {unsafe{transmute(proc)}}},
			stencilmask: {let proc = get_proc_address("glStencilMask"); if proc == null() {dummy_pfnglstencilmaskproc} else {unsafe{transmute(proc)}}},
			colormask: {let proc = get_proc_address("glColorMask"); if proc == null() {dummy_pfnglcolormaskproc} else {unsafe{transmute(proc)}}},
			depthmask: {let proc = get_proc_address("glDepthMask"); if proc == null() {dummy_pfngldepthmaskproc} else {unsafe{transmute(proc)}}},
			disable: {let proc = get_proc_address("glDisable"); if proc == null() {dummy_pfngldisableproc} else {unsafe{transmute(proc)}}},
			enable: {let proc = get_proc_address("glEnable"); if proc == null() {dummy_pfnglenableproc} else {unsafe{transmute(proc)}}},
			finish: {let proc = get_proc_address("glFinish"); if proc == null() {dummy_pfnglfinishproc} else {unsafe{transmute(proc)}}},
			flush: {let proc = get_proc_address("glFlush"); if proc == null() {dummy_pfnglflushproc} else {unsafe{transmute(proc)}}},
			blendfunc: {let proc = get_proc_address("glBlendFunc"); if proc == null() {dummy_pfnglblendfuncproc} else {unsafe{transmute(proc)}}},
			logicop: {let proc = get_proc_address("glLogicOp"); if proc == null() {dummy_pfngllogicopproc} else {unsafe{transmute(proc)}}},
			stencilfunc: {let proc = get_proc_address("glStencilFunc"); if proc == null() {dummy_pfnglstencilfuncproc} else {unsafe{transmute(proc)}}},
			stencilop: {let proc = get_proc_address("glStencilOp"); if proc == null() {dummy_pfnglstencilopproc} else {unsafe{transmute(proc)}}},
			depthfunc: {let proc = get_proc_address("glDepthFunc"); if proc == null() {dummy_pfngldepthfuncproc} else {unsafe{transmute(proc)}}},
			pixelstoref: {let proc = get_proc_address("glPixelStoref"); if proc == null() {dummy_pfnglpixelstorefproc} else {unsafe{transmute(proc)}}},
			pixelstorei: {let proc = get_proc_address("glPixelStorei"); if proc == null() {dummy_pfnglpixelstoreiproc} else {unsafe{transmute(proc)}}},
			readbuffer: {let proc = get_proc_address("glReadBuffer"); if proc == null() {dummy_pfnglreadbufferproc} else {unsafe{transmute(proc)}}},
			readpixels: {let proc = get_proc_address("glReadPixels"); if proc == null() {dummy_pfnglreadpixelsproc} else {unsafe{transmute(proc)}}},
			getbooleanv: {let proc = get_proc_address("glGetBooleanv"); if proc == null() {dummy_pfnglgetbooleanvproc} else {unsafe{transmute(proc)}}},
			getdoublev: {let proc = get_proc_address("glGetDoublev"); if proc == null() {dummy_pfnglgetdoublevproc} else {unsafe{transmute(proc)}}},
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			getfloatv: {let proc = get_proc_address("glGetFloatv"); if proc == null() {dummy_pfnglgetfloatvproc} else {unsafe{transmute(proc)}}},
			getintegerv: {let proc = get_proc_address("glGetIntegerv"); if proc == null() {dummy_pfnglgetintegervproc} else {unsafe{transmute(proc)}}},
			getstring: {let proc = get_proc_address("glGetString"); if proc == null() {dummy_pfnglgetstringproc} else {unsafe{transmute(proc)}}},
			getteximage: {let proc = get_proc_address("glGetTexImage"); if proc == null() {dummy_pfnglgetteximageproc} else {unsafe{transmute(proc)}}},
			gettexparameterfv: {let proc = get_proc_address("glGetTexParameterfv"); if proc == null() {dummy_pfnglgettexparameterfvproc} else {unsafe{transmute(proc)}}},
			gettexparameteriv: {let proc = get_proc_address("glGetTexParameteriv"); if proc == null() {dummy_pfnglgettexparameterivproc} else {unsafe{transmute(proc)}}},
			gettexlevelparameterfv: {let proc = get_proc_address("glGetTexLevelParameterfv"); if proc == null() {dummy_pfnglgettexlevelparameterfvproc} else {unsafe{transmute(proc)}}},
			gettexlevelparameteriv: {let proc = get_proc_address("glGetTexLevelParameteriv"); if proc == null() {dummy_pfnglgettexlevelparameterivproc} else {unsafe{transmute(proc)}}},
			isenabled: {let proc = get_proc_address("glIsEnabled"); if proc == null() {dummy_pfnglisenabledproc} else {unsafe{transmute(proc)}}},
			depthrange: {let proc = get_proc_address("glDepthRange"); if proc == null() {dummy_pfngldepthrangeproc} else {unsafe{transmute(proc)}}},
			viewport: {let proc = get_proc_address("glViewport"); if proc == null() {dummy_pfnglviewportproc} else {unsafe{transmute(proc)}}},
		};
		ret.fetch_version()?;
		Ok(ret)
	}
	#[inline(always)]
	fn fetch_version(&mut self) -> Result<()> {
		self.vendor = self.glGetString(GL_VENDOR)?;
		self.renderer = self.glGetString(GL_RENDERER)?;
		self.version = self.glGetString(GL_VERSION)?;
		self.spec = "OpenGL";
		let mut verstr = self.version;
		if verstr.starts_with("OpenGL ES ") {
			verstr = &verstr["OpenGL ES ".len()..];
			self.spec = "OpenGL ES ";
		} else if let Some((left, right)) = verstr.split_once(' ') {
			verstr = left;
			self.spec = right;
		}
		let mut v: Vec<&str> = verstr.split('.').collect();
		v.resize(3, "0");
		v = v.into_iter().map(|x|if x == "" {"0"} else {x}).collect();
		self.major_version = v[0].parse().unwrap();
		self.minor_version = v[1].parse().unwrap();
		self.release_version = v[2].parse().unwrap();
		Ok(())
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version10 {
	fn default() -> Self {
		Self {
			available: false,
			spec: "unknown",
			major_version: 0,
			minor_version: 0,
			release_version: 0,
			vendor: "unknown",
			renderer: "unknown",
			version: "unknown",
			cullface: dummy_pfnglcullfaceproc,
			frontface: dummy_pfnglfrontfaceproc,
			hint: dummy_pfnglhintproc,
			linewidth: dummy_pfngllinewidthproc,
			pointsize: dummy_pfnglpointsizeproc,
			polygonmode: dummy_pfnglpolygonmodeproc,
			scissor: dummy_pfnglscissorproc,
			texparameterf: dummy_pfngltexparameterfproc,
			texparameterfv: dummy_pfngltexparameterfvproc,
			texparameteri: dummy_pfngltexparameteriproc,
			texparameteriv: dummy_pfngltexparameterivproc,
			teximage1d: dummy_pfnglteximage1dproc,
			teximage2d: dummy_pfnglteximage2dproc,
			drawbuffer: dummy_pfngldrawbufferproc,
			clear: dummy_pfnglclearproc,
			clearcolor: dummy_pfnglclearcolorproc,
			clearstencil: dummy_pfnglclearstencilproc,
			cleardepth: dummy_pfnglcleardepthproc,
			stencilmask: dummy_pfnglstencilmaskproc,
			colormask: dummy_pfnglcolormaskproc,
			depthmask: dummy_pfngldepthmaskproc,
			disable: dummy_pfngldisableproc,
			enable: dummy_pfnglenableproc,
			finish: dummy_pfnglfinishproc,
			flush: dummy_pfnglflushproc,
			blendfunc: dummy_pfnglblendfuncproc,
			logicop: dummy_pfngllogicopproc,
			stencilfunc: dummy_pfnglstencilfuncproc,
			stencilop: dummy_pfnglstencilopproc,
			depthfunc: dummy_pfngldepthfuncproc,
			pixelstoref: dummy_pfnglpixelstorefproc,
			pixelstorei: dummy_pfnglpixelstoreiproc,
			readbuffer: dummy_pfnglreadbufferproc,
			readpixels: dummy_pfnglreadpixelsproc,
			getbooleanv: dummy_pfnglgetbooleanvproc,
			getdoublev: dummy_pfnglgetdoublevproc,
			geterror: dummy_pfnglgeterrorproc,
			getfloatv: dummy_pfnglgetfloatvproc,
			getintegerv: dummy_pfnglgetintegervproc,
			getstring: dummy_pfnglgetstringproc,
			getteximage: dummy_pfnglgetteximageproc,
			gettexparameterfv: dummy_pfnglgettexparameterfvproc,
			gettexparameteriv: dummy_pfnglgettexparameterivproc,
			gettexlevelparameterfv: dummy_pfnglgettexlevelparameterfvproc,
			gettexlevelparameteriv: dummy_pfnglgettexlevelparameterivproc,
			isenabled: dummy_pfnglisenabledproc,
			depthrange: dummy_pfngldepthrangeproc,
			viewport: dummy_pfnglviewportproc,
		}
	}
}
impl Debug for Version10 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version10")
			.field("available", &self.available)
			.field("spec", &self.spec)
			.field("major_version", &self.major_version)
			.field("minor_version", &self.minor_version)
			.field("release_version", &self.release_version)
			.field("vendor", &self.vendor)
			.field("renderer", &self.renderer)
			.field("version", &self.version)
			.field("cullface", unsafe{if transmute::<_, *const c_void>(self.cullface) == (dummy_pfnglcullfaceproc as *const c_void) {&null::<PFNGLCULLFACEPROC>()} else {&self.cullface}})
			.field("frontface", unsafe{if transmute::<_, *const c_void>(self.frontface) == (dummy_pfnglfrontfaceproc as *const c_void) {&null::<PFNGLFRONTFACEPROC>()} else {&self.frontface}})
			.field("hint", unsafe{if transmute::<_, *const c_void>(self.hint) == (dummy_pfnglhintproc as *const c_void) {&null::<PFNGLHINTPROC>()} else {&self.hint}})
			.field("linewidth", unsafe{if transmute::<_, *const c_void>(self.linewidth) == (dummy_pfngllinewidthproc as *const c_void) {&null::<PFNGLLINEWIDTHPROC>()} else {&self.linewidth}})
			.field("pointsize", unsafe{if transmute::<_, *const c_void>(self.pointsize) == (dummy_pfnglpointsizeproc as *const c_void) {&null::<PFNGLPOINTSIZEPROC>()} else {&self.pointsize}})
			.field("polygonmode", unsafe{if transmute::<_, *const c_void>(self.polygonmode) == (dummy_pfnglpolygonmodeproc as *const c_void) {&null::<PFNGLPOLYGONMODEPROC>()} else {&self.polygonmode}})
			.field("scissor", unsafe{if transmute::<_, *const c_void>(self.scissor) == (dummy_pfnglscissorproc as *const c_void) {&null::<PFNGLSCISSORPROC>()} else {&self.scissor}})
			.field("texparameterf", unsafe{if transmute::<_, *const c_void>(self.texparameterf) == (dummy_pfngltexparameterfproc as *const c_void) {&null::<PFNGLTEXPARAMETERFPROC>()} else {&self.texparameterf}})
			.field("texparameterfv", unsafe{if transmute::<_, *const c_void>(self.texparameterfv) == (dummy_pfngltexparameterfvproc as *const c_void) {&null::<PFNGLTEXPARAMETERFVPROC>()} else {&self.texparameterfv}})
			.field("texparameteri", unsafe{if transmute::<_, *const c_void>(self.texparameteri) == (dummy_pfngltexparameteriproc as *const c_void) {&null::<PFNGLTEXPARAMETERIPROC>()} else {&self.texparameteri}})
			.field("texparameteriv", unsafe{if transmute::<_, *const c_void>(self.texparameteriv) == (dummy_pfngltexparameterivproc as *const c_void) {&null::<PFNGLTEXPARAMETERIVPROC>()} else {&self.texparameteriv}})
			.field("teximage1d", unsafe{if transmute::<_, *const c_void>(self.teximage1d) == (dummy_pfnglteximage1dproc as *const c_void) {&null::<PFNGLTEXIMAGE1DPROC>()} else {&self.teximage1d}})
			.field("teximage2d", unsafe{if transmute::<_, *const c_void>(self.teximage2d) == (dummy_pfnglteximage2dproc as *const c_void) {&null::<PFNGLTEXIMAGE2DPROC>()} else {&self.teximage2d}})
			.field("drawbuffer", unsafe{if transmute::<_, *const c_void>(self.drawbuffer) == (dummy_pfngldrawbufferproc as *const c_void) {&null::<PFNGLDRAWBUFFERPROC>()} else {&self.drawbuffer}})
			.field("clear", unsafe{if transmute::<_, *const c_void>(self.clear) == (dummy_pfnglclearproc as *const c_void) {&null::<PFNGLCLEARPROC>()} else {&self.clear}})
			.field("clearcolor", unsafe{if transmute::<_, *const c_void>(self.clearcolor) == (dummy_pfnglclearcolorproc as *const c_void) {&null::<PFNGLCLEARCOLORPROC>()} else {&self.clearcolor}})
			.field("clearstencil", unsafe{if transmute::<_, *const c_void>(self.clearstencil) == (dummy_pfnglclearstencilproc as *const c_void) {&null::<PFNGLCLEARSTENCILPROC>()} else {&self.clearstencil}})
			.field("cleardepth", unsafe{if transmute::<_, *const c_void>(self.cleardepth) == (dummy_pfnglcleardepthproc as *const c_void) {&null::<PFNGLCLEARDEPTHPROC>()} else {&self.cleardepth}})
			.field("stencilmask", unsafe{if transmute::<_, *const c_void>(self.stencilmask) == (dummy_pfnglstencilmaskproc as *const c_void) {&null::<PFNGLSTENCILMASKPROC>()} else {&self.stencilmask}})
			.field("colormask", unsafe{if transmute::<_, *const c_void>(self.colormask) == (dummy_pfnglcolormaskproc as *const c_void) {&null::<PFNGLCOLORMASKPROC>()} else {&self.colormask}})
			.field("depthmask", unsafe{if transmute::<_, *const c_void>(self.depthmask) == (dummy_pfngldepthmaskproc as *const c_void) {&null::<PFNGLDEPTHMASKPROC>()} else {&self.depthmask}})
			.field("disable", unsafe{if transmute::<_, *const c_void>(self.disable) == (dummy_pfngldisableproc as *const c_void) {&null::<PFNGLDISABLEPROC>()} else {&self.disable}})
			.field("enable", unsafe{if transmute::<_, *const c_void>(self.enable) == (dummy_pfnglenableproc as *const c_void) {&null::<PFNGLENABLEPROC>()} else {&self.enable}})
			.field("finish", unsafe{if transmute::<_, *const c_void>(self.finish) == (dummy_pfnglfinishproc as *const c_void) {&null::<PFNGLFINISHPROC>()} else {&self.finish}})
			.field("flush", unsafe{if transmute::<_, *const c_void>(self.flush) == (dummy_pfnglflushproc as *const c_void) {&null::<PFNGLFLUSHPROC>()} else {&self.flush}})
			.field("blendfunc", unsafe{if transmute::<_, *const c_void>(self.blendfunc) == (dummy_pfnglblendfuncproc as *const c_void) {&null::<PFNGLBLENDFUNCPROC>()} else {&self.blendfunc}})
			.field("logicop", unsafe{if transmute::<_, *const c_void>(self.logicop) == (dummy_pfngllogicopproc as *const c_void) {&null::<PFNGLLOGICOPPROC>()} else {&self.logicop}})
			.field("stencilfunc", unsafe{if transmute::<_, *const c_void>(self.stencilfunc) == (dummy_pfnglstencilfuncproc as *const c_void) {&null::<PFNGLSTENCILFUNCPROC>()} else {&self.stencilfunc}})
			.field("stencilop", unsafe{if transmute::<_, *const c_void>(self.stencilop) == (dummy_pfnglstencilopproc as *const c_void) {&null::<PFNGLSTENCILOPPROC>()} else {&self.stencilop}})
			.field("depthfunc", unsafe{if transmute::<_, *const c_void>(self.depthfunc) == (dummy_pfngldepthfuncproc as *const c_void) {&null::<PFNGLDEPTHFUNCPROC>()} else {&self.depthfunc}})
			.field("pixelstoref", unsafe{if transmute::<_, *const c_void>(self.pixelstoref) == (dummy_pfnglpixelstorefproc as *const c_void) {&null::<PFNGLPIXELSTOREFPROC>()} else {&self.pixelstoref}})
			.field("pixelstorei", unsafe{if transmute::<_, *const c_void>(self.pixelstorei) == (dummy_pfnglpixelstoreiproc as *const c_void) {&null::<PFNGLPIXELSTOREIPROC>()} else {&self.pixelstorei}})
			.field("readbuffer", unsafe{if transmute::<_, *const c_void>(self.readbuffer) == (dummy_pfnglreadbufferproc as *const c_void) {&null::<PFNGLREADBUFFERPROC>()} else {&self.readbuffer}})
			.field("readpixels", unsafe{if transmute::<_, *const c_void>(self.readpixels) == (dummy_pfnglreadpixelsproc as *const c_void) {&null::<PFNGLREADPIXELSPROC>()} else {&self.readpixels}})
			.field("getbooleanv", unsafe{if transmute::<_, *const c_void>(self.getbooleanv) == (dummy_pfnglgetbooleanvproc as *const c_void) {&null::<PFNGLGETBOOLEANVPROC>()} else {&self.getbooleanv}})
			.field("getdoublev", unsafe{if transmute::<_, *const c_void>(self.getdoublev) == (dummy_pfnglgetdoublevproc as *const c_void) {&null::<PFNGLGETDOUBLEVPROC>()} else {&self.getdoublev}})
			.field("geterror", unsafe{if transmute::<_, *const c_void>(self.geterror) == (dummy_pfnglgeterrorproc as *const c_void) {&null::<PFNGLGETERRORPROC>()} else {&self.geterror}})
			.field("getfloatv", unsafe{if transmute::<_, *const c_void>(self.getfloatv) == (dummy_pfnglgetfloatvproc as *const c_void) {&null::<PFNGLGETFLOATVPROC>()} else {&self.getfloatv}})
			.field("getintegerv", unsafe{if transmute::<_, *const c_void>(self.getintegerv) == (dummy_pfnglgetintegervproc as *const c_void) {&null::<PFNGLGETINTEGERVPROC>()} else {&self.getintegerv}})
			.field("getstring", unsafe{if transmute::<_, *const c_void>(self.getstring) == (dummy_pfnglgetstringproc as *const c_void) {&null::<PFNGLGETSTRINGPROC>()} else {&self.getstring}})
			.field("getteximage", unsafe{if transmute::<_, *const c_void>(self.getteximage) == (dummy_pfnglgetteximageproc as *const c_void) {&null::<PFNGLGETTEXIMAGEPROC>()} else {&self.getteximage}})
			.field("gettexparameterfv", unsafe{if transmute::<_, *const c_void>(self.gettexparameterfv) == (dummy_pfnglgettexparameterfvproc as *const c_void) {&null::<PFNGLGETTEXPARAMETERFVPROC>()} else {&self.gettexparameterfv}})
			.field("gettexparameteriv", unsafe{if transmute::<_, *const c_void>(self.gettexparameteriv) == (dummy_pfnglgettexparameterivproc as *const c_void) {&null::<PFNGLGETTEXPARAMETERIVPROC>()} else {&self.gettexparameteriv}})
			.field("gettexlevelparameterfv", unsafe{if transmute::<_, *const c_void>(self.gettexlevelparameterfv) == (dummy_pfnglgettexlevelparameterfvproc as *const c_void) {&null::<PFNGLGETTEXLEVELPARAMETERFVPROC>()} else {&self.gettexlevelparameterfv}})
			.field("gettexlevelparameteriv", unsafe{if transmute::<_, *const c_void>(self.gettexlevelparameteriv) == (dummy_pfnglgettexlevelparameterivproc as *const c_void) {&null::<PFNGLGETTEXLEVELPARAMETERIVPROC>()} else {&self.gettexlevelparameteriv}})
			.field("isenabled", unsafe{if transmute::<_, *const c_void>(self.isenabled) == (dummy_pfnglisenabledproc as *const c_void) {&null::<PFNGLISENABLEDPROC>()} else {&self.isenabled}})
			.field("depthrange", unsafe{if transmute::<_, *const c_void>(self.depthrange) == (dummy_pfngldepthrangeproc as *const c_void) {&null::<PFNGLDEPTHRANGEPROC>()} else {&self.depthrange}})
			.field("viewport", unsafe{if transmute::<_, *const c_void>(self.viewport) == (dummy_pfnglviewportproc as *const c_void) {&null::<PFNGLVIEWPORTPROC>()} else {&self.viewport}})
			.finish()
		} else {
			f.debug_struct("Version10")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}
pub type GLclampf = khronos_float_t;
pub type GLclampd = f64;
type PFNGLDRAWARRAYSPROC = extern "system" fn(GLenum, GLint, GLsizei);
type PFNGLDRAWELEMENTSPROC = extern "system" fn(GLenum, GLsizei, GLenum, *const c_void);
type PFNGLGETPOINTERVPROC = extern "system" fn(GLenum, *mut *mut c_void);
type PFNGLPOLYGONOFFSETPROC = extern "system" fn(GLfloat, GLfloat);
type PFNGLCOPYTEXIMAGE1DPROC = extern "system" fn(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);
type PFNGLCOPYTEXIMAGE2DPROC = extern "system" fn(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);
type PFNGLCOPYTEXSUBIMAGE1DPROC = extern "system" fn(GLenum, GLint, GLint, GLint, GLint, GLsizei);
type PFNGLCOPYTEXSUBIMAGE2DPROC = extern "system" fn(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
type PFNGLTEXSUBIMAGE1DPROC = extern "system" fn(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, *const c_void);
type PFNGLTEXSUBIMAGE2DPROC = extern "system" fn(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, *const c_void);
type PFNGLBINDTEXTUREPROC = extern "system" fn(GLenum, GLuint);
type PFNGLDELETETEXTURESPROC = extern "system" fn(GLsizei, *const GLuint);
type PFNGLGENTEXTURESPROC = extern "system" fn(GLsizei, *mut GLuint);
type PFNGLISTEXTUREPROC = extern "system" fn(GLuint) -> GLboolean;
extern "system" fn dummy_pfngldrawarraysproc (_: GLenum, _: GLint, _: GLsizei) {
	panic!("OpenGL function pointer `glDrawArrays()` is null.")
}
extern "system" fn dummy_pfngldrawelementsproc (_: GLenum, _: GLsizei, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glDrawElements()` is null.")
}
extern "system" fn dummy_pfnglgetpointervproc (_: GLenum, _: *mut *mut c_void) {
	panic!("OpenGL function pointer `glGetPointerv()` is null.")
}
extern "system" fn dummy_pfnglpolygonoffsetproc (_: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glPolygonOffset()` is null.")
}
extern "system" fn dummy_pfnglcopyteximage1dproc (_: GLenum, _: GLint, _: GLenum, _: GLint, _: GLint, _: GLsizei, _: GLint) {
	panic!("OpenGL function pointer `glCopyTexImage1D()` is null.")
}
extern "system" fn dummy_pfnglcopyteximage2dproc (_: GLenum, _: GLint, _: GLenum, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLint) {
	panic!("OpenGL function pointer `glCopyTexImage2D()` is null.")
}
extern "system" fn dummy_pfnglcopytexsubimage1dproc (_: GLenum, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei) {
	panic!("OpenGL function pointer `glCopyTexSubImage1D()` is null.")
}
extern "system" fn dummy_pfnglcopytexsubimage2dproc (_: GLenum, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glCopyTexSubImage2D()` is null.")
}
extern "system" fn dummy_pfngltexsubimage1dproc (_: GLenum, _: GLint, _: GLint, _: GLsizei, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glTexSubImage1D()` is null.")
}
extern "system" fn dummy_pfngltexsubimage2dproc (_: GLenum, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glTexSubImage2D()` is null.")
}
extern "system" fn dummy_pfnglbindtextureproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glBindTexture()` is null.")
}
extern "system" fn dummy_pfngldeletetexturesproc (_: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glDeleteTextures()` is null.")
}
extern "system" fn dummy_pfnglgentexturesproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGenTextures()` is null.")
}
extern "system" fn dummy_pfnglistextureproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsTexture()` is null.")
}
pub const GL_COLOR_LOGIC_OP: GLenum = 0x0BF2;
pub const GL_POLYGON_OFFSET_UNITS: GLenum = 0x2A00;
pub const GL_POLYGON_OFFSET_POINT: GLenum = 0x2A01;
pub const GL_POLYGON_OFFSET_LINE: GLenum = 0x2A02;
pub const GL_POLYGON_OFFSET_FILL: GLenum = 0x8037;
pub const GL_POLYGON_OFFSET_FACTOR: GLenum = 0x8038;
pub const GL_TEXTURE_BINDING_1D: GLenum = 0x8068;
pub const GL_TEXTURE_BINDING_2D: GLenum = 0x8069;
pub const GL_TEXTURE_INTERNAL_FORMAT: GLenum = 0x1003;
pub const GL_TEXTURE_RED_SIZE: GLenum = 0x805C;
pub const GL_TEXTURE_GREEN_SIZE: GLenum = 0x805D;
pub const GL_TEXTURE_BLUE_SIZE: GLenum = 0x805E;
pub const GL_TEXTURE_ALPHA_SIZE: GLenum = 0x805F;
pub const GL_DOUBLE: GLenum = 0x140A;
pub const GL_PROXY_TEXTURE_1D: GLenum = 0x8063;
pub const GL_PROXY_TEXTURE_2D: GLenum = 0x8064;
pub const GL_R3_G3_B2: GLenum = 0x2A10;
pub const GL_RGB4: GLenum = 0x804F;
pub const GL_RGB5: GLenum = 0x8050;
pub const GL_RGB8: GLenum = 0x8051;
pub const GL_RGB10: GLenum = 0x8052;
pub const GL_RGB12: GLenum = 0x8053;
pub const GL_RGB16: GLenum = 0x8054;
pub const GL_RGBA2: GLenum = 0x8055;
pub const GL_RGBA4: GLenum = 0x8056;
pub const GL_RGB5_A1: GLenum = 0x8057;
pub const GL_RGBA8: GLenum = 0x8058;
pub const GL_RGB10_A2: GLenum = 0x8059;
pub const GL_RGBA12: GLenum = 0x805A;
pub const GL_RGBA16: GLenum = 0x805B;
pub const GL_VERTEX_ARRAY: GLenum = 0x8074;

pub trait GL_1_1 {
	fn glGetError(&self) -> GLenum;
	fn glDrawArrays(&self, mode: GLenum, first: GLint, count: GLsizei) -> Result<()>;
	fn glDrawElements(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void) -> Result<()>;
	fn glGetPointerv(&self, pname: GLenum, params: *mut *mut c_void) -> Result<()>;
	fn glPolygonOffset(&self, factor: GLfloat, units: GLfloat) -> Result<()>;
	fn glCopyTexImage1D(&self, target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, border: GLint) -> Result<()>;
	fn glCopyTexImage2D(&self, target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint) -> Result<()>;
	fn glCopyTexSubImage1D(&self, target: GLenum, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei) -> Result<()>;
	fn glCopyTexSubImage2D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()>;
	fn glTexSubImage1D(&self, target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()>;
	fn glTexSubImage2D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()>;
	fn glBindTexture(&self, target: GLenum, texture: GLuint) -> Result<()>;
	fn glDeleteTextures(&self, n: GLsizei, textures: *const GLuint) -> Result<()>;
	fn glGenTextures(&self, n: GLsizei, textures: *mut GLuint) -> Result<()>;
	fn glIsTexture(&self, texture: GLuint) -> Result<GLboolean>;
}

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version11 {
	available: bool,
	geterror: PFNGLGETERRORPROC,
	drawarrays: PFNGLDRAWARRAYSPROC,
	drawelements: PFNGLDRAWELEMENTSPROC,
	getpointerv: PFNGLGETPOINTERVPROC,
	polygonoffset: PFNGLPOLYGONOFFSETPROC,
	copyteximage1d: PFNGLCOPYTEXIMAGE1DPROC,
	copyteximage2d: PFNGLCOPYTEXIMAGE2DPROC,
	copytexsubimage1d: PFNGLCOPYTEXSUBIMAGE1DPROC,
	copytexsubimage2d: PFNGLCOPYTEXSUBIMAGE2DPROC,
	texsubimage1d: PFNGLTEXSUBIMAGE1DPROC,
	texsubimage2d: PFNGLTEXSUBIMAGE2DPROC,
	bindtexture: PFNGLBINDTEXTUREPROC,
	deletetextures: PFNGLDELETETEXTURESPROC,
	gentextures: PFNGLGENTEXTURESPROC,
	istexture: PFNGLISTEXTUREPROC,
}

impl GL_1_1 for Version11 {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	#[inline(always)]
	fn glDrawArrays(&self, mode: GLenum, first: GLint, count: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawArrays", catch_unwind(||(self.drawarrays)(mode, first, count)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawArrays", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawElements(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void) -> Result<()> {
		let ret = process_catch("glDrawElements", catch_unwind(||(self.drawelements)(mode, count, type_, indices)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElements", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetPointerv(&self, pname: GLenum, params: *mut *mut c_void) -> Result<()> {
		let ret = process_catch("glGetPointerv", catch_unwind(||(self.getpointerv)(pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetPointerv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPolygonOffset(&self, factor: GLfloat, units: GLfloat) -> Result<()> {
		let ret = process_catch("glPolygonOffset", catch_unwind(||(self.polygonoffset)(factor, units)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPolygonOffset", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyTexImage1D(&self, target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, border: GLint) -> Result<()> {
		let ret = process_catch("glCopyTexImage1D", catch_unwind(||(self.copyteximage1d)(target, level, internalformat, x, y, width, border)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexImage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyTexImage2D(&self, target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint) -> Result<()> {
		let ret = process_catch("glCopyTexImage2D", catch_unwind(||(self.copyteximage2d)(target, level, internalformat, x, y, width, height, border)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexImage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyTexSubImage1D(&self, target: GLenum, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTexSubImage1D", catch_unwind(||(self.copytexsubimage1d)(target, level, xoffset, x, y, width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexSubImage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyTexSubImage2D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTexSubImage2D", catch_unwind(||(self.copytexsubimage2d)(target, level, xoffset, yoffset, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexSubImage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexSubImage1D(&self, target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexSubImage1D", catch_unwind(||(self.texsubimage1d)(target, level, xoffset, width, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexSubImage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexSubImage2D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexSubImage2D", catch_unwind(||(self.texsubimage2d)(target, level, xoffset, yoffset, width, height, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexSubImage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindTexture(&self, target: GLenum, texture: GLuint) -> Result<()> {
		let ret = process_catch("glBindTexture", catch_unwind(||(self.bindtexture)(target, texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindTexture", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteTextures(&self, n: GLsizei, textures: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteTextures", catch_unwind(||(self.deletetextures)(n, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteTextures", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenTextures(&self, n: GLsizei, textures: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenTextures", catch_unwind(||(self.gentextures)(n, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenTextures", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsTexture(&self, texture: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsTexture", catch_unwind(||(self.istexture)(texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsTexture", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version11 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (1, 1, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			drawarrays: {let proc = get_proc_address("glDrawArrays"); if proc == null() {dummy_pfngldrawarraysproc} else {unsafe{transmute(proc)}}},
			drawelements: {let proc = get_proc_address("glDrawElements"); if proc == null() {dummy_pfngldrawelementsproc} else {unsafe{transmute(proc)}}},
			getpointerv: {let proc = get_proc_address("glGetPointerv"); if proc == null() {dummy_pfnglgetpointervproc} else {unsafe{transmute(proc)}}},
			polygonoffset: {let proc = get_proc_address("glPolygonOffset"); if proc == null() {dummy_pfnglpolygonoffsetproc} else {unsafe{transmute(proc)}}},
			copyteximage1d: {let proc = get_proc_address("glCopyTexImage1D"); if proc == null() {dummy_pfnglcopyteximage1dproc} else {unsafe{transmute(proc)}}},
			copyteximage2d: {let proc = get_proc_address("glCopyTexImage2D"); if proc == null() {dummy_pfnglcopyteximage2dproc} else {unsafe{transmute(proc)}}},
			copytexsubimage1d: {let proc = get_proc_address("glCopyTexSubImage1D"); if proc == null() {dummy_pfnglcopytexsubimage1dproc} else {unsafe{transmute(proc)}}},
			copytexsubimage2d: {let proc = get_proc_address("glCopyTexSubImage2D"); if proc == null() {dummy_pfnglcopytexsubimage2dproc} else {unsafe{transmute(proc)}}},
			texsubimage1d: {let proc = get_proc_address("glTexSubImage1D"); if proc == null() {dummy_pfngltexsubimage1dproc} else {unsafe{transmute(proc)}}},
			texsubimage2d: {let proc = get_proc_address("glTexSubImage2D"); if proc == null() {dummy_pfngltexsubimage2dproc} else {unsafe{transmute(proc)}}},
			bindtexture: {let proc = get_proc_address("glBindTexture"); if proc == null() {dummy_pfnglbindtextureproc} else {unsafe{transmute(proc)}}},
			deletetextures: {let proc = get_proc_address("glDeleteTextures"); if proc == null() {dummy_pfngldeletetexturesproc} else {unsafe{transmute(proc)}}},
			gentextures: {let proc = get_proc_address("glGenTextures"); if proc == null() {dummy_pfnglgentexturesproc} else {unsafe{transmute(proc)}}},
			istexture: {let proc = get_proc_address("glIsTexture"); if proc == null() {dummy_pfnglistextureproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version11 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			drawarrays: dummy_pfngldrawarraysproc,
			drawelements: dummy_pfngldrawelementsproc,
			getpointerv: dummy_pfnglgetpointervproc,
			polygonoffset: dummy_pfnglpolygonoffsetproc,
			copyteximage1d: dummy_pfnglcopyteximage1dproc,
			copyteximage2d: dummy_pfnglcopyteximage2dproc,
			copytexsubimage1d: dummy_pfnglcopytexsubimage1dproc,
			copytexsubimage2d: dummy_pfnglcopytexsubimage2dproc,
			texsubimage1d: dummy_pfngltexsubimage1dproc,
			texsubimage2d: dummy_pfngltexsubimage2dproc,
			bindtexture: dummy_pfnglbindtextureproc,
			deletetextures: dummy_pfngldeletetexturesproc,
			gentextures: dummy_pfnglgentexturesproc,
			istexture: dummy_pfnglistextureproc,
		}
	}
}
impl Debug for Version11 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version11")
			.field("available", &self.available)
			.field("drawarrays", unsafe{if transmute::<_, *const c_void>(self.drawarrays) == (dummy_pfngldrawarraysproc as *const c_void) {&null::<PFNGLDRAWARRAYSPROC>()} else {&self.drawarrays}})
			.field("drawelements", unsafe{if transmute::<_, *const c_void>(self.drawelements) == (dummy_pfngldrawelementsproc as *const c_void) {&null::<PFNGLDRAWELEMENTSPROC>()} else {&self.drawelements}})
			.field("getpointerv", unsafe{if transmute::<_, *const c_void>(self.getpointerv) == (dummy_pfnglgetpointervproc as *const c_void) {&null::<PFNGLGETPOINTERVPROC>()} else {&self.getpointerv}})
			.field("polygonoffset", unsafe{if transmute::<_, *const c_void>(self.polygonoffset) == (dummy_pfnglpolygonoffsetproc as *const c_void) {&null::<PFNGLPOLYGONOFFSETPROC>()} else {&self.polygonoffset}})
			.field("copyteximage1d", unsafe{if transmute::<_, *const c_void>(self.copyteximage1d) == (dummy_pfnglcopyteximage1dproc as *const c_void) {&null::<PFNGLCOPYTEXIMAGE1DPROC>()} else {&self.copyteximage1d}})
			.field("copyteximage2d", unsafe{if transmute::<_, *const c_void>(self.copyteximage2d) == (dummy_pfnglcopyteximage2dproc as *const c_void) {&null::<PFNGLCOPYTEXIMAGE2DPROC>()} else {&self.copyteximage2d}})
			.field("copytexsubimage1d", unsafe{if transmute::<_, *const c_void>(self.copytexsubimage1d) == (dummy_pfnglcopytexsubimage1dproc as *const c_void) {&null::<PFNGLCOPYTEXSUBIMAGE1DPROC>()} else {&self.copytexsubimage1d}})
			.field("copytexsubimage2d", unsafe{if transmute::<_, *const c_void>(self.copytexsubimage2d) == (dummy_pfnglcopytexsubimage2dproc as *const c_void) {&null::<PFNGLCOPYTEXSUBIMAGE2DPROC>()} else {&self.copytexsubimage2d}})
			.field("texsubimage1d", unsafe{if transmute::<_, *const c_void>(self.texsubimage1d) == (dummy_pfngltexsubimage1dproc as *const c_void) {&null::<PFNGLTEXSUBIMAGE1DPROC>()} else {&self.texsubimage1d}})
			.field("texsubimage2d", unsafe{if transmute::<_, *const c_void>(self.texsubimage2d) == (dummy_pfngltexsubimage2dproc as *const c_void) {&null::<PFNGLTEXSUBIMAGE2DPROC>()} else {&self.texsubimage2d}})
			.field("bindtexture", unsafe{if transmute::<_, *const c_void>(self.bindtexture) == (dummy_pfnglbindtextureproc as *const c_void) {&null::<PFNGLBINDTEXTUREPROC>()} else {&self.bindtexture}})
			.field("deletetextures", unsafe{if transmute::<_, *const c_void>(self.deletetextures) == (dummy_pfngldeletetexturesproc as *const c_void) {&null::<PFNGLDELETETEXTURESPROC>()} else {&self.deletetextures}})
			.field("gentextures", unsafe{if transmute::<_, *const c_void>(self.gentextures) == (dummy_pfnglgentexturesproc as *const c_void) {&null::<PFNGLGENTEXTURESPROC>()} else {&self.gentextures}})
			.field("istexture", unsafe{if transmute::<_, *const c_void>(self.istexture) == (dummy_pfnglistextureproc as *const c_void) {&null::<PFNGLISTEXTUREPROC>()} else {&self.istexture}})
			.finish()
		} else {
			f.debug_struct("Version11")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}
type PFNGLDRAWRANGEELEMENTSPROC = extern "system" fn(GLenum, GLuint, GLuint, GLsizei, GLenum, *const c_void);
type PFNGLTEXIMAGE3DPROC = extern "system" fn(GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, *const c_void);
type PFNGLTEXSUBIMAGE3DPROC = extern "system" fn(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, *const c_void);
type PFNGLCOPYTEXSUBIMAGE3DPROC = extern "system" fn(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
extern "system" fn dummy_pfngldrawrangeelementsproc (_: GLenum, _: GLuint, _: GLuint, _: GLsizei, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glDrawRangeElements()` is null.")
}
extern "system" fn dummy_pfnglteximage3dproc (_: GLenum, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei, _: GLint, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glTexImage3D()` is null.")
}
extern "system" fn dummy_pfngltexsubimage3dproc (_: GLenum, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glTexSubImage3D()` is null.")
}
extern "system" fn dummy_pfnglcopytexsubimage3dproc (_: GLenum, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glCopyTexSubImage3D()` is null.")
}
pub const GL_UNSIGNED_BYTE_3_3_2: GLenum = 0x8032;
pub const GL_UNSIGNED_SHORT_4_4_4_4: GLenum = 0x8033;
pub const GL_UNSIGNED_SHORT_5_5_5_1: GLenum = 0x8034;
pub const GL_UNSIGNED_INT_8_8_8_8: GLenum = 0x8035;
pub const GL_UNSIGNED_INT_10_10_10_2: GLenum = 0x8036;
pub const GL_TEXTURE_BINDING_3D: GLenum = 0x806A;
pub const GL_PACK_SKIP_IMAGES: GLenum = 0x806B;
pub const GL_PACK_IMAGE_HEIGHT: GLenum = 0x806C;
pub const GL_UNPACK_SKIP_IMAGES: GLenum = 0x806D;
pub const GL_UNPACK_IMAGE_HEIGHT: GLenum = 0x806E;
pub const GL_TEXTURE_3D: GLenum = 0x806F;
pub const GL_PROXY_TEXTURE_3D: GLenum = 0x8070;
pub const GL_TEXTURE_DEPTH: GLenum = 0x8071;
pub const GL_TEXTURE_WRAP_R: GLenum = 0x8072;
pub const GL_MAX_3D_TEXTURE_SIZE: GLenum = 0x8073;
pub const GL_UNSIGNED_BYTE_2_3_3_REV: GLenum = 0x8362;
pub const GL_UNSIGNED_SHORT_5_6_5: GLenum = 0x8363;
pub const GL_UNSIGNED_SHORT_5_6_5_REV: GLenum = 0x8364;
pub const GL_UNSIGNED_SHORT_4_4_4_4_REV: GLenum = 0x8365;
pub const GL_UNSIGNED_SHORT_1_5_5_5_REV: GLenum = 0x8366;
pub const GL_UNSIGNED_INT_8_8_8_8_REV: GLenum = 0x8367;
pub const GL_UNSIGNED_INT_2_10_10_10_REV: GLenum = 0x8368;
pub const GL_BGR: GLenum = 0x80E0;
pub const GL_BGRA: GLenum = 0x80E1;
pub const GL_MAX_ELEMENTS_VERTICES: GLenum = 0x80E8;
pub const GL_MAX_ELEMENTS_INDICES: GLenum = 0x80E9;
pub const GL_CLAMP_TO_EDGE: GLint = 0x812F;
pub const GL_TEXTURE_MIN_LOD: GLenum = 0x813A;
pub const GL_TEXTURE_MAX_LOD: GLenum = 0x813B;
pub const GL_TEXTURE_BASE_LEVEL: GLenum = 0x813C;
pub const GL_TEXTURE_MAX_LEVEL: GLenum = 0x813D;
pub const GL_SMOOTH_POINT_SIZE_RANGE: GLenum = 0x0B12;
pub const GL_SMOOTH_POINT_SIZE_GRANULARITY: GLenum = 0x0B13;
pub const GL_SMOOTH_LINE_WIDTH_RANGE: GLenum = 0x0B22;
pub const GL_SMOOTH_LINE_WIDTH_GRANULARITY: GLenum = 0x0B23;
pub const GL_ALIASED_LINE_WIDTH_RANGE: GLenum = 0x846E;
pub const GL_RESCALE_NORMAL: GLenum = 0x803A;
pub const GL_LIGHT_MODEL_COLOR_CONTROL: GLenum = 0x81F8;
pub const GL_SINGLE_COLOR: GLenum = 0x81F9;
pub const GL_SEPARATE_SPECULAR_COLOR: GLenum = 0x81FA;
pub const GL_ALIASED_POINT_SIZE_RANGE: GLenum = 0x846D;

pub trait GL_1_2 {
	fn glGetError(&self) -> GLenum;
	fn glDrawRangeElements(&self, mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type_: GLenum, indices: *const c_void) -> Result<()>;
	fn glTexImage3D(&self, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()>;
	fn glTexSubImage3D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()>;
	fn glCopyTexSubImage3D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()>;
}

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version12 {
	available: bool,
	geterror: PFNGLGETERRORPROC,
	drawrangeelements: PFNGLDRAWRANGEELEMENTSPROC,
	teximage3d: PFNGLTEXIMAGE3DPROC,
	texsubimage3d: PFNGLTEXSUBIMAGE3DPROC,
	copytexsubimage3d: PFNGLCOPYTEXSUBIMAGE3DPROC,
}

impl GL_1_2 for Version12 {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	#[inline(always)]
	fn glDrawRangeElements(&self, mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type_: GLenum, indices: *const c_void) -> Result<()> {
		let ret = process_catch("glDrawRangeElements", catch_unwind(||(self.drawrangeelements)(mode, start, end, count, type_, indices)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawRangeElements", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexImage3D(&self, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexImage3D", catch_unwind(||(self.teximage3d)(target, level, internalformat, width, height, depth, border, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexSubImage3D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexSubImage3D", catch_unwind(||(self.texsubimage3d)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexSubImage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyTexSubImage3D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTexSubImage3D", catch_unwind(||(self.copytexsubimage3d)(target, level, xoffset, yoffset, zoffset, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexSubImage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version12 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (1, 2, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			drawrangeelements: {let proc = get_proc_address("glDrawRangeElements"); if proc == null() {dummy_pfngldrawrangeelementsproc} else {unsafe{transmute(proc)}}},
			teximage3d: {let proc = get_proc_address("glTexImage3D"); if proc == null() {dummy_pfnglteximage3dproc} else {unsafe{transmute(proc)}}},
			texsubimage3d: {let proc = get_proc_address("glTexSubImage3D"); if proc == null() {dummy_pfngltexsubimage3dproc} else {unsafe{transmute(proc)}}},
			copytexsubimage3d: {let proc = get_proc_address("glCopyTexSubImage3D"); if proc == null() {dummy_pfnglcopytexsubimage3dproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version12 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			drawrangeelements: dummy_pfngldrawrangeelementsproc,
			teximage3d: dummy_pfnglteximage3dproc,
			texsubimage3d: dummy_pfngltexsubimage3dproc,
			copytexsubimage3d: dummy_pfnglcopytexsubimage3dproc,
		}
	}
}
impl Debug for Version12 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version12")
			.field("available", &self.available)
			.field("drawrangeelements", unsafe{if transmute::<_, *const c_void>(self.drawrangeelements) == (dummy_pfngldrawrangeelementsproc as *const c_void) {&null::<PFNGLDRAWRANGEELEMENTSPROC>()} else {&self.drawrangeelements}})
			.field("teximage3d", unsafe{if transmute::<_, *const c_void>(self.teximage3d) == (dummy_pfnglteximage3dproc as *const c_void) {&null::<PFNGLTEXIMAGE3DPROC>()} else {&self.teximage3d}})
			.field("texsubimage3d", unsafe{if transmute::<_, *const c_void>(self.texsubimage3d) == (dummy_pfngltexsubimage3dproc as *const c_void) {&null::<PFNGLTEXSUBIMAGE3DPROC>()} else {&self.texsubimage3d}})
			.field("copytexsubimage3d", unsafe{if transmute::<_, *const c_void>(self.copytexsubimage3d) == (dummy_pfnglcopytexsubimage3dproc as *const c_void) {&null::<PFNGLCOPYTEXSUBIMAGE3DPROC>()} else {&self.copytexsubimage3d}})
			.finish()
		} else {
			f.debug_struct("Version12")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}
type PFNGLACTIVETEXTUREPROC = extern "system" fn(GLenum);
type PFNGLSAMPLECOVERAGEPROC = extern "system" fn(GLfloat, GLboolean);
type PFNGLCOMPRESSEDTEXIMAGE3DPROC = extern "system" fn(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, *const c_void);
type PFNGLCOMPRESSEDTEXIMAGE2DPROC = extern "system" fn(GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, *const c_void);
type PFNGLCOMPRESSEDTEXIMAGE1DPROC = extern "system" fn(GLenum, GLint, GLenum, GLsizei, GLint, GLsizei, *const c_void);
type PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC = extern "system" fn(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, *const c_void);
type PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC = extern "system" fn(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, *const c_void);
type PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC = extern "system" fn(GLenum, GLint, GLint, GLsizei, GLenum, GLsizei, *const c_void);
type PFNGLGETCOMPRESSEDTEXIMAGEPROC = extern "system" fn(GLenum, GLint, *mut c_void);
type PFNGLCLIENTACTIVETEXTUREPROC = extern "system" fn(GLenum);
type PFNGLMULTITEXCOORD1DPROC = extern "system" fn(GLenum, GLdouble);
type PFNGLMULTITEXCOORD1DVPROC = extern "system" fn(GLenum, *const GLdouble);
type PFNGLMULTITEXCOORD1FPROC = extern "system" fn(GLenum, GLfloat);
type PFNGLMULTITEXCOORD1FVPROC = extern "system" fn(GLenum, *const GLfloat);
type PFNGLMULTITEXCOORD1IPROC = extern "system" fn(GLenum, GLint);
type PFNGLMULTITEXCOORD1IVPROC = extern "system" fn(GLenum, *const GLint);
type PFNGLMULTITEXCOORD1SPROC = extern "system" fn(GLenum, GLshort);
type PFNGLMULTITEXCOORD1SVPROC = extern "system" fn(GLenum, *const GLshort);
type PFNGLMULTITEXCOORD2DPROC = extern "system" fn(GLenum, GLdouble, GLdouble);
type PFNGLMULTITEXCOORD2DVPROC = extern "system" fn(GLenum, *const GLdouble);
type PFNGLMULTITEXCOORD2FPROC = extern "system" fn(GLenum, GLfloat, GLfloat);
type PFNGLMULTITEXCOORD2FVPROC = extern "system" fn(GLenum, *const GLfloat);
type PFNGLMULTITEXCOORD2IPROC = extern "system" fn(GLenum, GLint, GLint);
type PFNGLMULTITEXCOORD2IVPROC = extern "system" fn(GLenum, *const GLint);
type PFNGLMULTITEXCOORD2SPROC = extern "system" fn(GLenum, GLshort, GLshort);
type PFNGLMULTITEXCOORD2SVPROC = extern "system" fn(GLenum, *const GLshort);
type PFNGLMULTITEXCOORD3DPROC = extern "system" fn(GLenum, GLdouble, GLdouble, GLdouble);
type PFNGLMULTITEXCOORD3DVPROC = extern "system" fn(GLenum, *const GLdouble);
type PFNGLMULTITEXCOORD3FPROC = extern "system" fn(GLenum, GLfloat, GLfloat, GLfloat);
type PFNGLMULTITEXCOORD3FVPROC = extern "system" fn(GLenum, *const GLfloat);
type PFNGLMULTITEXCOORD3IPROC = extern "system" fn(GLenum, GLint, GLint, GLint);
type PFNGLMULTITEXCOORD3IVPROC = extern "system" fn(GLenum, *const GLint);
type PFNGLMULTITEXCOORD3SPROC = extern "system" fn(GLenum, GLshort, GLshort, GLshort);
type PFNGLMULTITEXCOORD3SVPROC = extern "system" fn(GLenum, *const GLshort);
type PFNGLMULTITEXCOORD4DPROC = extern "system" fn(GLenum, GLdouble, GLdouble, GLdouble, GLdouble);
type PFNGLMULTITEXCOORD4DVPROC = extern "system" fn(GLenum, *const GLdouble);
type PFNGLMULTITEXCOORD4FPROC = extern "system" fn(GLenum, GLfloat, GLfloat, GLfloat, GLfloat);
type PFNGLMULTITEXCOORD4FVPROC = extern "system" fn(GLenum, *const GLfloat);
type PFNGLMULTITEXCOORD4IPROC = extern "system" fn(GLenum, GLint, GLint, GLint, GLint);
type PFNGLMULTITEXCOORD4IVPROC = extern "system" fn(GLenum, *const GLint);
type PFNGLMULTITEXCOORD4SPROC = extern "system" fn(GLenum, GLshort, GLshort, GLshort, GLshort);
type PFNGLMULTITEXCOORD4SVPROC = extern "system" fn(GLenum, *const GLshort);
type PFNGLLOADTRANSPOSEMATRIXFPROC = extern "system" fn(*const GLfloat);
type PFNGLLOADTRANSPOSEMATRIXDPROC = extern "system" fn(*const GLdouble);
type PFNGLMULTTRANSPOSEMATRIXFPROC = extern "system" fn(*const GLfloat);
type PFNGLMULTTRANSPOSEMATRIXDPROC = extern "system" fn(*const GLdouble);
extern "system" fn dummy_pfnglactivetextureproc (_: GLenum) {
	panic!("OpenGL function pointer `glActiveTexture()` is null.")
}
extern "system" fn dummy_pfnglsamplecoverageproc (_: GLfloat, _: GLboolean) {
	panic!("OpenGL function pointer `glSampleCoverage()` is null.")
}
extern "system" fn dummy_pfnglcompressedteximage3dproc (_: GLenum, _: GLint, _: GLenum, _: GLsizei, _: GLsizei, _: GLsizei, _: GLint, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glCompressedTexImage3D()` is null.")
}
extern "system" fn dummy_pfnglcompressedteximage2dproc (_: GLenum, _: GLint, _: GLenum, _: GLsizei, _: GLsizei, _: GLint, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glCompressedTexImage2D()` is null.")
}
extern "system" fn dummy_pfnglcompressedteximage1dproc (_: GLenum, _: GLint, _: GLenum, _: GLsizei, _: GLint, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glCompressedTexImage1D()` is null.")
}
extern "system" fn dummy_pfnglcompressedtexsubimage3dproc (_: GLenum, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei, _: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glCompressedTexSubImage3D()` is null.")
}
extern "system" fn dummy_pfnglcompressedtexsubimage2dproc (_: GLenum, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glCompressedTexSubImage2D()` is null.")
}
extern "system" fn dummy_pfnglcompressedtexsubimage1dproc (_: GLenum, _: GLint, _: GLint, _: GLsizei, _: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glCompressedTexSubImage1D()` is null.")
}
extern "system" fn dummy_pfnglgetcompressedteximageproc (_: GLenum, _: GLint, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetCompressedTexImage()` is null.")
}
extern "system" fn dummy_pfnglclientactivetextureproc (_: GLenum) {
	panic!("OpenGL function pointer `glClientActiveTexture()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord1dproc (_: GLenum, _: GLdouble) {
	panic!("OpenGL function pointer `glMultiTexCoord1d()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord1dvproc (_: GLenum, _: *const GLdouble) {
	panic!("OpenGL function pointer `glMultiTexCoord1dv()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord1fproc (_: GLenum, _: GLfloat) {
	panic!("OpenGL function pointer `glMultiTexCoord1f()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord1fvproc (_: GLenum, _: *const GLfloat) {
	panic!("OpenGL function pointer `glMultiTexCoord1fv()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord1iproc (_: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glMultiTexCoord1i()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord1ivproc (_: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glMultiTexCoord1iv()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord1sproc (_: GLenum, _: GLshort) {
	panic!("OpenGL function pointer `glMultiTexCoord1s()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord1svproc (_: GLenum, _: *const GLshort) {
	panic!("OpenGL function pointer `glMultiTexCoord1sv()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord2dproc (_: GLenum, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glMultiTexCoord2d()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord2dvproc (_: GLenum, _: *const GLdouble) {
	panic!("OpenGL function pointer `glMultiTexCoord2dv()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord2fproc (_: GLenum, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glMultiTexCoord2f()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord2fvproc (_: GLenum, _: *const GLfloat) {
	panic!("OpenGL function pointer `glMultiTexCoord2fv()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord2iproc (_: GLenum, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glMultiTexCoord2i()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord2ivproc (_: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glMultiTexCoord2iv()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord2sproc (_: GLenum, _: GLshort, _: GLshort) {
	panic!("OpenGL function pointer `glMultiTexCoord2s()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord2svproc (_: GLenum, _: *const GLshort) {
	panic!("OpenGL function pointer `glMultiTexCoord2sv()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord3dproc (_: GLenum, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glMultiTexCoord3d()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord3dvproc (_: GLenum, _: *const GLdouble) {
	panic!("OpenGL function pointer `glMultiTexCoord3dv()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord3fproc (_: GLenum, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glMultiTexCoord3f()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord3fvproc (_: GLenum, _: *const GLfloat) {
	panic!("OpenGL function pointer `glMultiTexCoord3fv()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord3iproc (_: GLenum, _: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glMultiTexCoord3i()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord3ivproc (_: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glMultiTexCoord3iv()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord3sproc (_: GLenum, _: GLshort, _: GLshort, _: GLshort) {
	panic!("OpenGL function pointer `glMultiTexCoord3s()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord3svproc (_: GLenum, _: *const GLshort) {
	panic!("OpenGL function pointer `glMultiTexCoord3sv()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord4dproc (_: GLenum, _: GLdouble, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glMultiTexCoord4d()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord4dvproc (_: GLenum, _: *const GLdouble) {
	panic!("OpenGL function pointer `glMultiTexCoord4dv()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord4fproc (_: GLenum, _: GLfloat, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glMultiTexCoord4f()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord4fvproc (_: GLenum, _: *const GLfloat) {
	panic!("OpenGL function pointer `glMultiTexCoord4fv()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord4iproc (_: GLenum, _: GLint, _: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glMultiTexCoord4i()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord4ivproc (_: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glMultiTexCoord4iv()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord4sproc (_: GLenum, _: GLshort, _: GLshort, _: GLshort, _: GLshort) {
	panic!("OpenGL function pointer `glMultiTexCoord4s()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoord4svproc (_: GLenum, _: *const GLshort) {
	panic!("OpenGL function pointer `glMultiTexCoord4sv()` is null.")
}
extern "system" fn dummy_pfnglloadtransposematrixfproc (_: *const GLfloat) {
	panic!("OpenGL function pointer `glLoadTransposeMatrixf()` is null.")
}
extern "system" fn dummy_pfnglloadtransposematrixdproc (_: *const GLdouble) {
	panic!("OpenGL function pointer `glLoadTransposeMatrixd()` is null.")
}
extern "system" fn dummy_pfnglmulttransposematrixfproc (_: *const GLfloat) {
	panic!("OpenGL function pointer `glMultTransposeMatrixf()` is null.")
}
extern "system" fn dummy_pfnglmulttransposematrixdproc (_: *const GLdouble) {
	panic!("OpenGL function pointer `glMultTransposeMatrixd()` is null.")
}
pub const GL_TEXTURE0: GLenum = 0x84C0;
pub const GL_TEXTURE1: GLenum = 0x84C1;
pub const GL_TEXTURE2: GLenum = 0x84C2;
pub const GL_TEXTURE3: GLenum = 0x84C3;
pub const GL_TEXTURE4: GLenum = 0x84C4;
pub const GL_TEXTURE5: GLenum = 0x84C5;
pub const GL_TEXTURE6: GLenum = 0x84C6;
pub const GL_TEXTURE7: GLenum = 0x84C7;
pub const GL_TEXTURE8: GLenum = 0x84C8;
pub const GL_TEXTURE9: GLenum = 0x84C9;
pub const GL_TEXTURE10: GLenum = 0x84CA;
pub const GL_TEXTURE11: GLenum = 0x84CB;
pub const GL_TEXTURE12: GLenum = 0x84CC;
pub const GL_TEXTURE13: GLenum = 0x84CD;
pub const GL_TEXTURE14: GLenum = 0x84CE;
pub const GL_TEXTURE15: GLenum = 0x84CF;
pub const GL_TEXTURE16: GLenum = 0x84D0;
pub const GL_TEXTURE17: GLenum = 0x84D1;
pub const GL_TEXTURE18: GLenum = 0x84D2;
pub const GL_TEXTURE19: GLenum = 0x84D3;
pub const GL_TEXTURE20: GLenum = 0x84D4;
pub const GL_TEXTURE21: GLenum = 0x84D5;
pub const GL_TEXTURE22: GLenum = 0x84D6;
pub const GL_TEXTURE23: GLenum = 0x84D7;
pub const GL_TEXTURE24: GLenum = 0x84D8;
pub const GL_TEXTURE25: GLenum = 0x84D9;
pub const GL_TEXTURE26: GLenum = 0x84DA;
pub const GL_TEXTURE27: GLenum = 0x84DB;
pub const GL_TEXTURE28: GLenum = 0x84DC;
pub const GL_TEXTURE29: GLenum = 0x84DD;
pub const GL_TEXTURE30: GLenum = 0x84DE;
pub const GL_TEXTURE31: GLenum = 0x84DF;
pub const GL_ACTIVE_TEXTURE: GLenum = 0x84E0;
pub const GL_MULTISAMPLE: GLenum = 0x809D;
pub const GL_SAMPLE_ALPHA_TO_COVERAGE: GLenum = 0x809E;
pub const GL_SAMPLE_ALPHA_TO_ONE: GLenum = 0x809F;
pub const GL_SAMPLE_COVERAGE: GLenum = 0x80A0;
pub const GL_SAMPLE_BUFFERS: GLenum = 0x80A8;
pub const GL_SAMPLES: GLenum = 0x80A9;
pub const GL_SAMPLE_COVERAGE_VALUE: GLenum = 0x80AA;
pub const GL_SAMPLE_COVERAGE_INVERT: GLenum = 0x80AB;
pub const GL_TEXTURE_CUBE_MAP: GLenum = 0x8513;
pub const GL_TEXTURE_BINDING_CUBE_MAP: GLenum = 0x8514;
pub const GL_TEXTURE_CUBE_MAP_POSITIVE_X: GLenum = 0x8515;
pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_X: GLenum = 0x8516;
pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Y: GLenum = 0x8517;
pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: GLenum = 0x8518;
pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Z: GLenum = 0x8519;
pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: GLenum = 0x851A;
pub const GL_PROXY_TEXTURE_CUBE_MAP: GLenum = 0x851B;
pub const GL_MAX_CUBE_MAP_TEXTURE_SIZE: GLenum = 0x851C;
pub const GL_COMPRESSED_RGB: GLenum = 0x84ED;
pub const GL_COMPRESSED_RGBA: GLenum = 0x84EE;
pub const GL_TEXTURE_COMPRESSION_HINT: GLenum = 0x84EF;
pub const GL_TEXTURE_COMPRESSED_IMAGE_SIZE: GLenum = 0x86A0;
pub const GL_TEXTURE_COMPRESSED: GLenum = 0x86A1;
pub const GL_NUM_COMPRESSED_TEXTURE_FORMATS: GLenum = 0x86A2;
pub const GL_COMPRESSED_TEXTURE_FORMATS: GLenum = 0x86A3;
pub const GL_CLAMP_TO_BORDER: GLint = 0x812D;
pub const GL_CLIENT_ACTIVE_TEXTURE: GLenum = 0x84E1;
pub const GL_MAX_TEXTURE_UNITS: GLenum = 0x84E2;
pub const GL_TRANSPOSE_MODELVIEW_MATRIX: GLenum = 0x84E3;
pub const GL_TRANSPOSE_PROJECTION_MATRIX: GLenum = 0x84E4;
pub const GL_TRANSPOSE_TEXTURE_MATRIX: GLenum = 0x84E5;
pub const GL_TRANSPOSE_COLOR_MATRIX: GLenum = 0x84E6;
pub const GL_MULTISAMPLE_BIT: GLbitfield = 0x20000000;
pub const GL_NORMAL_MAP: GLenum = 0x8511;
pub const GL_REFLECTION_MAP: GLenum = 0x8512;
pub const GL_COMPRESSED_ALPHA: GLenum = 0x84E9;
pub const GL_COMPRESSED_LUMINANCE: GLenum = 0x84EA;
pub const GL_COMPRESSED_LUMINANCE_ALPHA: GLenum = 0x84EB;
pub const GL_COMPRESSED_INTENSITY: GLenum = 0x84EC;
pub const GL_COMBINE: GLenum = 0x8570;
pub const GL_COMBINE_RGB: GLenum = 0x8571;
pub const GL_COMBINE_ALPHA: GLenum = 0x8572;
pub const GL_SOURCE0_RGB: GLenum = 0x8580;
pub const GL_SOURCE1_RGB: GLenum = 0x8581;
pub const GL_SOURCE2_RGB: GLenum = 0x8582;
pub const GL_SOURCE0_ALPHA: GLenum = 0x8588;
pub const GL_SOURCE1_ALPHA: GLenum = 0x8589;
pub const GL_SOURCE2_ALPHA: GLenum = 0x858A;
pub const GL_OPERAND0_RGB: GLenum = 0x8590;
pub const GL_OPERAND1_RGB: GLenum = 0x8591;
pub const GL_OPERAND2_RGB: GLenum = 0x8592;
pub const GL_OPERAND0_ALPHA: GLenum = 0x8598;
pub const GL_OPERAND1_ALPHA: GLenum = 0x8599;
pub const GL_OPERAND2_ALPHA: GLenum = 0x859A;
pub const GL_RGB_SCALE: GLenum = 0x8573;
pub const GL_ADD_SIGNED: GLenum = 0x8574;
pub const GL_INTERPOLATE: GLenum = 0x8575;
pub const GL_SUBTRACT: GLenum = 0x84E7;
pub const GL_CONSTANT: GLenum = 0x8576;
pub const GL_PRIMARY_COLOR: GLenum = 0x8577;
pub const GL_PREVIOUS: GLenum = 0x8578;
pub const GL_DOT3_RGB: GLenum = 0x86AE;
pub const GL_DOT3_RGBA: GLenum = 0x86AF;

pub trait GL_1_3 {
	fn glGetError(&self) -> GLenum;
	fn glActiveTexture(&self, texture: GLenum) -> Result<()>;
	fn glSampleCoverage(&self, value: GLfloat, invert: GLboolean) -> Result<()>;
	fn glCompressedTexImage3D(&self, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void) -> Result<()>;
	fn glCompressedTexImage2D(&self, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void) -> Result<()>;
	fn glCompressedTexImage1D(&self, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void) -> Result<()>;
	fn glCompressedTexSubImage3D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()>;
	fn glCompressedTexSubImage2D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()>;
	fn glCompressedTexSubImage1D(&self, target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()>;
	fn glGetCompressedTexImage(&self, target: GLenum, level: GLint, img: *mut c_void) -> Result<()>;
	fn glClientActiveTexture(&self, texture: GLenum) -> Result<()>;
	fn glMultiTexCoord1d(&self, target: GLenum, s: GLdouble) -> Result<()>;
	fn glMultiTexCoord1dv(&self, target: GLenum, v: *const GLdouble) -> Result<()>;
	fn glMultiTexCoord1f(&self, target: GLenum, s: GLfloat) -> Result<()>;
	fn glMultiTexCoord1fv(&self, target: GLenum, v: *const GLfloat) -> Result<()>;
	fn glMultiTexCoord1i(&self, target: GLenum, s: GLint) -> Result<()>;
	fn glMultiTexCoord1iv(&self, target: GLenum, v: *const GLint) -> Result<()>;
	fn glMultiTexCoord1s(&self, target: GLenum, s: GLshort) -> Result<()>;
	fn glMultiTexCoord1sv(&self, target: GLenum, v: *const GLshort) -> Result<()>;
	fn glMultiTexCoord2d(&self, target: GLenum, s: GLdouble, t: GLdouble) -> Result<()>;
	fn glMultiTexCoord2dv(&self, target: GLenum, v: *const GLdouble) -> Result<()>;
	fn glMultiTexCoord2f(&self, target: GLenum, s: GLfloat, t: GLfloat) -> Result<()>;
	fn glMultiTexCoord2fv(&self, target: GLenum, v: *const GLfloat) -> Result<()>;
	fn glMultiTexCoord2i(&self, target: GLenum, s: GLint, t: GLint) -> Result<()>;
	fn glMultiTexCoord2iv(&self, target: GLenum, v: *const GLint) -> Result<()>;
	fn glMultiTexCoord2s(&self, target: GLenum, s: GLshort, t: GLshort) -> Result<()>;
	fn glMultiTexCoord2sv(&self, target: GLenum, v: *const GLshort) -> Result<()>;
	fn glMultiTexCoord3d(&self, target: GLenum, s: GLdouble, t: GLdouble, r: GLdouble) -> Result<()>;
	fn glMultiTexCoord3dv(&self, target: GLenum, v: *const GLdouble) -> Result<()>;
	fn glMultiTexCoord3f(&self, target: GLenum, s: GLfloat, t: GLfloat, r: GLfloat) -> Result<()>;
	fn glMultiTexCoord3fv(&self, target: GLenum, v: *const GLfloat) -> Result<()>;
	fn glMultiTexCoord3i(&self, target: GLenum, s: GLint, t: GLint, r: GLint) -> Result<()>;
	fn glMultiTexCoord3iv(&self, target: GLenum, v: *const GLint) -> Result<()>;
	fn glMultiTexCoord3s(&self, target: GLenum, s: GLshort, t: GLshort, r: GLshort) -> Result<()>;
	fn glMultiTexCoord3sv(&self, target: GLenum, v: *const GLshort) -> Result<()>;
	fn glMultiTexCoord4d(&self, target: GLenum, s: GLdouble, t: GLdouble, r: GLdouble, q: GLdouble) -> Result<()>;
	fn glMultiTexCoord4dv(&self, target: GLenum, v: *const GLdouble) -> Result<()>;
	fn glMultiTexCoord4f(&self, target: GLenum, s: GLfloat, t: GLfloat, r: GLfloat, q: GLfloat) -> Result<()>;
	fn glMultiTexCoord4fv(&self, target: GLenum, v: *const GLfloat) -> Result<()>;
	fn glMultiTexCoord4i(&self, target: GLenum, s: GLint, t: GLint, r: GLint, q: GLint) -> Result<()>;
	fn glMultiTexCoord4iv(&self, target: GLenum, v: *const GLint) -> Result<()>;
	fn glMultiTexCoord4s(&self, target: GLenum, s: GLshort, t: GLshort, r: GLshort, q: GLshort) -> Result<()>;
	fn glMultiTexCoord4sv(&self, target: GLenum, v: *const GLshort) -> Result<()>;
	fn glLoadTransposeMatrixf(&self, m: *const GLfloat) -> Result<()>;
	fn glLoadTransposeMatrixd(&self, m: *const GLdouble) -> Result<()>;
	fn glMultTransposeMatrixf(&self, m: *const GLfloat) -> Result<()>;
	fn glMultTransposeMatrixd(&self, m: *const GLdouble) -> Result<()>;
}

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version13 {
	available: bool,
	geterror: PFNGLGETERRORPROC,
	activetexture: PFNGLACTIVETEXTUREPROC,
	samplecoverage: PFNGLSAMPLECOVERAGEPROC,
	compressedteximage3d: PFNGLCOMPRESSEDTEXIMAGE3DPROC,
	compressedteximage2d: PFNGLCOMPRESSEDTEXIMAGE2DPROC,
	compressedteximage1d: PFNGLCOMPRESSEDTEXIMAGE1DPROC,
	compressedtexsubimage3d: PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC,
	compressedtexsubimage2d: PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC,
	compressedtexsubimage1d: PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC,
	getcompressedteximage: PFNGLGETCOMPRESSEDTEXIMAGEPROC,
	clientactivetexture: PFNGLCLIENTACTIVETEXTUREPROC,
	multitexcoord1d: PFNGLMULTITEXCOORD1DPROC,
	multitexcoord1dv: PFNGLMULTITEXCOORD1DVPROC,
	multitexcoord1f: PFNGLMULTITEXCOORD1FPROC,
	multitexcoord1fv: PFNGLMULTITEXCOORD1FVPROC,
	multitexcoord1i: PFNGLMULTITEXCOORD1IPROC,
	multitexcoord1iv: PFNGLMULTITEXCOORD1IVPROC,
	multitexcoord1s: PFNGLMULTITEXCOORD1SPROC,
	multitexcoord1sv: PFNGLMULTITEXCOORD1SVPROC,
	multitexcoord2d: PFNGLMULTITEXCOORD2DPROC,
	multitexcoord2dv: PFNGLMULTITEXCOORD2DVPROC,
	multitexcoord2f: PFNGLMULTITEXCOORD2FPROC,
	multitexcoord2fv: PFNGLMULTITEXCOORD2FVPROC,
	multitexcoord2i: PFNGLMULTITEXCOORD2IPROC,
	multitexcoord2iv: PFNGLMULTITEXCOORD2IVPROC,
	multitexcoord2s: PFNGLMULTITEXCOORD2SPROC,
	multitexcoord2sv: PFNGLMULTITEXCOORD2SVPROC,
	multitexcoord3d: PFNGLMULTITEXCOORD3DPROC,
	multitexcoord3dv: PFNGLMULTITEXCOORD3DVPROC,
	multitexcoord3f: PFNGLMULTITEXCOORD3FPROC,
	multitexcoord3fv: PFNGLMULTITEXCOORD3FVPROC,
	multitexcoord3i: PFNGLMULTITEXCOORD3IPROC,
	multitexcoord3iv: PFNGLMULTITEXCOORD3IVPROC,
	multitexcoord3s: PFNGLMULTITEXCOORD3SPROC,
	multitexcoord3sv: PFNGLMULTITEXCOORD3SVPROC,
	multitexcoord4d: PFNGLMULTITEXCOORD4DPROC,
	multitexcoord4dv: PFNGLMULTITEXCOORD4DVPROC,
	multitexcoord4f: PFNGLMULTITEXCOORD4FPROC,
	multitexcoord4fv: PFNGLMULTITEXCOORD4FVPROC,
	multitexcoord4i: PFNGLMULTITEXCOORD4IPROC,
	multitexcoord4iv: PFNGLMULTITEXCOORD4IVPROC,
	multitexcoord4s: PFNGLMULTITEXCOORD4SPROC,
	multitexcoord4sv: PFNGLMULTITEXCOORD4SVPROC,
	loadtransposematrixf: PFNGLLOADTRANSPOSEMATRIXFPROC,
	loadtransposematrixd: PFNGLLOADTRANSPOSEMATRIXDPROC,
	multtransposematrixf: PFNGLMULTTRANSPOSEMATRIXFPROC,
	multtransposematrixd: PFNGLMULTTRANSPOSEMATRIXDPROC,
}

impl GL_1_3 for Version13 {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	#[inline(always)]
	fn glActiveTexture(&self, texture: GLenum) -> Result<()> {
		let ret = process_catch("glActiveTexture", catch_unwind(||(self.activetexture)(texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glActiveTexture", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSampleCoverage(&self, value: GLfloat, invert: GLboolean) -> Result<()> {
		let ret = process_catch("glSampleCoverage", catch_unwind(||(self.samplecoverage)(value, invert)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSampleCoverage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompressedTexImage3D(&self, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexImage3D", catch_unwind(||(self.compressedteximage3d)(target, level, internalformat, width, height, depth, border, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexImage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompressedTexImage2D(&self, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexImage2D", catch_unwind(||(self.compressedteximage2d)(target, level, internalformat, width, height, border, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexImage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompressedTexImage1D(&self, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexImage1D", catch_unwind(||(self.compressedteximage1d)(target, level, internalformat, width, border, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexImage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompressedTexSubImage3D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexSubImage3D", catch_unwind(||(self.compressedtexsubimage3d)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexSubImage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompressedTexSubImage2D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexSubImage2D", catch_unwind(||(self.compressedtexsubimage2d)(target, level, xoffset, yoffset, width, height, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexSubImage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompressedTexSubImage1D(&self, target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexSubImage1D", catch_unwind(||(self.compressedtexsubimage1d)(target, level, xoffset, width, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexSubImage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetCompressedTexImage(&self, target: GLenum, level: GLint, img: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetCompressedTexImage", catch_unwind(||(self.getcompressedteximage)(target, level, img)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetCompressedTexImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClientActiveTexture(&self, texture: GLenum) -> Result<()> {
		let ret = process_catch("glClientActiveTexture", catch_unwind(||(self.clientactivetexture)(texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClientActiveTexture", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord1d(&self, target: GLenum, s: GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1d", catch_unwind(||(self.multitexcoord1d)(target, s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord1dv(&self, target: GLenum, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1dv", catch_unwind(||(self.multitexcoord1dv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord1f(&self, target: GLenum, s: GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1f", catch_unwind(||(self.multitexcoord1f)(target, s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord1fv(&self, target: GLenum, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1fv", catch_unwind(||(self.multitexcoord1fv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord1i(&self, target: GLenum, s: GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1i", catch_unwind(||(self.multitexcoord1i)(target, s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord1iv(&self, target: GLenum, v: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1iv", catch_unwind(||(self.multitexcoord1iv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord1s(&self, target: GLenum, s: GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1s", catch_unwind(||(self.multitexcoord1s)(target, s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord1sv(&self, target: GLenum, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1sv", catch_unwind(||(self.multitexcoord1sv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord2d(&self, target: GLenum, s: GLdouble, t: GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2d", catch_unwind(||(self.multitexcoord2d)(target, s, t)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord2dv(&self, target: GLenum, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2dv", catch_unwind(||(self.multitexcoord2dv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord2f(&self, target: GLenum, s: GLfloat, t: GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2f", catch_unwind(||(self.multitexcoord2f)(target, s, t)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord2fv(&self, target: GLenum, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2fv", catch_unwind(||(self.multitexcoord2fv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord2i(&self, target: GLenum, s: GLint, t: GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2i", catch_unwind(||(self.multitexcoord2i)(target, s, t)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord2iv(&self, target: GLenum, v: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2iv", catch_unwind(||(self.multitexcoord2iv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord2s(&self, target: GLenum, s: GLshort, t: GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2s", catch_unwind(||(self.multitexcoord2s)(target, s, t)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord2sv(&self, target: GLenum, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2sv", catch_unwind(||(self.multitexcoord2sv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord3d(&self, target: GLenum, s: GLdouble, t: GLdouble, r: GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3d", catch_unwind(||(self.multitexcoord3d)(target, s, t, r)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord3dv(&self, target: GLenum, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3dv", catch_unwind(||(self.multitexcoord3dv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord3f(&self, target: GLenum, s: GLfloat, t: GLfloat, r: GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3f", catch_unwind(||(self.multitexcoord3f)(target, s, t, r)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord3fv(&self, target: GLenum, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3fv", catch_unwind(||(self.multitexcoord3fv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord3i(&self, target: GLenum, s: GLint, t: GLint, r: GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3i", catch_unwind(||(self.multitexcoord3i)(target, s, t, r)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord3iv(&self, target: GLenum, v: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3iv", catch_unwind(||(self.multitexcoord3iv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord3s(&self, target: GLenum, s: GLshort, t: GLshort, r: GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3s", catch_unwind(||(self.multitexcoord3s)(target, s, t, r)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord3sv(&self, target: GLenum, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3sv", catch_unwind(||(self.multitexcoord3sv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord4d(&self, target: GLenum, s: GLdouble, t: GLdouble, r: GLdouble, q: GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4d", catch_unwind(||(self.multitexcoord4d)(target, s, t, r, q)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord4dv(&self, target: GLenum, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4dv", catch_unwind(||(self.multitexcoord4dv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord4f(&self, target: GLenum, s: GLfloat, t: GLfloat, r: GLfloat, q: GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4f", catch_unwind(||(self.multitexcoord4f)(target, s, t, r, q)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord4fv(&self, target: GLenum, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4fv", catch_unwind(||(self.multitexcoord4fv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord4i(&self, target: GLenum, s: GLint, t: GLint, r: GLint, q: GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4i", catch_unwind(||(self.multitexcoord4i)(target, s, t, r, q)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord4iv(&self, target: GLenum, v: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4iv", catch_unwind(||(self.multitexcoord4iv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord4s(&self, target: GLenum, s: GLshort, t: GLshort, r: GLshort, q: GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4s", catch_unwind(||(self.multitexcoord4s)(target, s, t, r, q)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord4sv(&self, target: GLenum, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4sv", catch_unwind(||(self.multitexcoord4sv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glLoadTransposeMatrixf(&self, m: *const GLfloat) -> Result<()> {
		let ret = process_catch("glLoadTransposeMatrixf", catch_unwind(||(self.loadtransposematrixf)(m)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLoadTransposeMatrixf", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glLoadTransposeMatrixd(&self, m: *const GLdouble) -> Result<()> {
		let ret = process_catch("glLoadTransposeMatrixd", catch_unwind(||(self.loadtransposematrixd)(m)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLoadTransposeMatrixd", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultTransposeMatrixf(&self, m: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultTransposeMatrixf", catch_unwind(||(self.multtransposematrixf)(m)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultTransposeMatrixf", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultTransposeMatrixd(&self, m: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultTransposeMatrixd", catch_unwind(||(self.multtransposematrixd)(m)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultTransposeMatrixd", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version13 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (1, 3, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			activetexture: {let proc = get_proc_address("glActiveTexture"); if proc == null() {dummy_pfnglactivetextureproc} else {unsafe{transmute(proc)}}},
			samplecoverage: {let proc = get_proc_address("glSampleCoverage"); if proc == null() {dummy_pfnglsamplecoverageproc} else {unsafe{transmute(proc)}}},
			compressedteximage3d: {let proc = get_proc_address("glCompressedTexImage3D"); if proc == null() {dummy_pfnglcompressedteximage3dproc} else {unsafe{transmute(proc)}}},
			compressedteximage2d: {let proc = get_proc_address("glCompressedTexImage2D"); if proc == null() {dummy_pfnglcompressedteximage2dproc} else {unsafe{transmute(proc)}}},
			compressedteximage1d: {let proc = get_proc_address("glCompressedTexImage1D"); if proc == null() {dummy_pfnglcompressedteximage1dproc} else {unsafe{transmute(proc)}}},
			compressedtexsubimage3d: {let proc = get_proc_address("glCompressedTexSubImage3D"); if proc == null() {dummy_pfnglcompressedtexsubimage3dproc} else {unsafe{transmute(proc)}}},
			compressedtexsubimage2d: {let proc = get_proc_address("glCompressedTexSubImage2D"); if proc == null() {dummy_pfnglcompressedtexsubimage2dproc} else {unsafe{transmute(proc)}}},
			compressedtexsubimage1d: {let proc = get_proc_address("glCompressedTexSubImage1D"); if proc == null() {dummy_pfnglcompressedtexsubimage1dproc} else {unsafe{transmute(proc)}}},
			getcompressedteximage: {let proc = get_proc_address("glGetCompressedTexImage"); if proc == null() {dummy_pfnglgetcompressedteximageproc} else {unsafe{transmute(proc)}}},
			clientactivetexture: {let proc = get_proc_address("glClientActiveTexture"); if proc == null() {dummy_pfnglclientactivetextureproc} else {unsafe{transmute(proc)}}},
			multitexcoord1d: {let proc = get_proc_address("glMultiTexCoord1d"); if proc == null() {dummy_pfnglmultitexcoord1dproc} else {unsafe{transmute(proc)}}},
			multitexcoord1dv: {let proc = get_proc_address("glMultiTexCoord1dv"); if proc == null() {dummy_pfnglmultitexcoord1dvproc} else {unsafe{transmute(proc)}}},
			multitexcoord1f: {let proc = get_proc_address("glMultiTexCoord1f"); if proc == null() {dummy_pfnglmultitexcoord1fproc} else {unsafe{transmute(proc)}}},
			multitexcoord1fv: {let proc = get_proc_address("glMultiTexCoord1fv"); if proc == null() {dummy_pfnglmultitexcoord1fvproc} else {unsafe{transmute(proc)}}},
			multitexcoord1i: {let proc = get_proc_address("glMultiTexCoord1i"); if proc == null() {dummy_pfnglmultitexcoord1iproc} else {unsafe{transmute(proc)}}},
			multitexcoord1iv: {let proc = get_proc_address("glMultiTexCoord1iv"); if proc == null() {dummy_pfnglmultitexcoord1ivproc} else {unsafe{transmute(proc)}}},
			multitexcoord1s: {let proc = get_proc_address("glMultiTexCoord1s"); if proc == null() {dummy_pfnglmultitexcoord1sproc} else {unsafe{transmute(proc)}}},
			multitexcoord1sv: {let proc = get_proc_address("glMultiTexCoord1sv"); if proc == null() {dummy_pfnglmultitexcoord1svproc} else {unsafe{transmute(proc)}}},
			multitexcoord2d: {let proc = get_proc_address("glMultiTexCoord2d"); if proc == null() {dummy_pfnglmultitexcoord2dproc} else {unsafe{transmute(proc)}}},
			multitexcoord2dv: {let proc = get_proc_address("glMultiTexCoord2dv"); if proc == null() {dummy_pfnglmultitexcoord2dvproc} else {unsafe{transmute(proc)}}},
			multitexcoord2f: {let proc = get_proc_address("glMultiTexCoord2f"); if proc == null() {dummy_pfnglmultitexcoord2fproc} else {unsafe{transmute(proc)}}},
			multitexcoord2fv: {let proc = get_proc_address("glMultiTexCoord2fv"); if proc == null() {dummy_pfnglmultitexcoord2fvproc} else {unsafe{transmute(proc)}}},
			multitexcoord2i: {let proc = get_proc_address("glMultiTexCoord2i"); if proc == null() {dummy_pfnglmultitexcoord2iproc} else {unsafe{transmute(proc)}}},
			multitexcoord2iv: {let proc = get_proc_address("glMultiTexCoord2iv"); if proc == null() {dummy_pfnglmultitexcoord2ivproc} else {unsafe{transmute(proc)}}},
			multitexcoord2s: {let proc = get_proc_address("glMultiTexCoord2s"); if proc == null() {dummy_pfnglmultitexcoord2sproc} else {unsafe{transmute(proc)}}},
			multitexcoord2sv: {let proc = get_proc_address("glMultiTexCoord2sv"); if proc == null() {dummy_pfnglmultitexcoord2svproc} else {unsafe{transmute(proc)}}},
			multitexcoord3d: {let proc = get_proc_address("glMultiTexCoord3d"); if proc == null() {dummy_pfnglmultitexcoord3dproc} else {unsafe{transmute(proc)}}},
			multitexcoord3dv: {let proc = get_proc_address("glMultiTexCoord3dv"); if proc == null() {dummy_pfnglmultitexcoord3dvproc} else {unsafe{transmute(proc)}}},
			multitexcoord3f: {let proc = get_proc_address("glMultiTexCoord3f"); if proc == null() {dummy_pfnglmultitexcoord3fproc} else {unsafe{transmute(proc)}}},
			multitexcoord3fv: {let proc = get_proc_address("glMultiTexCoord3fv"); if proc == null() {dummy_pfnglmultitexcoord3fvproc} else {unsafe{transmute(proc)}}},
			multitexcoord3i: {let proc = get_proc_address("glMultiTexCoord3i"); if proc == null() {dummy_pfnglmultitexcoord3iproc} else {unsafe{transmute(proc)}}},
			multitexcoord3iv: {let proc = get_proc_address("glMultiTexCoord3iv"); if proc == null() {dummy_pfnglmultitexcoord3ivproc} else {unsafe{transmute(proc)}}},
			multitexcoord3s: {let proc = get_proc_address("glMultiTexCoord3s"); if proc == null() {dummy_pfnglmultitexcoord3sproc} else {unsafe{transmute(proc)}}},
			multitexcoord3sv: {let proc = get_proc_address("glMultiTexCoord3sv"); if proc == null() {dummy_pfnglmultitexcoord3svproc} else {unsafe{transmute(proc)}}},
			multitexcoord4d: {let proc = get_proc_address("glMultiTexCoord4d"); if proc == null() {dummy_pfnglmultitexcoord4dproc} else {unsafe{transmute(proc)}}},
			multitexcoord4dv: {let proc = get_proc_address("glMultiTexCoord4dv"); if proc == null() {dummy_pfnglmultitexcoord4dvproc} else {unsafe{transmute(proc)}}},
			multitexcoord4f: {let proc = get_proc_address("glMultiTexCoord4f"); if proc == null() {dummy_pfnglmultitexcoord4fproc} else {unsafe{transmute(proc)}}},
			multitexcoord4fv: {let proc = get_proc_address("glMultiTexCoord4fv"); if proc == null() {dummy_pfnglmultitexcoord4fvproc} else {unsafe{transmute(proc)}}},
			multitexcoord4i: {let proc = get_proc_address("glMultiTexCoord4i"); if proc == null() {dummy_pfnglmultitexcoord4iproc} else {unsafe{transmute(proc)}}},
			multitexcoord4iv: {let proc = get_proc_address("glMultiTexCoord4iv"); if proc == null() {dummy_pfnglmultitexcoord4ivproc} else {unsafe{transmute(proc)}}},
			multitexcoord4s: {let proc = get_proc_address("glMultiTexCoord4s"); if proc == null() {dummy_pfnglmultitexcoord4sproc} else {unsafe{transmute(proc)}}},
			multitexcoord4sv: {let proc = get_proc_address("glMultiTexCoord4sv"); if proc == null() {dummy_pfnglmultitexcoord4svproc} else {unsafe{transmute(proc)}}},
			loadtransposematrixf: {let proc = get_proc_address("glLoadTransposeMatrixf"); if proc == null() {dummy_pfnglloadtransposematrixfproc} else {unsafe{transmute(proc)}}},
			loadtransposematrixd: {let proc = get_proc_address("glLoadTransposeMatrixd"); if proc == null() {dummy_pfnglloadtransposematrixdproc} else {unsafe{transmute(proc)}}},
			multtransposematrixf: {let proc = get_proc_address("glMultTransposeMatrixf"); if proc == null() {dummy_pfnglmulttransposematrixfproc} else {unsafe{transmute(proc)}}},
			multtransposematrixd: {let proc = get_proc_address("glMultTransposeMatrixd"); if proc == null() {dummy_pfnglmulttransposematrixdproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version13 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			activetexture: dummy_pfnglactivetextureproc,
			samplecoverage: dummy_pfnglsamplecoverageproc,
			compressedteximage3d: dummy_pfnglcompressedteximage3dproc,
			compressedteximage2d: dummy_pfnglcompressedteximage2dproc,
			compressedteximage1d: dummy_pfnglcompressedteximage1dproc,
			compressedtexsubimage3d: dummy_pfnglcompressedtexsubimage3dproc,
			compressedtexsubimage2d: dummy_pfnglcompressedtexsubimage2dproc,
			compressedtexsubimage1d: dummy_pfnglcompressedtexsubimage1dproc,
			getcompressedteximage: dummy_pfnglgetcompressedteximageproc,
			clientactivetexture: dummy_pfnglclientactivetextureproc,
			multitexcoord1d: dummy_pfnglmultitexcoord1dproc,
			multitexcoord1dv: dummy_pfnglmultitexcoord1dvproc,
			multitexcoord1f: dummy_pfnglmultitexcoord1fproc,
			multitexcoord1fv: dummy_pfnglmultitexcoord1fvproc,
			multitexcoord1i: dummy_pfnglmultitexcoord1iproc,
			multitexcoord1iv: dummy_pfnglmultitexcoord1ivproc,
			multitexcoord1s: dummy_pfnglmultitexcoord1sproc,
			multitexcoord1sv: dummy_pfnglmultitexcoord1svproc,
			multitexcoord2d: dummy_pfnglmultitexcoord2dproc,
			multitexcoord2dv: dummy_pfnglmultitexcoord2dvproc,
			multitexcoord2f: dummy_pfnglmultitexcoord2fproc,
			multitexcoord2fv: dummy_pfnglmultitexcoord2fvproc,
			multitexcoord2i: dummy_pfnglmultitexcoord2iproc,
			multitexcoord2iv: dummy_pfnglmultitexcoord2ivproc,
			multitexcoord2s: dummy_pfnglmultitexcoord2sproc,
			multitexcoord2sv: dummy_pfnglmultitexcoord2svproc,
			multitexcoord3d: dummy_pfnglmultitexcoord3dproc,
			multitexcoord3dv: dummy_pfnglmultitexcoord3dvproc,
			multitexcoord3f: dummy_pfnglmultitexcoord3fproc,
			multitexcoord3fv: dummy_pfnglmultitexcoord3fvproc,
			multitexcoord3i: dummy_pfnglmultitexcoord3iproc,
			multitexcoord3iv: dummy_pfnglmultitexcoord3ivproc,
			multitexcoord3s: dummy_pfnglmultitexcoord3sproc,
			multitexcoord3sv: dummy_pfnglmultitexcoord3svproc,
			multitexcoord4d: dummy_pfnglmultitexcoord4dproc,
			multitexcoord4dv: dummy_pfnglmultitexcoord4dvproc,
			multitexcoord4f: dummy_pfnglmultitexcoord4fproc,
			multitexcoord4fv: dummy_pfnglmultitexcoord4fvproc,
			multitexcoord4i: dummy_pfnglmultitexcoord4iproc,
			multitexcoord4iv: dummy_pfnglmultitexcoord4ivproc,
			multitexcoord4s: dummy_pfnglmultitexcoord4sproc,
			multitexcoord4sv: dummy_pfnglmultitexcoord4svproc,
			loadtransposematrixf: dummy_pfnglloadtransposematrixfproc,
			loadtransposematrixd: dummy_pfnglloadtransposematrixdproc,
			multtransposematrixf: dummy_pfnglmulttransposematrixfproc,
			multtransposematrixd: dummy_pfnglmulttransposematrixdproc,
		}
	}
}
impl Debug for Version13 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version13")
			.field("available", &self.available)
			.field("activetexture", unsafe{if transmute::<_, *const c_void>(self.activetexture) == (dummy_pfnglactivetextureproc as *const c_void) {&null::<PFNGLACTIVETEXTUREPROC>()} else {&self.activetexture}})
			.field("samplecoverage", unsafe{if transmute::<_, *const c_void>(self.samplecoverage) == (dummy_pfnglsamplecoverageproc as *const c_void) {&null::<PFNGLSAMPLECOVERAGEPROC>()} else {&self.samplecoverage}})
			.field("compressedteximage3d", unsafe{if transmute::<_, *const c_void>(self.compressedteximage3d) == (dummy_pfnglcompressedteximage3dproc as *const c_void) {&null::<PFNGLCOMPRESSEDTEXIMAGE3DPROC>()} else {&self.compressedteximage3d}})
			.field("compressedteximage2d", unsafe{if transmute::<_, *const c_void>(self.compressedteximage2d) == (dummy_pfnglcompressedteximage2dproc as *const c_void) {&null::<PFNGLCOMPRESSEDTEXIMAGE2DPROC>()} else {&self.compressedteximage2d}})
			.field("compressedteximage1d", unsafe{if transmute::<_, *const c_void>(self.compressedteximage1d) == (dummy_pfnglcompressedteximage1dproc as *const c_void) {&null::<PFNGLCOMPRESSEDTEXIMAGE1DPROC>()} else {&self.compressedteximage1d}})
			.field("compressedtexsubimage3d", unsafe{if transmute::<_, *const c_void>(self.compressedtexsubimage3d) == (dummy_pfnglcompressedtexsubimage3dproc as *const c_void) {&null::<PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC>()} else {&self.compressedtexsubimage3d}})
			.field("compressedtexsubimage2d", unsafe{if transmute::<_, *const c_void>(self.compressedtexsubimage2d) == (dummy_pfnglcompressedtexsubimage2dproc as *const c_void) {&null::<PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC>()} else {&self.compressedtexsubimage2d}})
			.field("compressedtexsubimage1d", unsafe{if transmute::<_, *const c_void>(self.compressedtexsubimage1d) == (dummy_pfnglcompressedtexsubimage1dproc as *const c_void) {&null::<PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC>()} else {&self.compressedtexsubimage1d}})
			.field("getcompressedteximage", unsafe{if transmute::<_, *const c_void>(self.getcompressedteximage) == (dummy_pfnglgetcompressedteximageproc as *const c_void) {&null::<PFNGLGETCOMPRESSEDTEXIMAGEPROC>()} else {&self.getcompressedteximage}})
			.field("clientactivetexture", unsafe{if transmute::<_, *const c_void>(self.clientactivetexture) == (dummy_pfnglclientactivetextureproc as *const c_void) {&null::<PFNGLCLIENTACTIVETEXTUREPROC>()} else {&self.clientactivetexture}})
			.field("multitexcoord1d", unsafe{if transmute::<_, *const c_void>(self.multitexcoord1d) == (dummy_pfnglmultitexcoord1dproc as *const c_void) {&null::<PFNGLMULTITEXCOORD1DPROC>()} else {&self.multitexcoord1d}})
			.field("multitexcoord1dv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord1dv) == (dummy_pfnglmultitexcoord1dvproc as *const c_void) {&null::<PFNGLMULTITEXCOORD1DVPROC>()} else {&self.multitexcoord1dv}})
			.field("multitexcoord1f", unsafe{if transmute::<_, *const c_void>(self.multitexcoord1f) == (dummy_pfnglmultitexcoord1fproc as *const c_void) {&null::<PFNGLMULTITEXCOORD1FPROC>()} else {&self.multitexcoord1f}})
			.field("multitexcoord1fv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord1fv) == (dummy_pfnglmultitexcoord1fvproc as *const c_void) {&null::<PFNGLMULTITEXCOORD1FVPROC>()} else {&self.multitexcoord1fv}})
			.field("multitexcoord1i", unsafe{if transmute::<_, *const c_void>(self.multitexcoord1i) == (dummy_pfnglmultitexcoord1iproc as *const c_void) {&null::<PFNGLMULTITEXCOORD1IPROC>()} else {&self.multitexcoord1i}})
			.field("multitexcoord1iv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord1iv) == (dummy_pfnglmultitexcoord1ivproc as *const c_void) {&null::<PFNGLMULTITEXCOORD1IVPROC>()} else {&self.multitexcoord1iv}})
			.field("multitexcoord1s", unsafe{if transmute::<_, *const c_void>(self.multitexcoord1s) == (dummy_pfnglmultitexcoord1sproc as *const c_void) {&null::<PFNGLMULTITEXCOORD1SPROC>()} else {&self.multitexcoord1s}})
			.field("multitexcoord1sv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord1sv) == (dummy_pfnglmultitexcoord1svproc as *const c_void) {&null::<PFNGLMULTITEXCOORD1SVPROC>()} else {&self.multitexcoord1sv}})
			.field("multitexcoord2d", unsafe{if transmute::<_, *const c_void>(self.multitexcoord2d) == (dummy_pfnglmultitexcoord2dproc as *const c_void) {&null::<PFNGLMULTITEXCOORD2DPROC>()} else {&self.multitexcoord2d}})
			.field("multitexcoord2dv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord2dv) == (dummy_pfnglmultitexcoord2dvproc as *const c_void) {&null::<PFNGLMULTITEXCOORD2DVPROC>()} else {&self.multitexcoord2dv}})
			.field("multitexcoord2f", unsafe{if transmute::<_, *const c_void>(self.multitexcoord2f) == (dummy_pfnglmultitexcoord2fproc as *const c_void) {&null::<PFNGLMULTITEXCOORD2FPROC>()} else {&self.multitexcoord2f}})
			.field("multitexcoord2fv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord2fv) == (dummy_pfnglmultitexcoord2fvproc as *const c_void) {&null::<PFNGLMULTITEXCOORD2FVPROC>()} else {&self.multitexcoord2fv}})
			.field("multitexcoord2i", unsafe{if transmute::<_, *const c_void>(self.multitexcoord2i) == (dummy_pfnglmultitexcoord2iproc as *const c_void) {&null::<PFNGLMULTITEXCOORD2IPROC>()} else {&self.multitexcoord2i}})
			.field("multitexcoord2iv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord2iv) == (dummy_pfnglmultitexcoord2ivproc as *const c_void) {&null::<PFNGLMULTITEXCOORD2IVPROC>()} else {&self.multitexcoord2iv}})
			.field("multitexcoord2s", unsafe{if transmute::<_, *const c_void>(self.multitexcoord2s) == (dummy_pfnglmultitexcoord2sproc as *const c_void) {&null::<PFNGLMULTITEXCOORD2SPROC>()} else {&self.multitexcoord2s}})
			.field("multitexcoord2sv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord2sv) == (dummy_pfnglmultitexcoord2svproc as *const c_void) {&null::<PFNGLMULTITEXCOORD2SVPROC>()} else {&self.multitexcoord2sv}})
			.field("multitexcoord3d", unsafe{if transmute::<_, *const c_void>(self.multitexcoord3d) == (dummy_pfnglmultitexcoord3dproc as *const c_void) {&null::<PFNGLMULTITEXCOORD3DPROC>()} else {&self.multitexcoord3d}})
			.field("multitexcoord3dv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord3dv) == (dummy_pfnglmultitexcoord3dvproc as *const c_void) {&null::<PFNGLMULTITEXCOORD3DVPROC>()} else {&self.multitexcoord3dv}})
			.field("multitexcoord3f", unsafe{if transmute::<_, *const c_void>(self.multitexcoord3f) == (dummy_pfnglmultitexcoord3fproc as *const c_void) {&null::<PFNGLMULTITEXCOORD3FPROC>()} else {&self.multitexcoord3f}})
			.field("multitexcoord3fv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord3fv) == (dummy_pfnglmultitexcoord3fvproc as *const c_void) {&null::<PFNGLMULTITEXCOORD3FVPROC>()} else {&self.multitexcoord3fv}})
			.field("multitexcoord3i", unsafe{if transmute::<_, *const c_void>(self.multitexcoord3i) == (dummy_pfnglmultitexcoord3iproc as *const c_void) {&null::<PFNGLMULTITEXCOORD3IPROC>()} else {&self.multitexcoord3i}})
			.field("multitexcoord3iv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord3iv) == (dummy_pfnglmultitexcoord3ivproc as *const c_void) {&null::<PFNGLMULTITEXCOORD3IVPROC>()} else {&self.multitexcoord3iv}})
			.field("multitexcoord3s", unsafe{if transmute::<_, *const c_void>(self.multitexcoord3s) == (dummy_pfnglmultitexcoord3sproc as *const c_void) {&null::<PFNGLMULTITEXCOORD3SPROC>()} else {&self.multitexcoord3s}})
			.field("multitexcoord3sv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord3sv) == (dummy_pfnglmultitexcoord3svproc as *const c_void) {&null::<PFNGLMULTITEXCOORD3SVPROC>()} else {&self.multitexcoord3sv}})
			.field("multitexcoord4d", unsafe{if transmute::<_, *const c_void>(self.multitexcoord4d) == (dummy_pfnglmultitexcoord4dproc as *const c_void) {&null::<PFNGLMULTITEXCOORD4DPROC>()} else {&self.multitexcoord4d}})
			.field("multitexcoord4dv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord4dv) == (dummy_pfnglmultitexcoord4dvproc as *const c_void) {&null::<PFNGLMULTITEXCOORD4DVPROC>()} else {&self.multitexcoord4dv}})
			.field("multitexcoord4f", unsafe{if transmute::<_, *const c_void>(self.multitexcoord4f) == (dummy_pfnglmultitexcoord4fproc as *const c_void) {&null::<PFNGLMULTITEXCOORD4FPROC>()} else {&self.multitexcoord4f}})
			.field("multitexcoord4fv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord4fv) == (dummy_pfnglmultitexcoord4fvproc as *const c_void) {&null::<PFNGLMULTITEXCOORD4FVPROC>()} else {&self.multitexcoord4fv}})
			.field("multitexcoord4i", unsafe{if transmute::<_, *const c_void>(self.multitexcoord4i) == (dummy_pfnglmultitexcoord4iproc as *const c_void) {&null::<PFNGLMULTITEXCOORD4IPROC>()} else {&self.multitexcoord4i}})
			.field("multitexcoord4iv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord4iv) == (dummy_pfnglmultitexcoord4ivproc as *const c_void) {&null::<PFNGLMULTITEXCOORD4IVPROC>()} else {&self.multitexcoord4iv}})
			.field("multitexcoord4s", unsafe{if transmute::<_, *const c_void>(self.multitexcoord4s) == (dummy_pfnglmultitexcoord4sproc as *const c_void) {&null::<PFNGLMULTITEXCOORD4SPROC>()} else {&self.multitexcoord4s}})
			.field("multitexcoord4sv", unsafe{if transmute::<_, *const c_void>(self.multitexcoord4sv) == (dummy_pfnglmultitexcoord4svproc as *const c_void) {&null::<PFNGLMULTITEXCOORD4SVPROC>()} else {&self.multitexcoord4sv}})
			.field("loadtransposematrixf", unsafe{if transmute::<_, *const c_void>(self.loadtransposematrixf) == (dummy_pfnglloadtransposematrixfproc as *const c_void) {&null::<PFNGLLOADTRANSPOSEMATRIXFPROC>()} else {&self.loadtransposematrixf}})
			.field("loadtransposematrixd", unsafe{if transmute::<_, *const c_void>(self.loadtransposematrixd) == (dummy_pfnglloadtransposematrixdproc as *const c_void) {&null::<PFNGLLOADTRANSPOSEMATRIXDPROC>()} else {&self.loadtransposematrixd}})
			.field("multtransposematrixf", unsafe{if transmute::<_, *const c_void>(self.multtransposematrixf) == (dummy_pfnglmulttransposematrixfproc as *const c_void) {&null::<PFNGLMULTTRANSPOSEMATRIXFPROC>()} else {&self.multtransposematrixf}})
			.field("multtransposematrixd", unsafe{if transmute::<_, *const c_void>(self.multtransposematrixd) == (dummy_pfnglmulttransposematrixdproc as *const c_void) {&null::<PFNGLMULTTRANSPOSEMATRIXDPROC>()} else {&self.multtransposematrixd}})
			.finish()
		} else {
			f.debug_struct("Version13")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}
type PFNGLBLENDFUNCSEPARATEPROC = extern "system" fn(GLenum, GLenum, GLenum, GLenum);
type PFNGLMULTIDRAWARRAYSPROC = extern "system" fn(GLenum, *const GLint, *const GLsizei, GLsizei);
type PFNGLMULTIDRAWELEMENTSPROC = extern "system" fn(GLenum, *const GLsizei, GLenum, *const *const c_void, GLsizei);
type PFNGLPOINTPARAMETERFPROC = extern "system" fn(GLenum, GLfloat);
type PFNGLPOINTPARAMETERFVPROC = extern "system" fn(GLenum, *const GLfloat);
type PFNGLPOINTPARAMETERIPROC = extern "system" fn(GLenum, GLint);
type PFNGLPOINTPARAMETERIVPROC = extern "system" fn(GLenum, *const GLint);
type PFNGLFOGCOORDFPROC = extern "system" fn(GLfloat);
type PFNGLFOGCOORDFVPROC = extern "system" fn(*const GLfloat);
type PFNGLFOGCOORDDPROC = extern "system" fn(GLdouble);
type PFNGLFOGCOORDDVPROC = extern "system" fn(*const GLdouble);
type PFNGLFOGCOORDPOINTERPROC = extern "system" fn(GLenum, GLsizei, *const c_void);
type PFNGLSECONDARYCOLOR3BPROC = extern "system" fn(GLbyte, GLbyte, GLbyte);
type PFNGLSECONDARYCOLOR3BVPROC = extern "system" fn(*const GLbyte);
type PFNGLSECONDARYCOLOR3DPROC = extern "system" fn(GLdouble, GLdouble, GLdouble);
type PFNGLSECONDARYCOLOR3DVPROC = extern "system" fn(*const GLdouble);
type PFNGLSECONDARYCOLOR3FPROC = extern "system" fn(GLfloat, GLfloat, GLfloat);
type PFNGLSECONDARYCOLOR3FVPROC = extern "system" fn(*const GLfloat);
type PFNGLSECONDARYCOLOR3IPROC = extern "system" fn(GLint, GLint, GLint);
type PFNGLSECONDARYCOLOR3IVPROC = extern "system" fn(*const GLint);
type PFNGLSECONDARYCOLOR3SPROC = extern "system" fn(GLshort, GLshort, GLshort);
type PFNGLSECONDARYCOLOR3SVPROC = extern "system" fn(*const GLshort);
type PFNGLSECONDARYCOLOR3UBPROC = extern "system" fn(GLubyte, GLubyte, GLubyte);
type PFNGLSECONDARYCOLOR3UBVPROC = extern "system" fn(*const GLubyte);
type PFNGLSECONDARYCOLOR3UIPROC = extern "system" fn(GLuint, GLuint, GLuint);
type PFNGLSECONDARYCOLOR3UIVPROC = extern "system" fn(*const GLuint);
type PFNGLSECONDARYCOLOR3USPROC = extern "system" fn(GLushort, GLushort, GLushort);
type PFNGLSECONDARYCOLOR3USVPROC = extern "system" fn(*const GLushort);
type PFNGLSECONDARYCOLORPOINTERPROC = extern "system" fn(GLint, GLenum, GLsizei, *const c_void);
type PFNGLWINDOWPOS2DPROC = extern "system" fn(GLdouble, GLdouble);
type PFNGLWINDOWPOS2DVPROC = extern "system" fn(*const GLdouble);
type PFNGLWINDOWPOS2FPROC = extern "system" fn(GLfloat, GLfloat);
type PFNGLWINDOWPOS2FVPROC = extern "system" fn(*const GLfloat);
type PFNGLWINDOWPOS2IPROC = extern "system" fn(GLint, GLint);
type PFNGLWINDOWPOS2IVPROC = extern "system" fn(*const GLint);
type PFNGLWINDOWPOS2SPROC = extern "system" fn(GLshort, GLshort);
type PFNGLWINDOWPOS2SVPROC = extern "system" fn(*const GLshort);
type PFNGLWINDOWPOS3DPROC = extern "system" fn(GLdouble, GLdouble, GLdouble);
type PFNGLWINDOWPOS3DVPROC = extern "system" fn(*const GLdouble);
type PFNGLWINDOWPOS3FPROC = extern "system" fn(GLfloat, GLfloat, GLfloat);
type PFNGLWINDOWPOS3FVPROC = extern "system" fn(*const GLfloat);
type PFNGLWINDOWPOS3IPROC = extern "system" fn(GLint, GLint, GLint);
type PFNGLWINDOWPOS3IVPROC = extern "system" fn(*const GLint);
type PFNGLWINDOWPOS3SPROC = extern "system" fn(GLshort, GLshort, GLshort);
type PFNGLWINDOWPOS3SVPROC = extern "system" fn(*const GLshort);
type PFNGLBLENDCOLORPROC = extern "system" fn(GLfloat, GLfloat, GLfloat, GLfloat);
type PFNGLBLENDEQUATIONPROC = extern "system" fn(GLenum);
extern "system" fn dummy_pfnglblendfuncseparateproc (_: GLenum, _: GLenum, _: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glBlendFuncSeparate()` is null.")
}
extern "system" fn dummy_pfnglmultidrawarraysproc (_: GLenum, _: *const GLint, _: *const GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glMultiDrawArrays()` is null.")
}
extern "system" fn dummy_pfnglmultidrawelementsproc (_: GLenum, _: *const GLsizei, _: GLenum, _: *const *const c_void, _: GLsizei) {
	panic!("OpenGL function pointer `glMultiDrawElements()` is null.")
}
extern "system" fn dummy_pfnglpointparameterfproc (_: GLenum, _: GLfloat) {
	panic!("OpenGL function pointer `glPointParameterf()` is null.")
}
extern "system" fn dummy_pfnglpointparameterfvproc (_: GLenum, _: *const GLfloat) {
	panic!("OpenGL function pointer `glPointParameterfv()` is null.")
}
extern "system" fn dummy_pfnglpointparameteriproc (_: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glPointParameteri()` is null.")
}
extern "system" fn dummy_pfnglpointparameterivproc (_: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glPointParameteriv()` is null.")
}
extern "system" fn dummy_pfnglfogcoordfproc (_: GLfloat) {
	panic!("OpenGL function pointer `glFogCoordf()` is null.")
}
extern "system" fn dummy_pfnglfogcoordfvproc (_: *const GLfloat) {
	panic!("OpenGL function pointer `glFogCoordfv()` is null.")
}
extern "system" fn dummy_pfnglfogcoorddproc (_: GLdouble) {
	panic!("OpenGL function pointer `glFogCoordd()` is null.")
}
extern "system" fn dummy_pfnglfogcoorddvproc (_: *const GLdouble) {
	panic!("OpenGL function pointer `glFogCoorddv()` is null.")
}
extern "system" fn dummy_pfnglfogcoordpointerproc (_: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glFogCoordPointer()` is null.")
}
extern "system" fn dummy_pfnglsecondarycolor3bproc (_: GLbyte, _: GLbyte, _: GLbyte) {
	panic!("OpenGL function pointer `glSecondaryColor3b()` is null.")
}
extern "system" fn dummy_pfnglsecondarycolor3bvproc (_: *const GLbyte) {
	panic!("OpenGL function pointer `glSecondaryColor3bv()` is null.")
}
extern "system" fn dummy_pfnglsecondarycolor3dproc (_: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glSecondaryColor3d()` is null.")
}
extern "system" fn dummy_pfnglsecondarycolor3dvproc (_: *const GLdouble) {
	panic!("OpenGL function pointer `glSecondaryColor3dv()` is null.")
}
extern "system" fn dummy_pfnglsecondarycolor3fproc (_: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glSecondaryColor3f()` is null.")
}
extern "system" fn dummy_pfnglsecondarycolor3fvproc (_: *const GLfloat) {
	panic!("OpenGL function pointer `glSecondaryColor3fv()` is null.")
}
extern "system" fn dummy_pfnglsecondarycolor3iproc (_: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glSecondaryColor3i()` is null.")
}
extern "system" fn dummy_pfnglsecondarycolor3ivproc (_: *const GLint) {
	panic!("OpenGL function pointer `glSecondaryColor3iv()` is null.")
}
extern "system" fn dummy_pfnglsecondarycolor3sproc (_: GLshort, _: GLshort, _: GLshort) {
	panic!("OpenGL function pointer `glSecondaryColor3s()` is null.")
}
extern "system" fn dummy_pfnglsecondarycolor3svproc (_: *const GLshort) {
	panic!("OpenGL function pointer `glSecondaryColor3sv()` is null.")
}
extern "system" fn dummy_pfnglsecondarycolor3ubproc (_: GLubyte, _: GLubyte, _: GLubyte) {
	panic!("OpenGL function pointer `glSecondaryColor3ub()` is null.")
}
extern "system" fn dummy_pfnglsecondarycolor3ubvproc (_: *const GLubyte) {
	panic!("OpenGL function pointer `glSecondaryColor3ubv()` is null.")
}
extern "system" fn dummy_pfnglsecondarycolor3uiproc (_: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glSecondaryColor3ui()` is null.")
}
extern "system" fn dummy_pfnglsecondarycolor3uivproc (_: *const GLuint) {
	panic!("OpenGL function pointer `glSecondaryColor3uiv()` is null.")
}
extern "system" fn dummy_pfnglsecondarycolor3usproc (_: GLushort, _: GLushort, _: GLushort) {
	panic!("OpenGL function pointer `glSecondaryColor3us()` is null.")
}
extern "system" fn dummy_pfnglsecondarycolor3usvproc (_: *const GLushort) {
	panic!("OpenGL function pointer `glSecondaryColor3usv()` is null.")
}
extern "system" fn dummy_pfnglsecondarycolorpointerproc (_: GLint, _: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glSecondaryColorPointer()` is null.")
}
extern "system" fn dummy_pfnglwindowpos2dproc (_: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glWindowPos2d()` is null.")
}
extern "system" fn dummy_pfnglwindowpos2dvproc (_: *const GLdouble) {
	panic!("OpenGL function pointer `glWindowPos2dv()` is null.")
}
extern "system" fn dummy_pfnglwindowpos2fproc (_: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glWindowPos2f()` is null.")
}
extern "system" fn dummy_pfnglwindowpos2fvproc (_: *const GLfloat) {
	panic!("OpenGL function pointer `glWindowPos2fv()` is null.")
}
extern "system" fn dummy_pfnglwindowpos2iproc (_: GLint, _: GLint) {
	panic!("OpenGL function pointer `glWindowPos2i()` is null.")
}
extern "system" fn dummy_pfnglwindowpos2ivproc (_: *const GLint) {
	panic!("OpenGL function pointer `glWindowPos2iv()` is null.")
}
extern "system" fn dummy_pfnglwindowpos2sproc (_: GLshort, _: GLshort) {
	panic!("OpenGL function pointer `glWindowPos2s()` is null.")
}
extern "system" fn dummy_pfnglwindowpos2svproc (_: *const GLshort) {
	panic!("OpenGL function pointer `glWindowPos2sv()` is null.")
}
extern "system" fn dummy_pfnglwindowpos3dproc (_: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glWindowPos3d()` is null.")
}
extern "system" fn dummy_pfnglwindowpos3dvproc (_: *const GLdouble) {
	panic!("OpenGL function pointer `glWindowPos3dv()` is null.")
}
extern "system" fn dummy_pfnglwindowpos3fproc (_: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glWindowPos3f()` is null.")
}
extern "system" fn dummy_pfnglwindowpos3fvproc (_: *const GLfloat) {
	panic!("OpenGL function pointer `glWindowPos3fv()` is null.")
}
extern "system" fn dummy_pfnglwindowpos3iproc (_: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glWindowPos3i()` is null.")
}
extern "system" fn dummy_pfnglwindowpos3ivproc (_: *const GLint) {
	panic!("OpenGL function pointer `glWindowPos3iv()` is null.")
}
extern "system" fn dummy_pfnglwindowpos3sproc (_: GLshort, _: GLshort, _: GLshort) {
	panic!("OpenGL function pointer `glWindowPos3s()` is null.")
}
extern "system" fn dummy_pfnglwindowpos3svproc (_: *const GLshort) {
	panic!("OpenGL function pointer `glWindowPos3sv()` is null.")
}
extern "system" fn dummy_pfnglblendcolorproc (_: GLfloat, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glBlendColor()` is null.")
}
extern "system" fn dummy_pfnglblendequationproc (_: GLenum) {
	panic!("OpenGL function pointer `glBlendEquation()` is null.")
}
pub const GL_BLEND_DST_RGB: GLenum = 0x80C8;
pub const GL_BLEND_SRC_RGB: GLenum = 0x80C9;
pub const GL_BLEND_DST_ALPHA: GLenum = 0x80CA;
pub const GL_BLEND_SRC_ALPHA: GLenum = 0x80CB;
pub const GL_POINT_FADE_THRESHOLD_SIZE: GLenum = 0x8128;
pub const GL_DEPTH_COMPONENT16: GLenum = 0x81A5;
pub const GL_DEPTH_COMPONENT24: GLenum = 0x81A6;
pub const GL_DEPTH_COMPONENT32: GLenum = 0x81A7;
pub const GL_MIRRORED_REPEAT: GLint = 0x8370;
pub const GL_MAX_TEXTURE_LOD_BIAS: GLenum = 0x84FD;
pub const GL_TEXTURE_LOD_BIAS: GLenum = 0x8501;
pub const GL_INCR_WRAP: GLenum = 0x8507;
pub const GL_DECR_WRAP: GLenum = 0x8508;
pub const GL_TEXTURE_DEPTH_SIZE: GLenum = 0x884A;
pub const GL_TEXTURE_COMPARE_MODE: GLenum = 0x884C;
pub const GL_TEXTURE_COMPARE_FUNC: GLenum = 0x884D;
pub const GL_POINT_SIZE_MIN: GLenum = 0x8126;
pub const GL_POINT_SIZE_MAX: GLenum = 0x8127;
pub const GL_POINT_DISTANCE_ATTENUATION: GLenum = 0x8129;
pub const GL_GENERATE_MIPMAP: GLenum = 0x8191;
pub const GL_GENERATE_MIPMAP_HINT: GLenum = 0x8192;
pub const GL_FOG_COORDINATE_SOURCE: GLenum = 0x8450;
pub const GL_FOG_COORDINATE: GLenum = 0x8451;
pub const GL_FRAGMENT_DEPTH: GLenum = 0x8452;
pub const GL_CURRENT_FOG_COORDINATE: GLenum = 0x8453;
pub const GL_FOG_COORDINATE_ARRAY_TYPE: GLenum = 0x8454;
pub const GL_FOG_COORDINATE_ARRAY_STRIDE: GLenum = 0x8455;
pub const GL_FOG_COORDINATE_ARRAY_POINTER: GLenum = 0x8456;
pub const GL_FOG_COORDINATE_ARRAY: GLenum = 0x8457;
pub const GL_COLOR_SUM: GLenum = 0x8458;
pub const GL_CURRENT_SECONDARY_COLOR: GLenum = 0x8459;
pub const GL_SECONDARY_COLOR_ARRAY_SIZE: GLenum = 0x845A;
pub const GL_SECONDARY_COLOR_ARRAY_TYPE: GLenum = 0x845B;
pub const GL_SECONDARY_COLOR_ARRAY_STRIDE: GLenum = 0x845C;
pub const GL_SECONDARY_COLOR_ARRAY_POINTER: GLenum = 0x845D;
pub const GL_SECONDARY_COLOR_ARRAY: GLenum = 0x845E;
pub const GL_TEXTURE_FILTER_CONTROL: GLenum = 0x8500;
pub const GL_DEPTH_TEXTURE_MODE: GLenum = 0x884B;
pub const GL_COMPARE_R_TO_TEXTURE: GLenum = 0x884E;
pub const GL_BLEND_COLOR: GLenum = 0x8005;
pub const GL_BLEND_EQUATION: GLenum = 0x8009;
pub const GL_CONSTANT_COLOR: GLenum = 0x8001;
pub const GL_ONE_MINUS_CONSTANT_COLOR: GLenum = 0x8002;
pub const GL_CONSTANT_ALPHA: GLenum = 0x8003;
pub const GL_ONE_MINUS_CONSTANT_ALPHA: GLenum = 0x8004;
pub const GL_FUNC_ADD: GLenum = 0x8006;
pub const GL_FUNC_REVERSE_SUBTRACT: GLenum = 0x800B;
pub const GL_FUNC_SUBTRACT: GLenum = 0x800A;
pub const GL_MIN: GLenum = 0x8007;
pub const GL_MAX: GLenum = 0x8008;

pub trait GL_1_4 {
	fn glGetError(&self) -> GLenum;
	fn glBlendFuncSeparate(&self, sfactorRGB: GLenum, dfactorRGB: GLenum, sfactorAlpha: GLenum, dfactorAlpha: GLenum) -> Result<()>;
	fn glMultiDrawArrays(&self, mode: GLenum, first: *const GLint, count: *const GLsizei, drawcount: GLsizei) -> Result<()>;
	fn glMultiDrawElements(&self, mode: GLenum, count: *const GLsizei, type_: GLenum, indices: *const *const c_void, drawcount: GLsizei) -> Result<()>;
	fn glPointParameterf(&self, pname: GLenum, param: GLfloat) -> Result<()>;
	fn glPointParameterfv(&self, pname: GLenum, params: *const GLfloat) -> Result<()>;
	fn glPointParameteri(&self, pname: GLenum, param: GLint) -> Result<()>;
	fn glPointParameteriv(&self, pname: GLenum, params: *const GLint) -> Result<()>;
	fn glFogCoordf(&self, coord: GLfloat) -> Result<()>;
	fn glFogCoordfv(&self, coord: *const GLfloat) -> Result<()>;
	fn glFogCoordd(&self, coord: GLdouble) -> Result<()>;
	fn glFogCoorddv(&self, coord: *const GLdouble) -> Result<()>;
	fn glFogCoordPointer(&self, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()>;
	fn glSecondaryColor3b(&self, red: GLbyte, green: GLbyte, blue: GLbyte) -> Result<()>;
	fn glSecondaryColor3bv(&self, v: *const GLbyte) -> Result<()>;
	fn glSecondaryColor3d(&self, red: GLdouble, green: GLdouble, blue: GLdouble) -> Result<()>;
	fn glSecondaryColor3dv(&self, v: *const GLdouble) -> Result<()>;
	fn glSecondaryColor3f(&self, red: GLfloat, green: GLfloat, blue: GLfloat) -> Result<()>;
	fn glSecondaryColor3fv(&self, v: *const GLfloat) -> Result<()>;
	fn glSecondaryColor3i(&self, red: GLint, green: GLint, blue: GLint) -> Result<()>;
	fn glSecondaryColor3iv(&self, v: *const GLint) -> Result<()>;
	fn glSecondaryColor3s(&self, red: GLshort, green: GLshort, blue: GLshort) -> Result<()>;
	fn glSecondaryColor3sv(&self, v: *const GLshort) -> Result<()>;
	fn glSecondaryColor3ub(&self, red: GLubyte, green: GLubyte, blue: GLubyte) -> Result<()>;
	fn glSecondaryColor3ubv(&self, v: *const GLubyte) -> Result<()>;
	fn glSecondaryColor3ui(&self, red: GLuint, green: GLuint, blue: GLuint) -> Result<()>;
	fn glSecondaryColor3uiv(&self, v: *const GLuint) -> Result<()>;
	fn glSecondaryColor3us(&self, red: GLushort, green: GLushort, blue: GLushort) -> Result<()>;
	fn glSecondaryColor3usv(&self, v: *const GLushort) -> Result<()>;
	fn glSecondaryColorPointer(&self, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()>;
	fn glWindowPos2d(&self, x: GLdouble, y: GLdouble) -> Result<()>;
	fn glWindowPos2dv(&self, v: *const GLdouble) -> Result<()>;
	fn glWindowPos2f(&self, x: GLfloat, y: GLfloat) -> Result<()>;
	fn glWindowPos2fv(&self, v: *const GLfloat) -> Result<()>;
	fn glWindowPos2i(&self, x: GLint, y: GLint) -> Result<()>;
	fn glWindowPos2iv(&self, v: *const GLint) -> Result<()>;
	fn glWindowPos2s(&self, x: GLshort, y: GLshort) -> Result<()>;
	fn glWindowPos2sv(&self, v: *const GLshort) -> Result<()>;
	fn glWindowPos3d(&self, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()>;
	fn glWindowPos3dv(&self, v: *const GLdouble) -> Result<()>;
	fn glWindowPos3f(&self, x: GLfloat, y: GLfloat, z: GLfloat) -> Result<()>;
	fn glWindowPos3fv(&self, v: *const GLfloat) -> Result<()>;
	fn glWindowPos3i(&self, x: GLint, y: GLint, z: GLint) -> Result<()>;
	fn glWindowPos3iv(&self, v: *const GLint) -> Result<()>;
	fn glWindowPos3s(&self, x: GLshort, y: GLshort, z: GLshort) -> Result<()>;
	fn glWindowPos3sv(&self, v: *const GLshort) -> Result<()>;
	fn glBlendColor(&self, red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) -> Result<()>;
	fn glBlendEquation(&self, mode: GLenum) -> Result<()>;
}

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version14 {
	available: bool,
	geterror: PFNGLGETERRORPROC,
	blendfuncseparate: PFNGLBLENDFUNCSEPARATEPROC,
	multidrawarrays: PFNGLMULTIDRAWARRAYSPROC,
	multidrawelements: PFNGLMULTIDRAWELEMENTSPROC,
	pointparameterf: PFNGLPOINTPARAMETERFPROC,
	pointparameterfv: PFNGLPOINTPARAMETERFVPROC,
	pointparameteri: PFNGLPOINTPARAMETERIPROC,
	pointparameteriv: PFNGLPOINTPARAMETERIVPROC,
	fogcoordf: PFNGLFOGCOORDFPROC,
	fogcoordfv: PFNGLFOGCOORDFVPROC,
	fogcoordd: PFNGLFOGCOORDDPROC,
	fogcoorddv: PFNGLFOGCOORDDVPROC,
	fogcoordpointer: PFNGLFOGCOORDPOINTERPROC,
	secondarycolor3b: PFNGLSECONDARYCOLOR3BPROC,
	secondarycolor3bv: PFNGLSECONDARYCOLOR3BVPROC,
	secondarycolor3d: PFNGLSECONDARYCOLOR3DPROC,
	secondarycolor3dv: PFNGLSECONDARYCOLOR3DVPROC,
	secondarycolor3f: PFNGLSECONDARYCOLOR3FPROC,
	secondarycolor3fv: PFNGLSECONDARYCOLOR3FVPROC,
	secondarycolor3i: PFNGLSECONDARYCOLOR3IPROC,
	secondarycolor3iv: PFNGLSECONDARYCOLOR3IVPROC,
	secondarycolor3s: PFNGLSECONDARYCOLOR3SPROC,
	secondarycolor3sv: PFNGLSECONDARYCOLOR3SVPROC,
	secondarycolor3ub: PFNGLSECONDARYCOLOR3UBPROC,
	secondarycolor3ubv: PFNGLSECONDARYCOLOR3UBVPROC,
	secondarycolor3ui: PFNGLSECONDARYCOLOR3UIPROC,
	secondarycolor3uiv: PFNGLSECONDARYCOLOR3UIVPROC,
	secondarycolor3us: PFNGLSECONDARYCOLOR3USPROC,
	secondarycolor3usv: PFNGLSECONDARYCOLOR3USVPROC,
	secondarycolorpointer: PFNGLSECONDARYCOLORPOINTERPROC,
	windowpos2d: PFNGLWINDOWPOS2DPROC,
	windowpos2dv: PFNGLWINDOWPOS2DVPROC,
	windowpos2f: PFNGLWINDOWPOS2FPROC,
	windowpos2fv: PFNGLWINDOWPOS2FVPROC,
	windowpos2i: PFNGLWINDOWPOS2IPROC,
	windowpos2iv: PFNGLWINDOWPOS2IVPROC,
	windowpos2s: PFNGLWINDOWPOS2SPROC,
	windowpos2sv: PFNGLWINDOWPOS2SVPROC,
	windowpos3d: PFNGLWINDOWPOS3DPROC,
	windowpos3dv: PFNGLWINDOWPOS3DVPROC,
	windowpos3f: PFNGLWINDOWPOS3FPROC,
	windowpos3fv: PFNGLWINDOWPOS3FVPROC,
	windowpos3i: PFNGLWINDOWPOS3IPROC,
	windowpos3iv: PFNGLWINDOWPOS3IVPROC,
	windowpos3s: PFNGLWINDOWPOS3SPROC,
	windowpos3sv: PFNGLWINDOWPOS3SVPROC,
	blendcolor: PFNGLBLENDCOLORPROC,
	blendequation: PFNGLBLENDEQUATIONPROC,
}

impl GL_1_4 for Version14 {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	#[inline(always)]
	fn glBlendFuncSeparate(&self, sfactorRGB: GLenum, dfactorRGB: GLenum, sfactorAlpha: GLenum, dfactorAlpha: GLenum) -> Result<()> {
		let ret = process_catch("glBlendFuncSeparate", catch_unwind(||(self.blendfuncseparate)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendFuncSeparate", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiDrawArrays(&self, mode: GLenum, first: *const GLint, count: *const GLsizei, drawcount: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawArrays", catch_unwind(||(self.multidrawarrays)(mode, first, count, drawcount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawArrays", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiDrawElements(&self, mode: GLenum, count: *const GLsizei, type_: GLenum, indices: *const *const c_void, drawcount: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawElements", catch_unwind(||(self.multidrawelements)(mode, count, type_, indices, drawcount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawElements", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPointParameterf(&self, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glPointParameterf", catch_unwind(||(self.pointparameterf)(pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointParameterf", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPointParameterfv(&self, pname: GLenum, params: *const GLfloat) -> Result<()> {
		let ret = process_catch("glPointParameterfv", catch_unwind(||(self.pointparameterfv)(pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPointParameteri(&self, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glPointParameteri", catch_unwind(||(self.pointparameteri)(pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointParameteri", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPointParameteriv(&self, pname: GLenum, params: *const GLint) -> Result<()> {
		let ret = process_catch("glPointParameteriv", catch_unwind(||(self.pointparameteriv)(pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFogCoordf(&self, coord: GLfloat) -> Result<()> {
		let ret = process_catch("glFogCoordf", catch_unwind(||(self.fogcoordf)(coord)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoordf", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFogCoordfv(&self, coord: *const GLfloat) -> Result<()> {
		let ret = process_catch("glFogCoordfv", catch_unwind(||(self.fogcoordfv)(coord)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoordfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFogCoordd(&self, coord: GLdouble) -> Result<()> {
		let ret = process_catch("glFogCoordd", catch_unwind(||(self.fogcoordd)(coord)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoordd", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFogCoorddv(&self, coord: *const GLdouble) -> Result<()> {
		let ret = process_catch("glFogCoorddv", catch_unwind(||(self.fogcoorddv)(coord)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoorddv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFogCoordPointer(&self, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glFogCoordPointer", catch_unwind(||(self.fogcoordpointer)(type_, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoordPointer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3b(&self, red: GLbyte, green: GLbyte, blue: GLbyte) -> Result<()> {
		let ret = process_catch("glSecondaryColor3b", catch_unwind(||(self.secondarycolor3b)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3b", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3bv(&self, v: *const GLbyte) -> Result<()> {
		let ret = process_catch("glSecondaryColor3bv", catch_unwind(||(self.secondarycolor3bv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3bv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3d(&self, red: GLdouble, green: GLdouble, blue: GLdouble) -> Result<()> {
		let ret = process_catch("glSecondaryColor3d", catch_unwind(||(self.secondarycolor3d)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3dv(&self, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glSecondaryColor3dv", catch_unwind(||(self.secondarycolor3dv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3f(&self, red: GLfloat, green: GLfloat, blue: GLfloat) -> Result<()> {
		let ret = process_catch("glSecondaryColor3f", catch_unwind(||(self.secondarycolor3f)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3fv(&self, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glSecondaryColor3fv", catch_unwind(||(self.secondarycolor3fv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3i(&self, red: GLint, green: GLint, blue: GLint) -> Result<()> {
		let ret = process_catch("glSecondaryColor3i", catch_unwind(||(self.secondarycolor3i)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3iv(&self, v: *const GLint) -> Result<()> {
		let ret = process_catch("glSecondaryColor3iv", catch_unwind(||(self.secondarycolor3iv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3s(&self, red: GLshort, green: GLshort, blue: GLshort) -> Result<()> {
		let ret = process_catch("glSecondaryColor3s", catch_unwind(||(self.secondarycolor3s)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3sv(&self, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glSecondaryColor3sv", catch_unwind(||(self.secondarycolor3sv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3ub(&self, red: GLubyte, green: GLubyte, blue: GLubyte) -> Result<()> {
		let ret = process_catch("glSecondaryColor3ub", catch_unwind(||(self.secondarycolor3ub)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3ub", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3ubv(&self, v: *const GLubyte) -> Result<()> {
		let ret = process_catch("glSecondaryColor3ubv", catch_unwind(||(self.secondarycolor3ubv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3ubv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3ui(&self, red: GLuint, green: GLuint, blue: GLuint) -> Result<()> {
		let ret = process_catch("glSecondaryColor3ui", catch_unwind(||(self.secondarycolor3ui)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3uiv(&self, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glSecondaryColor3uiv", catch_unwind(||(self.secondarycolor3uiv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3us(&self, red: GLushort, green: GLushort, blue: GLushort) -> Result<()> {
		let ret = process_catch("glSecondaryColor3us", catch_unwind(||(self.secondarycolor3us)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3us", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3usv(&self, v: *const GLushort) -> Result<()> {
		let ret = process_catch("glSecondaryColor3usv", catch_unwind(||(self.secondarycolor3usv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3usv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColorPointer(&self, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glSecondaryColorPointer", catch_unwind(||(self.secondarycolorpointer)(size, type_, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColorPointer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos2d(&self, x: GLdouble, y: GLdouble) -> Result<()> {
		let ret = process_catch("glWindowPos2d", catch_unwind(||(self.windowpos2d)(x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos2dv(&self, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glWindowPos2dv", catch_unwind(||(self.windowpos2dv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos2f(&self, x: GLfloat, y: GLfloat) -> Result<()> {
		let ret = process_catch("glWindowPos2f", catch_unwind(||(self.windowpos2f)(x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos2fv(&self, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glWindowPos2fv", catch_unwind(||(self.windowpos2fv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos2i(&self, x: GLint, y: GLint) -> Result<()> {
		let ret = process_catch("glWindowPos2i", catch_unwind(||(self.windowpos2i)(x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos2iv(&self, v: *const GLint) -> Result<()> {
		let ret = process_catch("glWindowPos2iv", catch_unwind(||(self.windowpos2iv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos2s(&self, x: GLshort, y: GLshort) -> Result<()> {
		let ret = process_catch("glWindowPos2s", catch_unwind(||(self.windowpos2s)(x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos2sv(&self, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glWindowPos2sv", catch_unwind(||(self.windowpos2sv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos3d(&self, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()> {
		let ret = process_catch("glWindowPos3d", catch_unwind(||(self.windowpos3d)(x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos3dv(&self, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glWindowPos3dv", catch_unwind(||(self.windowpos3dv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos3f(&self, x: GLfloat, y: GLfloat, z: GLfloat) -> Result<()> {
		let ret = process_catch("glWindowPos3f", catch_unwind(||(self.windowpos3f)(x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos3fv(&self, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glWindowPos3fv", catch_unwind(||(self.windowpos3fv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos3i(&self, x: GLint, y: GLint, z: GLint) -> Result<()> {
		let ret = process_catch("glWindowPos3i", catch_unwind(||(self.windowpos3i)(x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos3iv(&self, v: *const GLint) -> Result<()> {
		let ret = process_catch("glWindowPos3iv", catch_unwind(||(self.windowpos3iv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos3s(&self, x: GLshort, y: GLshort, z: GLshort) -> Result<()> {
		let ret = process_catch("glWindowPos3s", catch_unwind(||(self.windowpos3s)(x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos3sv(&self, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glWindowPos3sv", catch_unwind(||(self.windowpos3sv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBlendColor(&self, red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) -> Result<()> {
		let ret = process_catch("glBlendColor", catch_unwind(||(self.blendcolor)(red, green, blue, alpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendColor", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBlendEquation(&self, mode: GLenum) -> Result<()> {
		let ret = process_catch("glBlendEquation", catch_unwind(||(self.blendequation)(mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendEquation", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version14 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (1, 4, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			blendfuncseparate: {let proc = get_proc_address("glBlendFuncSeparate"); if proc == null() {dummy_pfnglblendfuncseparateproc} else {unsafe{transmute(proc)}}},
			multidrawarrays: {let proc = get_proc_address("glMultiDrawArrays"); if proc == null() {dummy_pfnglmultidrawarraysproc} else {unsafe{transmute(proc)}}},
			multidrawelements: {let proc = get_proc_address("glMultiDrawElements"); if proc == null() {dummy_pfnglmultidrawelementsproc} else {unsafe{transmute(proc)}}},
			pointparameterf: {let proc = get_proc_address("glPointParameterf"); if proc == null() {dummy_pfnglpointparameterfproc} else {unsafe{transmute(proc)}}},
			pointparameterfv: {let proc = get_proc_address("glPointParameterfv"); if proc == null() {dummy_pfnglpointparameterfvproc} else {unsafe{transmute(proc)}}},
			pointparameteri: {let proc = get_proc_address("glPointParameteri"); if proc == null() {dummy_pfnglpointparameteriproc} else {unsafe{transmute(proc)}}},
			pointparameteriv: {let proc = get_proc_address("glPointParameteriv"); if proc == null() {dummy_pfnglpointparameterivproc} else {unsafe{transmute(proc)}}},
			fogcoordf: {let proc = get_proc_address("glFogCoordf"); if proc == null() {dummy_pfnglfogcoordfproc} else {unsafe{transmute(proc)}}},
			fogcoordfv: {let proc = get_proc_address("glFogCoordfv"); if proc == null() {dummy_pfnglfogcoordfvproc} else {unsafe{transmute(proc)}}},
			fogcoordd: {let proc = get_proc_address("glFogCoordd"); if proc == null() {dummy_pfnglfogcoorddproc} else {unsafe{transmute(proc)}}},
			fogcoorddv: {let proc = get_proc_address("glFogCoorddv"); if proc == null() {dummy_pfnglfogcoorddvproc} else {unsafe{transmute(proc)}}},
			fogcoordpointer: {let proc = get_proc_address("glFogCoordPointer"); if proc == null() {dummy_pfnglfogcoordpointerproc} else {unsafe{transmute(proc)}}},
			secondarycolor3b: {let proc = get_proc_address("glSecondaryColor3b"); if proc == null() {dummy_pfnglsecondarycolor3bproc} else {unsafe{transmute(proc)}}},
			secondarycolor3bv: {let proc = get_proc_address("glSecondaryColor3bv"); if proc == null() {dummy_pfnglsecondarycolor3bvproc} else {unsafe{transmute(proc)}}},
			secondarycolor3d: {let proc = get_proc_address("glSecondaryColor3d"); if proc == null() {dummy_pfnglsecondarycolor3dproc} else {unsafe{transmute(proc)}}},
			secondarycolor3dv: {let proc = get_proc_address("glSecondaryColor3dv"); if proc == null() {dummy_pfnglsecondarycolor3dvproc} else {unsafe{transmute(proc)}}},
			secondarycolor3f: {let proc = get_proc_address("glSecondaryColor3f"); if proc == null() {dummy_pfnglsecondarycolor3fproc} else {unsafe{transmute(proc)}}},
			secondarycolor3fv: {let proc = get_proc_address("glSecondaryColor3fv"); if proc == null() {dummy_pfnglsecondarycolor3fvproc} else {unsafe{transmute(proc)}}},
			secondarycolor3i: {let proc = get_proc_address("glSecondaryColor3i"); if proc == null() {dummy_pfnglsecondarycolor3iproc} else {unsafe{transmute(proc)}}},
			secondarycolor3iv: {let proc = get_proc_address("glSecondaryColor3iv"); if proc == null() {dummy_pfnglsecondarycolor3ivproc} else {unsafe{transmute(proc)}}},
			secondarycolor3s: {let proc = get_proc_address("glSecondaryColor3s"); if proc == null() {dummy_pfnglsecondarycolor3sproc} else {unsafe{transmute(proc)}}},
			secondarycolor3sv: {let proc = get_proc_address("glSecondaryColor3sv"); if proc == null() {dummy_pfnglsecondarycolor3svproc} else {unsafe{transmute(proc)}}},
			secondarycolor3ub: {let proc = get_proc_address("glSecondaryColor3ub"); if proc == null() {dummy_pfnglsecondarycolor3ubproc} else {unsafe{transmute(proc)}}},
			secondarycolor3ubv: {let proc = get_proc_address("glSecondaryColor3ubv"); if proc == null() {dummy_pfnglsecondarycolor3ubvproc} else {unsafe{transmute(proc)}}},
			secondarycolor3ui: {let proc = get_proc_address("glSecondaryColor3ui"); if proc == null() {dummy_pfnglsecondarycolor3uiproc} else {unsafe{transmute(proc)}}},
			secondarycolor3uiv: {let proc = get_proc_address("glSecondaryColor3uiv"); if proc == null() {dummy_pfnglsecondarycolor3uivproc} else {unsafe{transmute(proc)}}},
			secondarycolor3us: {let proc = get_proc_address("glSecondaryColor3us"); if proc == null() {dummy_pfnglsecondarycolor3usproc} else {unsafe{transmute(proc)}}},
			secondarycolor3usv: {let proc = get_proc_address("glSecondaryColor3usv"); if proc == null() {dummy_pfnglsecondarycolor3usvproc} else {unsafe{transmute(proc)}}},
			secondarycolorpointer: {let proc = get_proc_address("glSecondaryColorPointer"); if proc == null() {dummy_pfnglsecondarycolorpointerproc} else {unsafe{transmute(proc)}}},
			windowpos2d: {let proc = get_proc_address("glWindowPos2d"); if proc == null() {dummy_pfnglwindowpos2dproc} else {unsafe{transmute(proc)}}},
			windowpos2dv: {let proc = get_proc_address("glWindowPos2dv"); if proc == null() {dummy_pfnglwindowpos2dvproc} else {unsafe{transmute(proc)}}},
			windowpos2f: {let proc = get_proc_address("glWindowPos2f"); if proc == null() {dummy_pfnglwindowpos2fproc} else {unsafe{transmute(proc)}}},
			windowpos2fv: {let proc = get_proc_address("glWindowPos2fv"); if proc == null() {dummy_pfnglwindowpos2fvproc} else {unsafe{transmute(proc)}}},
			windowpos2i: {let proc = get_proc_address("glWindowPos2i"); if proc == null() {dummy_pfnglwindowpos2iproc} else {unsafe{transmute(proc)}}},
			windowpos2iv: {let proc = get_proc_address("glWindowPos2iv"); if proc == null() {dummy_pfnglwindowpos2ivproc} else {unsafe{transmute(proc)}}},
			windowpos2s: {let proc = get_proc_address("glWindowPos2s"); if proc == null() {dummy_pfnglwindowpos2sproc} else {unsafe{transmute(proc)}}},
			windowpos2sv: {let proc = get_proc_address("glWindowPos2sv"); if proc == null() {dummy_pfnglwindowpos2svproc} else {unsafe{transmute(proc)}}},
			windowpos3d: {let proc = get_proc_address("glWindowPos3d"); if proc == null() {dummy_pfnglwindowpos3dproc} else {unsafe{transmute(proc)}}},
			windowpos3dv: {let proc = get_proc_address("glWindowPos3dv"); if proc == null() {dummy_pfnglwindowpos3dvproc} else {unsafe{transmute(proc)}}},
			windowpos3f: {let proc = get_proc_address("glWindowPos3f"); if proc == null() {dummy_pfnglwindowpos3fproc} else {unsafe{transmute(proc)}}},
			windowpos3fv: {let proc = get_proc_address("glWindowPos3fv"); if proc == null() {dummy_pfnglwindowpos3fvproc} else {unsafe{transmute(proc)}}},
			windowpos3i: {let proc = get_proc_address("glWindowPos3i"); if proc == null() {dummy_pfnglwindowpos3iproc} else {unsafe{transmute(proc)}}},
			windowpos3iv: {let proc = get_proc_address("glWindowPos3iv"); if proc == null() {dummy_pfnglwindowpos3ivproc} else {unsafe{transmute(proc)}}},
			windowpos3s: {let proc = get_proc_address("glWindowPos3s"); if proc == null() {dummy_pfnglwindowpos3sproc} else {unsafe{transmute(proc)}}},
			windowpos3sv: {let proc = get_proc_address("glWindowPos3sv"); if proc == null() {dummy_pfnglwindowpos3svproc} else {unsafe{transmute(proc)}}},
			blendcolor: {let proc = get_proc_address("glBlendColor"); if proc == null() {dummy_pfnglblendcolorproc} else {unsafe{transmute(proc)}}},
			blendequation: {let proc = get_proc_address("glBlendEquation"); if proc == null() {dummy_pfnglblendequationproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version14 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			blendfuncseparate: dummy_pfnglblendfuncseparateproc,
			multidrawarrays: dummy_pfnglmultidrawarraysproc,
			multidrawelements: dummy_pfnglmultidrawelementsproc,
			pointparameterf: dummy_pfnglpointparameterfproc,
			pointparameterfv: dummy_pfnglpointparameterfvproc,
			pointparameteri: dummy_pfnglpointparameteriproc,
			pointparameteriv: dummy_pfnglpointparameterivproc,
			fogcoordf: dummy_pfnglfogcoordfproc,
			fogcoordfv: dummy_pfnglfogcoordfvproc,
			fogcoordd: dummy_pfnglfogcoorddproc,
			fogcoorddv: dummy_pfnglfogcoorddvproc,
			fogcoordpointer: dummy_pfnglfogcoordpointerproc,
			secondarycolor3b: dummy_pfnglsecondarycolor3bproc,
			secondarycolor3bv: dummy_pfnglsecondarycolor3bvproc,
			secondarycolor3d: dummy_pfnglsecondarycolor3dproc,
			secondarycolor3dv: dummy_pfnglsecondarycolor3dvproc,
			secondarycolor3f: dummy_pfnglsecondarycolor3fproc,
			secondarycolor3fv: dummy_pfnglsecondarycolor3fvproc,
			secondarycolor3i: dummy_pfnglsecondarycolor3iproc,
			secondarycolor3iv: dummy_pfnglsecondarycolor3ivproc,
			secondarycolor3s: dummy_pfnglsecondarycolor3sproc,
			secondarycolor3sv: dummy_pfnglsecondarycolor3svproc,
			secondarycolor3ub: dummy_pfnglsecondarycolor3ubproc,
			secondarycolor3ubv: dummy_pfnglsecondarycolor3ubvproc,
			secondarycolor3ui: dummy_pfnglsecondarycolor3uiproc,
			secondarycolor3uiv: dummy_pfnglsecondarycolor3uivproc,
			secondarycolor3us: dummy_pfnglsecondarycolor3usproc,
			secondarycolor3usv: dummy_pfnglsecondarycolor3usvproc,
			secondarycolorpointer: dummy_pfnglsecondarycolorpointerproc,
			windowpos2d: dummy_pfnglwindowpos2dproc,
			windowpos2dv: dummy_pfnglwindowpos2dvproc,
			windowpos2f: dummy_pfnglwindowpos2fproc,
			windowpos2fv: dummy_pfnglwindowpos2fvproc,
			windowpos2i: dummy_pfnglwindowpos2iproc,
			windowpos2iv: dummy_pfnglwindowpos2ivproc,
			windowpos2s: dummy_pfnglwindowpos2sproc,
			windowpos2sv: dummy_pfnglwindowpos2svproc,
			windowpos3d: dummy_pfnglwindowpos3dproc,
			windowpos3dv: dummy_pfnglwindowpos3dvproc,
			windowpos3f: dummy_pfnglwindowpos3fproc,
			windowpos3fv: dummy_pfnglwindowpos3fvproc,
			windowpos3i: dummy_pfnglwindowpos3iproc,
			windowpos3iv: dummy_pfnglwindowpos3ivproc,
			windowpos3s: dummy_pfnglwindowpos3sproc,
			windowpos3sv: dummy_pfnglwindowpos3svproc,
			blendcolor: dummy_pfnglblendcolorproc,
			blendequation: dummy_pfnglblendequationproc,
		}
	}
}
impl Debug for Version14 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version14")
			.field("available", &self.available)
			.field("blendfuncseparate", unsafe{if transmute::<_, *const c_void>(self.blendfuncseparate) == (dummy_pfnglblendfuncseparateproc as *const c_void) {&null::<PFNGLBLENDFUNCSEPARATEPROC>()} else {&self.blendfuncseparate}})
			.field("multidrawarrays", unsafe{if transmute::<_, *const c_void>(self.multidrawarrays) == (dummy_pfnglmultidrawarraysproc as *const c_void) {&null::<PFNGLMULTIDRAWARRAYSPROC>()} else {&self.multidrawarrays}})
			.field("multidrawelements", unsafe{if transmute::<_, *const c_void>(self.multidrawelements) == (dummy_pfnglmultidrawelementsproc as *const c_void) {&null::<PFNGLMULTIDRAWELEMENTSPROC>()} else {&self.multidrawelements}})
			.field("pointparameterf", unsafe{if transmute::<_, *const c_void>(self.pointparameterf) == (dummy_pfnglpointparameterfproc as *const c_void) {&null::<PFNGLPOINTPARAMETERFPROC>()} else {&self.pointparameterf}})
			.field("pointparameterfv", unsafe{if transmute::<_, *const c_void>(self.pointparameterfv) == (dummy_pfnglpointparameterfvproc as *const c_void) {&null::<PFNGLPOINTPARAMETERFVPROC>()} else {&self.pointparameterfv}})
			.field("pointparameteri", unsafe{if transmute::<_, *const c_void>(self.pointparameteri) == (dummy_pfnglpointparameteriproc as *const c_void) {&null::<PFNGLPOINTPARAMETERIPROC>()} else {&self.pointparameteri}})
			.field("pointparameteriv", unsafe{if transmute::<_, *const c_void>(self.pointparameteriv) == (dummy_pfnglpointparameterivproc as *const c_void) {&null::<PFNGLPOINTPARAMETERIVPROC>()} else {&self.pointparameteriv}})
			.field("fogcoordf", unsafe{if transmute::<_, *const c_void>(self.fogcoordf) == (dummy_pfnglfogcoordfproc as *const c_void) {&null::<PFNGLFOGCOORDFPROC>()} else {&self.fogcoordf}})
			.field("fogcoordfv", unsafe{if transmute::<_, *const c_void>(self.fogcoordfv) == (dummy_pfnglfogcoordfvproc as *const c_void) {&null::<PFNGLFOGCOORDFVPROC>()} else {&self.fogcoordfv}})
			.field("fogcoordd", unsafe{if transmute::<_, *const c_void>(self.fogcoordd) == (dummy_pfnglfogcoorddproc as *const c_void) {&null::<PFNGLFOGCOORDDPROC>()} else {&self.fogcoordd}})
			.field("fogcoorddv", unsafe{if transmute::<_, *const c_void>(self.fogcoorddv) == (dummy_pfnglfogcoorddvproc as *const c_void) {&null::<PFNGLFOGCOORDDVPROC>()} else {&self.fogcoorddv}})
			.field("fogcoordpointer", unsafe{if transmute::<_, *const c_void>(self.fogcoordpointer) == (dummy_pfnglfogcoordpointerproc as *const c_void) {&null::<PFNGLFOGCOORDPOINTERPROC>()} else {&self.fogcoordpointer}})
			.field("secondarycolor3b", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3b) == (dummy_pfnglsecondarycolor3bproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3BPROC>()} else {&self.secondarycolor3b}})
			.field("secondarycolor3bv", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3bv) == (dummy_pfnglsecondarycolor3bvproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3BVPROC>()} else {&self.secondarycolor3bv}})
			.field("secondarycolor3d", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3d) == (dummy_pfnglsecondarycolor3dproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3DPROC>()} else {&self.secondarycolor3d}})
			.field("secondarycolor3dv", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3dv) == (dummy_pfnglsecondarycolor3dvproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3DVPROC>()} else {&self.secondarycolor3dv}})
			.field("secondarycolor3f", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3f) == (dummy_pfnglsecondarycolor3fproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3FPROC>()} else {&self.secondarycolor3f}})
			.field("secondarycolor3fv", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3fv) == (dummy_pfnglsecondarycolor3fvproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3FVPROC>()} else {&self.secondarycolor3fv}})
			.field("secondarycolor3i", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3i) == (dummy_pfnglsecondarycolor3iproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3IPROC>()} else {&self.secondarycolor3i}})
			.field("secondarycolor3iv", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3iv) == (dummy_pfnglsecondarycolor3ivproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3IVPROC>()} else {&self.secondarycolor3iv}})
			.field("secondarycolor3s", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3s) == (dummy_pfnglsecondarycolor3sproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3SPROC>()} else {&self.secondarycolor3s}})
			.field("secondarycolor3sv", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3sv) == (dummy_pfnglsecondarycolor3svproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3SVPROC>()} else {&self.secondarycolor3sv}})
			.field("secondarycolor3ub", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3ub) == (dummy_pfnglsecondarycolor3ubproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3UBPROC>()} else {&self.secondarycolor3ub}})
			.field("secondarycolor3ubv", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3ubv) == (dummy_pfnglsecondarycolor3ubvproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3UBVPROC>()} else {&self.secondarycolor3ubv}})
			.field("secondarycolor3ui", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3ui) == (dummy_pfnglsecondarycolor3uiproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3UIPROC>()} else {&self.secondarycolor3ui}})
			.field("secondarycolor3uiv", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3uiv) == (dummy_pfnglsecondarycolor3uivproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3UIVPROC>()} else {&self.secondarycolor3uiv}})
			.field("secondarycolor3us", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3us) == (dummy_pfnglsecondarycolor3usproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3USPROC>()} else {&self.secondarycolor3us}})
			.field("secondarycolor3usv", unsafe{if transmute::<_, *const c_void>(self.secondarycolor3usv) == (dummy_pfnglsecondarycolor3usvproc as *const c_void) {&null::<PFNGLSECONDARYCOLOR3USVPROC>()} else {&self.secondarycolor3usv}})
			.field("secondarycolorpointer", unsafe{if transmute::<_, *const c_void>(self.secondarycolorpointer) == (dummy_pfnglsecondarycolorpointerproc as *const c_void) {&null::<PFNGLSECONDARYCOLORPOINTERPROC>()} else {&self.secondarycolorpointer}})
			.field("windowpos2d", unsafe{if transmute::<_, *const c_void>(self.windowpos2d) == (dummy_pfnglwindowpos2dproc as *const c_void) {&null::<PFNGLWINDOWPOS2DPROC>()} else {&self.windowpos2d}})
			.field("windowpos2dv", unsafe{if transmute::<_, *const c_void>(self.windowpos2dv) == (dummy_pfnglwindowpos2dvproc as *const c_void) {&null::<PFNGLWINDOWPOS2DVPROC>()} else {&self.windowpos2dv}})
			.field("windowpos2f", unsafe{if transmute::<_, *const c_void>(self.windowpos2f) == (dummy_pfnglwindowpos2fproc as *const c_void) {&null::<PFNGLWINDOWPOS2FPROC>()} else {&self.windowpos2f}})
			.field("windowpos2fv", unsafe{if transmute::<_, *const c_void>(self.windowpos2fv) == (dummy_pfnglwindowpos2fvproc as *const c_void) {&null::<PFNGLWINDOWPOS2FVPROC>()} else {&self.windowpos2fv}})
			.field("windowpos2i", unsafe{if transmute::<_, *const c_void>(self.windowpos2i) == (dummy_pfnglwindowpos2iproc as *const c_void) {&null::<PFNGLWINDOWPOS2IPROC>()} else {&self.windowpos2i}})
			.field("windowpos2iv", unsafe{if transmute::<_, *const c_void>(self.windowpos2iv) == (dummy_pfnglwindowpos2ivproc as *const c_void) {&null::<PFNGLWINDOWPOS2IVPROC>()} else {&self.windowpos2iv}})
			.field("windowpos2s", unsafe{if transmute::<_, *const c_void>(self.windowpos2s) == (dummy_pfnglwindowpos2sproc as *const c_void) {&null::<PFNGLWINDOWPOS2SPROC>()} else {&self.windowpos2s}})
			.field("windowpos2sv", unsafe{if transmute::<_, *const c_void>(self.windowpos2sv) == (dummy_pfnglwindowpos2svproc as *const c_void) {&null::<PFNGLWINDOWPOS2SVPROC>()} else {&self.windowpos2sv}})
			.field("windowpos3d", unsafe{if transmute::<_, *const c_void>(self.windowpos3d) == (dummy_pfnglwindowpos3dproc as *const c_void) {&null::<PFNGLWINDOWPOS3DPROC>()} else {&self.windowpos3d}})
			.field("windowpos3dv", unsafe{if transmute::<_, *const c_void>(self.windowpos3dv) == (dummy_pfnglwindowpos3dvproc as *const c_void) {&null::<PFNGLWINDOWPOS3DVPROC>()} else {&self.windowpos3dv}})
			.field("windowpos3f", unsafe{if transmute::<_, *const c_void>(self.windowpos3f) == (dummy_pfnglwindowpos3fproc as *const c_void) {&null::<PFNGLWINDOWPOS3FPROC>()} else {&self.windowpos3f}})
			.field("windowpos3fv", unsafe{if transmute::<_, *const c_void>(self.windowpos3fv) == (dummy_pfnglwindowpos3fvproc as *const c_void) {&null::<PFNGLWINDOWPOS3FVPROC>()} else {&self.windowpos3fv}})
			.field("windowpos3i", unsafe{if transmute::<_, *const c_void>(self.windowpos3i) == (dummy_pfnglwindowpos3iproc as *const c_void) {&null::<PFNGLWINDOWPOS3IPROC>()} else {&self.windowpos3i}})
			.field("windowpos3iv", unsafe{if transmute::<_, *const c_void>(self.windowpos3iv) == (dummy_pfnglwindowpos3ivproc as *const c_void) {&null::<PFNGLWINDOWPOS3IVPROC>()} else {&self.windowpos3iv}})
			.field("windowpos3s", unsafe{if transmute::<_, *const c_void>(self.windowpos3s) == (dummy_pfnglwindowpos3sproc as *const c_void) {&null::<PFNGLWINDOWPOS3SPROC>()} else {&self.windowpos3s}})
			.field("windowpos3sv", unsafe{if transmute::<_, *const c_void>(self.windowpos3sv) == (dummy_pfnglwindowpos3svproc as *const c_void) {&null::<PFNGLWINDOWPOS3SVPROC>()} else {&self.windowpos3sv}})
			.field("blendcolor", unsafe{if transmute::<_, *const c_void>(self.blendcolor) == (dummy_pfnglblendcolorproc as *const c_void) {&null::<PFNGLBLENDCOLORPROC>()} else {&self.blendcolor}})
			.field("blendequation", unsafe{if transmute::<_, *const c_void>(self.blendequation) == (dummy_pfnglblendequationproc as *const c_void) {&null::<PFNGLBLENDEQUATIONPROC>()} else {&self.blendequation}})
			.finish()
		} else {
			f.debug_struct("Version14")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}
pub type GLsizeiptr = khronos_ssize_t;
pub type GLintptr = khronos_intptr_t;
type PFNGLGENQUERIESPROC = extern "system" fn(GLsizei, *mut GLuint);
type PFNGLDELETEQUERIESPROC = extern "system" fn(GLsizei, *const GLuint);
type PFNGLISQUERYPROC = extern "system" fn(GLuint) -> GLboolean;
type PFNGLBEGINQUERYPROC = extern "system" fn(GLenum, GLuint);
type PFNGLENDQUERYPROC = extern "system" fn(GLenum);
type PFNGLGETQUERYIVPROC = extern "system" fn(GLenum, GLenum, *mut GLint);
type PFNGLGETQUERYOBJECTIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);
type PFNGLGETQUERYOBJECTUIVPROC = extern "system" fn(GLuint, GLenum, *mut GLuint);
type PFNGLBINDBUFFERPROC = extern "system" fn(GLenum, GLuint);
type PFNGLDELETEBUFFERSPROC = extern "system" fn(GLsizei, *const GLuint);
type PFNGLGENBUFFERSPROC = extern "system" fn(GLsizei, *mut GLuint);
type PFNGLISBUFFERPROC = extern "system" fn(GLuint) -> GLboolean;
type PFNGLBUFFERDATAPROC = extern "system" fn(GLenum, GLsizeiptr, *const c_void, GLenum);
type PFNGLBUFFERSUBDATAPROC = extern "system" fn(GLenum, GLintptr, GLsizeiptr, *const c_void);
type PFNGLGETBUFFERSUBDATAPROC = extern "system" fn(GLenum, GLintptr, GLsizeiptr, *mut c_void);
type PFNGLMAPBUFFERPROC = extern "system" fn(GLenum, GLenum) -> *mut c_void;
type PFNGLUNMAPBUFFERPROC = extern "system" fn(GLenum) -> GLboolean;
type PFNGLGETBUFFERPARAMETERIVPROC = extern "system" fn(GLenum, GLenum, *mut GLint);
type PFNGLGETBUFFERPOINTERVPROC = extern "system" fn(GLenum, GLenum, *mut *mut c_void);
extern "system" fn dummy_pfnglgenqueriesproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGenQueries()` is null.")
}
extern "system" fn dummy_pfngldeletequeriesproc (_: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glDeleteQueries()` is null.")
}
extern "system" fn dummy_pfnglisqueryproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsQuery()` is null.")
}
extern "system" fn dummy_pfnglbeginqueryproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glBeginQuery()` is null.")
}
extern "system" fn dummy_pfnglendqueryproc (_: GLenum) {
	panic!("OpenGL function pointer `glEndQuery()` is null.")
}
extern "system" fn dummy_pfnglgetqueryivproc (_: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetQueryiv()` is null.")
}
extern "system" fn dummy_pfnglgetqueryobjectivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetQueryObjectiv()` is null.")
}
extern "system" fn dummy_pfnglgetqueryobjectuivproc (_: GLuint, _: GLenum, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetQueryObjectuiv()` is null.")
}
extern "system" fn dummy_pfnglbindbufferproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glBindBuffer()` is null.")
}
extern "system" fn dummy_pfngldeletebuffersproc (_: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glDeleteBuffers()` is null.")
}
extern "system" fn dummy_pfnglgenbuffersproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGenBuffers()` is null.")
}
extern "system" fn dummy_pfnglisbufferproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsBuffer()` is null.")
}
extern "system" fn dummy_pfnglbufferdataproc (_: GLenum, _: GLsizeiptr, _: *const c_void, _: GLenum) {
	panic!("OpenGL function pointer `glBufferData()` is null.")
}
extern "system" fn dummy_pfnglbuffersubdataproc (_: GLenum, _: GLintptr, _: GLsizeiptr, _: *const c_void) {
	panic!("OpenGL function pointer `glBufferSubData()` is null.")
}
extern "system" fn dummy_pfnglgetbuffersubdataproc (_: GLenum, _: GLintptr, _: GLsizeiptr, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetBufferSubData()` is null.")
}
extern "system" fn dummy_pfnglmapbufferproc (_: GLenum, _: GLenum) -> *mut c_void {
	panic!("OpenGL function pointer `glMapBuffer()` is null.")
}
extern "system" fn dummy_pfnglunmapbufferproc (_: GLenum) -> GLboolean {
	panic!("OpenGL function pointer `glUnmapBuffer()` is null.")
}
extern "system" fn dummy_pfnglgetbufferparameterivproc (_: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetBufferParameteriv()` is null.")
}
extern "system" fn dummy_pfnglgetbufferpointervproc (_: GLenum, _: GLenum, _: *mut *mut c_void) {
	panic!("OpenGL function pointer `glGetBufferPointerv()` is null.")
}
pub const GL_BUFFER_SIZE: GLenum = 0x8764;
pub const GL_BUFFER_USAGE: GLenum = 0x8765;
pub const GL_QUERY_COUNTER_BITS: GLenum = 0x8864;
pub const GL_CURRENT_QUERY: GLenum = 0x8865;
pub const GL_QUERY_RESULT: GLenum = 0x8866;
pub const GL_QUERY_RESULT_AVAILABLE: GLenum = 0x8867;
pub const GL_ARRAY_BUFFER: GLenum = 0x8892;
pub const GL_ELEMENT_ARRAY_BUFFER: GLenum = 0x8893;
pub const GL_ARRAY_BUFFER_BINDING: GLenum = 0x8894;
pub const GL_ELEMENT_ARRAY_BUFFER_BINDING: GLenum = 0x8895;
pub const GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: GLenum = 0x889F;
pub const GL_READ_ONLY: GLenum = 0x88B8;
pub const GL_WRITE_ONLY: GLenum = 0x88B9;
pub const GL_READ_WRITE: GLenum = 0x88BA;
pub const GL_BUFFER_ACCESS: GLenum = 0x88BB;
pub const GL_BUFFER_MAPPED: GLenum = 0x88BC;
pub const GL_BUFFER_MAP_POINTER: GLenum = 0x88BD;
pub const GL_STREAM_DRAW: GLenum = 0x88E0;
pub const GL_STREAM_READ: GLenum = 0x88E1;
pub const GL_STREAM_COPY: GLenum = 0x88E2;
pub const GL_STATIC_DRAW: GLenum = 0x88E4;
pub const GL_STATIC_READ: GLenum = 0x88E5;
pub const GL_STATIC_COPY: GLenum = 0x88E6;
pub const GL_DYNAMIC_DRAW: GLenum = 0x88E8;
pub const GL_DYNAMIC_READ: GLenum = 0x88E9;
pub const GL_DYNAMIC_COPY: GLenum = 0x88EA;
pub const GL_SAMPLES_PASSED: GLenum = 0x8914;
pub const GL_SRC1_ALPHA: GLenum = 0x8589;
pub const GL_VERTEX_ARRAY_BUFFER_BINDING: GLenum = 0x8896;
pub const GL_NORMAL_ARRAY_BUFFER_BINDING: GLenum = 0x8897;
pub const GL_COLOR_ARRAY_BUFFER_BINDING: GLenum = 0x8898;
pub const GL_INDEX_ARRAY_BUFFER_BINDING: GLenum = 0x8899;
pub const GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING: GLenum = 0x889A;
pub const GL_EDGE_FLAG_ARRAY_BUFFER_BINDING: GLenum = 0x889B;
pub const GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING: GLenum = 0x889C;
pub const GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING: GLenum = 0x889D;
pub const GL_WEIGHT_ARRAY_BUFFER_BINDING: GLenum = 0x889E;
pub const GL_FOG_COORD_SRC: GLenum = 0x8450;
pub const GL_FOG_COORD: GLenum = 0x8451;
pub const GL_CURRENT_FOG_COORD: GLenum = 0x8453;
pub const GL_FOG_COORD_ARRAY_TYPE: GLenum = 0x8454;
pub const GL_FOG_COORD_ARRAY_STRIDE: GLenum = 0x8455;
pub const GL_FOG_COORD_ARRAY_POINTER: GLenum = 0x8456;
pub const GL_FOG_COORD_ARRAY: GLenum = 0x8457;
pub const GL_FOG_COORD_ARRAY_BUFFER_BINDING: GLenum = 0x889D;
pub const GL_SRC0_RGB: GLenum = 0x8580;
pub const GL_SRC1_RGB: GLenum = 0x8581;
pub const GL_SRC2_RGB: GLenum = 0x8582;
pub const GL_SRC0_ALPHA: GLenum = 0x8588;
pub const GL_SRC2_ALPHA: GLenum = 0x858A;

pub trait GL_1_5 {
	fn glGetError(&self) -> GLenum;
	fn glGenQueries(&self, n: GLsizei, ids: *mut GLuint) -> Result<()>;
	fn glDeleteQueries(&self, n: GLsizei, ids: *const GLuint) -> Result<()>;
	fn glIsQuery(&self, id: GLuint) -> Result<GLboolean>;
	fn glBeginQuery(&self, target: GLenum, id: GLuint) -> Result<()>;
	fn glEndQuery(&self, target: GLenum) -> Result<()>;
	fn glGetQueryiv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glGetQueryObjectiv(&self, id: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glGetQueryObjectuiv(&self, id: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()>;
	fn glBindBuffer(&self, target: GLenum, buffer: GLuint) -> Result<()>;
	fn glDeleteBuffers(&self, n: GLsizei, buffers: *const GLuint) -> Result<()>;
	fn glGenBuffers(&self, n: GLsizei, buffers: *mut GLuint) -> Result<()>;
	fn glIsBuffer(&self, buffer: GLuint) -> Result<GLboolean>;
	fn glBufferData(&self, target: GLenum, size: GLsizeiptr, data: *const c_void, usage: GLenum) -> Result<()>;
	fn glBufferSubData(&self, target: GLenum, offset: GLintptr, size: GLsizeiptr, data: *const c_void) -> Result<()>;
	fn glGetBufferSubData(&self, target: GLenum, offset: GLintptr, size: GLsizeiptr, data: *mut c_void) -> Result<()>;
	fn glMapBuffer(&self, target: GLenum, access: GLenum) -> Result<*mut c_void>;
	fn glUnmapBuffer(&self, target: GLenum) -> Result<GLboolean>;
	fn glGetBufferParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glGetBufferPointerv(&self, target: GLenum, pname: GLenum, params: *mut *mut c_void) -> Result<()>;
}

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version15 {
	available: bool,
	geterror: PFNGLGETERRORPROC,
	genqueries: PFNGLGENQUERIESPROC,
	deletequeries: PFNGLDELETEQUERIESPROC,
	isquery: PFNGLISQUERYPROC,
	beginquery: PFNGLBEGINQUERYPROC,
	endquery: PFNGLENDQUERYPROC,
	getqueryiv: PFNGLGETQUERYIVPROC,
	getqueryobjectiv: PFNGLGETQUERYOBJECTIVPROC,
	getqueryobjectuiv: PFNGLGETQUERYOBJECTUIVPROC,
	bindbuffer: PFNGLBINDBUFFERPROC,
	deletebuffers: PFNGLDELETEBUFFERSPROC,
	genbuffers: PFNGLGENBUFFERSPROC,
	isbuffer: PFNGLISBUFFERPROC,
	bufferdata: PFNGLBUFFERDATAPROC,
	buffersubdata: PFNGLBUFFERSUBDATAPROC,
	getbuffersubdata: PFNGLGETBUFFERSUBDATAPROC,
	mapbuffer: PFNGLMAPBUFFERPROC,
	unmapbuffer: PFNGLUNMAPBUFFERPROC,
	getbufferparameteriv: PFNGLGETBUFFERPARAMETERIVPROC,
	getbufferpointerv: PFNGLGETBUFFERPOINTERVPROC,
}

impl GL_1_5 for Version15 {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	#[inline(always)]
	fn glGenQueries(&self, n: GLsizei, ids: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenQueries", catch_unwind(||(self.genqueries)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenQueries", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteQueries(&self, n: GLsizei, ids: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteQueries", catch_unwind(||(self.deletequeries)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteQueries", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsQuery(&self, id: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsQuery", catch_unwind(||(self.isquery)(id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsQuery", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBeginQuery(&self, target: GLenum, id: GLuint) -> Result<()> {
		let ret = process_catch("glBeginQuery", catch_unwind(||(self.beginquery)(target, id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBeginQuery", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glEndQuery(&self, target: GLenum) -> Result<()> {
		let ret = process_catch("glEndQuery", catch_unwind(||(self.endquery)(target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEndQuery", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryiv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetQueryiv", catch_unwind(||(self.getqueryiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryObjectiv(&self, id: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetQueryObjectiv", catch_unwind(||(self.getqueryobjectiv)(id, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryObjectiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryObjectuiv(&self, id: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetQueryObjectuiv", catch_unwind(||(self.getqueryobjectuiv)(id, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryObjectuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindBuffer(&self, target: GLenum, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glBindBuffer", catch_unwind(||(self.bindbuffer)(target, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteBuffers(&self, n: GLsizei, buffers: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteBuffers", catch_unwind(||(self.deletebuffers)(n, buffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteBuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenBuffers(&self, n: GLsizei, buffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenBuffers", catch_unwind(||(self.genbuffers)(n, buffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenBuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsBuffer(&self, buffer: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsBuffer", catch_unwind(||(self.isbuffer)(buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBufferData(&self, target: GLenum, size: GLsizeiptr, data: *const c_void, usage: GLenum) -> Result<()> {
		let ret = process_catch("glBufferData", catch_unwind(||(self.bufferdata)(target, size, data, usage)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBufferData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBufferSubData(&self, target: GLenum, offset: GLintptr, size: GLsizeiptr, data: *const c_void) -> Result<()> {
		let ret = process_catch("glBufferSubData", catch_unwind(||(self.buffersubdata)(target, offset, size, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetBufferSubData(&self, target: GLenum, offset: GLintptr, size: GLsizeiptr, data: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetBufferSubData", catch_unwind(||(self.getbuffersubdata)(target, offset, size, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMapBuffer(&self, target: GLenum, access: GLenum) -> Result<*mut c_void> {
		let ret = process_catch("glMapBuffer", catch_unwind(||(self.mapbuffer)(target, access)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMapBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUnmapBuffer(&self, target: GLenum) -> Result<GLboolean> {
		let ret = process_catch("glUnmapBuffer", catch_unwind(||(self.unmapbuffer)(target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUnmapBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetBufferParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetBufferParameteriv", catch_unwind(||(self.getbufferparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBufferParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetBufferPointerv(&self, target: GLenum, pname: GLenum, params: *mut *mut c_void) -> Result<()> {
		let ret = process_catch("glGetBufferPointerv", catch_unwind(||(self.getbufferpointerv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBufferPointerv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version15 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (1, 5, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			genqueries: {let proc = get_proc_address("glGenQueries"); if proc == null() {dummy_pfnglgenqueriesproc} else {unsafe{transmute(proc)}}},
			deletequeries: {let proc = get_proc_address("glDeleteQueries"); if proc == null() {dummy_pfngldeletequeriesproc} else {unsafe{transmute(proc)}}},
			isquery: {let proc = get_proc_address("glIsQuery"); if proc == null() {dummy_pfnglisqueryproc} else {unsafe{transmute(proc)}}},
			beginquery: {let proc = get_proc_address("glBeginQuery"); if proc == null() {dummy_pfnglbeginqueryproc} else {unsafe{transmute(proc)}}},
			endquery: {let proc = get_proc_address("glEndQuery"); if proc == null() {dummy_pfnglendqueryproc} else {unsafe{transmute(proc)}}},
			getqueryiv: {let proc = get_proc_address("glGetQueryiv"); if proc == null() {dummy_pfnglgetqueryivproc} else {unsafe{transmute(proc)}}},
			getqueryobjectiv: {let proc = get_proc_address("glGetQueryObjectiv"); if proc == null() {dummy_pfnglgetqueryobjectivproc} else {unsafe{transmute(proc)}}},
			getqueryobjectuiv: {let proc = get_proc_address("glGetQueryObjectuiv"); if proc == null() {dummy_pfnglgetqueryobjectuivproc} else {unsafe{transmute(proc)}}},
			bindbuffer: {let proc = get_proc_address("glBindBuffer"); if proc == null() {dummy_pfnglbindbufferproc} else {unsafe{transmute(proc)}}},
			deletebuffers: {let proc = get_proc_address("glDeleteBuffers"); if proc == null() {dummy_pfngldeletebuffersproc} else {unsafe{transmute(proc)}}},
			genbuffers: {let proc = get_proc_address("glGenBuffers"); if proc == null() {dummy_pfnglgenbuffersproc} else {unsafe{transmute(proc)}}},
			isbuffer: {let proc = get_proc_address("glIsBuffer"); if proc == null() {dummy_pfnglisbufferproc} else {unsafe{transmute(proc)}}},
			bufferdata: {let proc = get_proc_address("glBufferData"); if proc == null() {dummy_pfnglbufferdataproc} else {unsafe{transmute(proc)}}},
			buffersubdata: {let proc = get_proc_address("glBufferSubData"); if proc == null() {dummy_pfnglbuffersubdataproc} else {unsafe{transmute(proc)}}},
			getbuffersubdata: {let proc = get_proc_address("glGetBufferSubData"); if proc == null() {dummy_pfnglgetbuffersubdataproc} else {unsafe{transmute(proc)}}},
			mapbuffer: {let proc = get_proc_address("glMapBuffer"); if proc == null() {dummy_pfnglmapbufferproc} else {unsafe{transmute(proc)}}},
			unmapbuffer: {let proc = get_proc_address("glUnmapBuffer"); if proc == null() {dummy_pfnglunmapbufferproc} else {unsafe{transmute(proc)}}},
			getbufferparameteriv: {let proc = get_proc_address("glGetBufferParameteriv"); if proc == null() {dummy_pfnglgetbufferparameterivproc} else {unsafe{transmute(proc)}}},
			getbufferpointerv: {let proc = get_proc_address("glGetBufferPointerv"); if proc == null() {dummy_pfnglgetbufferpointervproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version15 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			genqueries: dummy_pfnglgenqueriesproc,
			deletequeries: dummy_pfngldeletequeriesproc,
			isquery: dummy_pfnglisqueryproc,
			beginquery: dummy_pfnglbeginqueryproc,
			endquery: dummy_pfnglendqueryproc,
			getqueryiv: dummy_pfnglgetqueryivproc,
			getqueryobjectiv: dummy_pfnglgetqueryobjectivproc,
			getqueryobjectuiv: dummy_pfnglgetqueryobjectuivproc,
			bindbuffer: dummy_pfnglbindbufferproc,
			deletebuffers: dummy_pfngldeletebuffersproc,
			genbuffers: dummy_pfnglgenbuffersproc,
			isbuffer: dummy_pfnglisbufferproc,
			bufferdata: dummy_pfnglbufferdataproc,
			buffersubdata: dummy_pfnglbuffersubdataproc,
			getbuffersubdata: dummy_pfnglgetbuffersubdataproc,
			mapbuffer: dummy_pfnglmapbufferproc,
			unmapbuffer: dummy_pfnglunmapbufferproc,
			getbufferparameteriv: dummy_pfnglgetbufferparameterivproc,
			getbufferpointerv: dummy_pfnglgetbufferpointervproc,
		}
	}
}
impl Debug for Version15 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version15")
			.field("available", &self.available)
			.field("genqueries", unsafe{if transmute::<_, *const c_void>(self.genqueries) == (dummy_pfnglgenqueriesproc as *const c_void) {&null::<PFNGLGENQUERIESPROC>()} else {&self.genqueries}})
			.field("deletequeries", unsafe{if transmute::<_, *const c_void>(self.deletequeries) == (dummy_pfngldeletequeriesproc as *const c_void) {&null::<PFNGLDELETEQUERIESPROC>()} else {&self.deletequeries}})
			.field("isquery", unsafe{if transmute::<_, *const c_void>(self.isquery) == (dummy_pfnglisqueryproc as *const c_void) {&null::<PFNGLISQUERYPROC>()} else {&self.isquery}})
			.field("beginquery", unsafe{if transmute::<_, *const c_void>(self.beginquery) == (dummy_pfnglbeginqueryproc as *const c_void) {&null::<PFNGLBEGINQUERYPROC>()} else {&self.beginquery}})
			.field("endquery", unsafe{if transmute::<_, *const c_void>(self.endquery) == (dummy_pfnglendqueryproc as *const c_void) {&null::<PFNGLENDQUERYPROC>()} else {&self.endquery}})
			.field("getqueryiv", unsafe{if transmute::<_, *const c_void>(self.getqueryiv) == (dummy_pfnglgetqueryivproc as *const c_void) {&null::<PFNGLGETQUERYIVPROC>()} else {&self.getqueryiv}})
			.field("getqueryobjectiv", unsafe{if transmute::<_, *const c_void>(self.getqueryobjectiv) == (dummy_pfnglgetqueryobjectivproc as *const c_void) {&null::<PFNGLGETQUERYOBJECTIVPROC>()} else {&self.getqueryobjectiv}})
			.field("getqueryobjectuiv", unsafe{if transmute::<_, *const c_void>(self.getqueryobjectuiv) == (dummy_pfnglgetqueryobjectuivproc as *const c_void) {&null::<PFNGLGETQUERYOBJECTUIVPROC>()} else {&self.getqueryobjectuiv}})
			.field("bindbuffer", unsafe{if transmute::<_, *const c_void>(self.bindbuffer) == (dummy_pfnglbindbufferproc as *const c_void) {&null::<PFNGLBINDBUFFERPROC>()} else {&self.bindbuffer}})
			.field("deletebuffers", unsafe{if transmute::<_, *const c_void>(self.deletebuffers) == (dummy_pfngldeletebuffersproc as *const c_void) {&null::<PFNGLDELETEBUFFERSPROC>()} else {&self.deletebuffers}})
			.field("genbuffers", unsafe{if transmute::<_, *const c_void>(self.genbuffers) == (dummy_pfnglgenbuffersproc as *const c_void) {&null::<PFNGLGENBUFFERSPROC>()} else {&self.genbuffers}})
			.field("isbuffer", unsafe{if transmute::<_, *const c_void>(self.isbuffer) == (dummy_pfnglisbufferproc as *const c_void) {&null::<PFNGLISBUFFERPROC>()} else {&self.isbuffer}})
			.field("bufferdata", unsafe{if transmute::<_, *const c_void>(self.bufferdata) == (dummy_pfnglbufferdataproc as *const c_void) {&null::<PFNGLBUFFERDATAPROC>()} else {&self.bufferdata}})
			.field("buffersubdata", unsafe{if transmute::<_, *const c_void>(self.buffersubdata) == (dummy_pfnglbuffersubdataproc as *const c_void) {&null::<PFNGLBUFFERSUBDATAPROC>()} else {&self.buffersubdata}})
			.field("getbuffersubdata", unsafe{if transmute::<_, *const c_void>(self.getbuffersubdata) == (dummy_pfnglgetbuffersubdataproc as *const c_void) {&null::<PFNGLGETBUFFERSUBDATAPROC>()} else {&self.getbuffersubdata}})
			.field("mapbuffer", unsafe{if transmute::<_, *const c_void>(self.mapbuffer) == (dummy_pfnglmapbufferproc as *const c_void) {&null::<PFNGLMAPBUFFERPROC>()} else {&self.mapbuffer}})
			.field("unmapbuffer", unsafe{if transmute::<_, *const c_void>(self.unmapbuffer) == (dummy_pfnglunmapbufferproc as *const c_void) {&null::<PFNGLUNMAPBUFFERPROC>()} else {&self.unmapbuffer}})
			.field("getbufferparameteriv", unsafe{if transmute::<_, *const c_void>(self.getbufferparameteriv) == (dummy_pfnglgetbufferparameterivproc as *const c_void) {&null::<PFNGLGETBUFFERPARAMETERIVPROC>()} else {&self.getbufferparameteriv}})
			.field("getbufferpointerv", unsafe{if transmute::<_, *const c_void>(self.getbufferpointerv) == (dummy_pfnglgetbufferpointervproc as *const c_void) {&null::<PFNGLGETBUFFERPOINTERVPROC>()} else {&self.getbufferpointerv}})
			.finish()
		} else {
			f.debug_struct("Version15")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}
pub type GLchar = i8;
type PFNGLBLENDEQUATIONSEPARATEPROC = extern "system" fn(GLenum, GLenum);
type PFNGLDRAWBUFFERSPROC = extern "system" fn(GLsizei, *const GLenum);
type PFNGLSTENCILOPSEPARATEPROC = extern "system" fn(GLenum, GLenum, GLenum, GLenum);
type PFNGLSTENCILFUNCSEPARATEPROC = extern "system" fn(GLenum, GLenum, GLint, GLuint);
type PFNGLSTENCILMASKSEPARATEPROC = extern "system" fn(GLenum, GLuint);
type PFNGLATTACHSHADERPROC = extern "system" fn(GLuint, GLuint);
type PFNGLBINDATTRIBLOCATIONPROC = extern "system" fn(GLuint, GLuint, *const GLchar);
type PFNGLCOMPILESHADERPROC = extern "system" fn(GLuint);
type PFNGLCREATEPROGRAMPROC = extern "system" fn() -> GLuint;
type PFNGLCREATESHADERPROC = extern "system" fn(GLenum) -> GLuint;
type PFNGLDELETEPROGRAMPROC = extern "system" fn(GLuint);
type PFNGLDELETESHADERPROC = extern "system" fn(GLuint);
type PFNGLDETACHSHADERPROC = extern "system" fn(GLuint, GLuint);
type PFNGLDISABLEVERTEXATTRIBARRAYPROC = extern "system" fn(GLuint);
type PFNGLENABLEVERTEXATTRIBARRAYPROC = extern "system" fn(GLuint);
type PFNGLGETACTIVEATTRIBPROC = extern "system" fn(GLuint, GLuint, GLsizei, *mut GLsizei, *mut GLint, *mut GLenum, *mut GLchar);
type PFNGLGETACTIVEUNIFORMPROC = extern "system" fn(GLuint, GLuint, GLsizei, *mut GLsizei, *mut GLint, *mut GLenum, *mut GLchar);
type PFNGLGETATTACHEDSHADERSPROC = extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLuint);
type PFNGLGETATTRIBLOCATIONPROC = extern "system" fn(GLuint, *const GLchar) -> GLint;
type PFNGLGETPROGRAMIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);
type PFNGLGETPROGRAMINFOLOGPROC = extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar);
type PFNGLGETSHADERIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);
type PFNGLGETSHADERINFOLOGPROC = extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar);
type PFNGLGETSHADERSOURCEPROC = extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar);
type PFNGLGETUNIFORMLOCATIONPROC = extern "system" fn(GLuint, *const GLchar) -> GLint;
type PFNGLGETUNIFORMFVPROC = extern "system" fn(GLuint, GLint, *mut GLfloat);
type PFNGLGETUNIFORMIVPROC = extern "system" fn(GLuint, GLint, *mut GLint);
type PFNGLGETVERTEXATTRIBDVPROC = extern "system" fn(GLuint, GLenum, *mut GLdouble);
type PFNGLGETVERTEXATTRIBFVPROC = extern "system" fn(GLuint, GLenum, *mut GLfloat);
type PFNGLGETVERTEXATTRIBIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);
type PFNGLGETVERTEXATTRIBPOINTERVPROC = extern "system" fn(GLuint, GLenum, *mut *mut c_void);
type PFNGLISPROGRAMPROC = extern "system" fn(GLuint) -> GLboolean;
type PFNGLISSHADERPROC = extern "system" fn(GLuint) -> GLboolean;
type PFNGLLINKPROGRAMPROC = extern "system" fn(GLuint);
type PFNGLSHADERSOURCEPROC = extern "system" fn(GLuint, GLsizei, *const *const GLchar, *const GLint);
type PFNGLUSEPROGRAMPROC = extern "system" fn(GLuint);
type PFNGLUNIFORM1FPROC = extern "system" fn(GLint, GLfloat);
type PFNGLUNIFORM2FPROC = extern "system" fn(GLint, GLfloat, GLfloat);
type PFNGLUNIFORM3FPROC = extern "system" fn(GLint, GLfloat, GLfloat, GLfloat);
type PFNGLUNIFORM4FPROC = extern "system" fn(GLint, GLfloat, GLfloat, GLfloat, GLfloat);
type PFNGLUNIFORM1IPROC = extern "system" fn(GLint, GLint);
type PFNGLUNIFORM2IPROC = extern "system" fn(GLint, GLint, GLint);
type PFNGLUNIFORM3IPROC = extern "system" fn(GLint, GLint, GLint, GLint);
type PFNGLUNIFORM4IPROC = extern "system" fn(GLint, GLint, GLint, GLint, GLint);
type PFNGLUNIFORM1FVPROC = extern "system" fn(GLint, GLsizei, *const GLfloat);
type PFNGLUNIFORM2FVPROC = extern "system" fn(GLint, GLsizei, *const GLfloat);
type PFNGLUNIFORM3FVPROC = extern "system" fn(GLint, GLsizei, *const GLfloat);
type PFNGLUNIFORM4FVPROC = extern "system" fn(GLint, GLsizei, *const GLfloat);
type PFNGLUNIFORM1IVPROC = extern "system" fn(GLint, GLsizei, *const GLint);
type PFNGLUNIFORM2IVPROC = extern "system" fn(GLint, GLsizei, *const GLint);
type PFNGLUNIFORM3IVPROC = extern "system" fn(GLint, GLsizei, *const GLint);
type PFNGLUNIFORM4IVPROC = extern "system" fn(GLint, GLsizei, *const GLint);
type PFNGLUNIFORMMATRIX2FVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat);
type PFNGLUNIFORMMATRIX3FVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat);
type PFNGLUNIFORMMATRIX4FVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat);
type PFNGLVALIDATEPROGRAMPROC = extern "system" fn(GLuint);
type PFNGLVERTEXATTRIB1DPROC = extern "system" fn(GLuint, GLdouble);
type PFNGLVERTEXATTRIB1DVPROC = extern "system" fn(GLuint, *const GLdouble);
type PFNGLVERTEXATTRIB1FPROC = extern "system" fn(GLuint, GLfloat);
type PFNGLVERTEXATTRIB1FVPROC = extern "system" fn(GLuint, *const GLfloat);
type PFNGLVERTEXATTRIB1SPROC = extern "system" fn(GLuint, GLshort);
type PFNGLVERTEXATTRIB1SVPROC = extern "system" fn(GLuint, *const GLshort);
type PFNGLVERTEXATTRIB2DPROC = extern "system" fn(GLuint, GLdouble, GLdouble);
type PFNGLVERTEXATTRIB2DVPROC = extern "system" fn(GLuint, *const GLdouble);
type PFNGLVERTEXATTRIB2FPROC = extern "system" fn(GLuint, GLfloat, GLfloat);
type PFNGLVERTEXATTRIB2FVPROC = extern "system" fn(GLuint, *const GLfloat);
type PFNGLVERTEXATTRIB2SPROC = extern "system" fn(GLuint, GLshort, GLshort);
type PFNGLVERTEXATTRIB2SVPROC = extern "system" fn(GLuint, *const GLshort);
type PFNGLVERTEXATTRIB3DPROC = extern "system" fn(GLuint, GLdouble, GLdouble, GLdouble);
type PFNGLVERTEXATTRIB3DVPROC = extern "system" fn(GLuint, *const GLdouble);
type PFNGLVERTEXATTRIB3FPROC = extern "system" fn(GLuint, GLfloat, GLfloat, GLfloat);
type PFNGLVERTEXATTRIB3FVPROC = extern "system" fn(GLuint, *const GLfloat);
type PFNGLVERTEXATTRIB3SPROC = extern "system" fn(GLuint, GLshort, GLshort, GLshort);
type PFNGLVERTEXATTRIB3SVPROC = extern "system" fn(GLuint, *const GLshort);
type PFNGLVERTEXATTRIB4NBVPROC = extern "system" fn(GLuint, *const GLbyte);
type PFNGLVERTEXATTRIB4NIVPROC = extern "system" fn(GLuint, *const GLint);
type PFNGLVERTEXATTRIB4NSVPROC = extern "system" fn(GLuint, *const GLshort);
type PFNGLVERTEXATTRIB4NUBPROC = extern "system" fn(GLuint, GLubyte, GLubyte, GLubyte, GLubyte);
type PFNGLVERTEXATTRIB4NUBVPROC = extern "system" fn(GLuint, *const GLubyte);
type PFNGLVERTEXATTRIB4NUIVPROC = extern "system" fn(GLuint, *const GLuint);
type PFNGLVERTEXATTRIB4NUSVPROC = extern "system" fn(GLuint, *const GLushort);
type PFNGLVERTEXATTRIB4BVPROC = extern "system" fn(GLuint, *const GLbyte);
type PFNGLVERTEXATTRIB4DPROC = extern "system" fn(GLuint, GLdouble, GLdouble, GLdouble, GLdouble);
type PFNGLVERTEXATTRIB4DVPROC = extern "system" fn(GLuint, *const GLdouble);
type PFNGLVERTEXATTRIB4FPROC = extern "system" fn(GLuint, GLfloat, GLfloat, GLfloat, GLfloat);
type PFNGLVERTEXATTRIB4FVPROC = extern "system" fn(GLuint, *const GLfloat);
type PFNGLVERTEXATTRIB4IVPROC = extern "system" fn(GLuint, *const GLint);
type PFNGLVERTEXATTRIB4SPROC = extern "system" fn(GLuint, GLshort, GLshort, GLshort, GLshort);
type PFNGLVERTEXATTRIB4SVPROC = extern "system" fn(GLuint, *const GLshort);
type PFNGLVERTEXATTRIB4UBVPROC = extern "system" fn(GLuint, *const GLubyte);
type PFNGLVERTEXATTRIB4UIVPROC = extern "system" fn(GLuint, *const GLuint);
type PFNGLVERTEXATTRIB4USVPROC = extern "system" fn(GLuint, *const GLushort);
type PFNGLVERTEXATTRIBPOINTERPROC = extern "system" fn(GLuint, GLint, GLenum, GLboolean, GLsizei, *const c_void);
extern "system" fn dummy_pfnglblendequationseparateproc (_: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glBlendEquationSeparate()` is null.")
}
extern "system" fn dummy_pfngldrawbuffersproc (_: GLsizei, _: *const GLenum) {
	panic!("OpenGL function pointer `glDrawBuffers()` is null.")
}
extern "system" fn dummy_pfnglstencilopseparateproc (_: GLenum, _: GLenum, _: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glStencilOpSeparate()` is null.")
}
extern "system" fn dummy_pfnglstencilfuncseparateproc (_: GLenum, _: GLenum, _: GLint, _: GLuint) {
	panic!("OpenGL function pointer `glStencilFuncSeparate()` is null.")
}
extern "system" fn dummy_pfnglstencilmaskseparateproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glStencilMaskSeparate()` is null.")
}
extern "system" fn dummy_pfnglattachshaderproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glAttachShader()` is null.")
}
extern "system" fn dummy_pfnglbindattriblocationproc (_: GLuint, _: GLuint, _: *const GLchar) {
	panic!("OpenGL function pointer `glBindAttribLocation()` is null.")
}
extern "system" fn dummy_pfnglcompileshaderproc (_: GLuint) {
	panic!("OpenGL function pointer `glCompileShader()` is null.")
}
extern "system" fn dummy_pfnglcreateprogramproc () -> GLuint {
	panic!("OpenGL function pointer `glCreateProgram()` is null.")
}
extern "system" fn dummy_pfnglcreateshaderproc (_: GLenum) -> GLuint {
	panic!("OpenGL function pointer `glCreateShader()` is null.")
}
extern "system" fn dummy_pfngldeleteprogramproc (_: GLuint) {
	panic!("OpenGL function pointer `glDeleteProgram()` is null.")
}
extern "system" fn dummy_pfngldeleteshaderproc (_: GLuint) {
	panic!("OpenGL function pointer `glDeleteShader()` is null.")
}
extern "system" fn dummy_pfngldetachshaderproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glDetachShader()` is null.")
}
extern "system" fn dummy_pfngldisablevertexattribarrayproc (_: GLuint) {
	panic!("OpenGL function pointer `glDisableVertexAttribArray()` is null.")
}
extern "system" fn dummy_pfnglenablevertexattribarrayproc (_: GLuint) {
	panic!("OpenGL function pointer `glEnableVertexAttribArray()` is null.")
}
extern "system" fn dummy_pfnglgetactiveattribproc (_: GLuint, _: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLint, _: *mut GLenum, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetActiveAttrib()` is null.")
}
extern "system" fn dummy_pfnglgetactiveuniformproc (_: GLuint, _: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLint, _: *mut GLenum, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetActiveUniform()` is null.")
}
extern "system" fn dummy_pfnglgetattachedshadersproc (_: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetAttachedShaders()` is null.")
}
extern "system" fn dummy_pfnglgetattriblocationproc (_: GLuint, _: *const GLchar) -> GLint {
	panic!("OpenGL function pointer `glGetAttribLocation()` is null.")
}
extern "system" fn dummy_pfnglgetprogramivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetProgramiv()` is null.")
}
extern "system" fn dummy_pfnglgetprograminfologproc (_: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetProgramInfoLog()` is null.")
}
extern "system" fn dummy_pfnglgetshaderivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetShaderiv()` is null.")
}
extern "system" fn dummy_pfnglgetshaderinfologproc (_: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetShaderInfoLog()` is null.")
}
extern "system" fn dummy_pfnglgetshadersourceproc (_: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetShaderSource()` is null.")
}
extern "system" fn dummy_pfnglgetuniformlocationproc (_: GLuint, _: *const GLchar) -> GLint {
	panic!("OpenGL function pointer `glGetUniformLocation()` is null.")
}
extern "system" fn dummy_pfnglgetuniformfvproc (_: GLuint, _: GLint, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetUniformfv()` is null.")
}
extern "system" fn dummy_pfnglgetuniformivproc (_: GLuint, _: GLint, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetUniformiv()` is null.")
}
extern "system" fn dummy_pfnglgetvertexattribdvproc (_: GLuint, _: GLenum, _: *mut GLdouble) {
	panic!("OpenGL function pointer `glGetVertexAttribdv()` is null.")
}
extern "system" fn dummy_pfnglgetvertexattribfvproc (_: GLuint, _: GLenum, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetVertexAttribfv()` is null.")
}
extern "system" fn dummy_pfnglgetvertexattribivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetVertexAttribiv()` is null.")
}
extern "system" fn dummy_pfnglgetvertexattribpointervproc (_: GLuint, _: GLenum, _: *mut *mut c_void) {
	panic!("OpenGL function pointer `glGetVertexAttribPointerv()` is null.")
}
extern "system" fn dummy_pfnglisprogramproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsProgram()` is null.")
}
extern "system" fn dummy_pfnglisshaderproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsShader()` is null.")
}
extern "system" fn dummy_pfngllinkprogramproc (_: GLuint) {
	panic!("OpenGL function pointer `glLinkProgram()` is null.")
}
extern "system" fn dummy_pfnglshadersourceproc (_: GLuint, _: GLsizei, _: *const *const GLchar, _: *const GLint) {
	panic!("OpenGL function pointer `glShaderSource()` is null.")
}
extern "system" fn dummy_pfngluseprogramproc (_: GLuint) {
	panic!("OpenGL function pointer `glUseProgram()` is null.")
}
extern "system" fn dummy_pfngluniform1fproc (_: GLint, _: GLfloat) {
	panic!("OpenGL function pointer `glUniform1f()` is null.")
}
extern "system" fn dummy_pfngluniform2fproc (_: GLint, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glUniform2f()` is null.")
}
extern "system" fn dummy_pfngluniform3fproc (_: GLint, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glUniform3f()` is null.")
}
extern "system" fn dummy_pfngluniform4fproc (_: GLint, _: GLfloat, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glUniform4f()` is null.")
}
extern "system" fn dummy_pfngluniform1iproc (_: GLint, _: GLint) {
	panic!("OpenGL function pointer `glUniform1i()` is null.")
}
extern "system" fn dummy_pfngluniform2iproc (_: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glUniform2i()` is null.")
}
extern "system" fn dummy_pfngluniform3iproc (_: GLint, _: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glUniform3i()` is null.")
}
extern "system" fn dummy_pfngluniform4iproc (_: GLint, _: GLint, _: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glUniform4i()` is null.")
}
extern "system" fn dummy_pfngluniform1fvproc (_: GLint, _: GLsizei, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniform1fv()` is null.")
}
extern "system" fn dummy_pfngluniform2fvproc (_: GLint, _: GLsizei, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniform2fv()` is null.")
}
extern "system" fn dummy_pfngluniform3fvproc (_: GLint, _: GLsizei, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniform3fv()` is null.")
}
extern "system" fn dummy_pfngluniform4fvproc (_: GLint, _: GLsizei, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniform4fv()` is null.")
}
extern "system" fn dummy_pfngluniform1ivproc (_: GLint, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glUniform1iv()` is null.")
}
extern "system" fn dummy_pfngluniform2ivproc (_: GLint, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glUniform2iv()` is null.")
}
extern "system" fn dummy_pfngluniform3ivproc (_: GLint, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glUniform3iv()` is null.")
}
extern "system" fn dummy_pfngluniform4ivproc (_: GLint, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glUniform4iv()` is null.")
}
extern "system" fn dummy_pfngluniformmatrix2fvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniformMatrix2fv()` is null.")
}
extern "system" fn dummy_pfngluniformmatrix3fvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniformMatrix3fv()` is null.")
}
extern "system" fn dummy_pfngluniformmatrix4fvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniformMatrix4fv()` is null.")
}
extern "system" fn dummy_pfnglvalidateprogramproc (_: GLuint) {
	panic!("OpenGL function pointer `glValidateProgram()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib1dproc (_: GLuint, _: GLdouble) {
	panic!("OpenGL function pointer `glVertexAttrib1d()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib1dvproc (_: GLuint, _: *const GLdouble) {
	panic!("OpenGL function pointer `glVertexAttrib1dv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib1fproc (_: GLuint, _: GLfloat) {
	panic!("OpenGL function pointer `glVertexAttrib1f()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib1fvproc (_: GLuint, _: *const GLfloat) {
	panic!("OpenGL function pointer `glVertexAttrib1fv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib1sproc (_: GLuint, _: GLshort) {
	panic!("OpenGL function pointer `glVertexAttrib1s()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib1svproc (_: GLuint, _: *const GLshort) {
	panic!("OpenGL function pointer `glVertexAttrib1sv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib2dproc (_: GLuint, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glVertexAttrib2d()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib2dvproc (_: GLuint, _: *const GLdouble) {
	panic!("OpenGL function pointer `glVertexAttrib2dv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib2fproc (_: GLuint, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glVertexAttrib2f()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib2fvproc (_: GLuint, _: *const GLfloat) {
	panic!("OpenGL function pointer `glVertexAttrib2fv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib2sproc (_: GLuint, _: GLshort, _: GLshort) {
	panic!("OpenGL function pointer `glVertexAttrib2s()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib2svproc (_: GLuint, _: *const GLshort) {
	panic!("OpenGL function pointer `glVertexAttrib2sv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib3dproc (_: GLuint, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glVertexAttrib3d()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib3dvproc (_: GLuint, _: *const GLdouble) {
	panic!("OpenGL function pointer `glVertexAttrib3dv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib3fproc (_: GLuint, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glVertexAttrib3f()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib3fvproc (_: GLuint, _: *const GLfloat) {
	panic!("OpenGL function pointer `glVertexAttrib3fv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib3sproc (_: GLuint, _: GLshort, _: GLshort, _: GLshort) {
	panic!("OpenGL function pointer `glVertexAttrib3s()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib3svproc (_: GLuint, _: *const GLshort) {
	panic!("OpenGL function pointer `glVertexAttrib3sv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib4nbvproc (_: GLuint, _: *const GLbyte) {
	panic!("OpenGL function pointer `glVertexAttrib4Nbv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib4nivproc (_: GLuint, _: *const GLint) {
	panic!("OpenGL function pointer `glVertexAttrib4Niv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib4nsvproc (_: GLuint, _: *const GLshort) {
	panic!("OpenGL function pointer `glVertexAttrib4Nsv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib4nubproc (_: GLuint, _: GLubyte, _: GLubyte, _: GLubyte, _: GLubyte) {
	panic!("OpenGL function pointer `glVertexAttrib4Nub()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib4nubvproc (_: GLuint, _: *const GLubyte) {
	panic!("OpenGL function pointer `glVertexAttrib4Nubv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib4nuivproc (_: GLuint, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttrib4Nuiv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib4nusvproc (_: GLuint, _: *const GLushort) {
	panic!("OpenGL function pointer `glVertexAttrib4Nusv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib4bvproc (_: GLuint, _: *const GLbyte) {
	panic!("OpenGL function pointer `glVertexAttrib4bv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib4dproc (_: GLuint, _: GLdouble, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glVertexAttrib4d()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib4dvproc (_: GLuint, _: *const GLdouble) {
	panic!("OpenGL function pointer `glVertexAttrib4dv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib4fproc (_: GLuint, _: GLfloat, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glVertexAttrib4f()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib4fvproc (_: GLuint, _: *const GLfloat) {
	panic!("OpenGL function pointer `glVertexAttrib4fv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib4ivproc (_: GLuint, _: *const GLint) {
	panic!("OpenGL function pointer `glVertexAttrib4iv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib4sproc (_: GLuint, _: GLshort, _: GLshort, _: GLshort, _: GLshort) {
	panic!("OpenGL function pointer `glVertexAttrib4s()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib4svproc (_: GLuint, _: *const GLshort) {
	panic!("OpenGL function pointer `glVertexAttrib4sv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib4ubvproc (_: GLuint, _: *const GLubyte) {
	panic!("OpenGL function pointer `glVertexAttrib4ubv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib4uivproc (_: GLuint, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttrib4uiv()` is null.")
}
extern "system" fn dummy_pfnglvertexattrib4usvproc (_: GLuint, _: *const GLushort) {
	panic!("OpenGL function pointer `glVertexAttrib4usv()` is null.")
}
extern "system" fn dummy_pfnglvertexattribpointerproc (_: GLuint, _: GLint, _: GLenum, _: GLboolean, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glVertexAttribPointer()` is null.")
}
pub const GL_BLEND_EQUATION_RGB: GLenum = 0x8009;
pub const GL_VERTEX_ATTRIB_ARRAY_ENABLED: GLenum = 0x8622;
pub const GL_VERTEX_ATTRIB_ARRAY_SIZE: GLenum = 0x8623;
pub const GL_VERTEX_ATTRIB_ARRAY_STRIDE: GLenum = 0x8624;
pub const GL_VERTEX_ATTRIB_ARRAY_TYPE: GLenum = 0x8625;
pub const GL_CURRENT_VERTEX_ATTRIB: GLenum = 0x8626;
pub const GL_VERTEX_PROGRAM_POINT_SIZE: GLenum = 0x8642;
pub const GL_VERTEX_ATTRIB_ARRAY_POINTER: GLenum = 0x8645;
pub const GL_STENCIL_BACK_FUNC: GLenum = 0x8800;
pub const GL_STENCIL_BACK_FAIL: GLenum = 0x8801;
pub const GL_STENCIL_BACK_PASS_DEPTH_FAIL: GLenum = 0x8802;
pub const GL_STENCIL_BACK_PASS_DEPTH_PASS: GLenum = 0x8803;
pub const GL_MAX_DRAW_BUFFERS: GLenum = 0x8824;
pub const GL_DRAW_BUFFER0: GLenum = 0x8825;
pub const GL_DRAW_BUFFER1: GLenum = 0x8826;
pub const GL_DRAW_BUFFER2: GLenum = 0x8827;
pub const GL_DRAW_BUFFER3: GLenum = 0x8828;
pub const GL_DRAW_BUFFER4: GLenum = 0x8829;
pub const GL_DRAW_BUFFER5: GLenum = 0x882A;
pub const GL_DRAW_BUFFER6: GLenum = 0x882B;
pub const GL_DRAW_BUFFER7: GLenum = 0x882C;
pub const GL_DRAW_BUFFER8: GLenum = 0x882D;
pub const GL_DRAW_BUFFER9: GLenum = 0x882E;
pub const GL_DRAW_BUFFER10: GLenum = 0x882F;
pub const GL_DRAW_BUFFER11: GLenum = 0x8830;
pub const GL_DRAW_BUFFER12: GLenum = 0x8831;
pub const GL_DRAW_BUFFER13: GLenum = 0x8832;
pub const GL_DRAW_BUFFER14: GLenum = 0x8833;
pub const GL_DRAW_BUFFER15: GLenum = 0x8834;
pub const GL_BLEND_EQUATION_ALPHA: GLenum = 0x883D;
pub const GL_MAX_VERTEX_ATTRIBS: GLenum = 0x8869;
pub const GL_VERTEX_ATTRIB_ARRAY_NORMALIZED: GLenum = 0x886A;
pub const GL_MAX_TEXTURE_IMAGE_UNITS: GLenum = 0x8872;
pub const GL_FRAGMENT_SHADER: GLenum = 0x8B30;
pub const GL_VERTEX_SHADER: GLenum = 0x8B31;
pub const GL_MAX_FRAGMENT_UNIFORM_COMPONENTS: GLenum = 0x8B49;
pub const GL_MAX_VERTEX_UNIFORM_COMPONENTS: GLenum = 0x8B4A;
pub const GL_MAX_VARYING_FLOATS: GLenum = 0x8B4B;
pub const GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS: GLenum = 0x8B4C;
pub const GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS: GLenum = 0x8B4D;
pub const GL_SHADER_TYPE: GLenum = 0x8B4F;
pub const GL_FLOAT_VEC2: GLenum = 0x8B50;
pub const GL_FLOAT_VEC3: GLenum = 0x8B51;
pub const GL_FLOAT_VEC4: GLenum = 0x8B52;
pub const GL_INT_VEC2: GLenum = 0x8B53;
pub const GL_INT_VEC3: GLenum = 0x8B54;
pub const GL_INT_VEC4: GLenum = 0x8B55;
pub const GL_BOOL: GLenum = 0x8B56;
pub const GL_BOOL_VEC2: GLenum = 0x8B57;
pub const GL_BOOL_VEC3: GLenum = 0x8B58;
pub const GL_BOOL_VEC4: GLenum = 0x8B59;
pub const GL_FLOAT_MAT2: GLenum = 0x8B5A;
pub const GL_FLOAT_MAT3: GLenum = 0x8B5B;
pub const GL_FLOAT_MAT4: GLenum = 0x8B5C;
pub const GL_SAMPLER_1D: GLenum = 0x8B5D;
pub const GL_SAMPLER_2D: GLenum = 0x8B5E;
pub const GL_SAMPLER_3D: GLenum = 0x8B5F;
pub const GL_SAMPLER_CUBE: GLenum = 0x8B60;
pub const GL_SAMPLER_1D_SHADOW: GLenum = 0x8B61;
pub const GL_SAMPLER_2D_SHADOW: GLenum = 0x8B62;
pub const GL_DELETE_STATUS: GLenum = 0x8B80;
pub const GL_COMPILE_STATUS: GLenum = 0x8B81;
pub const GL_LINK_STATUS: GLenum = 0x8B82;
pub const GL_VALIDATE_STATUS: GLenum = 0x8B83;
pub const GL_INFO_LOG_LENGTH: GLenum = 0x8B84;
pub const GL_ATTACHED_SHADERS: GLenum = 0x8B85;
pub const GL_ACTIVE_UNIFORMS: GLenum = 0x8B86;
pub const GL_ACTIVE_UNIFORM_MAX_LENGTH: GLenum = 0x8B87;
pub const GL_SHADER_SOURCE_LENGTH: GLenum = 0x8B88;
pub const GL_ACTIVE_ATTRIBUTES: GLenum = 0x8B89;
pub const GL_ACTIVE_ATTRIBUTE_MAX_LENGTH: GLenum = 0x8B8A;
pub const GL_FRAGMENT_SHADER_DERIVATIVE_HINT: GLenum = 0x8B8B;
pub const GL_SHADING_LANGUAGE_VERSION: GLenum = 0x8B8C;
pub const GL_CURRENT_PROGRAM: GLenum = 0x8B8D;
pub const GL_POINT_SPRITE_COORD_ORIGIN: GLenum = 0x8CA0;
pub const GL_LOWER_LEFT: GLenum = 0x8CA1;
pub const GL_UPPER_LEFT: GLenum = 0x8CA2;
pub const GL_STENCIL_BACK_REF: GLenum = 0x8CA3;
pub const GL_STENCIL_BACK_VALUE_MASK: GLenum = 0x8CA4;
pub const GL_STENCIL_BACK_WRITEMASK: GLenum = 0x8CA5;
pub const GL_VERTEX_PROGRAM_TWO_SIDE: GLenum = 0x8643;
pub const GL_POINT_SPRITE: GLenum = 0x8861;
pub const GL_COORD_REPLACE: GLenum = 0x8862;
pub const GL_MAX_TEXTURE_COORDS: GLenum = 0x8871;

pub trait GL_2_0 {
	fn glGetError(&self) -> GLenum;
	fn glBlendEquationSeparate(&self, modeRGB: GLenum, modeAlpha: GLenum) -> Result<()>;
	fn glDrawBuffers(&self, n: GLsizei, bufs: *const GLenum) -> Result<()>;
	fn glStencilOpSeparate(&self, face: GLenum, sfail: GLenum, dpfail: GLenum, dppass: GLenum) -> Result<()>;
	fn glStencilFuncSeparate(&self, face: GLenum, func: GLenum, ref_: GLint, mask: GLuint) -> Result<()>;
	fn glStencilMaskSeparate(&self, face: GLenum, mask: GLuint) -> Result<()>;
	fn glAttachShader(&self, program: GLuint, shader: GLuint) -> Result<()>;
	fn glBindAttribLocation(&self, program: GLuint, index: GLuint, name: *const GLchar) -> Result<()>;
	fn glCompileShader(&self, shader: GLuint) -> Result<()>;
	fn glCreateProgram(&self) -> Result<GLuint>;
	fn glCreateShader(&self, type_: GLenum) -> Result<GLuint>;
	fn glDeleteProgram(&self, program: GLuint) -> Result<()>;
	fn glDeleteShader(&self, shader: GLuint) -> Result<()>;
	fn glDetachShader(&self, program: GLuint, shader: GLuint) -> Result<()>;
	fn glDisableVertexAttribArray(&self, index: GLuint) -> Result<()>;
	fn glEnableVertexAttribArray(&self, index: GLuint) -> Result<()>;
	fn glGetActiveAttrib(&self, program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLint, type_: *mut GLenum, name: *mut GLchar) -> Result<()>;
	fn glGetActiveUniform(&self, program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLint, type_: *mut GLenum, name: *mut GLchar) -> Result<()>;
	fn glGetAttachedShaders(&self, program: GLuint, maxCount: GLsizei, count: *mut GLsizei, shaders: *mut GLuint) -> Result<()>;
	fn glGetAttribLocation(&self, program: GLuint, name: *const GLchar) -> Result<GLint>;
	fn glGetProgramiv(&self, program: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glGetProgramInfoLog(&self, program: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> Result<()>;
	fn glGetShaderiv(&self, shader: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glGetShaderInfoLog(&self, shader: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> Result<()>;
	fn glGetShaderSource(&self, shader: GLuint, bufSize: GLsizei, length: *mut GLsizei, source: *mut GLchar) -> Result<()>;
	fn glGetUniformLocation(&self, program: GLuint, name: *const GLchar) -> Result<GLint>;
	fn glGetUniformfv(&self, program: GLuint, location: GLint, params: *mut GLfloat) -> Result<()>;
	fn glGetUniformiv(&self, program: GLuint, location: GLint, params: *mut GLint) -> Result<()>;
	fn glGetVertexAttribdv(&self, index: GLuint, pname: GLenum, params: *mut GLdouble) -> Result<()>;
	fn glGetVertexAttribfv(&self, index: GLuint, pname: GLenum, params: *mut GLfloat) -> Result<()>;
	fn glGetVertexAttribiv(&self, index: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glGetVertexAttribPointerv(&self, index: GLuint, pname: GLenum, pointer: *mut *mut c_void) -> Result<()>;
	fn glIsProgram(&self, program: GLuint) -> Result<GLboolean>;
	fn glIsShader(&self, shader: GLuint) -> Result<GLboolean>;
	fn glLinkProgram(&self, program: GLuint) -> Result<()>;
	fn glShaderSource(&self, shader: GLuint, count: GLsizei, string_: *const *const GLchar, length: *const GLint) -> Result<()>;
	fn glUseProgram(&self, program: GLuint) -> Result<()>;
	fn glUniform1f(&self, location: GLint, v0: GLfloat) -> Result<()>;
	fn glUniform2f(&self, location: GLint, v0: GLfloat, v1: GLfloat) -> Result<()>;
	fn glUniform3f(&self, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat) -> Result<()>;
	fn glUniform4f(&self, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat) -> Result<()>;
	fn glUniform1i(&self, location: GLint, v0: GLint) -> Result<()>;
	fn glUniform2i(&self, location: GLint, v0: GLint, v1: GLint) -> Result<()>;
	fn glUniform3i(&self, location: GLint, v0: GLint, v1: GLint, v2: GLint) -> Result<()>;
	fn glUniform4i(&self, location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint) -> Result<()>;
	fn glUniform1fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()>;
	fn glUniform2fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()>;
	fn glUniform3fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()>;
	fn glUniform4fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()>;
	fn glUniform1iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()>;
	fn glUniform2iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()>;
	fn glUniform3iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()>;
	fn glUniform4iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()>;
	fn glUniformMatrix2fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;
	fn glUniformMatrix3fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;
	fn glUniformMatrix4fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;
	fn glValidateProgram(&self, program: GLuint) -> Result<()>;
	fn glVertexAttrib1d(&self, index: GLuint, x: GLdouble) -> Result<()>;
	fn glVertexAttrib1dv(&self, index: GLuint, v: *const GLdouble) -> Result<()>;
	fn glVertexAttrib1f(&self, index: GLuint, x: GLfloat) -> Result<()>;
	fn glVertexAttrib1fv(&self, index: GLuint, v: *const GLfloat) -> Result<()>;
	fn glVertexAttrib1s(&self, index: GLuint, x: GLshort) -> Result<()>;
	fn glVertexAttrib1sv(&self, index: GLuint, v: *const GLshort) -> Result<()>;
	fn glVertexAttrib2d(&self, index: GLuint, x: GLdouble, y: GLdouble) -> Result<()>;
	fn glVertexAttrib2dv(&self, index: GLuint, v: *const GLdouble) -> Result<()>;
	fn glVertexAttrib2f(&self, index: GLuint, x: GLfloat, y: GLfloat) -> Result<()>;
	fn glVertexAttrib2fv(&self, index: GLuint, v: *const GLfloat) -> Result<()>;
	fn glVertexAttrib2s(&self, index: GLuint, x: GLshort, y: GLshort) -> Result<()>;
	fn glVertexAttrib2sv(&self, index: GLuint, v: *const GLshort) -> Result<()>;
	fn glVertexAttrib3d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()>;
	fn glVertexAttrib3dv(&self, index: GLuint, v: *const GLdouble) -> Result<()>;
	fn glVertexAttrib3f(&self, index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat) -> Result<()>;
	fn glVertexAttrib3fv(&self, index: GLuint, v: *const GLfloat) -> Result<()>;
	fn glVertexAttrib3s(&self, index: GLuint, x: GLshort, y: GLshort, z: GLshort) -> Result<()>;
	fn glVertexAttrib3sv(&self, index: GLuint, v: *const GLshort) -> Result<()>;
	fn glVertexAttrib4Nbv(&self, index: GLuint, v: *const GLbyte) -> Result<()>;
	fn glVertexAttrib4Niv(&self, index: GLuint, v: *const GLint) -> Result<()>;
	fn glVertexAttrib4Nsv(&self, index: GLuint, v: *const GLshort) -> Result<()>;
	fn glVertexAttrib4Nub(&self, index: GLuint, x: GLubyte, y: GLubyte, z: GLubyte, w: GLubyte) -> Result<()>;
	fn glVertexAttrib4Nubv(&self, index: GLuint, v: *const GLubyte) -> Result<()>;
	fn glVertexAttrib4Nuiv(&self, index: GLuint, v: *const GLuint) -> Result<()>;
	fn glVertexAttrib4Nusv(&self, index: GLuint, v: *const GLushort) -> Result<()>;
	fn glVertexAttrib4bv(&self, index: GLuint, v: *const GLbyte) -> Result<()>;
	fn glVertexAttrib4d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble) -> Result<()>;
	fn glVertexAttrib4dv(&self, index: GLuint, v: *const GLdouble) -> Result<()>;
	fn glVertexAttrib4f(&self, index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat) -> Result<()>;
	fn glVertexAttrib4fv(&self, index: GLuint, v: *const GLfloat) -> Result<()>;
	fn glVertexAttrib4iv(&self, index: GLuint, v: *const GLint) -> Result<()>;
	fn glVertexAttrib4s(&self, index: GLuint, x: GLshort, y: GLshort, z: GLshort, w: GLshort) -> Result<()>;
	fn glVertexAttrib4sv(&self, index: GLuint, v: *const GLshort) -> Result<()>;
	fn glVertexAttrib4ubv(&self, index: GLuint, v: *const GLubyte) -> Result<()>;
	fn glVertexAttrib4uiv(&self, index: GLuint, v: *const GLuint) -> Result<()>;
	fn glVertexAttrib4usv(&self, index: GLuint, v: *const GLushort) -> Result<()>;
	fn glVertexAttribPointer(&self, index: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, stride: GLsizei, pointer: *const c_void) -> Result<()>;
	fn get_shading_language_version(&self) -> &'static str;
}

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version20 {
	shading_language_version: &'static str,
	available: bool,
	geterror: PFNGLGETERRORPROC,
	blendequationseparate: PFNGLBLENDEQUATIONSEPARATEPROC,
	drawbuffers: PFNGLDRAWBUFFERSPROC,
	stencilopseparate: PFNGLSTENCILOPSEPARATEPROC,
	stencilfuncseparate: PFNGLSTENCILFUNCSEPARATEPROC,
	stencilmaskseparate: PFNGLSTENCILMASKSEPARATEPROC,
	attachshader: PFNGLATTACHSHADERPROC,
	bindattriblocation: PFNGLBINDATTRIBLOCATIONPROC,
	compileshader: PFNGLCOMPILESHADERPROC,
	createprogram: PFNGLCREATEPROGRAMPROC,
	createshader: PFNGLCREATESHADERPROC,
	deleteprogram: PFNGLDELETEPROGRAMPROC,
	deleteshader: PFNGLDELETESHADERPROC,
	detachshader: PFNGLDETACHSHADERPROC,
	disablevertexattribarray: PFNGLDISABLEVERTEXATTRIBARRAYPROC,
	enablevertexattribarray: PFNGLENABLEVERTEXATTRIBARRAYPROC,
	getactiveattrib: PFNGLGETACTIVEATTRIBPROC,
	getactiveuniform: PFNGLGETACTIVEUNIFORMPROC,
	getattachedshaders: PFNGLGETATTACHEDSHADERSPROC,
	getattriblocation: PFNGLGETATTRIBLOCATIONPROC,
	getprogramiv: PFNGLGETPROGRAMIVPROC,
	getprograminfolog: PFNGLGETPROGRAMINFOLOGPROC,
	getshaderiv: PFNGLGETSHADERIVPROC,
	getshaderinfolog: PFNGLGETSHADERINFOLOGPROC,
	getshadersource: PFNGLGETSHADERSOURCEPROC,
	getuniformlocation: PFNGLGETUNIFORMLOCATIONPROC,
	getuniformfv: PFNGLGETUNIFORMFVPROC,
	getuniformiv: PFNGLGETUNIFORMIVPROC,
	getvertexattribdv: PFNGLGETVERTEXATTRIBDVPROC,
	getvertexattribfv: PFNGLGETVERTEXATTRIBFVPROC,
	getvertexattribiv: PFNGLGETVERTEXATTRIBIVPROC,
	getvertexattribpointerv: PFNGLGETVERTEXATTRIBPOINTERVPROC,
	isprogram: PFNGLISPROGRAMPROC,
	isshader: PFNGLISSHADERPROC,
	linkprogram: PFNGLLINKPROGRAMPROC,
	shadersource: PFNGLSHADERSOURCEPROC,
	useprogram: PFNGLUSEPROGRAMPROC,
	uniform1f: PFNGLUNIFORM1FPROC,
	uniform2f: PFNGLUNIFORM2FPROC,
	uniform3f: PFNGLUNIFORM3FPROC,
	uniform4f: PFNGLUNIFORM4FPROC,
	uniform1i: PFNGLUNIFORM1IPROC,
	uniform2i: PFNGLUNIFORM2IPROC,
	uniform3i: PFNGLUNIFORM3IPROC,
	uniform4i: PFNGLUNIFORM4IPROC,
	uniform1fv: PFNGLUNIFORM1FVPROC,
	uniform2fv: PFNGLUNIFORM2FVPROC,
	uniform3fv: PFNGLUNIFORM3FVPROC,
	uniform4fv: PFNGLUNIFORM4FVPROC,
	uniform1iv: PFNGLUNIFORM1IVPROC,
	uniform2iv: PFNGLUNIFORM2IVPROC,
	uniform3iv: PFNGLUNIFORM3IVPROC,
	uniform4iv: PFNGLUNIFORM4IVPROC,
	uniformmatrix2fv: PFNGLUNIFORMMATRIX2FVPROC,
	uniformmatrix3fv: PFNGLUNIFORMMATRIX3FVPROC,
	uniformmatrix4fv: PFNGLUNIFORMMATRIX4FVPROC,
	validateprogram: PFNGLVALIDATEPROGRAMPROC,
	vertexattrib1d: PFNGLVERTEXATTRIB1DPROC,
	vertexattrib1dv: PFNGLVERTEXATTRIB1DVPROC,
	vertexattrib1f: PFNGLVERTEXATTRIB1FPROC,
	vertexattrib1fv: PFNGLVERTEXATTRIB1FVPROC,
	vertexattrib1s: PFNGLVERTEXATTRIB1SPROC,
	vertexattrib1sv: PFNGLVERTEXATTRIB1SVPROC,
	vertexattrib2d: PFNGLVERTEXATTRIB2DPROC,
	vertexattrib2dv: PFNGLVERTEXATTRIB2DVPROC,
	vertexattrib2f: PFNGLVERTEXATTRIB2FPROC,
	vertexattrib2fv: PFNGLVERTEXATTRIB2FVPROC,
	vertexattrib2s: PFNGLVERTEXATTRIB2SPROC,
	vertexattrib2sv: PFNGLVERTEXATTRIB2SVPROC,
	vertexattrib3d: PFNGLVERTEXATTRIB3DPROC,
	vertexattrib3dv: PFNGLVERTEXATTRIB3DVPROC,
	vertexattrib3f: PFNGLVERTEXATTRIB3FPROC,
	vertexattrib3fv: PFNGLVERTEXATTRIB3FVPROC,
	vertexattrib3s: PFNGLVERTEXATTRIB3SPROC,
	vertexattrib3sv: PFNGLVERTEXATTRIB3SVPROC,
	vertexattrib4nbv: PFNGLVERTEXATTRIB4NBVPROC,
	vertexattrib4niv: PFNGLVERTEXATTRIB4NIVPROC,
	vertexattrib4nsv: PFNGLVERTEXATTRIB4NSVPROC,
	vertexattrib4nub: PFNGLVERTEXATTRIB4NUBPROC,
	vertexattrib4nubv: PFNGLVERTEXATTRIB4NUBVPROC,
	vertexattrib4nuiv: PFNGLVERTEXATTRIB4NUIVPROC,
	vertexattrib4nusv: PFNGLVERTEXATTRIB4NUSVPROC,
	vertexattrib4bv: PFNGLVERTEXATTRIB4BVPROC,
	vertexattrib4d: PFNGLVERTEXATTRIB4DPROC,
	vertexattrib4dv: PFNGLVERTEXATTRIB4DVPROC,
	vertexattrib4f: PFNGLVERTEXATTRIB4FPROC,
	vertexattrib4fv: PFNGLVERTEXATTRIB4FVPROC,
	vertexattrib4iv: PFNGLVERTEXATTRIB4IVPROC,
	vertexattrib4s: PFNGLVERTEXATTRIB4SPROC,
	vertexattrib4sv: PFNGLVERTEXATTRIB4SVPROC,
	vertexattrib4ubv: PFNGLVERTEXATTRIB4UBVPROC,
	vertexattrib4uiv: PFNGLVERTEXATTRIB4UIVPROC,
	vertexattrib4usv: PFNGLVERTEXATTRIB4USVPROC,
	vertexattribpointer: PFNGLVERTEXATTRIBPOINTERPROC,
}

impl GL_2_0 for Version20 {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	#[inline(always)]
	fn glBlendEquationSeparate(&self, modeRGB: GLenum, modeAlpha: GLenum) -> Result<()> {
		let ret = process_catch("glBlendEquationSeparate", catch_unwind(||(self.blendequationseparate)(modeRGB, modeAlpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendEquationSeparate", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawBuffers(&self, n: GLsizei, bufs: *const GLenum) -> Result<()> {
		let ret = process_catch("glDrawBuffers", catch_unwind(||(self.drawbuffers)(n, bufs)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawBuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glStencilOpSeparate(&self, face: GLenum, sfail: GLenum, dpfail: GLenum, dppass: GLenum) -> Result<()> {
		let ret = process_catch("glStencilOpSeparate", catch_unwind(||(self.stencilopseparate)(face, sfail, dpfail, dppass)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilOpSeparate", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glStencilFuncSeparate(&self, face: GLenum, func: GLenum, ref_: GLint, mask: GLuint) -> Result<()> {
		let ret = process_catch("glStencilFuncSeparate", catch_unwind(||(self.stencilfuncseparate)(face, func, ref_, mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilFuncSeparate", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glStencilMaskSeparate(&self, face: GLenum, mask: GLuint) -> Result<()> {
		let ret = process_catch("glStencilMaskSeparate", catch_unwind(||(self.stencilmaskseparate)(face, mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilMaskSeparate", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glAttachShader(&self, program: GLuint, shader: GLuint) -> Result<()> {
		let ret = process_catch("glAttachShader", catch_unwind(||(self.attachshader)(program, shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glAttachShader", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindAttribLocation(&self, program: GLuint, index: GLuint, name: *const GLchar) -> Result<()> {
		let ret = process_catch("glBindAttribLocation", catch_unwind(||(self.bindattriblocation)(program, index, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindAttribLocation", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompileShader(&self, shader: GLuint) -> Result<()> {
		let ret = process_catch("glCompileShader", catch_unwind(||(self.compileshader)(shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompileShader", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateProgram(&self) -> Result<GLuint> {
		let ret = process_catch("glCreateProgram", catch_unwind(||(self.createprogram)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateProgram", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateShader(&self, type_: GLenum) -> Result<GLuint> {
		let ret = process_catch("glCreateShader", catch_unwind(||(self.createshader)(type_)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateShader", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteProgram(&self, program: GLuint) -> Result<()> {
		let ret = process_catch("glDeleteProgram", catch_unwind(||(self.deleteprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteProgram", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteShader(&self, shader: GLuint) -> Result<()> {
		let ret = process_catch("glDeleteShader", catch_unwind(||(self.deleteshader)(shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteShader", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDetachShader(&self, program: GLuint, shader: GLuint) -> Result<()> {
		let ret = process_catch("glDetachShader", catch_unwind(||(self.detachshader)(program, shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDetachShader", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDisableVertexAttribArray(&self, index: GLuint) -> Result<()> {
		let ret = process_catch("glDisableVertexAttribArray", catch_unwind(||(self.disablevertexattribarray)(index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDisableVertexAttribArray", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glEnableVertexAttribArray(&self, index: GLuint) -> Result<()> {
		let ret = process_catch("glEnableVertexAttribArray", catch_unwind(||(self.enablevertexattribarray)(index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEnableVertexAttribArray", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveAttrib(&self, program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLint, type_: *mut GLenum, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveAttrib", catch_unwind(||(self.getactiveattrib)(program, index, bufSize, length, size, type_, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveAttrib", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveUniform(&self, program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLint, type_: *mut GLenum, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveUniform", catch_unwind(||(self.getactiveuniform)(program, index, bufSize, length, size, type_, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniform", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetAttachedShaders(&self, program: GLuint, maxCount: GLsizei, count: *mut GLsizei, shaders: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetAttachedShaders", catch_unwind(||(self.getattachedshaders)(program, maxCount, count, shaders)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetAttachedShaders", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetAttribLocation(&self, program: GLuint, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetAttribLocation", catch_unwind(||(self.getattriblocation)(program, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetAttribLocation", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramiv(&self, program: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramiv", catch_unwind(||(self.getprogramiv)(program, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramInfoLog(&self, program: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetProgramInfoLog", catch_unwind(||(self.getprograminfolog)(program, bufSize, length, infoLog)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramInfoLog", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetShaderiv(&self, shader: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetShaderiv", catch_unwind(||(self.getshaderiv)(shader, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetShaderiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetShaderInfoLog(&self, shader: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetShaderInfoLog", catch_unwind(||(self.getshaderinfolog)(shader, bufSize, length, infoLog)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetShaderInfoLog", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetShaderSource(&self, shader: GLuint, bufSize: GLsizei, length: *mut GLsizei, source: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetShaderSource", catch_unwind(||(self.getshadersource)(shader, bufSize, length, source)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetShaderSource", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetUniformLocation(&self, program: GLuint, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetUniformLocation", catch_unwind(||(self.getuniformlocation)(program, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformLocation", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetUniformfv(&self, program: GLuint, location: GLint, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetUniformfv", catch_unwind(||(self.getuniformfv)(program, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetUniformiv(&self, program: GLuint, location: GLint, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetUniformiv", catch_unwind(||(self.getuniformiv)(program, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexAttribdv(&self, index: GLuint, pname: GLenum, params: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetVertexAttribdv", catch_unwind(||(self.getvertexattribdv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribdv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexAttribfv(&self, index: GLuint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetVertexAttribfv", catch_unwind(||(self.getvertexattribfv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexAttribiv(&self, index: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetVertexAttribiv", catch_unwind(||(self.getvertexattribiv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexAttribPointerv(&self, index: GLuint, pname: GLenum, pointer: *mut *mut c_void) -> Result<()> {
		let ret = process_catch("glGetVertexAttribPointerv", catch_unwind(||(self.getvertexattribpointerv)(index, pname, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribPointerv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsProgram(&self, program: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsProgram", catch_unwind(||(self.isprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsProgram", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsShader(&self, shader: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsShader", catch_unwind(||(self.isshader)(shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsShader", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glLinkProgram(&self, program: GLuint) -> Result<()> {
		let ret = process_catch("glLinkProgram", catch_unwind(||(self.linkprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLinkProgram", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glShaderSource(&self, shader: GLuint, count: GLsizei, string_: *const *const GLchar, length: *const GLint) -> Result<()> {
		let ret = process_catch("glShaderSource", catch_unwind(||(self.shadersource)(shader, count, string_, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glShaderSource", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUseProgram(&self, program: GLuint) -> Result<()> {
		let ret = process_catch("glUseProgram", catch_unwind(||(self.useprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUseProgram", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform1f(&self, location: GLint, v0: GLfloat) -> Result<()> {
		let ret = process_catch("glUniform1f", catch_unwind(||(self.uniform1f)(location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform2f(&self, location: GLint, v0: GLfloat, v1: GLfloat) -> Result<()> {
		let ret = process_catch("glUniform2f", catch_unwind(||(self.uniform2f)(location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform3f(&self, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat) -> Result<()> {
		let ret = process_catch("glUniform3f", catch_unwind(||(self.uniform3f)(location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform4f(&self, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat) -> Result<()> {
		let ret = process_catch("glUniform4f", catch_unwind(||(self.uniform4f)(location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform1i(&self, location: GLint, v0: GLint) -> Result<()> {
		let ret = process_catch("glUniform1i", catch_unwind(||(self.uniform1i)(location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform2i(&self, location: GLint, v0: GLint, v1: GLint) -> Result<()> {
		let ret = process_catch("glUniform2i", catch_unwind(||(self.uniform2i)(location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform3i(&self, location: GLint, v0: GLint, v1: GLint, v2: GLint) -> Result<()> {
		let ret = process_catch("glUniform3i", catch_unwind(||(self.uniform3i)(location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform4i(&self, location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint) -> Result<()> {
		let ret = process_catch("glUniform4i", catch_unwind(||(self.uniform4i)(location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform1fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniform1fv", catch_unwind(||(self.uniform1fv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform2fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniform2fv", catch_unwind(||(self.uniform2fv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform3fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniform3fv", catch_unwind(||(self.uniform3fv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform4fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniform4fv", catch_unwind(||(self.uniform4fv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform1iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glUniform1iv", catch_unwind(||(self.uniform1iv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform2iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glUniform2iv", catch_unwind(||(self.uniform2iv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform3iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glUniform3iv", catch_unwind(||(self.uniform3iv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform4iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glUniform4iv", catch_unwind(||(self.uniform4iv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix2fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix2fv", catch_unwind(||(self.uniformmatrix2fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix3fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix3fv", catch_unwind(||(self.uniformmatrix3fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix4fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix4fv", catch_unwind(||(self.uniformmatrix4fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glValidateProgram(&self, program: GLuint) -> Result<()> {
		let ret = process_catch("glValidateProgram", catch_unwind(||(self.validateprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glValidateProgram", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib1d(&self, index: GLuint, x: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib1d", catch_unwind(||(self.vertexattrib1d)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib1dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib1dv", catch_unwind(||(self.vertexattrib1dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib1f(&self, index: GLuint, x: GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib1f", catch_unwind(||(self.vertexattrib1f)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib1fv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib1fv", catch_unwind(||(self.vertexattrib1fv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib1s(&self, index: GLuint, x: GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib1s", catch_unwind(||(self.vertexattrib1s)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib1sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib1sv", catch_unwind(||(self.vertexattrib1sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib2d(&self, index: GLuint, x: GLdouble, y: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib2d", catch_unwind(||(self.vertexattrib2d)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib2dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib2dv", catch_unwind(||(self.vertexattrib2dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib2f(&self, index: GLuint, x: GLfloat, y: GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib2f", catch_unwind(||(self.vertexattrib2f)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib2fv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib2fv", catch_unwind(||(self.vertexattrib2fv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib2s(&self, index: GLuint, x: GLshort, y: GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib2s", catch_unwind(||(self.vertexattrib2s)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib2sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib2sv", catch_unwind(||(self.vertexattrib2sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib3d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib3d", catch_unwind(||(self.vertexattrib3d)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib3dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib3dv", catch_unwind(||(self.vertexattrib3dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib3f(&self, index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib3f", catch_unwind(||(self.vertexattrib3f)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib3fv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib3fv", catch_unwind(||(self.vertexattrib3fv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib3s(&self, index: GLuint, x: GLshort, y: GLshort, z: GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib3s", catch_unwind(||(self.vertexattrib3s)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib3sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib3sv", catch_unwind(||(self.vertexattrib3sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4Nbv(&self, index: GLuint, v: *const GLbyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nbv", catch_unwind(||(self.vertexattrib4nbv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nbv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4Niv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Niv", catch_unwind(||(self.vertexattrib4niv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Niv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4Nsv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nsv", catch_unwind(||(self.vertexattrib4nsv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nsv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4Nub(&self, index: GLuint, x: GLubyte, y: GLubyte, z: GLubyte, w: GLubyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nub", catch_unwind(||(self.vertexattrib4nub)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nub", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4Nubv(&self, index: GLuint, v: *const GLubyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nubv", catch_unwind(||(self.vertexattrib4nubv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nubv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4Nuiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nuiv", catch_unwind(||(self.vertexattrib4nuiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4Nusv(&self, index: GLuint, v: *const GLushort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nusv", catch_unwind(||(self.vertexattrib4nusv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nusv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4bv(&self, index: GLuint, v: *const GLbyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4bv", catch_unwind(||(self.vertexattrib4bv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4bv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib4d", catch_unwind(||(self.vertexattrib4d)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib4dv", catch_unwind(||(self.vertexattrib4dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4f(&self, index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib4f", catch_unwind(||(self.vertexattrib4f)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4fv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib4fv", catch_unwind(||(self.vertexattrib4fv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttrib4iv", catch_unwind(||(self.vertexattrib4iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4s(&self, index: GLuint, x: GLshort, y: GLshort, z: GLshort, w: GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4s", catch_unwind(||(self.vertexattrib4s)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4s", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4sv", catch_unwind(||(self.vertexattrib4sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4ubv(&self, index: GLuint, v: *const GLubyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4ubv", catch_unwind(||(self.vertexattrib4ubv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4ubv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttrib4uiv", catch_unwind(||(self.vertexattrib4uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4usv(&self, index: GLuint, v: *const GLushort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4usv", catch_unwind(||(self.vertexattrib4usv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4usv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribPointer(&self, index: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glVertexAttribPointer", catch_unwind(||(self.vertexattribpointer)(index, size, type_, normalized, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribPointer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn get_shading_language_version(&self) -> &'static str {
		self.shading_language_version
	}
}

impl Version20 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (2, 0, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			blendequationseparate: {let proc = get_proc_address("glBlendEquationSeparate"); if proc == null() {dummy_pfnglblendequationseparateproc} else {unsafe{transmute(proc)}}},
			drawbuffers: {let proc = get_proc_address("glDrawBuffers"); if proc == null() {dummy_pfngldrawbuffersproc} else {unsafe{transmute(proc)}}},
			stencilopseparate: {let proc = get_proc_address("glStencilOpSeparate"); if proc == null() {dummy_pfnglstencilopseparateproc} else {unsafe{transmute(proc)}}},
			stencilfuncseparate: {let proc = get_proc_address("glStencilFuncSeparate"); if proc == null() {dummy_pfnglstencilfuncseparateproc} else {unsafe{transmute(proc)}}},
			stencilmaskseparate: {let proc = get_proc_address("glStencilMaskSeparate"); if proc == null() {dummy_pfnglstencilmaskseparateproc} else {unsafe{transmute(proc)}}},
			attachshader: {let proc = get_proc_address("glAttachShader"); if proc == null() {dummy_pfnglattachshaderproc} else {unsafe{transmute(proc)}}},
			bindattriblocation: {let proc = get_proc_address("glBindAttribLocation"); if proc == null() {dummy_pfnglbindattriblocationproc} else {unsafe{transmute(proc)}}},
			compileshader: {let proc = get_proc_address("glCompileShader"); if proc == null() {dummy_pfnglcompileshaderproc} else {unsafe{transmute(proc)}}},
			createprogram: {let proc = get_proc_address("glCreateProgram"); if proc == null() {dummy_pfnglcreateprogramproc} else {unsafe{transmute(proc)}}},
			createshader: {let proc = get_proc_address("glCreateShader"); if proc == null() {dummy_pfnglcreateshaderproc} else {unsafe{transmute(proc)}}},
			deleteprogram: {let proc = get_proc_address("glDeleteProgram"); if proc == null() {dummy_pfngldeleteprogramproc} else {unsafe{transmute(proc)}}},
			deleteshader: {let proc = get_proc_address("glDeleteShader"); if proc == null() {dummy_pfngldeleteshaderproc} else {unsafe{transmute(proc)}}},
			detachshader: {let proc = get_proc_address("glDetachShader"); if proc == null() {dummy_pfngldetachshaderproc} else {unsafe{transmute(proc)}}},
			disablevertexattribarray: {let proc = get_proc_address("glDisableVertexAttribArray"); if proc == null() {dummy_pfngldisablevertexattribarrayproc} else {unsafe{transmute(proc)}}},
			enablevertexattribarray: {let proc = get_proc_address("glEnableVertexAttribArray"); if proc == null() {dummy_pfnglenablevertexattribarrayproc} else {unsafe{transmute(proc)}}},
			getactiveattrib: {let proc = get_proc_address("glGetActiveAttrib"); if proc == null() {dummy_pfnglgetactiveattribproc} else {unsafe{transmute(proc)}}},
			getactiveuniform: {let proc = get_proc_address("glGetActiveUniform"); if proc == null() {dummy_pfnglgetactiveuniformproc} else {unsafe{transmute(proc)}}},
			getattachedshaders: {let proc = get_proc_address("glGetAttachedShaders"); if proc == null() {dummy_pfnglgetattachedshadersproc} else {unsafe{transmute(proc)}}},
			getattriblocation: {let proc = get_proc_address("glGetAttribLocation"); if proc == null() {dummy_pfnglgetattriblocationproc} else {unsafe{transmute(proc)}}},
			getprogramiv: {let proc = get_proc_address("glGetProgramiv"); if proc == null() {dummy_pfnglgetprogramivproc} else {unsafe{transmute(proc)}}},
			getprograminfolog: {let proc = get_proc_address("glGetProgramInfoLog"); if proc == null() {dummy_pfnglgetprograminfologproc} else {unsafe{transmute(proc)}}},
			getshaderiv: {let proc = get_proc_address("glGetShaderiv"); if proc == null() {dummy_pfnglgetshaderivproc} else {unsafe{transmute(proc)}}},
			getshaderinfolog: {let proc = get_proc_address("glGetShaderInfoLog"); if proc == null() {dummy_pfnglgetshaderinfologproc} else {unsafe{transmute(proc)}}},
			getshadersource: {let proc = get_proc_address("glGetShaderSource"); if proc == null() {dummy_pfnglgetshadersourceproc} else {unsafe{transmute(proc)}}},
			getuniformlocation: {let proc = get_proc_address("glGetUniformLocation"); if proc == null() {dummy_pfnglgetuniformlocationproc} else {unsafe{transmute(proc)}}},
			getuniformfv: {let proc = get_proc_address("glGetUniformfv"); if proc == null() {dummy_pfnglgetuniformfvproc} else {unsafe{transmute(proc)}}},
			getuniformiv: {let proc = get_proc_address("glGetUniformiv"); if proc == null() {dummy_pfnglgetuniformivproc} else {unsafe{transmute(proc)}}},
			getvertexattribdv: {let proc = get_proc_address("glGetVertexAttribdv"); if proc == null() {dummy_pfnglgetvertexattribdvproc} else {unsafe{transmute(proc)}}},
			getvertexattribfv: {let proc = get_proc_address("glGetVertexAttribfv"); if proc == null() {dummy_pfnglgetvertexattribfvproc} else {unsafe{transmute(proc)}}},
			getvertexattribiv: {let proc = get_proc_address("glGetVertexAttribiv"); if proc == null() {dummy_pfnglgetvertexattribivproc} else {unsafe{transmute(proc)}}},
			getvertexattribpointerv: {let proc = get_proc_address("glGetVertexAttribPointerv"); if proc == null() {dummy_pfnglgetvertexattribpointervproc} else {unsafe{transmute(proc)}}},
			isprogram: {let proc = get_proc_address("glIsProgram"); if proc == null() {dummy_pfnglisprogramproc} else {unsafe{transmute(proc)}}},
			isshader: {let proc = get_proc_address("glIsShader"); if proc == null() {dummy_pfnglisshaderproc} else {unsafe{transmute(proc)}}},
			linkprogram: {let proc = get_proc_address("glLinkProgram"); if proc == null() {dummy_pfngllinkprogramproc} else {unsafe{transmute(proc)}}},
			shadersource: {let proc = get_proc_address("glShaderSource"); if proc == null() {dummy_pfnglshadersourceproc} else {unsafe{transmute(proc)}}},
			useprogram: {let proc = get_proc_address("glUseProgram"); if proc == null() {dummy_pfngluseprogramproc} else {unsafe{transmute(proc)}}},
			uniform1f: {let proc = get_proc_address("glUniform1f"); if proc == null() {dummy_pfngluniform1fproc} else {unsafe{transmute(proc)}}},
			uniform2f: {let proc = get_proc_address("glUniform2f"); if proc == null() {dummy_pfngluniform2fproc} else {unsafe{transmute(proc)}}},
			uniform3f: {let proc = get_proc_address("glUniform3f"); if proc == null() {dummy_pfngluniform3fproc} else {unsafe{transmute(proc)}}},
			uniform4f: {let proc = get_proc_address("glUniform4f"); if proc == null() {dummy_pfngluniform4fproc} else {unsafe{transmute(proc)}}},
			uniform1i: {let proc = get_proc_address("glUniform1i"); if proc == null() {dummy_pfngluniform1iproc} else {unsafe{transmute(proc)}}},
			uniform2i: {let proc = get_proc_address("glUniform2i"); if proc == null() {dummy_pfngluniform2iproc} else {unsafe{transmute(proc)}}},
			uniform3i: {let proc = get_proc_address("glUniform3i"); if proc == null() {dummy_pfngluniform3iproc} else {unsafe{transmute(proc)}}},
			uniform4i: {let proc = get_proc_address("glUniform4i"); if proc == null() {dummy_pfngluniform4iproc} else {unsafe{transmute(proc)}}},
			uniform1fv: {let proc = get_proc_address("glUniform1fv"); if proc == null() {dummy_pfngluniform1fvproc} else {unsafe{transmute(proc)}}},
			uniform2fv: {let proc = get_proc_address("glUniform2fv"); if proc == null() {dummy_pfngluniform2fvproc} else {unsafe{transmute(proc)}}},
			uniform3fv: {let proc = get_proc_address("glUniform3fv"); if proc == null() {dummy_pfngluniform3fvproc} else {unsafe{transmute(proc)}}},
			uniform4fv: {let proc = get_proc_address("glUniform4fv"); if proc == null() {dummy_pfngluniform4fvproc} else {unsafe{transmute(proc)}}},
			uniform1iv: {let proc = get_proc_address("glUniform1iv"); if proc == null() {dummy_pfngluniform1ivproc} else {unsafe{transmute(proc)}}},
			uniform2iv: {let proc = get_proc_address("glUniform2iv"); if proc == null() {dummy_pfngluniform2ivproc} else {unsafe{transmute(proc)}}},
			uniform3iv: {let proc = get_proc_address("glUniform3iv"); if proc == null() {dummy_pfngluniform3ivproc} else {unsafe{transmute(proc)}}},
			uniform4iv: {let proc = get_proc_address("glUniform4iv"); if proc == null() {dummy_pfngluniform4ivproc} else {unsafe{transmute(proc)}}},
			uniformmatrix2fv: {let proc = get_proc_address("glUniformMatrix2fv"); if proc == null() {dummy_pfngluniformmatrix2fvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix3fv: {let proc = get_proc_address("glUniformMatrix3fv"); if proc == null() {dummy_pfngluniformmatrix3fvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix4fv: {let proc = get_proc_address("glUniformMatrix4fv"); if proc == null() {dummy_pfngluniformmatrix4fvproc} else {unsafe{transmute(proc)}}},
			validateprogram: {let proc = get_proc_address("glValidateProgram"); if proc == null() {dummy_pfnglvalidateprogramproc} else {unsafe{transmute(proc)}}},
			vertexattrib1d: {let proc = get_proc_address("glVertexAttrib1d"); if proc == null() {dummy_pfnglvertexattrib1dproc} else {unsafe{transmute(proc)}}},
			vertexattrib1dv: {let proc = get_proc_address("glVertexAttrib1dv"); if proc == null() {dummy_pfnglvertexattrib1dvproc} else {unsafe{transmute(proc)}}},
			vertexattrib1f: {let proc = get_proc_address("glVertexAttrib1f"); if proc == null() {dummy_pfnglvertexattrib1fproc} else {unsafe{transmute(proc)}}},
			vertexattrib1fv: {let proc = get_proc_address("glVertexAttrib1fv"); if proc == null() {dummy_pfnglvertexattrib1fvproc} else {unsafe{transmute(proc)}}},
			vertexattrib1s: {let proc = get_proc_address("glVertexAttrib1s"); if proc == null() {dummy_pfnglvertexattrib1sproc} else {unsafe{transmute(proc)}}},
			vertexattrib1sv: {let proc = get_proc_address("glVertexAttrib1sv"); if proc == null() {dummy_pfnglvertexattrib1svproc} else {unsafe{transmute(proc)}}},
			vertexattrib2d: {let proc = get_proc_address("glVertexAttrib2d"); if proc == null() {dummy_pfnglvertexattrib2dproc} else {unsafe{transmute(proc)}}},
			vertexattrib2dv: {let proc = get_proc_address("glVertexAttrib2dv"); if proc == null() {dummy_pfnglvertexattrib2dvproc} else {unsafe{transmute(proc)}}},
			vertexattrib2f: {let proc = get_proc_address("glVertexAttrib2f"); if proc == null() {dummy_pfnglvertexattrib2fproc} else {unsafe{transmute(proc)}}},
			vertexattrib2fv: {let proc = get_proc_address("glVertexAttrib2fv"); if proc == null() {dummy_pfnglvertexattrib2fvproc} else {unsafe{transmute(proc)}}},
			vertexattrib2s: {let proc = get_proc_address("glVertexAttrib2s"); if proc == null() {dummy_pfnglvertexattrib2sproc} else {unsafe{transmute(proc)}}},
			vertexattrib2sv: {let proc = get_proc_address("glVertexAttrib2sv"); if proc == null() {dummy_pfnglvertexattrib2svproc} else {unsafe{transmute(proc)}}},
			vertexattrib3d: {let proc = get_proc_address("glVertexAttrib3d"); if proc == null() {dummy_pfnglvertexattrib3dproc} else {unsafe{transmute(proc)}}},
			vertexattrib3dv: {let proc = get_proc_address("glVertexAttrib3dv"); if proc == null() {dummy_pfnglvertexattrib3dvproc} else {unsafe{transmute(proc)}}},
			vertexattrib3f: {let proc = get_proc_address("glVertexAttrib3f"); if proc == null() {dummy_pfnglvertexattrib3fproc} else {unsafe{transmute(proc)}}},
			vertexattrib3fv: {let proc = get_proc_address("glVertexAttrib3fv"); if proc == null() {dummy_pfnglvertexattrib3fvproc} else {unsafe{transmute(proc)}}},
			vertexattrib3s: {let proc = get_proc_address("glVertexAttrib3s"); if proc == null() {dummy_pfnglvertexattrib3sproc} else {unsafe{transmute(proc)}}},
			vertexattrib3sv: {let proc = get_proc_address("glVertexAttrib3sv"); if proc == null() {dummy_pfnglvertexattrib3svproc} else {unsafe{transmute(proc)}}},
			vertexattrib4nbv: {let proc = get_proc_address("glVertexAttrib4Nbv"); if proc == null() {dummy_pfnglvertexattrib4nbvproc} else {unsafe{transmute(proc)}}},
			vertexattrib4niv: {let proc = get_proc_address("glVertexAttrib4Niv"); if proc == null() {dummy_pfnglvertexattrib4nivproc} else {unsafe{transmute(proc)}}},
			vertexattrib4nsv: {let proc = get_proc_address("glVertexAttrib4Nsv"); if proc == null() {dummy_pfnglvertexattrib4nsvproc} else {unsafe{transmute(proc)}}},
			vertexattrib4nub: {let proc = get_proc_address("glVertexAttrib4Nub"); if proc == null() {dummy_pfnglvertexattrib4nubproc} else {unsafe{transmute(proc)}}},
			vertexattrib4nubv: {let proc = get_proc_address("glVertexAttrib4Nubv"); if proc == null() {dummy_pfnglvertexattrib4nubvproc} else {unsafe{transmute(proc)}}},
			vertexattrib4nuiv: {let proc = get_proc_address("glVertexAttrib4Nuiv"); if proc == null() {dummy_pfnglvertexattrib4nuivproc} else {unsafe{transmute(proc)}}},
			vertexattrib4nusv: {let proc = get_proc_address("glVertexAttrib4Nusv"); if proc == null() {dummy_pfnglvertexattrib4nusvproc} else {unsafe{transmute(proc)}}},
			vertexattrib4bv: {let proc = get_proc_address("glVertexAttrib4bv"); if proc == null() {dummy_pfnglvertexattrib4bvproc} else {unsafe{transmute(proc)}}},
			vertexattrib4d: {let proc = get_proc_address("glVertexAttrib4d"); if proc == null() {dummy_pfnglvertexattrib4dproc} else {unsafe{transmute(proc)}}},
			vertexattrib4dv: {let proc = get_proc_address("glVertexAttrib4dv"); if proc == null() {dummy_pfnglvertexattrib4dvproc} else {unsafe{transmute(proc)}}},
			vertexattrib4f: {let proc = get_proc_address("glVertexAttrib4f"); if proc == null() {dummy_pfnglvertexattrib4fproc} else {unsafe{transmute(proc)}}},
			vertexattrib4fv: {let proc = get_proc_address("glVertexAttrib4fv"); if proc == null() {dummy_pfnglvertexattrib4fvproc} else {unsafe{transmute(proc)}}},
			vertexattrib4iv: {let proc = get_proc_address("glVertexAttrib4iv"); if proc == null() {dummy_pfnglvertexattrib4ivproc} else {unsafe{transmute(proc)}}},
			vertexattrib4s: {let proc = get_proc_address("glVertexAttrib4s"); if proc == null() {dummy_pfnglvertexattrib4sproc} else {unsafe{transmute(proc)}}},
			vertexattrib4sv: {let proc = get_proc_address("glVertexAttrib4sv"); if proc == null() {dummy_pfnglvertexattrib4svproc} else {unsafe{transmute(proc)}}},
			vertexattrib4ubv: {let proc = get_proc_address("glVertexAttrib4ubv"); if proc == null() {dummy_pfnglvertexattrib4ubvproc} else {unsafe{transmute(proc)}}},
			vertexattrib4uiv: {let proc = get_proc_address("glVertexAttrib4uiv"); if proc == null() {dummy_pfnglvertexattrib4uivproc} else {unsafe{transmute(proc)}}},
			vertexattrib4usv: {let proc = get_proc_address("glVertexAttrib4usv"); if proc == null() {dummy_pfnglvertexattrib4usvproc} else {unsafe{transmute(proc)}}},
			vertexattribpointer: {let proc = get_proc_address("glVertexAttribPointer"); if proc == null() {dummy_pfnglvertexattribpointerproc} else {unsafe{transmute(proc)}}},
			shading_language_version: base.glGetString(GL_SHADING_LANGUAGE_VERSION).unwrap(),
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version20 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			blendequationseparate: dummy_pfnglblendequationseparateproc,
			drawbuffers: dummy_pfngldrawbuffersproc,
			stencilopseparate: dummy_pfnglstencilopseparateproc,
			stencilfuncseparate: dummy_pfnglstencilfuncseparateproc,
			stencilmaskseparate: dummy_pfnglstencilmaskseparateproc,
			attachshader: dummy_pfnglattachshaderproc,
			bindattriblocation: dummy_pfnglbindattriblocationproc,
			compileshader: dummy_pfnglcompileshaderproc,
			createprogram: dummy_pfnglcreateprogramproc,
			createshader: dummy_pfnglcreateshaderproc,
			deleteprogram: dummy_pfngldeleteprogramproc,
			deleteshader: dummy_pfngldeleteshaderproc,
			detachshader: dummy_pfngldetachshaderproc,
			disablevertexattribarray: dummy_pfngldisablevertexattribarrayproc,
			enablevertexattribarray: dummy_pfnglenablevertexattribarrayproc,
			getactiveattrib: dummy_pfnglgetactiveattribproc,
			getactiveuniform: dummy_pfnglgetactiveuniformproc,
			getattachedshaders: dummy_pfnglgetattachedshadersproc,
			getattriblocation: dummy_pfnglgetattriblocationproc,
			getprogramiv: dummy_pfnglgetprogramivproc,
			getprograminfolog: dummy_pfnglgetprograminfologproc,
			getshaderiv: dummy_pfnglgetshaderivproc,
			getshaderinfolog: dummy_pfnglgetshaderinfologproc,
			getshadersource: dummy_pfnglgetshadersourceproc,
			getuniformlocation: dummy_pfnglgetuniformlocationproc,
			getuniformfv: dummy_pfnglgetuniformfvproc,
			getuniformiv: dummy_pfnglgetuniformivproc,
			getvertexattribdv: dummy_pfnglgetvertexattribdvproc,
			getvertexattribfv: dummy_pfnglgetvertexattribfvproc,
			getvertexattribiv: dummy_pfnglgetvertexattribivproc,
			getvertexattribpointerv: dummy_pfnglgetvertexattribpointervproc,
			isprogram: dummy_pfnglisprogramproc,
			isshader: dummy_pfnglisshaderproc,
			linkprogram: dummy_pfngllinkprogramproc,
			shadersource: dummy_pfnglshadersourceproc,
			useprogram: dummy_pfngluseprogramproc,
			uniform1f: dummy_pfngluniform1fproc,
			uniform2f: dummy_pfngluniform2fproc,
			uniform3f: dummy_pfngluniform3fproc,
			uniform4f: dummy_pfngluniform4fproc,
			uniform1i: dummy_pfngluniform1iproc,
			uniform2i: dummy_pfngluniform2iproc,
			uniform3i: dummy_pfngluniform3iproc,
			uniform4i: dummy_pfngluniform4iproc,
			uniform1fv: dummy_pfngluniform1fvproc,
			uniform2fv: dummy_pfngluniform2fvproc,
			uniform3fv: dummy_pfngluniform3fvproc,
			uniform4fv: dummy_pfngluniform4fvproc,
			uniform1iv: dummy_pfngluniform1ivproc,
			uniform2iv: dummy_pfngluniform2ivproc,
			uniform3iv: dummy_pfngluniform3ivproc,
			uniform4iv: dummy_pfngluniform4ivproc,
			uniformmatrix2fv: dummy_pfngluniformmatrix2fvproc,
			uniformmatrix3fv: dummy_pfngluniformmatrix3fvproc,
			uniformmatrix4fv: dummy_pfngluniformmatrix4fvproc,
			validateprogram: dummy_pfnglvalidateprogramproc,
			vertexattrib1d: dummy_pfnglvertexattrib1dproc,
			vertexattrib1dv: dummy_pfnglvertexattrib1dvproc,
			vertexattrib1f: dummy_pfnglvertexattrib1fproc,
			vertexattrib1fv: dummy_pfnglvertexattrib1fvproc,
			vertexattrib1s: dummy_pfnglvertexattrib1sproc,
			vertexattrib1sv: dummy_pfnglvertexattrib1svproc,
			vertexattrib2d: dummy_pfnglvertexattrib2dproc,
			vertexattrib2dv: dummy_pfnglvertexattrib2dvproc,
			vertexattrib2f: dummy_pfnglvertexattrib2fproc,
			vertexattrib2fv: dummy_pfnglvertexattrib2fvproc,
			vertexattrib2s: dummy_pfnglvertexattrib2sproc,
			vertexattrib2sv: dummy_pfnglvertexattrib2svproc,
			vertexattrib3d: dummy_pfnglvertexattrib3dproc,
			vertexattrib3dv: dummy_pfnglvertexattrib3dvproc,
			vertexattrib3f: dummy_pfnglvertexattrib3fproc,
			vertexattrib3fv: dummy_pfnglvertexattrib3fvproc,
			vertexattrib3s: dummy_pfnglvertexattrib3sproc,
			vertexattrib3sv: dummy_pfnglvertexattrib3svproc,
			vertexattrib4nbv: dummy_pfnglvertexattrib4nbvproc,
			vertexattrib4niv: dummy_pfnglvertexattrib4nivproc,
			vertexattrib4nsv: dummy_pfnglvertexattrib4nsvproc,
			vertexattrib4nub: dummy_pfnglvertexattrib4nubproc,
			vertexattrib4nubv: dummy_pfnglvertexattrib4nubvproc,
			vertexattrib4nuiv: dummy_pfnglvertexattrib4nuivproc,
			vertexattrib4nusv: dummy_pfnglvertexattrib4nusvproc,
			vertexattrib4bv: dummy_pfnglvertexattrib4bvproc,
			vertexattrib4d: dummy_pfnglvertexattrib4dproc,
			vertexattrib4dv: dummy_pfnglvertexattrib4dvproc,
			vertexattrib4f: dummy_pfnglvertexattrib4fproc,
			vertexattrib4fv: dummy_pfnglvertexattrib4fvproc,
			vertexattrib4iv: dummy_pfnglvertexattrib4ivproc,
			vertexattrib4s: dummy_pfnglvertexattrib4sproc,
			vertexattrib4sv: dummy_pfnglvertexattrib4svproc,
			vertexattrib4ubv: dummy_pfnglvertexattrib4ubvproc,
			vertexattrib4uiv: dummy_pfnglvertexattrib4uivproc,
			vertexattrib4usv: dummy_pfnglvertexattrib4usvproc,
			vertexattribpointer: dummy_pfnglvertexattribpointerproc,
			shading_language_version: "unknown",
		}
	}
}
impl Debug for Version20 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version20")
			.field("available", &self.available)
			.field("shading_language_version", &self.shading_language_version)
			.field("blendequationseparate", unsafe{if transmute::<_, *const c_void>(self.blendequationseparate) == (dummy_pfnglblendequationseparateproc as *const c_void) {&null::<PFNGLBLENDEQUATIONSEPARATEPROC>()} else {&self.blendequationseparate}})
			.field("drawbuffers", unsafe{if transmute::<_, *const c_void>(self.drawbuffers) == (dummy_pfngldrawbuffersproc as *const c_void) {&null::<PFNGLDRAWBUFFERSPROC>()} else {&self.drawbuffers}})
			.field("stencilopseparate", unsafe{if transmute::<_, *const c_void>(self.stencilopseparate) == (dummy_pfnglstencilopseparateproc as *const c_void) {&null::<PFNGLSTENCILOPSEPARATEPROC>()} else {&self.stencilopseparate}})
			.field("stencilfuncseparate", unsafe{if transmute::<_, *const c_void>(self.stencilfuncseparate) == (dummy_pfnglstencilfuncseparateproc as *const c_void) {&null::<PFNGLSTENCILFUNCSEPARATEPROC>()} else {&self.stencilfuncseparate}})
			.field("stencilmaskseparate", unsafe{if transmute::<_, *const c_void>(self.stencilmaskseparate) == (dummy_pfnglstencilmaskseparateproc as *const c_void) {&null::<PFNGLSTENCILMASKSEPARATEPROC>()} else {&self.stencilmaskseparate}})
			.field("attachshader", unsafe{if transmute::<_, *const c_void>(self.attachshader) == (dummy_pfnglattachshaderproc as *const c_void) {&null::<PFNGLATTACHSHADERPROC>()} else {&self.attachshader}})
			.field("bindattriblocation", unsafe{if transmute::<_, *const c_void>(self.bindattriblocation) == (dummy_pfnglbindattriblocationproc as *const c_void) {&null::<PFNGLBINDATTRIBLOCATIONPROC>()} else {&self.bindattriblocation}})
			.field("compileshader", unsafe{if transmute::<_, *const c_void>(self.compileshader) == (dummy_pfnglcompileshaderproc as *const c_void) {&null::<PFNGLCOMPILESHADERPROC>()} else {&self.compileshader}})
			.field("createprogram", unsafe{if transmute::<_, *const c_void>(self.createprogram) == (dummy_pfnglcreateprogramproc as *const c_void) {&null::<PFNGLCREATEPROGRAMPROC>()} else {&self.createprogram}})
			.field("createshader", unsafe{if transmute::<_, *const c_void>(self.createshader) == (dummy_pfnglcreateshaderproc as *const c_void) {&null::<PFNGLCREATESHADERPROC>()} else {&self.createshader}})
			.field("deleteprogram", unsafe{if transmute::<_, *const c_void>(self.deleteprogram) == (dummy_pfngldeleteprogramproc as *const c_void) {&null::<PFNGLDELETEPROGRAMPROC>()} else {&self.deleteprogram}})
			.field("deleteshader", unsafe{if transmute::<_, *const c_void>(self.deleteshader) == (dummy_pfngldeleteshaderproc as *const c_void) {&null::<PFNGLDELETESHADERPROC>()} else {&self.deleteshader}})
			.field("detachshader", unsafe{if transmute::<_, *const c_void>(self.detachshader) == (dummy_pfngldetachshaderproc as *const c_void) {&null::<PFNGLDETACHSHADERPROC>()} else {&self.detachshader}})
			.field("disablevertexattribarray", unsafe{if transmute::<_, *const c_void>(self.disablevertexattribarray) == (dummy_pfngldisablevertexattribarrayproc as *const c_void) {&null::<PFNGLDISABLEVERTEXATTRIBARRAYPROC>()} else {&self.disablevertexattribarray}})
			.field("enablevertexattribarray", unsafe{if transmute::<_, *const c_void>(self.enablevertexattribarray) == (dummy_pfnglenablevertexattribarrayproc as *const c_void) {&null::<PFNGLENABLEVERTEXATTRIBARRAYPROC>()} else {&self.enablevertexattribarray}})
			.field("getactiveattrib", unsafe{if transmute::<_, *const c_void>(self.getactiveattrib) == (dummy_pfnglgetactiveattribproc as *const c_void) {&null::<PFNGLGETACTIVEATTRIBPROC>()} else {&self.getactiveattrib}})
			.field("getactiveuniform", unsafe{if transmute::<_, *const c_void>(self.getactiveuniform) == (dummy_pfnglgetactiveuniformproc as *const c_void) {&null::<PFNGLGETACTIVEUNIFORMPROC>()} else {&self.getactiveuniform}})
			.field("getattachedshaders", unsafe{if transmute::<_, *const c_void>(self.getattachedshaders) == (dummy_pfnglgetattachedshadersproc as *const c_void) {&null::<PFNGLGETATTACHEDSHADERSPROC>()} else {&self.getattachedshaders}})
			.field("getattriblocation", unsafe{if transmute::<_, *const c_void>(self.getattriblocation) == (dummy_pfnglgetattriblocationproc as *const c_void) {&null::<PFNGLGETATTRIBLOCATIONPROC>()} else {&self.getattriblocation}})
			.field("getprogramiv", unsafe{if transmute::<_, *const c_void>(self.getprogramiv) == (dummy_pfnglgetprogramivproc as *const c_void) {&null::<PFNGLGETPROGRAMIVPROC>()} else {&self.getprogramiv}})
			.field("getprograminfolog", unsafe{if transmute::<_, *const c_void>(self.getprograminfolog) == (dummy_pfnglgetprograminfologproc as *const c_void) {&null::<PFNGLGETPROGRAMINFOLOGPROC>()} else {&self.getprograminfolog}})
			.field("getshaderiv", unsafe{if transmute::<_, *const c_void>(self.getshaderiv) == (dummy_pfnglgetshaderivproc as *const c_void) {&null::<PFNGLGETSHADERIVPROC>()} else {&self.getshaderiv}})
			.field("getshaderinfolog", unsafe{if transmute::<_, *const c_void>(self.getshaderinfolog) == (dummy_pfnglgetshaderinfologproc as *const c_void) {&null::<PFNGLGETSHADERINFOLOGPROC>()} else {&self.getshaderinfolog}})
			.field("getshadersource", unsafe{if transmute::<_, *const c_void>(self.getshadersource) == (dummy_pfnglgetshadersourceproc as *const c_void) {&null::<PFNGLGETSHADERSOURCEPROC>()} else {&self.getshadersource}})
			.field("getuniformlocation", unsafe{if transmute::<_, *const c_void>(self.getuniformlocation) == (dummy_pfnglgetuniformlocationproc as *const c_void) {&null::<PFNGLGETUNIFORMLOCATIONPROC>()} else {&self.getuniformlocation}})
			.field("getuniformfv", unsafe{if transmute::<_, *const c_void>(self.getuniformfv) == (dummy_pfnglgetuniformfvproc as *const c_void) {&null::<PFNGLGETUNIFORMFVPROC>()} else {&self.getuniformfv}})
			.field("getuniformiv", unsafe{if transmute::<_, *const c_void>(self.getuniformiv) == (dummy_pfnglgetuniformivproc as *const c_void) {&null::<PFNGLGETUNIFORMIVPROC>()} else {&self.getuniformiv}})
			.field("getvertexattribdv", unsafe{if transmute::<_, *const c_void>(self.getvertexattribdv) == (dummy_pfnglgetvertexattribdvproc as *const c_void) {&null::<PFNGLGETVERTEXATTRIBDVPROC>()} else {&self.getvertexattribdv}})
			.field("getvertexattribfv", unsafe{if transmute::<_, *const c_void>(self.getvertexattribfv) == (dummy_pfnglgetvertexattribfvproc as *const c_void) {&null::<PFNGLGETVERTEXATTRIBFVPROC>()} else {&self.getvertexattribfv}})
			.field("getvertexattribiv", unsafe{if transmute::<_, *const c_void>(self.getvertexattribiv) == (dummy_pfnglgetvertexattribivproc as *const c_void) {&null::<PFNGLGETVERTEXATTRIBIVPROC>()} else {&self.getvertexattribiv}})
			.field("getvertexattribpointerv", unsafe{if transmute::<_, *const c_void>(self.getvertexattribpointerv) == (dummy_pfnglgetvertexattribpointervproc as *const c_void) {&null::<PFNGLGETVERTEXATTRIBPOINTERVPROC>()} else {&self.getvertexattribpointerv}})
			.field("isprogram", unsafe{if transmute::<_, *const c_void>(self.isprogram) == (dummy_pfnglisprogramproc as *const c_void) {&null::<PFNGLISPROGRAMPROC>()} else {&self.isprogram}})
			.field("isshader", unsafe{if transmute::<_, *const c_void>(self.isshader) == (dummy_pfnglisshaderproc as *const c_void) {&null::<PFNGLISSHADERPROC>()} else {&self.isshader}})
			.field("linkprogram", unsafe{if transmute::<_, *const c_void>(self.linkprogram) == (dummy_pfngllinkprogramproc as *const c_void) {&null::<PFNGLLINKPROGRAMPROC>()} else {&self.linkprogram}})
			.field("shadersource", unsafe{if transmute::<_, *const c_void>(self.shadersource) == (dummy_pfnglshadersourceproc as *const c_void) {&null::<PFNGLSHADERSOURCEPROC>()} else {&self.shadersource}})
			.field("useprogram", unsafe{if transmute::<_, *const c_void>(self.useprogram) == (dummy_pfngluseprogramproc as *const c_void) {&null::<PFNGLUSEPROGRAMPROC>()} else {&self.useprogram}})
			.field("uniform1f", unsafe{if transmute::<_, *const c_void>(self.uniform1f) == (dummy_pfngluniform1fproc as *const c_void) {&null::<PFNGLUNIFORM1FPROC>()} else {&self.uniform1f}})
			.field("uniform2f", unsafe{if transmute::<_, *const c_void>(self.uniform2f) == (dummy_pfngluniform2fproc as *const c_void) {&null::<PFNGLUNIFORM2FPROC>()} else {&self.uniform2f}})
			.field("uniform3f", unsafe{if transmute::<_, *const c_void>(self.uniform3f) == (dummy_pfngluniform3fproc as *const c_void) {&null::<PFNGLUNIFORM3FPROC>()} else {&self.uniform3f}})
			.field("uniform4f", unsafe{if transmute::<_, *const c_void>(self.uniform4f) == (dummy_pfngluniform4fproc as *const c_void) {&null::<PFNGLUNIFORM4FPROC>()} else {&self.uniform4f}})
			.field("uniform1i", unsafe{if transmute::<_, *const c_void>(self.uniform1i) == (dummy_pfngluniform1iproc as *const c_void) {&null::<PFNGLUNIFORM1IPROC>()} else {&self.uniform1i}})
			.field("uniform2i", unsafe{if transmute::<_, *const c_void>(self.uniform2i) == (dummy_pfngluniform2iproc as *const c_void) {&null::<PFNGLUNIFORM2IPROC>()} else {&self.uniform2i}})
			.field("uniform3i", unsafe{if transmute::<_, *const c_void>(self.uniform3i) == (dummy_pfngluniform3iproc as *const c_void) {&null::<PFNGLUNIFORM3IPROC>()} else {&self.uniform3i}})
			.field("uniform4i", unsafe{if transmute::<_, *const c_void>(self.uniform4i) == (dummy_pfngluniform4iproc as *const c_void) {&null::<PFNGLUNIFORM4IPROC>()} else {&self.uniform4i}})
			.field("uniform1fv", unsafe{if transmute::<_, *const c_void>(self.uniform1fv) == (dummy_pfngluniform1fvproc as *const c_void) {&null::<PFNGLUNIFORM1FVPROC>()} else {&self.uniform1fv}})
			.field("uniform2fv", unsafe{if transmute::<_, *const c_void>(self.uniform2fv) == (dummy_pfngluniform2fvproc as *const c_void) {&null::<PFNGLUNIFORM2FVPROC>()} else {&self.uniform2fv}})
			.field("uniform3fv", unsafe{if transmute::<_, *const c_void>(self.uniform3fv) == (dummy_pfngluniform3fvproc as *const c_void) {&null::<PFNGLUNIFORM3FVPROC>()} else {&self.uniform3fv}})
			.field("uniform4fv", unsafe{if transmute::<_, *const c_void>(self.uniform4fv) == (dummy_pfngluniform4fvproc as *const c_void) {&null::<PFNGLUNIFORM4FVPROC>()} else {&self.uniform4fv}})
			.field("uniform1iv", unsafe{if transmute::<_, *const c_void>(self.uniform1iv) == (dummy_pfngluniform1ivproc as *const c_void) {&null::<PFNGLUNIFORM1IVPROC>()} else {&self.uniform1iv}})
			.field("uniform2iv", unsafe{if transmute::<_, *const c_void>(self.uniform2iv) == (dummy_pfngluniform2ivproc as *const c_void) {&null::<PFNGLUNIFORM2IVPROC>()} else {&self.uniform2iv}})
			.field("uniform3iv", unsafe{if transmute::<_, *const c_void>(self.uniform3iv) == (dummy_pfngluniform3ivproc as *const c_void) {&null::<PFNGLUNIFORM3IVPROC>()} else {&self.uniform3iv}})
			.field("uniform4iv", unsafe{if transmute::<_, *const c_void>(self.uniform4iv) == (dummy_pfngluniform4ivproc as *const c_void) {&null::<PFNGLUNIFORM4IVPROC>()} else {&self.uniform4iv}})
			.field("uniformmatrix2fv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix2fv) == (dummy_pfngluniformmatrix2fvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX2FVPROC>()} else {&self.uniformmatrix2fv}})
			.field("uniformmatrix3fv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix3fv) == (dummy_pfngluniformmatrix3fvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX3FVPROC>()} else {&self.uniformmatrix3fv}})
			.field("uniformmatrix4fv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix4fv) == (dummy_pfngluniformmatrix4fvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX4FVPROC>()} else {&self.uniformmatrix4fv}})
			.field("validateprogram", unsafe{if transmute::<_, *const c_void>(self.validateprogram) == (dummy_pfnglvalidateprogramproc as *const c_void) {&null::<PFNGLVALIDATEPROGRAMPROC>()} else {&self.validateprogram}})
			.field("vertexattrib1d", unsafe{if transmute::<_, *const c_void>(self.vertexattrib1d) == (dummy_pfnglvertexattrib1dproc as *const c_void) {&null::<PFNGLVERTEXATTRIB1DPROC>()} else {&self.vertexattrib1d}})
			.field("vertexattrib1dv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib1dv) == (dummy_pfnglvertexattrib1dvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB1DVPROC>()} else {&self.vertexattrib1dv}})
			.field("vertexattrib1f", unsafe{if transmute::<_, *const c_void>(self.vertexattrib1f) == (dummy_pfnglvertexattrib1fproc as *const c_void) {&null::<PFNGLVERTEXATTRIB1FPROC>()} else {&self.vertexattrib1f}})
			.field("vertexattrib1fv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib1fv) == (dummy_pfnglvertexattrib1fvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB1FVPROC>()} else {&self.vertexattrib1fv}})
			.field("vertexattrib1s", unsafe{if transmute::<_, *const c_void>(self.vertexattrib1s) == (dummy_pfnglvertexattrib1sproc as *const c_void) {&null::<PFNGLVERTEXATTRIB1SPROC>()} else {&self.vertexattrib1s}})
			.field("vertexattrib1sv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib1sv) == (dummy_pfnglvertexattrib1svproc as *const c_void) {&null::<PFNGLVERTEXATTRIB1SVPROC>()} else {&self.vertexattrib1sv}})
			.field("vertexattrib2d", unsafe{if transmute::<_, *const c_void>(self.vertexattrib2d) == (dummy_pfnglvertexattrib2dproc as *const c_void) {&null::<PFNGLVERTEXATTRIB2DPROC>()} else {&self.vertexattrib2d}})
			.field("vertexattrib2dv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib2dv) == (dummy_pfnglvertexattrib2dvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB2DVPROC>()} else {&self.vertexattrib2dv}})
			.field("vertexattrib2f", unsafe{if transmute::<_, *const c_void>(self.vertexattrib2f) == (dummy_pfnglvertexattrib2fproc as *const c_void) {&null::<PFNGLVERTEXATTRIB2FPROC>()} else {&self.vertexattrib2f}})
			.field("vertexattrib2fv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib2fv) == (dummy_pfnglvertexattrib2fvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB2FVPROC>()} else {&self.vertexattrib2fv}})
			.field("vertexattrib2s", unsafe{if transmute::<_, *const c_void>(self.vertexattrib2s) == (dummy_pfnglvertexattrib2sproc as *const c_void) {&null::<PFNGLVERTEXATTRIB2SPROC>()} else {&self.vertexattrib2s}})
			.field("vertexattrib2sv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib2sv) == (dummy_pfnglvertexattrib2svproc as *const c_void) {&null::<PFNGLVERTEXATTRIB2SVPROC>()} else {&self.vertexattrib2sv}})
			.field("vertexattrib3d", unsafe{if transmute::<_, *const c_void>(self.vertexattrib3d) == (dummy_pfnglvertexattrib3dproc as *const c_void) {&null::<PFNGLVERTEXATTRIB3DPROC>()} else {&self.vertexattrib3d}})
			.field("vertexattrib3dv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib3dv) == (dummy_pfnglvertexattrib3dvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB3DVPROC>()} else {&self.vertexattrib3dv}})
			.field("vertexattrib3f", unsafe{if transmute::<_, *const c_void>(self.vertexattrib3f) == (dummy_pfnglvertexattrib3fproc as *const c_void) {&null::<PFNGLVERTEXATTRIB3FPROC>()} else {&self.vertexattrib3f}})
			.field("vertexattrib3fv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib3fv) == (dummy_pfnglvertexattrib3fvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB3FVPROC>()} else {&self.vertexattrib3fv}})
			.field("vertexattrib3s", unsafe{if transmute::<_, *const c_void>(self.vertexattrib3s) == (dummy_pfnglvertexattrib3sproc as *const c_void) {&null::<PFNGLVERTEXATTRIB3SPROC>()} else {&self.vertexattrib3s}})
			.field("vertexattrib3sv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib3sv) == (dummy_pfnglvertexattrib3svproc as *const c_void) {&null::<PFNGLVERTEXATTRIB3SVPROC>()} else {&self.vertexattrib3sv}})
			.field("vertexattrib4nbv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4nbv) == (dummy_pfnglvertexattrib4nbvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4NBVPROC>()} else {&self.vertexattrib4nbv}})
			.field("vertexattrib4niv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4niv) == (dummy_pfnglvertexattrib4nivproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4NIVPROC>()} else {&self.vertexattrib4niv}})
			.field("vertexattrib4nsv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4nsv) == (dummy_pfnglvertexattrib4nsvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4NSVPROC>()} else {&self.vertexattrib4nsv}})
			.field("vertexattrib4nub", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4nub) == (dummy_pfnglvertexattrib4nubproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4NUBPROC>()} else {&self.vertexattrib4nub}})
			.field("vertexattrib4nubv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4nubv) == (dummy_pfnglvertexattrib4nubvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4NUBVPROC>()} else {&self.vertexattrib4nubv}})
			.field("vertexattrib4nuiv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4nuiv) == (dummy_pfnglvertexattrib4nuivproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4NUIVPROC>()} else {&self.vertexattrib4nuiv}})
			.field("vertexattrib4nusv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4nusv) == (dummy_pfnglvertexattrib4nusvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4NUSVPROC>()} else {&self.vertexattrib4nusv}})
			.field("vertexattrib4bv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4bv) == (dummy_pfnglvertexattrib4bvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4BVPROC>()} else {&self.vertexattrib4bv}})
			.field("vertexattrib4d", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4d) == (dummy_pfnglvertexattrib4dproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4DPROC>()} else {&self.vertexattrib4d}})
			.field("vertexattrib4dv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4dv) == (dummy_pfnglvertexattrib4dvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4DVPROC>()} else {&self.vertexattrib4dv}})
			.field("vertexattrib4f", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4f) == (dummy_pfnglvertexattrib4fproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4FPROC>()} else {&self.vertexattrib4f}})
			.field("vertexattrib4fv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4fv) == (dummy_pfnglvertexattrib4fvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4FVPROC>()} else {&self.vertexattrib4fv}})
			.field("vertexattrib4iv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4iv) == (dummy_pfnglvertexattrib4ivproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4IVPROC>()} else {&self.vertexattrib4iv}})
			.field("vertexattrib4s", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4s) == (dummy_pfnglvertexattrib4sproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4SPROC>()} else {&self.vertexattrib4s}})
			.field("vertexattrib4sv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4sv) == (dummy_pfnglvertexattrib4svproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4SVPROC>()} else {&self.vertexattrib4sv}})
			.field("vertexattrib4ubv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4ubv) == (dummy_pfnglvertexattrib4ubvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4UBVPROC>()} else {&self.vertexattrib4ubv}})
			.field("vertexattrib4uiv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4uiv) == (dummy_pfnglvertexattrib4uivproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4UIVPROC>()} else {&self.vertexattrib4uiv}})
			.field("vertexattrib4usv", unsafe{if transmute::<_, *const c_void>(self.vertexattrib4usv) == (dummy_pfnglvertexattrib4usvproc as *const c_void) {&null::<PFNGLVERTEXATTRIB4USVPROC>()} else {&self.vertexattrib4usv}})
			.field("vertexattribpointer", unsafe{if transmute::<_, *const c_void>(self.vertexattribpointer) == (dummy_pfnglvertexattribpointerproc as *const c_void) {&null::<PFNGLVERTEXATTRIBPOINTERPROC>()} else {&self.vertexattribpointer}})
			.finish()
		} else {
			f.debug_struct("Version20")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}
type PFNGLUNIFORMMATRIX2X3FVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat);
type PFNGLUNIFORMMATRIX3X2FVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat);
type PFNGLUNIFORMMATRIX2X4FVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat);
type PFNGLUNIFORMMATRIX4X2FVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat);
type PFNGLUNIFORMMATRIX3X4FVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat);
type PFNGLUNIFORMMATRIX4X3FVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLfloat);
extern "system" fn dummy_pfngluniformmatrix2x3fvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniformMatrix2x3fv()` is null.")
}
extern "system" fn dummy_pfngluniformmatrix3x2fvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniformMatrix3x2fv()` is null.")
}
extern "system" fn dummy_pfngluniformmatrix2x4fvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniformMatrix2x4fv()` is null.")
}
extern "system" fn dummy_pfngluniformmatrix4x2fvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniformMatrix4x2fv()` is null.")
}
extern "system" fn dummy_pfngluniformmatrix3x4fvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniformMatrix3x4fv()` is null.")
}
extern "system" fn dummy_pfngluniformmatrix4x3fvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glUniformMatrix4x3fv()` is null.")
}
pub const GL_PIXEL_PACK_BUFFER: GLenum = 0x88EB;
pub const GL_PIXEL_UNPACK_BUFFER: GLenum = 0x88EC;
pub const GL_PIXEL_PACK_BUFFER_BINDING: GLenum = 0x88ED;
pub const GL_PIXEL_UNPACK_BUFFER_BINDING: GLenum = 0x88EF;
pub const GL_FLOAT_MAT2x3: GLenum = 0x8B65;
pub const GL_FLOAT_MAT2x4: GLenum = 0x8B66;
pub const GL_FLOAT_MAT3x2: GLenum = 0x8B67;
pub const GL_FLOAT_MAT3x4: GLenum = 0x8B68;
pub const GL_FLOAT_MAT4x2: GLenum = 0x8B69;
pub const GL_FLOAT_MAT4x3: GLenum = 0x8B6A;
pub const GL_SRGB: GLenum = 0x8C40;
pub const GL_SRGB8: GLenum = 0x8C41;
pub const GL_SRGB_ALPHA: GLenum = 0x8C42;
pub const GL_SRGB8_ALPHA8: GLenum = 0x8C43;
pub const GL_COMPRESSED_SRGB: GLenum = 0x8C48;
pub const GL_COMPRESSED_SRGB_ALPHA: GLenum = 0x8C49;
pub const GL_CURRENT_RASTER_SECONDARY_COLOR: GLenum = 0x845F;
pub const GL_SLUMINANCE_ALPHA: GLenum = 0x8C44;
pub const GL_SLUMINANCE8_ALPHA8: GLenum = 0x8C45;
pub const GL_SLUMINANCE: GLenum = 0x8C46;
pub const GL_SLUMINANCE8: GLenum = 0x8C47;
pub const GL_COMPRESSED_SLUMINANCE: GLenum = 0x8C4A;
pub const GL_COMPRESSED_SLUMINANCE_ALPHA: GLenum = 0x8C4B;

pub trait GL_2_1 {
	fn glGetError(&self) -> GLenum;
	fn glUniformMatrix2x3fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;
	fn glUniformMatrix3x2fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;
	fn glUniformMatrix2x4fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;
	fn glUniformMatrix4x2fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;
	fn glUniformMatrix3x4fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;
	fn glUniformMatrix4x3fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;
}

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version21 {
	available: bool,
	geterror: PFNGLGETERRORPROC,
	uniformmatrix2x3fv: PFNGLUNIFORMMATRIX2X3FVPROC,
	uniformmatrix3x2fv: PFNGLUNIFORMMATRIX3X2FVPROC,
	uniformmatrix2x4fv: PFNGLUNIFORMMATRIX2X4FVPROC,
	uniformmatrix4x2fv: PFNGLUNIFORMMATRIX4X2FVPROC,
	uniformmatrix3x4fv: PFNGLUNIFORMMATRIX3X4FVPROC,
	uniformmatrix4x3fv: PFNGLUNIFORMMATRIX4X3FVPROC,
}

impl GL_2_1 for Version21 {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	#[inline(always)]
	fn glUniformMatrix2x3fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix2x3fv", catch_unwind(||(self.uniformmatrix2x3fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2x3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix3x2fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix3x2fv", catch_unwind(||(self.uniformmatrix3x2fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3x2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix2x4fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix2x4fv", catch_unwind(||(self.uniformmatrix2x4fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2x4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix4x2fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix4x2fv", catch_unwind(||(self.uniformmatrix4x2fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4x2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix3x4fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix3x4fv", catch_unwind(||(self.uniformmatrix3x4fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3x4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix4x3fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix4x3fv", catch_unwind(||(self.uniformmatrix4x3fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4x3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version21 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (2, 1, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			uniformmatrix2x3fv: {let proc = get_proc_address("glUniformMatrix2x3fv"); if proc == null() {dummy_pfngluniformmatrix2x3fvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix3x2fv: {let proc = get_proc_address("glUniformMatrix3x2fv"); if proc == null() {dummy_pfngluniformmatrix3x2fvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix2x4fv: {let proc = get_proc_address("glUniformMatrix2x4fv"); if proc == null() {dummy_pfngluniformmatrix2x4fvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix4x2fv: {let proc = get_proc_address("glUniformMatrix4x2fv"); if proc == null() {dummy_pfngluniformmatrix4x2fvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix3x4fv: {let proc = get_proc_address("glUniformMatrix3x4fv"); if proc == null() {dummy_pfngluniformmatrix3x4fvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix4x3fv: {let proc = get_proc_address("glUniformMatrix4x3fv"); if proc == null() {dummy_pfngluniformmatrix4x3fvproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version21 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			uniformmatrix2x3fv: dummy_pfngluniformmatrix2x3fvproc,
			uniformmatrix3x2fv: dummy_pfngluniformmatrix3x2fvproc,
			uniformmatrix2x4fv: dummy_pfngluniformmatrix2x4fvproc,
			uniformmatrix4x2fv: dummy_pfngluniformmatrix4x2fvproc,
			uniformmatrix3x4fv: dummy_pfngluniformmatrix3x4fvproc,
			uniformmatrix4x3fv: dummy_pfngluniformmatrix4x3fvproc,
		}
	}
}
impl Debug for Version21 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version21")
			.field("available", &self.available)
			.field("uniformmatrix2x3fv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix2x3fv) == (dummy_pfngluniformmatrix2x3fvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX2X3FVPROC>()} else {&self.uniformmatrix2x3fv}})
			.field("uniformmatrix3x2fv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix3x2fv) == (dummy_pfngluniformmatrix3x2fvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX3X2FVPROC>()} else {&self.uniformmatrix3x2fv}})
			.field("uniformmatrix2x4fv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix2x4fv) == (dummy_pfngluniformmatrix2x4fvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX2X4FVPROC>()} else {&self.uniformmatrix2x4fv}})
			.field("uniformmatrix4x2fv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix4x2fv) == (dummy_pfngluniformmatrix4x2fvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX4X2FVPROC>()} else {&self.uniformmatrix4x2fv}})
			.field("uniformmatrix3x4fv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix3x4fv) == (dummy_pfngluniformmatrix3x4fvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX3X4FVPROC>()} else {&self.uniformmatrix3x4fv}})
			.field("uniformmatrix4x3fv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix4x3fv) == (dummy_pfngluniformmatrix4x3fvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX4X3FVPROC>()} else {&self.uniformmatrix4x3fv}})
			.finish()
		} else {
			f.debug_struct("Version21")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}
pub type GLhalf = khronos_uint16_t;
type PFNGLCOLORMASKIPROC = extern "system" fn(GLuint, GLboolean, GLboolean, GLboolean, GLboolean);
type PFNGLGETBOOLEANI_VPROC = extern "system" fn(GLenum, GLuint, *mut GLboolean);
type PFNGLGETINTEGERI_VPROC = extern "system" fn(GLenum, GLuint, *mut GLint);
type PFNGLENABLEIPROC = extern "system" fn(GLenum, GLuint);
type PFNGLDISABLEIPROC = extern "system" fn(GLenum, GLuint);
type PFNGLISENABLEDIPROC = extern "system" fn(GLenum, GLuint) -> GLboolean;
type PFNGLBEGINTRANSFORMFEEDBACKPROC = extern "system" fn(GLenum);
type PFNGLENDTRANSFORMFEEDBACKPROC = extern "system" fn();
type PFNGLBINDBUFFERRANGEPROC = extern "system" fn(GLenum, GLuint, GLuint, GLintptr, GLsizeiptr);
type PFNGLBINDBUFFERBASEPROC = extern "system" fn(GLenum, GLuint, GLuint);
type PFNGLTRANSFORMFEEDBACKVARYINGSPROC = extern "system" fn(GLuint, GLsizei, *const *const GLchar, GLenum);
type PFNGLGETTRANSFORMFEEDBACKVARYINGPROC = extern "system" fn(GLuint, GLuint, GLsizei, *mut GLsizei, *mut GLsizei, *mut GLenum, *mut GLchar);
type PFNGLCLAMPCOLORPROC = extern "system" fn(GLenum, GLenum);
type PFNGLBEGINCONDITIONALRENDERPROC = extern "system" fn(GLuint, GLenum);
type PFNGLENDCONDITIONALRENDERPROC = extern "system" fn();
type PFNGLVERTEXATTRIBIPOINTERPROC = extern "system" fn(GLuint, GLint, GLenum, GLsizei, *const c_void);
type PFNGLGETVERTEXATTRIBIIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);
type PFNGLGETVERTEXATTRIBIUIVPROC = extern "system" fn(GLuint, GLenum, *mut GLuint);
type PFNGLVERTEXATTRIBI1IPROC = extern "system" fn(GLuint, GLint);
type PFNGLVERTEXATTRIBI2IPROC = extern "system" fn(GLuint, GLint, GLint);
type PFNGLVERTEXATTRIBI3IPROC = extern "system" fn(GLuint, GLint, GLint, GLint);
type PFNGLVERTEXATTRIBI4IPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint);
type PFNGLVERTEXATTRIBI1UIPROC = extern "system" fn(GLuint, GLuint);
type PFNGLVERTEXATTRIBI2UIPROC = extern "system" fn(GLuint, GLuint, GLuint);
type PFNGLVERTEXATTRIBI3UIPROC = extern "system" fn(GLuint, GLuint, GLuint, GLuint);
type PFNGLVERTEXATTRIBI4UIPROC = extern "system" fn(GLuint, GLuint, GLuint, GLuint, GLuint);
type PFNGLVERTEXATTRIBI1IVPROC = extern "system" fn(GLuint, *const GLint);
type PFNGLVERTEXATTRIBI2IVPROC = extern "system" fn(GLuint, *const GLint);
type PFNGLVERTEXATTRIBI3IVPROC = extern "system" fn(GLuint, *const GLint);
type PFNGLVERTEXATTRIBI4IVPROC = extern "system" fn(GLuint, *const GLint);
type PFNGLVERTEXATTRIBI1UIVPROC = extern "system" fn(GLuint, *const GLuint);
type PFNGLVERTEXATTRIBI2UIVPROC = extern "system" fn(GLuint, *const GLuint);
type PFNGLVERTEXATTRIBI3UIVPROC = extern "system" fn(GLuint, *const GLuint);
type PFNGLVERTEXATTRIBI4UIVPROC = extern "system" fn(GLuint, *const GLuint);
type PFNGLVERTEXATTRIBI4BVPROC = extern "system" fn(GLuint, *const GLbyte);
type PFNGLVERTEXATTRIBI4SVPROC = extern "system" fn(GLuint, *const GLshort);
type PFNGLVERTEXATTRIBI4UBVPROC = extern "system" fn(GLuint, *const GLubyte);
type PFNGLVERTEXATTRIBI4USVPROC = extern "system" fn(GLuint, *const GLushort);
type PFNGLGETUNIFORMUIVPROC = extern "system" fn(GLuint, GLint, *mut GLuint);
type PFNGLBINDFRAGDATALOCATIONPROC = extern "system" fn(GLuint, GLuint, *const GLchar);
type PFNGLGETFRAGDATALOCATIONPROC = extern "system" fn(GLuint, *const GLchar) -> GLint;
type PFNGLUNIFORM1UIPROC = extern "system" fn(GLint, GLuint);
type PFNGLUNIFORM2UIPROC = extern "system" fn(GLint, GLuint, GLuint);
type PFNGLUNIFORM3UIPROC = extern "system" fn(GLint, GLuint, GLuint, GLuint);
type PFNGLUNIFORM4UIPROC = extern "system" fn(GLint, GLuint, GLuint, GLuint, GLuint);
type PFNGLUNIFORM1UIVPROC = extern "system" fn(GLint, GLsizei, *const GLuint);
type PFNGLUNIFORM2UIVPROC = extern "system" fn(GLint, GLsizei, *const GLuint);
type PFNGLUNIFORM3UIVPROC = extern "system" fn(GLint, GLsizei, *const GLuint);
type PFNGLUNIFORM4UIVPROC = extern "system" fn(GLint, GLsizei, *const GLuint);
type PFNGLTEXPARAMETERIIVPROC = extern "system" fn(GLenum, GLenum, *const GLint);
type PFNGLTEXPARAMETERIUIVPROC = extern "system" fn(GLenum, GLenum, *const GLuint);
type PFNGLGETTEXPARAMETERIIVPROC = extern "system" fn(GLenum, GLenum, *mut GLint);
type PFNGLGETTEXPARAMETERIUIVPROC = extern "system" fn(GLenum, GLenum, *mut GLuint);
type PFNGLCLEARBUFFERIVPROC = extern "system" fn(GLenum, GLint, *const GLint);
type PFNGLCLEARBUFFERUIVPROC = extern "system" fn(GLenum, GLint, *const GLuint);
type PFNGLCLEARBUFFERFVPROC = extern "system" fn(GLenum, GLint, *const GLfloat);
type PFNGLCLEARBUFFERFIPROC = extern "system" fn(GLenum, GLint, GLfloat, GLint);
type PFNGLGETSTRINGIPROC = extern "system" fn(GLenum, GLuint) -> *const GLubyte;
type PFNGLISRENDERBUFFERPROC = extern "system" fn(GLuint) -> GLboolean;
type PFNGLBINDRENDERBUFFERPROC = extern "system" fn(GLenum, GLuint);
type PFNGLDELETERENDERBUFFERSPROC = extern "system" fn(GLsizei, *const GLuint);
type PFNGLGENRENDERBUFFERSPROC = extern "system" fn(GLsizei, *mut GLuint);
type PFNGLRENDERBUFFERSTORAGEPROC = extern "system" fn(GLenum, GLenum, GLsizei, GLsizei);
type PFNGLGETRENDERBUFFERPARAMETERIVPROC = extern "system" fn(GLenum, GLenum, *mut GLint);
type PFNGLISFRAMEBUFFERPROC = extern "system" fn(GLuint) -> GLboolean;
type PFNGLBINDFRAMEBUFFERPROC = extern "system" fn(GLenum, GLuint);
type PFNGLDELETEFRAMEBUFFERSPROC = extern "system" fn(GLsizei, *const GLuint);
type PFNGLGENFRAMEBUFFERSPROC = extern "system" fn(GLsizei, *mut GLuint);
type PFNGLCHECKFRAMEBUFFERSTATUSPROC = extern "system" fn(GLenum) -> GLenum;
type PFNGLFRAMEBUFFERTEXTURE1DPROC = extern "system" fn(GLenum, GLenum, GLenum, GLuint, GLint);
type PFNGLFRAMEBUFFERTEXTURE2DPROC = extern "system" fn(GLenum, GLenum, GLenum, GLuint, GLint);
type PFNGLFRAMEBUFFERTEXTURE3DPROC = extern "system" fn(GLenum, GLenum, GLenum, GLuint, GLint, GLint);
type PFNGLFRAMEBUFFERRENDERBUFFERPROC = extern "system" fn(GLenum, GLenum, GLenum, GLuint);
type PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC = extern "system" fn(GLenum, GLenum, GLenum, *mut GLint);
type PFNGLGENERATEMIPMAPPROC = extern "system" fn(GLenum);
type PFNGLBLITFRAMEBUFFERPROC = extern "system" fn(GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLbitfield, GLenum);
type PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC = extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei);
type PFNGLFRAMEBUFFERTEXTURELAYERPROC = extern "system" fn(GLenum, GLenum, GLuint, GLint, GLint);
type PFNGLMAPBUFFERRANGEPROC = extern "system" fn(GLenum, GLintptr, GLsizeiptr, GLbitfield) -> *mut c_void;
type PFNGLFLUSHMAPPEDBUFFERRANGEPROC = extern "system" fn(GLenum, GLintptr, GLsizeiptr);
type PFNGLBINDVERTEXARRAYPROC = extern "system" fn(GLuint);
type PFNGLDELETEVERTEXARRAYSPROC = extern "system" fn(GLsizei, *const GLuint);
type PFNGLGENVERTEXARRAYSPROC = extern "system" fn(GLsizei, *mut GLuint);
type PFNGLISVERTEXARRAYPROC = extern "system" fn(GLuint) -> GLboolean;
extern "system" fn dummy_pfnglcolormaskiproc (_: GLuint, _: GLboolean, _: GLboolean, _: GLboolean, _: GLboolean) {
	panic!("OpenGL function pointer `glColorMaski()` is null.")
}
extern "system" fn dummy_pfnglgetbooleani_vproc (_: GLenum, _: GLuint, _: *mut GLboolean) {
	panic!("OpenGL function pointer `glGetBooleani_v()` is null.")
}
extern "system" fn dummy_pfnglgetintegeri_vproc (_: GLenum, _: GLuint, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetIntegeri_v()` is null.")
}
extern "system" fn dummy_pfnglenableiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glEnablei()` is null.")
}
extern "system" fn dummy_pfngldisableiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glDisablei()` is null.")
}
extern "system" fn dummy_pfnglisenablediproc (_: GLenum, _: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsEnabledi()` is null.")
}
extern "system" fn dummy_pfnglbegintransformfeedbackproc (_: GLenum) {
	panic!("OpenGL function pointer `glBeginTransformFeedback()` is null.")
}
extern "system" fn dummy_pfnglendtransformfeedbackproc () {
	panic!("OpenGL function pointer `glEndTransformFeedback()` is null.")
}
extern "system" fn dummy_pfnglbindbufferrangeproc (_: GLenum, _: GLuint, _: GLuint, _: GLintptr, _: GLsizeiptr) {
	panic!("OpenGL function pointer `glBindBufferRange()` is null.")
}
extern "system" fn dummy_pfnglbindbufferbaseproc (_: GLenum, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glBindBufferBase()` is null.")
}
extern "system" fn dummy_pfngltransformfeedbackvaryingsproc (_: GLuint, _: GLsizei, _: *const *const GLchar, _: GLenum) {
	panic!("OpenGL function pointer `glTransformFeedbackVaryings()` is null.")
}
extern "system" fn dummy_pfnglgettransformfeedbackvaryingproc (_: GLuint, _: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLsizei, _: *mut GLenum, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetTransformFeedbackVarying()` is null.")
}
extern "system" fn dummy_pfnglclampcolorproc (_: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glClampColor()` is null.")
}
extern "system" fn dummy_pfnglbeginconditionalrenderproc (_: GLuint, _: GLenum) {
	panic!("OpenGL function pointer `glBeginConditionalRender()` is null.")
}
extern "system" fn dummy_pfnglendconditionalrenderproc () {
	panic!("OpenGL function pointer `glEndConditionalRender()` is null.")
}
extern "system" fn dummy_pfnglvertexattribipointerproc (_: GLuint, _: GLint, _: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glVertexAttribIPointer()` is null.")
}
extern "system" fn dummy_pfnglgetvertexattribiivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetVertexAttribIiv()` is null.")
}
extern "system" fn dummy_pfnglgetvertexattribiuivproc (_: GLuint, _: GLenum, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetVertexAttribIuiv()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi1iproc (_: GLuint, _: GLint) {
	panic!("OpenGL function pointer `glVertexAttribI1i()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi2iproc (_: GLuint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glVertexAttribI2i()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi3iproc (_: GLuint, _: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glVertexAttribI3i()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi4iproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glVertexAttribI4i()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi1uiproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribI1ui()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi2uiproc (_: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribI2ui()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi3uiproc (_: GLuint, _: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribI3ui()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi4uiproc (_: GLuint, _: GLuint, _: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribI4ui()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi1ivproc (_: GLuint, _: *const GLint) {
	panic!("OpenGL function pointer `glVertexAttribI1iv()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi2ivproc (_: GLuint, _: *const GLint) {
	panic!("OpenGL function pointer `glVertexAttribI2iv()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi3ivproc (_: GLuint, _: *const GLint) {
	panic!("OpenGL function pointer `glVertexAttribI3iv()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi4ivproc (_: GLuint, _: *const GLint) {
	panic!("OpenGL function pointer `glVertexAttribI4iv()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi1uivproc (_: GLuint, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttribI1uiv()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi2uivproc (_: GLuint, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttribI2uiv()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi3uivproc (_: GLuint, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttribI3uiv()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi4uivproc (_: GLuint, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttribI4uiv()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi4bvproc (_: GLuint, _: *const GLbyte) {
	panic!("OpenGL function pointer `glVertexAttribI4bv()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi4svproc (_: GLuint, _: *const GLshort) {
	panic!("OpenGL function pointer `glVertexAttribI4sv()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi4ubvproc (_: GLuint, _: *const GLubyte) {
	panic!("OpenGL function pointer `glVertexAttribI4ubv()` is null.")
}
extern "system" fn dummy_pfnglvertexattribi4usvproc (_: GLuint, _: *const GLushort) {
	panic!("OpenGL function pointer `glVertexAttribI4usv()` is null.")
}
extern "system" fn dummy_pfnglgetuniformuivproc (_: GLuint, _: GLint, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetUniformuiv()` is null.")
}
extern "system" fn dummy_pfnglbindfragdatalocationproc (_: GLuint, _: GLuint, _: *const GLchar) {
	panic!("OpenGL function pointer `glBindFragDataLocation()` is null.")
}
extern "system" fn dummy_pfnglgetfragdatalocationproc (_: GLuint, _: *const GLchar) -> GLint {
	panic!("OpenGL function pointer `glGetFragDataLocation()` is null.")
}
extern "system" fn dummy_pfngluniform1uiproc (_: GLint, _: GLuint) {
	panic!("OpenGL function pointer `glUniform1ui()` is null.")
}
extern "system" fn dummy_pfngluniform2uiproc (_: GLint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glUniform2ui()` is null.")
}
extern "system" fn dummy_pfngluniform3uiproc (_: GLint, _: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glUniform3ui()` is null.")
}
extern "system" fn dummy_pfngluniform4uiproc (_: GLint, _: GLuint, _: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glUniform4ui()` is null.")
}
extern "system" fn dummy_pfngluniform1uivproc (_: GLint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glUniform1uiv()` is null.")
}
extern "system" fn dummy_pfngluniform2uivproc (_: GLint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glUniform2uiv()` is null.")
}
extern "system" fn dummy_pfngluniform3uivproc (_: GLint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glUniform3uiv()` is null.")
}
extern "system" fn dummy_pfngluniform4uivproc (_: GLint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glUniform4uiv()` is null.")
}
extern "system" fn dummy_pfngltexparameteriivproc (_: GLenum, _: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glTexParameterIiv()` is null.")
}
extern "system" fn dummy_pfngltexparameteriuivproc (_: GLenum, _: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glTexParameterIuiv()` is null.")
}
extern "system" fn dummy_pfnglgettexparameteriivproc (_: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetTexParameterIiv()` is null.")
}
extern "system" fn dummy_pfnglgettexparameteriuivproc (_: GLenum, _: GLenum, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetTexParameterIuiv()` is null.")
}
extern "system" fn dummy_pfnglclearbufferivproc (_: GLenum, _: GLint, _: *const GLint) {
	panic!("OpenGL function pointer `glClearBufferiv()` is null.")
}
extern "system" fn dummy_pfnglclearbufferuivproc (_: GLenum, _: GLint, _: *const GLuint) {
	panic!("OpenGL function pointer `glClearBufferuiv()` is null.")
}
extern "system" fn dummy_pfnglclearbufferfvproc (_: GLenum, _: GLint, _: *const GLfloat) {
	panic!("OpenGL function pointer `glClearBufferfv()` is null.")
}
extern "system" fn dummy_pfnglclearbufferfiproc (_: GLenum, _: GLint, _: GLfloat, _: GLint) {
	panic!("OpenGL function pointer `glClearBufferfi()` is null.")
}
extern "system" fn dummy_pfnglgetstringiproc (_: GLenum, _: GLuint) -> *const GLubyte {
	panic!("OpenGL function pointer `glGetStringi()` is null.")
}
extern "system" fn dummy_pfnglisrenderbufferproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsRenderbuffer()` is null.")
}
extern "system" fn dummy_pfnglbindrenderbufferproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glBindRenderbuffer()` is null.")
}
extern "system" fn dummy_pfngldeleterenderbuffersproc (_: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glDeleteRenderbuffers()` is null.")
}
extern "system" fn dummy_pfnglgenrenderbuffersproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGenRenderbuffers()` is null.")
}
extern "system" fn dummy_pfnglrenderbufferstorageproc (_: GLenum, _: GLenum, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glRenderbufferStorage()` is null.")
}
extern "system" fn dummy_pfnglgetrenderbufferparameterivproc (_: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetRenderbufferParameteriv()` is null.")
}
extern "system" fn dummy_pfnglisframebufferproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsFramebuffer()` is null.")
}
extern "system" fn dummy_pfnglbindframebufferproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glBindFramebuffer()` is null.")
}
extern "system" fn dummy_pfngldeleteframebuffersproc (_: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glDeleteFramebuffers()` is null.")
}
extern "system" fn dummy_pfnglgenframebuffersproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGenFramebuffers()` is null.")
}
extern "system" fn dummy_pfnglcheckframebufferstatusproc (_: GLenum) -> GLenum {
	panic!("OpenGL function pointer `glCheckFramebufferStatus()` is null.")
}
extern "system" fn dummy_pfnglframebuffertexture1dproc (_: GLenum, _: GLenum, _: GLenum, _: GLuint, _: GLint) {
	panic!("OpenGL function pointer `glFramebufferTexture1D()` is null.")
}
extern "system" fn dummy_pfnglframebuffertexture2dproc (_: GLenum, _: GLenum, _: GLenum, _: GLuint, _: GLint) {
	panic!("OpenGL function pointer `glFramebufferTexture2D()` is null.")
}
extern "system" fn dummy_pfnglframebuffertexture3dproc (_: GLenum, _: GLenum, _: GLenum, _: GLuint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glFramebufferTexture3D()` is null.")
}
extern "system" fn dummy_pfnglframebufferrenderbufferproc (_: GLenum, _: GLenum, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glFramebufferRenderbuffer()` is null.")
}
extern "system" fn dummy_pfnglgetframebufferattachmentparameterivproc (_: GLenum, _: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetFramebufferAttachmentParameteriv()` is null.")
}
extern "system" fn dummy_pfnglgeneratemipmapproc (_: GLenum) {
	panic!("OpenGL function pointer `glGenerateMipmap()` is null.")
}
extern "system" fn dummy_pfnglblitframebufferproc (_: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLbitfield, _: GLenum) {
	panic!("OpenGL function pointer `glBlitFramebuffer()` is null.")
}
extern "system" fn dummy_pfnglrenderbufferstoragemultisampleproc (_: GLenum, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glRenderbufferStorageMultisample()` is null.")
}
extern "system" fn dummy_pfnglframebuffertexturelayerproc (_: GLenum, _: GLenum, _: GLuint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glFramebufferTextureLayer()` is null.")
}
extern "system" fn dummy_pfnglmapbufferrangeproc (_: GLenum, _: GLintptr, _: GLsizeiptr, _: GLbitfield) -> *mut c_void {
	panic!("OpenGL function pointer `glMapBufferRange()` is null.")
}
extern "system" fn dummy_pfnglflushmappedbufferrangeproc (_: GLenum, _: GLintptr, _: GLsizeiptr) {
	panic!("OpenGL function pointer `glFlushMappedBufferRange()` is null.")
}
extern "system" fn dummy_pfnglbindvertexarrayproc (_: GLuint) {
	panic!("OpenGL function pointer `glBindVertexArray()` is null.")
}
extern "system" fn dummy_pfngldeletevertexarraysproc (_: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glDeleteVertexArrays()` is null.")
}
extern "system" fn dummy_pfnglgenvertexarraysproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGenVertexArrays()` is null.")
}
extern "system" fn dummy_pfnglisvertexarrayproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsVertexArray()` is null.")
}
pub const GL_COMPARE_REF_TO_TEXTURE: GLenum = 0x884E;
pub const GL_CLIP_DISTANCE0: GLenum = 0x3000;
pub const GL_CLIP_DISTANCE1: GLenum = 0x3001;
pub const GL_CLIP_DISTANCE2: GLenum = 0x3002;
pub const GL_CLIP_DISTANCE3: GLenum = 0x3003;
pub const GL_CLIP_DISTANCE4: GLenum = 0x3004;
pub const GL_CLIP_DISTANCE5: GLenum = 0x3005;
pub const GL_CLIP_DISTANCE6: GLenum = 0x3006;
pub const GL_CLIP_DISTANCE7: GLenum = 0x3007;
pub const GL_MAX_CLIP_DISTANCES: GLenum = 0x0D32;
pub const GL_MAJOR_VERSION: GLenum = 0x821B;
pub const GL_MINOR_VERSION: GLenum = 0x821C;
pub const GL_NUM_EXTENSIONS: GLenum = 0x821D;
pub const GL_CONTEXT_FLAGS: GLenum = 0x821E;
pub const GL_COMPRESSED_RED: GLenum = 0x8225;
pub const GL_COMPRESSED_RG: GLenum = 0x8226;
pub const GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT: GLbitfield = 0x00000001;
pub const GL_RGBA32F: GLenum = 0x8814;
pub const GL_RGB32F: GLenum = 0x8815;
pub const GL_RGBA16F: GLenum = 0x881A;
pub const GL_RGB16F: GLenum = 0x881B;
pub const GL_VERTEX_ATTRIB_ARRAY_INTEGER: GLenum = 0x88FD;
pub const GL_MAX_ARRAY_TEXTURE_LAYERS: GLenum = 0x88FF;
pub const GL_MIN_PROGRAM_TEXEL_OFFSET: GLenum = 0x8904;
pub const GL_MAX_PROGRAM_TEXEL_OFFSET: GLenum = 0x8905;
pub const GL_CLAMP_READ_COLOR: GLenum = 0x891C;
pub const GL_FIXED_ONLY: GLenum = 0x891D;
pub const GL_MAX_VARYING_COMPONENTS: GLenum = 0x8B4B;
pub const GL_TEXTURE_1D_ARRAY: GLenum = 0x8C18;
pub const GL_PROXY_TEXTURE_1D_ARRAY: GLenum = 0x8C19;
pub const GL_TEXTURE_2D_ARRAY: GLenum = 0x8C1A;
pub const GL_PROXY_TEXTURE_2D_ARRAY: GLenum = 0x8C1B;
pub const GL_TEXTURE_BINDING_1D_ARRAY: GLenum = 0x8C1C;
pub const GL_TEXTURE_BINDING_2D_ARRAY: GLenum = 0x8C1D;
pub const GL_R11F_G11F_B10F: GLenum = 0x8C3A;
pub const GL_UNSIGNED_INT_10F_11F_11F_REV: GLenum = 0x8C3B;
pub const GL_RGB9_E5: GLenum = 0x8C3D;
pub const GL_UNSIGNED_INT_5_9_9_9_REV: GLenum = 0x8C3E;
pub const GL_TEXTURE_SHARED_SIZE: GLenum = 0x8C3F;
pub const GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: GLenum = 0x8C76;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_MODE: GLenum = 0x8C7F;
pub const GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: GLenum = 0x8C80;
pub const GL_TRANSFORM_FEEDBACK_VARYINGS: GLenum = 0x8C83;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_START: GLenum = 0x8C84;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_SIZE: GLenum = 0x8C85;
pub const GL_PRIMITIVES_GENERATED: GLenum = 0x8C87;
pub const GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: GLenum = 0x8C88;
pub const GL_RASTERIZER_DISCARD: GLenum = 0x8C89;
pub const GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: GLenum = 0x8C8A;
pub const GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: GLenum = 0x8C8B;
pub const GL_INTERLEAVED_ATTRIBS: GLenum = 0x8C8C;
pub const GL_SEPARATE_ATTRIBS: GLenum = 0x8C8D;
pub const GL_TRANSFORM_FEEDBACK_BUFFER: GLenum = 0x8C8E;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_BINDING: GLenum = 0x8C8F;
pub const GL_RGBA32UI: GLenum = 0x8D70;
pub const GL_RGB32UI: GLenum = 0x8D71;
pub const GL_RGBA16UI: GLenum = 0x8D76;
pub const GL_RGB16UI: GLenum = 0x8D77;
pub const GL_RGBA8UI: GLenum = 0x8D7C;
pub const GL_RGB8UI: GLenum = 0x8D7D;
pub const GL_RGBA32I: GLenum = 0x8D82;
pub const GL_RGB32I: GLenum = 0x8D83;
pub const GL_RGBA16I: GLenum = 0x8D88;
pub const GL_RGB16I: GLenum = 0x8D89;
pub const GL_RGBA8I: GLenum = 0x8D8E;
pub const GL_RGB8I: GLenum = 0x8D8F;
pub const GL_RED_INTEGER: GLenum = 0x8D94;
pub const GL_GREEN_INTEGER: GLenum = 0x8D95;
pub const GL_BLUE_INTEGER: GLenum = 0x8D96;
pub const GL_RGB_INTEGER: GLenum = 0x8D98;
pub const GL_RGBA_INTEGER: GLenum = 0x8D99;
pub const GL_BGR_INTEGER: GLenum = 0x8D9A;
pub const GL_BGRA_INTEGER: GLenum = 0x8D9B;
pub const GL_SAMPLER_1D_ARRAY: GLenum = 0x8DC0;
pub const GL_SAMPLER_2D_ARRAY: GLenum = 0x8DC1;
pub const GL_SAMPLER_1D_ARRAY_SHADOW: GLenum = 0x8DC3;
pub const GL_SAMPLER_2D_ARRAY_SHADOW: GLenum = 0x8DC4;
pub const GL_SAMPLER_CUBE_SHADOW: GLenum = 0x8DC5;
pub const GL_UNSIGNED_INT_VEC2: GLenum = 0x8DC6;
pub const GL_UNSIGNED_INT_VEC3: GLenum = 0x8DC7;
pub const GL_UNSIGNED_INT_VEC4: GLenum = 0x8DC8;
pub const GL_INT_SAMPLER_1D: GLenum = 0x8DC9;
pub const GL_INT_SAMPLER_2D: GLenum = 0x8DCA;
pub const GL_INT_SAMPLER_3D: GLenum = 0x8DCB;
pub const GL_INT_SAMPLER_CUBE: GLenum = 0x8DCC;
pub const GL_INT_SAMPLER_1D_ARRAY: GLenum = 0x8DCE;
pub const GL_INT_SAMPLER_2D_ARRAY: GLenum = 0x8DCF;
pub const GL_UNSIGNED_INT_SAMPLER_1D: GLenum = 0x8DD1;
pub const GL_UNSIGNED_INT_SAMPLER_2D: GLenum = 0x8DD2;
pub const GL_UNSIGNED_INT_SAMPLER_3D: GLenum = 0x8DD3;
pub const GL_UNSIGNED_INT_SAMPLER_CUBE: GLenum = 0x8DD4;
pub const GL_UNSIGNED_INT_SAMPLER_1D_ARRAY: GLenum = 0x8DD6;
pub const GL_UNSIGNED_INT_SAMPLER_2D_ARRAY: GLenum = 0x8DD7;
pub const GL_QUERY_WAIT: GLenum = 0x8E13;
pub const GL_QUERY_NO_WAIT: GLenum = 0x8E14;
pub const GL_QUERY_BY_REGION_WAIT: GLenum = 0x8E15;
pub const GL_QUERY_BY_REGION_NO_WAIT: GLenum = 0x8E16;
pub const GL_BUFFER_ACCESS_FLAGS: GLenum = 0x911F;
pub const GL_BUFFER_MAP_LENGTH: GLenum = 0x9120;
pub const GL_BUFFER_MAP_OFFSET: GLenum = 0x9121;
pub const GL_DEPTH_COMPONENT32F: GLenum = 0x8CAC;
pub const GL_DEPTH32F_STENCIL8: GLenum = 0x8CAD;
pub const GL_FLOAT_32_UNSIGNED_INT_24_8_REV: GLenum = 0x8DAD;
pub const GL_INVALID_FRAMEBUFFER_OPERATION: GLenum = 0x0506;
pub const GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: GLenum = 0x8210;
pub const GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: GLenum = 0x8211;
pub const GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE: GLenum = 0x8212;
pub const GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: GLenum = 0x8213;
pub const GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: GLenum = 0x8214;
pub const GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: GLenum = 0x8215;
pub const GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: GLenum = 0x8216;
pub const GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: GLenum = 0x8217;
pub const GL_FRAMEBUFFER_DEFAULT: GLenum = 0x8218;
pub const GL_FRAMEBUFFER_UNDEFINED: GLenum = 0x8219;
pub const GL_DEPTH_STENCIL_ATTACHMENT: GLenum = 0x821A;
pub const GL_MAX_RENDERBUFFER_SIZE: GLenum = 0x84E8;
pub const GL_DEPTH_STENCIL: GLenum = 0x84F9;
pub const GL_UNSIGNED_INT_24_8: GLenum = 0x84FA;
pub const GL_DEPTH24_STENCIL8: GLenum = 0x88F0;
pub const GL_TEXTURE_STENCIL_SIZE: GLenum = 0x88F1;
pub const GL_TEXTURE_RED_TYPE: GLenum = 0x8C10;
pub const GL_TEXTURE_GREEN_TYPE: GLenum = 0x8C11;
pub const GL_TEXTURE_BLUE_TYPE: GLenum = 0x8C12;
pub const GL_TEXTURE_ALPHA_TYPE: GLenum = 0x8C13;
pub const GL_TEXTURE_DEPTH_TYPE: GLenum = 0x8C16;
pub const GL_UNSIGNED_NORMALIZED: GLenum = 0x8C17;
pub const GL_FRAMEBUFFER_BINDING: GLenum = 0x8CA6;
pub const GL_DRAW_FRAMEBUFFER_BINDING: GLenum = 0x8CA6;
pub const GL_RENDERBUFFER_BINDING: GLenum = 0x8CA7;
pub const GL_READ_FRAMEBUFFER: GLenum = 0x8CA8;
pub const GL_DRAW_FRAMEBUFFER: GLenum = 0x8CA9;
pub const GL_READ_FRAMEBUFFER_BINDING: GLenum = 0x8CAA;
pub const GL_RENDERBUFFER_SAMPLES: GLenum = 0x8CAB;
pub const GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: GLenum = 0x8CD0;
pub const GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: GLenum = 0x8CD1;
pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: GLenum = 0x8CD2;
pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: GLenum = 0x8CD3;
pub const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: GLenum = 0x8CD4;
pub const GL_FRAMEBUFFER_COMPLETE: GLenum = 0x8CD5;
pub const GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT: GLenum = 0x8CD6;
pub const GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: GLenum = 0x8CD7;
pub const GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER: GLenum = 0x8CDB;
pub const GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER: GLenum = 0x8CDC;
pub const GL_FRAMEBUFFER_UNSUPPORTED: GLenum = 0x8CDD;
pub const GL_MAX_COLOR_ATTACHMENTS: GLenum = 0x8CDF;
pub const GL_COLOR_ATTACHMENT0: GLenum = 0x8CE0;
pub const GL_COLOR_ATTACHMENT1: GLenum = 0x8CE1;
pub const GL_COLOR_ATTACHMENT2: GLenum = 0x8CE2;
pub const GL_COLOR_ATTACHMENT3: GLenum = 0x8CE3;
pub const GL_COLOR_ATTACHMENT4: GLenum = 0x8CE4;
pub const GL_COLOR_ATTACHMENT5: GLenum = 0x8CE5;
pub const GL_COLOR_ATTACHMENT6: GLenum = 0x8CE6;
pub const GL_COLOR_ATTACHMENT7: GLenum = 0x8CE7;
pub const GL_COLOR_ATTACHMENT8: GLenum = 0x8CE8;
pub const GL_COLOR_ATTACHMENT9: GLenum = 0x8CE9;
pub const GL_COLOR_ATTACHMENT10: GLenum = 0x8CEA;
pub const GL_COLOR_ATTACHMENT11: GLenum = 0x8CEB;
pub const GL_COLOR_ATTACHMENT12: GLenum = 0x8CEC;
pub const GL_COLOR_ATTACHMENT13: GLenum = 0x8CED;
pub const GL_COLOR_ATTACHMENT14: GLenum = 0x8CEE;
pub const GL_COLOR_ATTACHMENT15: GLenum = 0x8CEF;
pub const GL_COLOR_ATTACHMENT16: GLenum = 0x8CF0;
pub const GL_COLOR_ATTACHMENT17: GLenum = 0x8CF1;
pub const GL_COLOR_ATTACHMENT18: GLenum = 0x8CF2;
pub const GL_COLOR_ATTACHMENT19: GLenum = 0x8CF3;
pub const GL_COLOR_ATTACHMENT20: GLenum = 0x8CF4;
pub const GL_COLOR_ATTACHMENT21: GLenum = 0x8CF5;
pub const GL_COLOR_ATTACHMENT22: GLenum = 0x8CF6;
pub const GL_COLOR_ATTACHMENT23: GLenum = 0x8CF7;
pub const GL_COLOR_ATTACHMENT24: GLenum = 0x8CF8;
pub const GL_COLOR_ATTACHMENT25: GLenum = 0x8CF9;
pub const GL_COLOR_ATTACHMENT26: GLenum = 0x8CFA;
pub const GL_COLOR_ATTACHMENT27: GLenum = 0x8CFB;
pub const GL_COLOR_ATTACHMENT28: GLenum = 0x8CFC;
pub const GL_COLOR_ATTACHMENT29: GLenum = 0x8CFD;
pub const GL_COLOR_ATTACHMENT30: GLenum = 0x8CFE;
pub const GL_COLOR_ATTACHMENT31: GLenum = 0x8CFF;
pub const GL_DEPTH_ATTACHMENT: GLenum = 0x8D00;
pub const GL_STENCIL_ATTACHMENT: GLenum = 0x8D20;
pub const GL_FRAMEBUFFER: GLenum = 0x8D40;
pub const GL_RENDERBUFFER: GLenum = 0x8D41;
pub const GL_RENDERBUFFER_WIDTH: GLenum = 0x8D42;
pub const GL_RENDERBUFFER_HEIGHT: GLenum = 0x8D43;
pub const GL_RENDERBUFFER_INTERNAL_FORMAT: GLenum = 0x8D44;
pub const GL_STENCIL_INDEX1: GLenum = 0x8D46;
pub const GL_STENCIL_INDEX4: GLenum = 0x8D47;
pub const GL_STENCIL_INDEX8: GLenum = 0x8D48;
pub const GL_STENCIL_INDEX16: GLenum = 0x8D49;
pub const GL_RENDERBUFFER_RED_SIZE: GLenum = 0x8D50;
pub const GL_RENDERBUFFER_GREEN_SIZE: GLenum = 0x8D51;
pub const GL_RENDERBUFFER_BLUE_SIZE: GLenum = 0x8D52;
pub const GL_RENDERBUFFER_ALPHA_SIZE: GLenum = 0x8D53;
pub const GL_RENDERBUFFER_DEPTH_SIZE: GLenum = 0x8D54;
pub const GL_RENDERBUFFER_STENCIL_SIZE: GLenum = 0x8D55;
pub const GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: GLenum = 0x8D56;
pub const GL_MAX_SAMPLES: GLenum = 0x8D57;
pub const GL_INDEX: GLenum = 0x8222;
pub const GL_TEXTURE_LUMINANCE_TYPE: GLenum = 0x8C14;
pub const GL_TEXTURE_INTENSITY_TYPE: GLenum = 0x8C15;
pub const GL_FRAMEBUFFER_SRGB: GLenum = 0x8DB9;
pub const GL_HALF_FLOAT: GLenum = 0x140B;
pub const GL_MAP_READ_BIT: GLbitfield = 0x0001;
pub const GL_MAP_WRITE_BIT: GLbitfield = 0x0002;
pub const GL_MAP_INVALIDATE_RANGE_BIT: GLbitfield = 0x0004;
pub const GL_MAP_INVALIDATE_BUFFER_BIT: GLbitfield = 0x0008;
pub const GL_MAP_FLUSH_EXPLICIT_BIT: GLbitfield = 0x0010;
pub const GL_MAP_UNSYNCHRONIZED_BIT: GLbitfield = 0x0020;
pub const GL_COMPRESSED_RED_RGTC1: GLenum = 0x8DBB;
pub const GL_COMPRESSED_SIGNED_RED_RGTC1: GLenum = 0x8DBC;
pub const GL_COMPRESSED_RG_RGTC2: GLenum = 0x8DBD;
pub const GL_COMPRESSED_SIGNED_RG_RGTC2: GLenum = 0x8DBE;
pub const GL_RG: GLenum = 0x8227;
pub const GL_RG_INTEGER: GLenum = 0x8228;
pub const GL_R8: GLenum = 0x8229;
pub const GL_R16: GLenum = 0x822A;
pub const GL_RG8: GLenum = 0x822B;
pub const GL_RG16: GLenum = 0x822C;
pub const GL_R16F: GLenum = 0x822D;
pub const GL_R32F: GLenum = 0x822E;
pub const GL_RG16F: GLenum = 0x822F;
pub const GL_RG32F: GLenum = 0x8230;
pub const GL_R8I: GLenum = 0x8231;
pub const GL_R8UI: GLenum = 0x8232;
pub const GL_R16I: GLenum = 0x8233;
pub const GL_R16UI: GLenum = 0x8234;
pub const GL_R32I: GLenum = 0x8235;
pub const GL_R32UI: GLenum = 0x8236;
pub const GL_RG8I: GLenum = 0x8237;
pub const GL_RG8UI: GLenum = 0x8238;
pub const GL_RG16I: GLenum = 0x8239;
pub const GL_RG16UI: GLenum = 0x823A;
pub const GL_RG32I: GLenum = 0x823B;
pub const GL_RG32UI: GLenum = 0x823C;
pub const GL_VERTEX_ARRAY_BINDING: GLenum = 0x85B5;
pub const GL_CLAMP_VERTEX_COLOR: GLenum = 0x891A;
pub const GL_CLAMP_FRAGMENT_COLOR: GLenum = 0x891B;
pub const GL_ALPHA_INTEGER: GLenum = 0x8D97;

pub trait GL_3_0 {
	fn glGetError(&self) -> GLenum;
	fn glColorMaski(&self, index: GLuint, r: GLboolean, g: GLboolean, b: GLboolean, a: GLboolean) -> Result<()>;
	fn glGetBooleani_v(&self, target: GLenum, index: GLuint, data: *mut GLboolean) -> Result<()>;
	fn glGetIntegeri_v(&self, target: GLenum, index: GLuint, data: *mut GLint) -> Result<()>;
	fn glEnablei(&self, target: GLenum, index: GLuint) -> Result<()>;
	fn glDisablei(&self, target: GLenum, index: GLuint) -> Result<()>;
	fn glIsEnabledi(&self, target: GLenum, index: GLuint) -> Result<GLboolean>;
	fn glBeginTransformFeedback(&self, primitiveMode: GLenum) -> Result<()>;
	fn glEndTransformFeedback(&self) -> Result<()>;
	fn glBindBufferRange(&self, target: GLenum, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()>;
	fn glBindBufferBase(&self, target: GLenum, index: GLuint, buffer: GLuint) -> Result<()>;
	fn glTransformFeedbackVaryings(&self, program: GLuint, count: GLsizei, varyings: *const *const GLchar, bufferMode: GLenum) -> Result<()>;
	fn glGetTransformFeedbackVarying(&self, program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLsizei, type_: *mut GLenum, name: *mut GLchar) -> Result<()>;
	fn glClampColor(&self, target: GLenum, clamp: GLenum) -> Result<()>;
	fn glBeginConditionalRender(&self, id: GLuint, mode: GLenum) -> Result<()>;
	fn glEndConditionalRender(&self) -> Result<()>;
	fn glVertexAttribIPointer(&self, index: GLuint, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()>;
	fn glGetVertexAttribIiv(&self, index: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glGetVertexAttribIuiv(&self, index: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()>;
	fn glVertexAttribI1i(&self, index: GLuint, x: GLint) -> Result<()>;
	fn glVertexAttribI2i(&self, index: GLuint, x: GLint, y: GLint) -> Result<()>;
	fn glVertexAttribI3i(&self, index: GLuint, x: GLint, y: GLint, z: GLint) -> Result<()>;
	fn glVertexAttribI4i(&self, index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint) -> Result<()>;
	fn glVertexAttribI1ui(&self, index: GLuint, x: GLuint) -> Result<()>;
	fn glVertexAttribI2ui(&self, index: GLuint, x: GLuint, y: GLuint) -> Result<()>;
	fn glVertexAttribI3ui(&self, index: GLuint, x: GLuint, y: GLuint, z: GLuint) -> Result<()>;
	fn glVertexAttribI4ui(&self, index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint) -> Result<()>;
	fn glVertexAttribI1iv(&self, index: GLuint, v: *const GLint) -> Result<()>;
	fn glVertexAttribI2iv(&self, index: GLuint, v: *const GLint) -> Result<()>;
	fn glVertexAttribI3iv(&self, index: GLuint, v: *const GLint) -> Result<()>;
	fn glVertexAttribI4iv(&self, index: GLuint, v: *const GLint) -> Result<()>;
	fn glVertexAttribI1uiv(&self, index: GLuint, v: *const GLuint) -> Result<()>;
	fn glVertexAttribI2uiv(&self, index: GLuint, v: *const GLuint) -> Result<()>;
	fn glVertexAttribI3uiv(&self, index: GLuint, v: *const GLuint) -> Result<()>;
	fn glVertexAttribI4uiv(&self, index: GLuint, v: *const GLuint) -> Result<()>;
	fn glVertexAttribI4bv(&self, index: GLuint, v: *const GLbyte) -> Result<()>;
	fn glVertexAttribI4sv(&self, index: GLuint, v: *const GLshort) -> Result<()>;
	fn glVertexAttribI4ubv(&self, index: GLuint, v: *const GLubyte) -> Result<()>;
	fn glVertexAttribI4usv(&self, index: GLuint, v: *const GLushort) -> Result<()>;
	fn glGetUniformuiv(&self, program: GLuint, location: GLint, params: *mut GLuint) -> Result<()>;
	fn glBindFragDataLocation(&self, program: GLuint, color: GLuint, name: *const GLchar) -> Result<()>;
	fn glGetFragDataLocation(&self, program: GLuint, name: *const GLchar) -> Result<GLint>;
	fn glUniform1ui(&self, location: GLint, v0: GLuint) -> Result<()>;
	fn glUniform2ui(&self, location: GLint, v0: GLuint, v1: GLuint) -> Result<()>;
	fn glUniform3ui(&self, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint) -> Result<()>;
	fn glUniform4ui(&self, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint) -> Result<()>;
	fn glUniform1uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()>;
	fn glUniform2uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()>;
	fn glUniform3uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()>;
	fn glUniform4uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()>;
	fn glTexParameterIiv(&self, target: GLenum, pname: GLenum, params: *const GLint) -> Result<()>;
	fn glTexParameterIuiv(&self, target: GLenum, pname: GLenum, params: *const GLuint) -> Result<()>;
	fn glGetTexParameterIiv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glGetTexParameterIuiv(&self, target: GLenum, pname: GLenum, params: *mut GLuint) -> Result<()>;
	fn glClearBufferiv(&self, buffer: GLenum, drawbuffer: GLint, value: *const GLint) -> Result<()>;
	fn glClearBufferuiv(&self, buffer: GLenum, drawbuffer: GLint, value: *const GLuint) -> Result<()>;
	fn glClearBufferfv(&self, buffer: GLenum, drawbuffer: GLint, value: *const GLfloat) -> Result<()>;
	fn glClearBufferfi(&self, buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint) -> Result<()>;
	fn glGetStringi(&self, name: GLenum, index: GLuint) -> Result<&'static str>;
	fn glIsRenderbuffer(&self, renderbuffer: GLuint) -> Result<GLboolean>;
	fn glBindRenderbuffer(&self, target: GLenum, renderbuffer: GLuint) -> Result<()>;
	fn glDeleteRenderbuffers(&self, n: GLsizei, renderbuffers: *const GLuint) -> Result<()>;
	fn glGenRenderbuffers(&self, n: GLsizei, renderbuffers: *mut GLuint) -> Result<()>;
	fn glRenderbufferStorage(&self, target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()>;
	fn glGetRenderbufferParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glIsFramebuffer(&self, framebuffer: GLuint) -> Result<GLboolean>;
	fn glBindFramebuffer(&self, target: GLenum, framebuffer: GLuint) -> Result<()>;
	fn glDeleteFramebuffers(&self, n: GLsizei, framebuffers: *const GLuint) -> Result<()>;
	fn glGenFramebuffers(&self, n: GLsizei, framebuffers: *mut GLuint) -> Result<()>;
	fn glCheckFramebufferStatus(&self, target: GLenum) -> Result<GLenum>;
	fn glFramebufferTexture1D(&self, target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint) -> Result<()>;
	fn glFramebufferTexture2D(&self, target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint) -> Result<()>;
	fn glFramebufferTexture3D(&self, target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint, zoffset: GLint) -> Result<()>;
	fn glFramebufferRenderbuffer(&self, target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint) -> Result<()>;
	fn glGetFramebufferAttachmentParameteriv(&self, target: GLenum, attachment: GLenum, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glGenerateMipmap(&self, target: GLenum) -> Result<()>;
	fn glBlitFramebuffer(&self, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum) -> Result<()>;
	fn glRenderbufferStorageMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()>;
	fn glFramebufferTextureLayer(&self, target: GLenum, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint) -> Result<()>;
	fn glMapBufferRange(&self, target: GLenum, offset: GLintptr, length: GLsizeiptr, access: GLbitfield) -> Result<*mut c_void>;
	fn glFlushMappedBufferRange(&self, target: GLenum, offset: GLintptr, length: GLsizeiptr) -> Result<()>;
	fn glBindVertexArray(&self, array: GLuint) -> Result<()>;
	fn glDeleteVertexArrays(&self, n: GLsizei, arrays: *const GLuint) -> Result<()>;
	fn glGenVertexArrays(&self, n: GLsizei, arrays: *mut GLuint) -> Result<()>;
	fn glIsVertexArray(&self, array: GLuint) -> Result<GLboolean>;
}

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version30 {
	available: bool,
	geterror: PFNGLGETERRORPROC,
	colormaski: PFNGLCOLORMASKIPROC,
	getbooleani_v: PFNGLGETBOOLEANI_VPROC,
	getintegeri_v: PFNGLGETINTEGERI_VPROC,
	enablei: PFNGLENABLEIPROC,
	disablei: PFNGLDISABLEIPROC,
	isenabledi: PFNGLISENABLEDIPROC,
	begintransformfeedback: PFNGLBEGINTRANSFORMFEEDBACKPROC,
	endtransformfeedback: PFNGLENDTRANSFORMFEEDBACKPROC,
	bindbufferrange: PFNGLBINDBUFFERRANGEPROC,
	bindbufferbase: PFNGLBINDBUFFERBASEPROC,
	transformfeedbackvaryings: PFNGLTRANSFORMFEEDBACKVARYINGSPROC,
	gettransformfeedbackvarying: PFNGLGETTRANSFORMFEEDBACKVARYINGPROC,
	clampcolor: PFNGLCLAMPCOLORPROC,
	beginconditionalrender: PFNGLBEGINCONDITIONALRENDERPROC,
	endconditionalrender: PFNGLENDCONDITIONALRENDERPROC,
	vertexattribipointer: PFNGLVERTEXATTRIBIPOINTERPROC,
	getvertexattribiiv: PFNGLGETVERTEXATTRIBIIVPROC,
	getvertexattribiuiv: PFNGLGETVERTEXATTRIBIUIVPROC,
	vertexattribi1i: PFNGLVERTEXATTRIBI1IPROC,
	vertexattribi2i: PFNGLVERTEXATTRIBI2IPROC,
	vertexattribi3i: PFNGLVERTEXATTRIBI3IPROC,
	vertexattribi4i: PFNGLVERTEXATTRIBI4IPROC,
	vertexattribi1ui: PFNGLVERTEXATTRIBI1UIPROC,
	vertexattribi2ui: PFNGLVERTEXATTRIBI2UIPROC,
	vertexattribi3ui: PFNGLVERTEXATTRIBI3UIPROC,
	vertexattribi4ui: PFNGLVERTEXATTRIBI4UIPROC,
	vertexattribi1iv: PFNGLVERTEXATTRIBI1IVPROC,
	vertexattribi2iv: PFNGLVERTEXATTRIBI2IVPROC,
	vertexattribi3iv: PFNGLVERTEXATTRIBI3IVPROC,
	vertexattribi4iv: PFNGLVERTEXATTRIBI4IVPROC,
	vertexattribi1uiv: PFNGLVERTEXATTRIBI1UIVPROC,
	vertexattribi2uiv: PFNGLVERTEXATTRIBI2UIVPROC,
	vertexattribi3uiv: PFNGLVERTEXATTRIBI3UIVPROC,
	vertexattribi4uiv: PFNGLVERTEXATTRIBI4UIVPROC,
	vertexattribi4bv: PFNGLVERTEXATTRIBI4BVPROC,
	vertexattribi4sv: PFNGLVERTEXATTRIBI4SVPROC,
	vertexattribi4ubv: PFNGLVERTEXATTRIBI4UBVPROC,
	vertexattribi4usv: PFNGLVERTEXATTRIBI4USVPROC,
	getuniformuiv: PFNGLGETUNIFORMUIVPROC,
	bindfragdatalocation: PFNGLBINDFRAGDATALOCATIONPROC,
	getfragdatalocation: PFNGLGETFRAGDATALOCATIONPROC,
	uniform1ui: PFNGLUNIFORM1UIPROC,
	uniform2ui: PFNGLUNIFORM2UIPROC,
	uniform3ui: PFNGLUNIFORM3UIPROC,
	uniform4ui: PFNGLUNIFORM4UIPROC,
	uniform1uiv: PFNGLUNIFORM1UIVPROC,
	uniform2uiv: PFNGLUNIFORM2UIVPROC,
	uniform3uiv: PFNGLUNIFORM3UIVPROC,
	uniform4uiv: PFNGLUNIFORM4UIVPROC,
	texparameteriiv: PFNGLTEXPARAMETERIIVPROC,
	texparameteriuiv: PFNGLTEXPARAMETERIUIVPROC,
	gettexparameteriiv: PFNGLGETTEXPARAMETERIIVPROC,
	gettexparameteriuiv: PFNGLGETTEXPARAMETERIUIVPROC,
	clearbufferiv: PFNGLCLEARBUFFERIVPROC,
	clearbufferuiv: PFNGLCLEARBUFFERUIVPROC,
	clearbufferfv: PFNGLCLEARBUFFERFVPROC,
	clearbufferfi: PFNGLCLEARBUFFERFIPROC,
	getstringi: PFNGLGETSTRINGIPROC,
	isrenderbuffer: PFNGLISRENDERBUFFERPROC,
	bindrenderbuffer: PFNGLBINDRENDERBUFFERPROC,
	deleterenderbuffers: PFNGLDELETERENDERBUFFERSPROC,
	genrenderbuffers: PFNGLGENRENDERBUFFERSPROC,
	renderbufferstorage: PFNGLRENDERBUFFERSTORAGEPROC,
	getrenderbufferparameteriv: PFNGLGETRENDERBUFFERPARAMETERIVPROC,
	isframebuffer: PFNGLISFRAMEBUFFERPROC,
	bindframebuffer: PFNGLBINDFRAMEBUFFERPROC,
	deleteframebuffers: PFNGLDELETEFRAMEBUFFERSPROC,
	genframebuffers: PFNGLGENFRAMEBUFFERSPROC,
	checkframebufferstatus: PFNGLCHECKFRAMEBUFFERSTATUSPROC,
	framebuffertexture1d: PFNGLFRAMEBUFFERTEXTURE1DPROC,
	framebuffertexture2d: PFNGLFRAMEBUFFERTEXTURE2DPROC,
	framebuffertexture3d: PFNGLFRAMEBUFFERTEXTURE3DPROC,
	framebufferrenderbuffer: PFNGLFRAMEBUFFERRENDERBUFFERPROC,
	getframebufferattachmentparameteriv: PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC,
	generatemipmap: PFNGLGENERATEMIPMAPPROC,
	blitframebuffer: PFNGLBLITFRAMEBUFFERPROC,
	renderbufferstoragemultisample: PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC,
	framebuffertexturelayer: PFNGLFRAMEBUFFERTEXTURELAYERPROC,
	mapbufferrange: PFNGLMAPBUFFERRANGEPROC,
	flushmappedbufferrange: PFNGLFLUSHMAPPEDBUFFERRANGEPROC,
	bindvertexarray: PFNGLBINDVERTEXARRAYPROC,
	deletevertexarrays: PFNGLDELETEVERTEXARRAYSPROC,
	genvertexarrays: PFNGLGENVERTEXARRAYSPROC,
	isvertexarray: PFNGLISVERTEXARRAYPROC,
}

impl GL_3_0 for Version30 {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	#[inline(always)]
	fn glColorMaski(&self, index: GLuint, r: GLboolean, g: GLboolean, b: GLboolean, a: GLboolean) -> Result<()> {
		let ret = process_catch("glColorMaski", catch_unwind(||(self.colormaski)(index, r, g, b, a)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorMaski", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetBooleani_v(&self, target: GLenum, index: GLuint, data: *mut GLboolean) -> Result<()> {
		let ret = process_catch("glGetBooleani_v", catch_unwind(||(self.getbooleani_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBooleani_v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetIntegeri_v(&self, target: GLenum, index: GLuint, data: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetIntegeri_v", catch_unwind(||(self.getintegeri_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetIntegeri_v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glEnablei(&self, target: GLenum, index: GLuint) -> Result<()> {
		let ret = process_catch("glEnablei", catch_unwind(||(self.enablei)(target, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEnablei", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDisablei(&self, target: GLenum, index: GLuint) -> Result<()> {
		let ret = process_catch("glDisablei", catch_unwind(||(self.disablei)(target, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDisablei", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsEnabledi(&self, target: GLenum, index: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsEnabledi", catch_unwind(||(self.isenabledi)(target, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsEnabledi", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBeginTransformFeedback(&self, primitiveMode: GLenum) -> Result<()> {
		let ret = process_catch("glBeginTransformFeedback", catch_unwind(||(self.begintransformfeedback)(primitiveMode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBeginTransformFeedback", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glEndTransformFeedback(&self) -> Result<()> {
		let ret = process_catch("glEndTransformFeedback", catch_unwind(||(self.endtransformfeedback)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEndTransformFeedback", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindBufferRange(&self, target: GLenum, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glBindBufferRange", catch_unwind(||(self.bindbufferrange)(target, index, buffer, offset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBufferRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindBufferBase(&self, target: GLenum, index: GLuint, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glBindBufferBase", catch_unwind(||(self.bindbufferbase)(target, index, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBufferBase", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTransformFeedbackVaryings(&self, program: GLuint, count: GLsizei, varyings: *const *const GLchar, bufferMode: GLenum) -> Result<()> {
		let ret = process_catch("glTransformFeedbackVaryings", catch_unwind(||(self.transformfeedbackvaryings)(program, count, varyings, bufferMode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTransformFeedbackVaryings", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTransformFeedbackVarying(&self, program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLsizei, type_: *mut GLenum, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetTransformFeedbackVarying", catch_unwind(||(self.gettransformfeedbackvarying)(program, index, bufSize, length, size, type_, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTransformFeedbackVarying", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClampColor(&self, target: GLenum, clamp: GLenum) -> Result<()> {
		let ret = process_catch("glClampColor", catch_unwind(||(self.clampcolor)(target, clamp)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClampColor", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBeginConditionalRender(&self, id: GLuint, mode: GLenum) -> Result<()> {
		let ret = process_catch("glBeginConditionalRender", catch_unwind(||(self.beginconditionalrender)(id, mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBeginConditionalRender", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glEndConditionalRender(&self) -> Result<()> {
		let ret = process_catch("glEndConditionalRender", catch_unwind(||(self.endconditionalrender)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEndConditionalRender", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribIPointer(&self, index: GLuint, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glVertexAttribIPointer", catch_unwind(||(self.vertexattribipointer)(index, size, type_, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribIPointer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexAttribIiv(&self, index: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetVertexAttribIiv", catch_unwind(||(self.getvertexattribiiv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribIiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexAttribIuiv(&self, index: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetVertexAttribIuiv", catch_unwind(||(self.getvertexattribiuiv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribIuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI1i(&self, index: GLuint, x: GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI1i", catch_unwind(||(self.vertexattribi1i)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI1i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI2i(&self, index: GLuint, x: GLint, y: GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI2i", catch_unwind(||(self.vertexattribi2i)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI2i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI3i(&self, index: GLuint, x: GLint, y: GLint, z: GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI3i", catch_unwind(||(self.vertexattribi3i)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI3i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI4i(&self, index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI4i", catch_unwind(||(self.vertexattribi4i)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI1ui(&self, index: GLuint, x: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI1ui", catch_unwind(||(self.vertexattribi1ui)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI1ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI2ui(&self, index: GLuint, x: GLuint, y: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI2ui", catch_unwind(||(self.vertexattribi2ui)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI2ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI3ui(&self, index: GLuint, x: GLuint, y: GLuint, z: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI3ui", catch_unwind(||(self.vertexattribi3ui)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI4ui(&self, index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI4ui", catch_unwind(||(self.vertexattribi4ui)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI1iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI1iv", catch_unwind(||(self.vertexattribi1iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI1iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI2iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI2iv", catch_unwind(||(self.vertexattribi2iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI2iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI3iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI3iv", catch_unwind(||(self.vertexattribi3iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI3iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI4iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI4iv", catch_unwind(||(self.vertexattribi4iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI1uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI1uiv", catch_unwind(||(self.vertexattribi1uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI1uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI2uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI2uiv", catch_unwind(||(self.vertexattribi2uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI2uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI3uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI3uiv", catch_unwind(||(self.vertexattribi3uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI4uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI4uiv", catch_unwind(||(self.vertexattribi4uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI4bv(&self, index: GLuint, v: *const GLbyte) -> Result<()> {
		let ret = process_catch("glVertexAttribI4bv", catch_unwind(||(self.vertexattribi4bv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4bv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI4sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttribI4sv", catch_unwind(||(self.vertexattribi4sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4sv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI4ubv(&self, index: GLuint, v: *const GLubyte) -> Result<()> {
		let ret = process_catch("glVertexAttribI4ubv", catch_unwind(||(self.vertexattribi4ubv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4ubv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI4usv(&self, index: GLuint, v: *const GLushort) -> Result<()> {
		let ret = process_catch("glVertexAttribI4usv", catch_unwind(||(self.vertexattribi4usv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4usv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetUniformuiv(&self, program: GLuint, location: GLint, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetUniformuiv", catch_unwind(||(self.getuniformuiv)(program, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindFragDataLocation(&self, program: GLuint, color: GLuint, name: *const GLchar) -> Result<()> {
		let ret = process_catch("glBindFragDataLocation", catch_unwind(||(self.bindfragdatalocation)(program, color, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindFragDataLocation", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetFragDataLocation(&self, program: GLuint, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetFragDataLocation", catch_unwind(||(self.getfragdatalocation)(program, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFragDataLocation", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform1ui(&self, location: GLint, v0: GLuint) -> Result<()> {
		let ret = process_catch("glUniform1ui", catch_unwind(||(self.uniform1ui)(location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform2ui(&self, location: GLint, v0: GLuint, v1: GLuint) -> Result<()> {
		let ret = process_catch("glUniform2ui", catch_unwind(||(self.uniform2ui)(location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform3ui(&self, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint) -> Result<()> {
		let ret = process_catch("glUniform3ui", catch_unwind(||(self.uniform3ui)(location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform4ui(&self, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint) -> Result<()> {
		let ret = process_catch("glUniform4ui", catch_unwind(||(self.uniform4ui)(location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform1uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniform1uiv", catch_unwind(||(self.uniform1uiv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform2uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniform2uiv", catch_unwind(||(self.uniform2uiv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform3uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniform3uiv", catch_unwind(||(self.uniform3uiv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform4uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniform4uiv", catch_unwind(||(self.uniform4uiv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexParameterIiv(&self, target: GLenum, pname: GLenum, params: *const GLint) -> Result<()> {
		let ret = process_catch("glTexParameterIiv", catch_unwind(||(self.texparameteriiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameterIiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexParameterIuiv(&self, target: GLenum, pname: GLenum, params: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexParameterIuiv", catch_unwind(||(self.texparameteriuiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameterIuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTexParameterIiv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTexParameterIiv", catch_unwind(||(self.gettexparameteriiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexParameterIiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTexParameterIuiv(&self, target: GLenum, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetTexParameterIuiv", catch_unwind(||(self.gettexparameteriuiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexParameterIuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearBufferiv(&self, buffer: GLenum, drawbuffer: GLint, value: *const GLint) -> Result<()> {
		let ret = process_catch("glClearBufferiv", catch_unwind(||(self.clearbufferiv)(buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearBufferuiv(&self, buffer: GLenum, drawbuffer: GLint, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glClearBufferuiv", catch_unwind(||(self.clearbufferuiv)(buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearBufferfv(&self, buffer: GLenum, drawbuffer: GLint, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glClearBufferfv", catch_unwind(||(self.clearbufferfv)(buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearBufferfi(&self, buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint) -> Result<()> {
		let ret = process_catch("glClearBufferfi", catch_unwind(||(self.clearbufferfi)(buffer, drawbuffer, depth, stencil)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferfi", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetStringi(&self, name: GLenum, index: GLuint) -> Result<&'static str> {
		let ret = process_catch("glGetStringi", catch_unwind(||unsafe{CStr::from_ptr((self.getstringi)(name, index) as *const i8)}.to_str().unwrap()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetStringi", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsRenderbuffer(&self, renderbuffer: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsRenderbuffer", catch_unwind(||(self.isrenderbuffer)(renderbuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsRenderbuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindRenderbuffer(&self, target: GLenum, renderbuffer: GLuint) -> Result<()> {
		let ret = process_catch("glBindRenderbuffer", catch_unwind(||(self.bindrenderbuffer)(target, renderbuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindRenderbuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteRenderbuffers(&self, n: GLsizei, renderbuffers: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteRenderbuffers", catch_unwind(||(self.deleterenderbuffers)(n, renderbuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteRenderbuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenRenderbuffers(&self, n: GLsizei, renderbuffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenRenderbuffers", catch_unwind(||(self.genrenderbuffers)(n, renderbuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenRenderbuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glRenderbufferStorage(&self, target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glRenderbufferStorage", catch_unwind(||(self.renderbufferstorage)(target, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glRenderbufferStorage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetRenderbufferParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetRenderbufferParameteriv", catch_unwind(||(self.getrenderbufferparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetRenderbufferParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsFramebuffer(&self, framebuffer: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsFramebuffer", catch_unwind(||(self.isframebuffer)(framebuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsFramebuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindFramebuffer(&self, target: GLenum, framebuffer: GLuint) -> Result<()> {
		let ret = process_catch("glBindFramebuffer", catch_unwind(||(self.bindframebuffer)(target, framebuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindFramebuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteFramebuffers(&self, n: GLsizei, framebuffers: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteFramebuffers", catch_unwind(||(self.deleteframebuffers)(n, framebuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteFramebuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenFramebuffers(&self, n: GLsizei, framebuffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenFramebuffers", catch_unwind(||(self.genframebuffers)(n, framebuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenFramebuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCheckFramebufferStatus(&self, target: GLenum) -> Result<GLenum> {
		let ret = process_catch("glCheckFramebufferStatus", catch_unwind(||(self.checkframebufferstatus)(target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCheckFramebufferStatus", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFramebufferTexture1D(&self, target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTexture1D", catch_unwind(||(self.framebuffertexture1d)(target, attachment, textarget, texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTexture1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFramebufferTexture2D(&self, target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTexture2D", catch_unwind(||(self.framebuffertexture2d)(target, attachment, textarget, texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTexture2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFramebufferTexture3D(&self, target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint, zoffset: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTexture3D", catch_unwind(||(self.framebuffertexture3d)(target, attachment, textarget, texture, level, zoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTexture3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFramebufferRenderbuffer(&self, target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint) -> Result<()> {
		let ret = process_catch("glFramebufferRenderbuffer", catch_unwind(||(self.framebufferrenderbuffer)(target, attachment, renderbuffertarget, renderbuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferRenderbuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetFramebufferAttachmentParameteriv(&self, target: GLenum, attachment: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetFramebufferAttachmentParameteriv", catch_unwind(||(self.getframebufferattachmentparameteriv)(target, attachment, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFramebufferAttachmentParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenerateMipmap(&self, target: GLenum) -> Result<()> {
		let ret = process_catch("glGenerateMipmap", catch_unwind(||(self.generatemipmap)(target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenerateMipmap", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBlitFramebuffer(&self, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum) -> Result<()> {
		let ret = process_catch("glBlitFramebuffer", catch_unwind(||(self.blitframebuffer)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlitFramebuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glRenderbufferStorageMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glRenderbufferStorageMultisample", catch_unwind(||(self.renderbufferstoragemultisample)(target, samples, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glRenderbufferStorageMultisample", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFramebufferTextureLayer(&self, target: GLenum, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTextureLayer", catch_unwind(||(self.framebuffertexturelayer)(target, attachment, texture, level, layer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTextureLayer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMapBufferRange(&self, target: GLenum, offset: GLintptr, length: GLsizeiptr, access: GLbitfield) -> Result<*mut c_void> {
		let ret = process_catch("glMapBufferRange", catch_unwind(||(self.mapbufferrange)(target, offset, length, access)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMapBufferRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFlushMappedBufferRange(&self, target: GLenum, offset: GLintptr, length: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glFlushMappedBufferRange", catch_unwind(||(self.flushmappedbufferrange)(target, offset, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFlushMappedBufferRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindVertexArray(&self, array: GLuint) -> Result<()> {
		let ret = process_catch("glBindVertexArray", catch_unwind(||(self.bindvertexarray)(array)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindVertexArray", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteVertexArrays(&self, n: GLsizei, arrays: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteVertexArrays", catch_unwind(||(self.deletevertexarrays)(n, arrays)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteVertexArrays", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenVertexArrays(&self, n: GLsizei, arrays: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenVertexArrays", catch_unwind(||(self.genvertexarrays)(n, arrays)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenVertexArrays", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsVertexArray(&self, array: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsVertexArray", catch_unwind(||(self.isvertexarray)(array)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsVertexArray", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version30 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (3, 0, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			colormaski: {let proc = get_proc_address("glColorMaski"); if proc == null() {dummy_pfnglcolormaskiproc} else {unsafe{transmute(proc)}}},
			getbooleani_v: {let proc = get_proc_address("glGetBooleani_v"); if proc == null() {dummy_pfnglgetbooleani_vproc} else {unsafe{transmute(proc)}}},
			getintegeri_v: {let proc = get_proc_address("glGetIntegeri_v"); if proc == null() {dummy_pfnglgetintegeri_vproc} else {unsafe{transmute(proc)}}},
			enablei: {let proc = get_proc_address("glEnablei"); if proc == null() {dummy_pfnglenableiproc} else {unsafe{transmute(proc)}}},
			disablei: {let proc = get_proc_address("glDisablei"); if proc == null() {dummy_pfngldisableiproc} else {unsafe{transmute(proc)}}},
			isenabledi: {let proc = get_proc_address("glIsEnabledi"); if proc == null() {dummy_pfnglisenablediproc} else {unsafe{transmute(proc)}}},
			begintransformfeedback: {let proc = get_proc_address("glBeginTransformFeedback"); if proc == null() {dummy_pfnglbegintransformfeedbackproc} else {unsafe{transmute(proc)}}},
			endtransformfeedback: {let proc = get_proc_address("glEndTransformFeedback"); if proc == null() {dummy_pfnglendtransformfeedbackproc} else {unsafe{transmute(proc)}}},
			bindbufferrange: {let proc = get_proc_address("glBindBufferRange"); if proc == null() {dummy_pfnglbindbufferrangeproc} else {unsafe{transmute(proc)}}},
			bindbufferbase: {let proc = get_proc_address("glBindBufferBase"); if proc == null() {dummy_pfnglbindbufferbaseproc} else {unsafe{transmute(proc)}}},
			transformfeedbackvaryings: {let proc = get_proc_address("glTransformFeedbackVaryings"); if proc == null() {dummy_pfngltransformfeedbackvaryingsproc} else {unsafe{transmute(proc)}}},
			gettransformfeedbackvarying: {let proc = get_proc_address("glGetTransformFeedbackVarying"); if proc == null() {dummy_pfnglgettransformfeedbackvaryingproc} else {unsafe{transmute(proc)}}},
			clampcolor: {let proc = get_proc_address("glClampColor"); if proc == null() {dummy_pfnglclampcolorproc} else {unsafe{transmute(proc)}}},
			beginconditionalrender: {let proc = get_proc_address("glBeginConditionalRender"); if proc == null() {dummy_pfnglbeginconditionalrenderproc} else {unsafe{transmute(proc)}}},
			endconditionalrender: {let proc = get_proc_address("glEndConditionalRender"); if proc == null() {dummy_pfnglendconditionalrenderproc} else {unsafe{transmute(proc)}}},
			vertexattribipointer: {let proc = get_proc_address("glVertexAttribIPointer"); if proc == null() {dummy_pfnglvertexattribipointerproc} else {unsafe{transmute(proc)}}},
			getvertexattribiiv: {let proc = get_proc_address("glGetVertexAttribIiv"); if proc == null() {dummy_pfnglgetvertexattribiivproc} else {unsafe{transmute(proc)}}},
			getvertexattribiuiv: {let proc = get_proc_address("glGetVertexAttribIuiv"); if proc == null() {dummy_pfnglgetvertexattribiuivproc} else {unsafe{transmute(proc)}}},
			vertexattribi1i: {let proc = get_proc_address("glVertexAttribI1i"); if proc == null() {dummy_pfnglvertexattribi1iproc} else {unsafe{transmute(proc)}}},
			vertexattribi2i: {let proc = get_proc_address("glVertexAttribI2i"); if proc == null() {dummy_pfnglvertexattribi2iproc} else {unsafe{transmute(proc)}}},
			vertexattribi3i: {let proc = get_proc_address("glVertexAttribI3i"); if proc == null() {dummy_pfnglvertexattribi3iproc} else {unsafe{transmute(proc)}}},
			vertexattribi4i: {let proc = get_proc_address("glVertexAttribI4i"); if proc == null() {dummy_pfnglvertexattribi4iproc} else {unsafe{transmute(proc)}}},
			vertexattribi1ui: {let proc = get_proc_address("glVertexAttribI1ui"); if proc == null() {dummy_pfnglvertexattribi1uiproc} else {unsafe{transmute(proc)}}},
			vertexattribi2ui: {let proc = get_proc_address("glVertexAttribI2ui"); if proc == null() {dummy_pfnglvertexattribi2uiproc} else {unsafe{transmute(proc)}}},
			vertexattribi3ui: {let proc = get_proc_address("glVertexAttribI3ui"); if proc == null() {dummy_pfnglvertexattribi3uiproc} else {unsafe{transmute(proc)}}},
			vertexattribi4ui: {let proc = get_proc_address("glVertexAttribI4ui"); if proc == null() {dummy_pfnglvertexattribi4uiproc} else {unsafe{transmute(proc)}}},
			vertexattribi1iv: {let proc = get_proc_address("glVertexAttribI1iv"); if proc == null() {dummy_pfnglvertexattribi1ivproc} else {unsafe{transmute(proc)}}},
			vertexattribi2iv: {let proc = get_proc_address("glVertexAttribI2iv"); if proc == null() {dummy_pfnglvertexattribi2ivproc} else {unsafe{transmute(proc)}}},
			vertexattribi3iv: {let proc = get_proc_address("glVertexAttribI3iv"); if proc == null() {dummy_pfnglvertexattribi3ivproc} else {unsafe{transmute(proc)}}},
			vertexattribi4iv: {let proc = get_proc_address("glVertexAttribI4iv"); if proc == null() {dummy_pfnglvertexattribi4ivproc} else {unsafe{transmute(proc)}}},
			vertexattribi1uiv: {let proc = get_proc_address("glVertexAttribI1uiv"); if proc == null() {dummy_pfnglvertexattribi1uivproc} else {unsafe{transmute(proc)}}},
			vertexattribi2uiv: {let proc = get_proc_address("glVertexAttribI2uiv"); if proc == null() {dummy_pfnglvertexattribi2uivproc} else {unsafe{transmute(proc)}}},
			vertexattribi3uiv: {let proc = get_proc_address("glVertexAttribI3uiv"); if proc == null() {dummy_pfnglvertexattribi3uivproc} else {unsafe{transmute(proc)}}},
			vertexattribi4uiv: {let proc = get_proc_address("glVertexAttribI4uiv"); if proc == null() {dummy_pfnglvertexattribi4uivproc} else {unsafe{transmute(proc)}}},
			vertexattribi4bv: {let proc = get_proc_address("glVertexAttribI4bv"); if proc == null() {dummy_pfnglvertexattribi4bvproc} else {unsafe{transmute(proc)}}},
			vertexattribi4sv: {let proc = get_proc_address("glVertexAttribI4sv"); if proc == null() {dummy_pfnglvertexattribi4svproc} else {unsafe{transmute(proc)}}},
			vertexattribi4ubv: {let proc = get_proc_address("glVertexAttribI4ubv"); if proc == null() {dummy_pfnglvertexattribi4ubvproc} else {unsafe{transmute(proc)}}},
			vertexattribi4usv: {let proc = get_proc_address("glVertexAttribI4usv"); if proc == null() {dummy_pfnglvertexattribi4usvproc} else {unsafe{transmute(proc)}}},
			getuniformuiv: {let proc = get_proc_address("glGetUniformuiv"); if proc == null() {dummy_pfnglgetuniformuivproc} else {unsafe{transmute(proc)}}},
			bindfragdatalocation: {let proc = get_proc_address("glBindFragDataLocation"); if proc == null() {dummy_pfnglbindfragdatalocationproc} else {unsafe{transmute(proc)}}},
			getfragdatalocation: {let proc = get_proc_address("glGetFragDataLocation"); if proc == null() {dummy_pfnglgetfragdatalocationproc} else {unsafe{transmute(proc)}}},
			uniform1ui: {let proc = get_proc_address("glUniform1ui"); if proc == null() {dummy_pfngluniform1uiproc} else {unsafe{transmute(proc)}}},
			uniform2ui: {let proc = get_proc_address("glUniform2ui"); if proc == null() {dummy_pfngluniform2uiproc} else {unsafe{transmute(proc)}}},
			uniform3ui: {let proc = get_proc_address("glUniform3ui"); if proc == null() {dummy_pfngluniform3uiproc} else {unsafe{transmute(proc)}}},
			uniform4ui: {let proc = get_proc_address("glUniform4ui"); if proc == null() {dummy_pfngluniform4uiproc} else {unsafe{transmute(proc)}}},
			uniform1uiv: {let proc = get_proc_address("glUniform1uiv"); if proc == null() {dummy_pfngluniform1uivproc} else {unsafe{transmute(proc)}}},
			uniform2uiv: {let proc = get_proc_address("glUniform2uiv"); if proc == null() {dummy_pfngluniform2uivproc} else {unsafe{transmute(proc)}}},
			uniform3uiv: {let proc = get_proc_address("glUniform3uiv"); if proc == null() {dummy_pfngluniform3uivproc} else {unsafe{transmute(proc)}}},
			uniform4uiv: {let proc = get_proc_address("glUniform4uiv"); if proc == null() {dummy_pfngluniform4uivproc} else {unsafe{transmute(proc)}}},
			texparameteriiv: {let proc = get_proc_address("glTexParameterIiv"); if proc == null() {dummy_pfngltexparameteriivproc} else {unsafe{transmute(proc)}}},
			texparameteriuiv: {let proc = get_proc_address("glTexParameterIuiv"); if proc == null() {dummy_pfngltexparameteriuivproc} else {unsafe{transmute(proc)}}},
			gettexparameteriiv: {let proc = get_proc_address("glGetTexParameterIiv"); if proc == null() {dummy_pfnglgettexparameteriivproc} else {unsafe{transmute(proc)}}},
			gettexparameteriuiv: {let proc = get_proc_address("glGetTexParameterIuiv"); if proc == null() {dummy_pfnglgettexparameteriuivproc} else {unsafe{transmute(proc)}}},
			clearbufferiv: {let proc = get_proc_address("glClearBufferiv"); if proc == null() {dummy_pfnglclearbufferivproc} else {unsafe{transmute(proc)}}},
			clearbufferuiv: {let proc = get_proc_address("glClearBufferuiv"); if proc == null() {dummy_pfnglclearbufferuivproc} else {unsafe{transmute(proc)}}},
			clearbufferfv: {let proc = get_proc_address("glClearBufferfv"); if proc == null() {dummy_pfnglclearbufferfvproc} else {unsafe{transmute(proc)}}},
			clearbufferfi: {let proc = get_proc_address("glClearBufferfi"); if proc == null() {dummy_pfnglclearbufferfiproc} else {unsafe{transmute(proc)}}},
			getstringi: {let proc = get_proc_address("glGetStringi"); if proc == null() {dummy_pfnglgetstringiproc} else {unsafe{transmute(proc)}}},
			isrenderbuffer: {let proc = get_proc_address("glIsRenderbuffer"); if proc == null() {dummy_pfnglisrenderbufferproc} else {unsafe{transmute(proc)}}},
			bindrenderbuffer: {let proc = get_proc_address("glBindRenderbuffer"); if proc == null() {dummy_pfnglbindrenderbufferproc} else {unsafe{transmute(proc)}}},
			deleterenderbuffers: {let proc = get_proc_address("glDeleteRenderbuffers"); if proc == null() {dummy_pfngldeleterenderbuffersproc} else {unsafe{transmute(proc)}}},
			genrenderbuffers: {let proc = get_proc_address("glGenRenderbuffers"); if proc == null() {dummy_pfnglgenrenderbuffersproc} else {unsafe{transmute(proc)}}},
			renderbufferstorage: {let proc = get_proc_address("glRenderbufferStorage"); if proc == null() {dummy_pfnglrenderbufferstorageproc} else {unsafe{transmute(proc)}}},
			getrenderbufferparameteriv: {let proc = get_proc_address("glGetRenderbufferParameteriv"); if proc == null() {dummy_pfnglgetrenderbufferparameterivproc} else {unsafe{transmute(proc)}}},
			isframebuffer: {let proc = get_proc_address("glIsFramebuffer"); if proc == null() {dummy_pfnglisframebufferproc} else {unsafe{transmute(proc)}}},
			bindframebuffer: {let proc = get_proc_address("glBindFramebuffer"); if proc == null() {dummy_pfnglbindframebufferproc} else {unsafe{transmute(proc)}}},
			deleteframebuffers: {let proc = get_proc_address("glDeleteFramebuffers"); if proc == null() {dummy_pfngldeleteframebuffersproc} else {unsafe{transmute(proc)}}},
			genframebuffers: {let proc = get_proc_address("glGenFramebuffers"); if proc == null() {dummy_pfnglgenframebuffersproc} else {unsafe{transmute(proc)}}},
			checkframebufferstatus: {let proc = get_proc_address("glCheckFramebufferStatus"); if proc == null() {dummy_pfnglcheckframebufferstatusproc} else {unsafe{transmute(proc)}}},
			framebuffertexture1d: {let proc = get_proc_address("glFramebufferTexture1D"); if proc == null() {dummy_pfnglframebuffertexture1dproc} else {unsafe{transmute(proc)}}},
			framebuffertexture2d: {let proc = get_proc_address("glFramebufferTexture2D"); if proc == null() {dummy_pfnglframebuffertexture2dproc} else {unsafe{transmute(proc)}}},
			framebuffertexture3d: {let proc = get_proc_address("glFramebufferTexture3D"); if proc == null() {dummy_pfnglframebuffertexture3dproc} else {unsafe{transmute(proc)}}},
			framebufferrenderbuffer: {let proc = get_proc_address("glFramebufferRenderbuffer"); if proc == null() {dummy_pfnglframebufferrenderbufferproc} else {unsafe{transmute(proc)}}},
			getframebufferattachmentparameteriv: {let proc = get_proc_address("glGetFramebufferAttachmentParameteriv"); if proc == null() {dummy_pfnglgetframebufferattachmentparameterivproc} else {unsafe{transmute(proc)}}},
			generatemipmap: {let proc = get_proc_address("glGenerateMipmap"); if proc == null() {dummy_pfnglgeneratemipmapproc} else {unsafe{transmute(proc)}}},
			blitframebuffer: {let proc = get_proc_address("glBlitFramebuffer"); if proc == null() {dummy_pfnglblitframebufferproc} else {unsafe{transmute(proc)}}},
			renderbufferstoragemultisample: {let proc = get_proc_address("glRenderbufferStorageMultisample"); if proc == null() {dummy_pfnglrenderbufferstoragemultisampleproc} else {unsafe{transmute(proc)}}},
			framebuffertexturelayer: {let proc = get_proc_address("glFramebufferTextureLayer"); if proc == null() {dummy_pfnglframebuffertexturelayerproc} else {unsafe{transmute(proc)}}},
			mapbufferrange: {let proc = get_proc_address("glMapBufferRange"); if proc == null() {dummy_pfnglmapbufferrangeproc} else {unsafe{transmute(proc)}}},
			flushmappedbufferrange: {let proc = get_proc_address("glFlushMappedBufferRange"); if proc == null() {dummy_pfnglflushmappedbufferrangeproc} else {unsafe{transmute(proc)}}},
			bindvertexarray: {let proc = get_proc_address("glBindVertexArray"); if proc == null() {dummy_pfnglbindvertexarrayproc} else {unsafe{transmute(proc)}}},
			deletevertexarrays: {let proc = get_proc_address("glDeleteVertexArrays"); if proc == null() {dummy_pfngldeletevertexarraysproc} else {unsafe{transmute(proc)}}},
			genvertexarrays: {let proc = get_proc_address("glGenVertexArrays"); if proc == null() {dummy_pfnglgenvertexarraysproc} else {unsafe{transmute(proc)}}},
			isvertexarray: {let proc = get_proc_address("glIsVertexArray"); if proc == null() {dummy_pfnglisvertexarrayproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version30 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			colormaski: dummy_pfnglcolormaskiproc,
			getbooleani_v: dummy_pfnglgetbooleani_vproc,
			getintegeri_v: dummy_pfnglgetintegeri_vproc,
			enablei: dummy_pfnglenableiproc,
			disablei: dummy_pfngldisableiproc,
			isenabledi: dummy_pfnglisenablediproc,
			begintransformfeedback: dummy_pfnglbegintransformfeedbackproc,
			endtransformfeedback: dummy_pfnglendtransformfeedbackproc,
			bindbufferrange: dummy_pfnglbindbufferrangeproc,
			bindbufferbase: dummy_pfnglbindbufferbaseproc,
			transformfeedbackvaryings: dummy_pfngltransformfeedbackvaryingsproc,
			gettransformfeedbackvarying: dummy_pfnglgettransformfeedbackvaryingproc,
			clampcolor: dummy_pfnglclampcolorproc,
			beginconditionalrender: dummy_pfnglbeginconditionalrenderproc,
			endconditionalrender: dummy_pfnglendconditionalrenderproc,
			vertexattribipointer: dummy_pfnglvertexattribipointerproc,
			getvertexattribiiv: dummy_pfnglgetvertexattribiivproc,
			getvertexattribiuiv: dummy_pfnglgetvertexattribiuivproc,
			vertexattribi1i: dummy_pfnglvertexattribi1iproc,
			vertexattribi2i: dummy_pfnglvertexattribi2iproc,
			vertexattribi3i: dummy_pfnglvertexattribi3iproc,
			vertexattribi4i: dummy_pfnglvertexattribi4iproc,
			vertexattribi1ui: dummy_pfnglvertexattribi1uiproc,
			vertexattribi2ui: dummy_pfnglvertexattribi2uiproc,
			vertexattribi3ui: dummy_pfnglvertexattribi3uiproc,
			vertexattribi4ui: dummy_pfnglvertexattribi4uiproc,
			vertexattribi1iv: dummy_pfnglvertexattribi1ivproc,
			vertexattribi2iv: dummy_pfnglvertexattribi2ivproc,
			vertexattribi3iv: dummy_pfnglvertexattribi3ivproc,
			vertexattribi4iv: dummy_pfnglvertexattribi4ivproc,
			vertexattribi1uiv: dummy_pfnglvertexattribi1uivproc,
			vertexattribi2uiv: dummy_pfnglvertexattribi2uivproc,
			vertexattribi3uiv: dummy_pfnglvertexattribi3uivproc,
			vertexattribi4uiv: dummy_pfnglvertexattribi4uivproc,
			vertexattribi4bv: dummy_pfnglvertexattribi4bvproc,
			vertexattribi4sv: dummy_pfnglvertexattribi4svproc,
			vertexattribi4ubv: dummy_pfnglvertexattribi4ubvproc,
			vertexattribi4usv: dummy_pfnglvertexattribi4usvproc,
			getuniformuiv: dummy_pfnglgetuniformuivproc,
			bindfragdatalocation: dummy_pfnglbindfragdatalocationproc,
			getfragdatalocation: dummy_pfnglgetfragdatalocationproc,
			uniform1ui: dummy_pfngluniform1uiproc,
			uniform2ui: dummy_pfngluniform2uiproc,
			uniform3ui: dummy_pfngluniform3uiproc,
			uniform4ui: dummy_pfngluniform4uiproc,
			uniform1uiv: dummy_pfngluniform1uivproc,
			uniform2uiv: dummy_pfngluniform2uivproc,
			uniform3uiv: dummy_pfngluniform3uivproc,
			uniform4uiv: dummy_pfngluniform4uivproc,
			texparameteriiv: dummy_pfngltexparameteriivproc,
			texparameteriuiv: dummy_pfngltexparameteriuivproc,
			gettexparameteriiv: dummy_pfnglgettexparameteriivproc,
			gettexparameteriuiv: dummy_pfnglgettexparameteriuivproc,
			clearbufferiv: dummy_pfnglclearbufferivproc,
			clearbufferuiv: dummy_pfnglclearbufferuivproc,
			clearbufferfv: dummy_pfnglclearbufferfvproc,
			clearbufferfi: dummy_pfnglclearbufferfiproc,
			getstringi: dummy_pfnglgetstringiproc,
			isrenderbuffer: dummy_pfnglisrenderbufferproc,
			bindrenderbuffer: dummy_pfnglbindrenderbufferproc,
			deleterenderbuffers: dummy_pfngldeleterenderbuffersproc,
			genrenderbuffers: dummy_pfnglgenrenderbuffersproc,
			renderbufferstorage: dummy_pfnglrenderbufferstorageproc,
			getrenderbufferparameteriv: dummy_pfnglgetrenderbufferparameterivproc,
			isframebuffer: dummy_pfnglisframebufferproc,
			bindframebuffer: dummy_pfnglbindframebufferproc,
			deleteframebuffers: dummy_pfngldeleteframebuffersproc,
			genframebuffers: dummy_pfnglgenframebuffersproc,
			checkframebufferstatus: dummy_pfnglcheckframebufferstatusproc,
			framebuffertexture1d: dummy_pfnglframebuffertexture1dproc,
			framebuffertexture2d: dummy_pfnglframebuffertexture2dproc,
			framebuffertexture3d: dummy_pfnglframebuffertexture3dproc,
			framebufferrenderbuffer: dummy_pfnglframebufferrenderbufferproc,
			getframebufferattachmentparameteriv: dummy_pfnglgetframebufferattachmentparameterivproc,
			generatemipmap: dummy_pfnglgeneratemipmapproc,
			blitframebuffer: dummy_pfnglblitframebufferproc,
			renderbufferstoragemultisample: dummy_pfnglrenderbufferstoragemultisampleproc,
			framebuffertexturelayer: dummy_pfnglframebuffertexturelayerproc,
			mapbufferrange: dummy_pfnglmapbufferrangeproc,
			flushmappedbufferrange: dummy_pfnglflushmappedbufferrangeproc,
			bindvertexarray: dummy_pfnglbindvertexarrayproc,
			deletevertexarrays: dummy_pfngldeletevertexarraysproc,
			genvertexarrays: dummy_pfnglgenvertexarraysproc,
			isvertexarray: dummy_pfnglisvertexarrayproc,
		}
	}
}
impl Debug for Version30 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version30")
			.field("available", &self.available)
			.field("colormaski", unsafe{if transmute::<_, *const c_void>(self.colormaski) == (dummy_pfnglcolormaskiproc as *const c_void) {&null::<PFNGLCOLORMASKIPROC>()} else {&self.colormaski}})
			.field("getbooleani_v", unsafe{if transmute::<_, *const c_void>(self.getbooleani_v) == (dummy_pfnglgetbooleani_vproc as *const c_void) {&null::<PFNGLGETBOOLEANI_VPROC>()} else {&self.getbooleani_v}})
			.field("getintegeri_v", unsafe{if transmute::<_, *const c_void>(self.getintegeri_v) == (dummy_pfnglgetintegeri_vproc as *const c_void) {&null::<PFNGLGETINTEGERI_VPROC>()} else {&self.getintegeri_v}})
			.field("enablei", unsafe{if transmute::<_, *const c_void>(self.enablei) == (dummy_pfnglenableiproc as *const c_void) {&null::<PFNGLENABLEIPROC>()} else {&self.enablei}})
			.field("disablei", unsafe{if transmute::<_, *const c_void>(self.disablei) == (dummy_pfngldisableiproc as *const c_void) {&null::<PFNGLDISABLEIPROC>()} else {&self.disablei}})
			.field("isenabledi", unsafe{if transmute::<_, *const c_void>(self.isenabledi) == (dummy_pfnglisenablediproc as *const c_void) {&null::<PFNGLISENABLEDIPROC>()} else {&self.isenabledi}})
			.field("begintransformfeedback", unsafe{if transmute::<_, *const c_void>(self.begintransformfeedback) == (dummy_pfnglbegintransformfeedbackproc as *const c_void) {&null::<PFNGLBEGINTRANSFORMFEEDBACKPROC>()} else {&self.begintransformfeedback}})
			.field("endtransformfeedback", unsafe{if transmute::<_, *const c_void>(self.endtransformfeedback) == (dummy_pfnglendtransformfeedbackproc as *const c_void) {&null::<PFNGLENDTRANSFORMFEEDBACKPROC>()} else {&self.endtransformfeedback}})
			.field("bindbufferrange", unsafe{if transmute::<_, *const c_void>(self.bindbufferrange) == (dummy_pfnglbindbufferrangeproc as *const c_void) {&null::<PFNGLBINDBUFFERRANGEPROC>()} else {&self.bindbufferrange}})
			.field("bindbufferbase", unsafe{if transmute::<_, *const c_void>(self.bindbufferbase) == (dummy_pfnglbindbufferbaseproc as *const c_void) {&null::<PFNGLBINDBUFFERBASEPROC>()} else {&self.bindbufferbase}})
			.field("transformfeedbackvaryings", unsafe{if transmute::<_, *const c_void>(self.transformfeedbackvaryings) == (dummy_pfngltransformfeedbackvaryingsproc as *const c_void) {&null::<PFNGLTRANSFORMFEEDBACKVARYINGSPROC>()} else {&self.transformfeedbackvaryings}})
			.field("gettransformfeedbackvarying", unsafe{if transmute::<_, *const c_void>(self.gettransformfeedbackvarying) == (dummy_pfnglgettransformfeedbackvaryingproc as *const c_void) {&null::<PFNGLGETTRANSFORMFEEDBACKVARYINGPROC>()} else {&self.gettransformfeedbackvarying}})
			.field("clampcolor", unsafe{if transmute::<_, *const c_void>(self.clampcolor) == (dummy_pfnglclampcolorproc as *const c_void) {&null::<PFNGLCLAMPCOLORPROC>()} else {&self.clampcolor}})
			.field("beginconditionalrender", unsafe{if transmute::<_, *const c_void>(self.beginconditionalrender) == (dummy_pfnglbeginconditionalrenderproc as *const c_void) {&null::<PFNGLBEGINCONDITIONALRENDERPROC>()} else {&self.beginconditionalrender}})
			.field("endconditionalrender", unsafe{if transmute::<_, *const c_void>(self.endconditionalrender) == (dummy_pfnglendconditionalrenderproc as *const c_void) {&null::<PFNGLENDCONDITIONALRENDERPROC>()} else {&self.endconditionalrender}})
			.field("vertexattribipointer", unsafe{if transmute::<_, *const c_void>(self.vertexattribipointer) == (dummy_pfnglvertexattribipointerproc as *const c_void) {&null::<PFNGLVERTEXATTRIBIPOINTERPROC>()} else {&self.vertexattribipointer}})
			.field("getvertexattribiiv", unsafe{if transmute::<_, *const c_void>(self.getvertexattribiiv) == (dummy_pfnglgetvertexattribiivproc as *const c_void) {&null::<PFNGLGETVERTEXATTRIBIIVPROC>()} else {&self.getvertexattribiiv}})
			.field("getvertexattribiuiv", unsafe{if transmute::<_, *const c_void>(self.getvertexattribiuiv) == (dummy_pfnglgetvertexattribiuivproc as *const c_void) {&null::<PFNGLGETVERTEXATTRIBIUIVPROC>()} else {&self.getvertexattribiuiv}})
			.field("vertexattribi1i", unsafe{if transmute::<_, *const c_void>(self.vertexattribi1i) == (dummy_pfnglvertexattribi1iproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI1IPROC>()} else {&self.vertexattribi1i}})
			.field("vertexattribi2i", unsafe{if transmute::<_, *const c_void>(self.vertexattribi2i) == (dummy_pfnglvertexattribi2iproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI2IPROC>()} else {&self.vertexattribi2i}})
			.field("vertexattribi3i", unsafe{if transmute::<_, *const c_void>(self.vertexattribi3i) == (dummy_pfnglvertexattribi3iproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI3IPROC>()} else {&self.vertexattribi3i}})
			.field("vertexattribi4i", unsafe{if transmute::<_, *const c_void>(self.vertexattribi4i) == (dummy_pfnglvertexattribi4iproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI4IPROC>()} else {&self.vertexattribi4i}})
			.field("vertexattribi1ui", unsafe{if transmute::<_, *const c_void>(self.vertexattribi1ui) == (dummy_pfnglvertexattribi1uiproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI1UIPROC>()} else {&self.vertexattribi1ui}})
			.field("vertexattribi2ui", unsafe{if transmute::<_, *const c_void>(self.vertexattribi2ui) == (dummy_pfnglvertexattribi2uiproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI2UIPROC>()} else {&self.vertexattribi2ui}})
			.field("vertexattribi3ui", unsafe{if transmute::<_, *const c_void>(self.vertexattribi3ui) == (dummy_pfnglvertexattribi3uiproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI3UIPROC>()} else {&self.vertexattribi3ui}})
			.field("vertexattribi4ui", unsafe{if transmute::<_, *const c_void>(self.vertexattribi4ui) == (dummy_pfnglvertexattribi4uiproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI4UIPROC>()} else {&self.vertexattribi4ui}})
			.field("vertexattribi1iv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi1iv) == (dummy_pfnglvertexattribi1ivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI1IVPROC>()} else {&self.vertexattribi1iv}})
			.field("vertexattribi2iv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi2iv) == (dummy_pfnglvertexattribi2ivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI2IVPROC>()} else {&self.vertexattribi2iv}})
			.field("vertexattribi3iv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi3iv) == (dummy_pfnglvertexattribi3ivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI3IVPROC>()} else {&self.vertexattribi3iv}})
			.field("vertexattribi4iv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi4iv) == (dummy_pfnglvertexattribi4ivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI4IVPROC>()} else {&self.vertexattribi4iv}})
			.field("vertexattribi1uiv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi1uiv) == (dummy_pfnglvertexattribi1uivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI1UIVPROC>()} else {&self.vertexattribi1uiv}})
			.field("vertexattribi2uiv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi2uiv) == (dummy_pfnglvertexattribi2uivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI2UIVPROC>()} else {&self.vertexattribi2uiv}})
			.field("vertexattribi3uiv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi3uiv) == (dummy_pfnglvertexattribi3uivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI3UIVPROC>()} else {&self.vertexattribi3uiv}})
			.field("vertexattribi4uiv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi4uiv) == (dummy_pfnglvertexattribi4uivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI4UIVPROC>()} else {&self.vertexattribi4uiv}})
			.field("vertexattribi4bv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi4bv) == (dummy_pfnglvertexattribi4bvproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI4BVPROC>()} else {&self.vertexattribi4bv}})
			.field("vertexattribi4sv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi4sv) == (dummy_pfnglvertexattribi4svproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI4SVPROC>()} else {&self.vertexattribi4sv}})
			.field("vertexattribi4ubv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi4ubv) == (dummy_pfnglvertexattribi4ubvproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI4UBVPROC>()} else {&self.vertexattribi4ubv}})
			.field("vertexattribi4usv", unsafe{if transmute::<_, *const c_void>(self.vertexattribi4usv) == (dummy_pfnglvertexattribi4usvproc as *const c_void) {&null::<PFNGLVERTEXATTRIBI4USVPROC>()} else {&self.vertexattribi4usv}})
			.field("getuniformuiv", unsafe{if transmute::<_, *const c_void>(self.getuniformuiv) == (dummy_pfnglgetuniformuivproc as *const c_void) {&null::<PFNGLGETUNIFORMUIVPROC>()} else {&self.getuniformuiv}})
			.field("bindfragdatalocation", unsafe{if transmute::<_, *const c_void>(self.bindfragdatalocation) == (dummy_pfnglbindfragdatalocationproc as *const c_void) {&null::<PFNGLBINDFRAGDATALOCATIONPROC>()} else {&self.bindfragdatalocation}})
			.field("getfragdatalocation", unsafe{if transmute::<_, *const c_void>(self.getfragdatalocation) == (dummy_pfnglgetfragdatalocationproc as *const c_void) {&null::<PFNGLGETFRAGDATALOCATIONPROC>()} else {&self.getfragdatalocation}})
			.field("uniform1ui", unsafe{if transmute::<_, *const c_void>(self.uniform1ui) == (dummy_pfngluniform1uiproc as *const c_void) {&null::<PFNGLUNIFORM1UIPROC>()} else {&self.uniform1ui}})
			.field("uniform2ui", unsafe{if transmute::<_, *const c_void>(self.uniform2ui) == (dummy_pfngluniform2uiproc as *const c_void) {&null::<PFNGLUNIFORM2UIPROC>()} else {&self.uniform2ui}})
			.field("uniform3ui", unsafe{if transmute::<_, *const c_void>(self.uniform3ui) == (dummy_pfngluniform3uiproc as *const c_void) {&null::<PFNGLUNIFORM3UIPROC>()} else {&self.uniform3ui}})
			.field("uniform4ui", unsafe{if transmute::<_, *const c_void>(self.uniform4ui) == (dummy_pfngluniform4uiproc as *const c_void) {&null::<PFNGLUNIFORM4UIPROC>()} else {&self.uniform4ui}})
			.field("uniform1uiv", unsafe{if transmute::<_, *const c_void>(self.uniform1uiv) == (dummy_pfngluniform1uivproc as *const c_void) {&null::<PFNGLUNIFORM1UIVPROC>()} else {&self.uniform1uiv}})
			.field("uniform2uiv", unsafe{if transmute::<_, *const c_void>(self.uniform2uiv) == (dummy_pfngluniform2uivproc as *const c_void) {&null::<PFNGLUNIFORM2UIVPROC>()} else {&self.uniform2uiv}})
			.field("uniform3uiv", unsafe{if transmute::<_, *const c_void>(self.uniform3uiv) == (dummy_pfngluniform3uivproc as *const c_void) {&null::<PFNGLUNIFORM3UIVPROC>()} else {&self.uniform3uiv}})
			.field("uniform4uiv", unsafe{if transmute::<_, *const c_void>(self.uniform4uiv) == (dummy_pfngluniform4uivproc as *const c_void) {&null::<PFNGLUNIFORM4UIVPROC>()} else {&self.uniform4uiv}})
			.field("texparameteriiv", unsafe{if transmute::<_, *const c_void>(self.texparameteriiv) == (dummy_pfngltexparameteriivproc as *const c_void) {&null::<PFNGLTEXPARAMETERIIVPROC>()} else {&self.texparameteriiv}})
			.field("texparameteriuiv", unsafe{if transmute::<_, *const c_void>(self.texparameteriuiv) == (dummy_pfngltexparameteriuivproc as *const c_void) {&null::<PFNGLTEXPARAMETERIUIVPROC>()} else {&self.texparameteriuiv}})
			.field("gettexparameteriiv", unsafe{if transmute::<_, *const c_void>(self.gettexparameteriiv) == (dummy_pfnglgettexparameteriivproc as *const c_void) {&null::<PFNGLGETTEXPARAMETERIIVPROC>()} else {&self.gettexparameteriiv}})
			.field("gettexparameteriuiv", unsafe{if transmute::<_, *const c_void>(self.gettexparameteriuiv) == (dummy_pfnglgettexparameteriuivproc as *const c_void) {&null::<PFNGLGETTEXPARAMETERIUIVPROC>()} else {&self.gettexparameteriuiv}})
			.field("clearbufferiv", unsafe{if transmute::<_, *const c_void>(self.clearbufferiv) == (dummy_pfnglclearbufferivproc as *const c_void) {&null::<PFNGLCLEARBUFFERIVPROC>()} else {&self.clearbufferiv}})
			.field("clearbufferuiv", unsafe{if transmute::<_, *const c_void>(self.clearbufferuiv) == (dummy_pfnglclearbufferuivproc as *const c_void) {&null::<PFNGLCLEARBUFFERUIVPROC>()} else {&self.clearbufferuiv}})
			.field("clearbufferfv", unsafe{if transmute::<_, *const c_void>(self.clearbufferfv) == (dummy_pfnglclearbufferfvproc as *const c_void) {&null::<PFNGLCLEARBUFFERFVPROC>()} else {&self.clearbufferfv}})
			.field("clearbufferfi", unsafe{if transmute::<_, *const c_void>(self.clearbufferfi) == (dummy_pfnglclearbufferfiproc as *const c_void) {&null::<PFNGLCLEARBUFFERFIPROC>()} else {&self.clearbufferfi}})
			.field("getstringi", unsafe{if transmute::<_, *const c_void>(self.getstringi) == (dummy_pfnglgetstringiproc as *const c_void) {&null::<PFNGLGETSTRINGIPROC>()} else {&self.getstringi}})
			.field("isrenderbuffer", unsafe{if transmute::<_, *const c_void>(self.isrenderbuffer) == (dummy_pfnglisrenderbufferproc as *const c_void) {&null::<PFNGLISRENDERBUFFERPROC>()} else {&self.isrenderbuffer}})
			.field("bindrenderbuffer", unsafe{if transmute::<_, *const c_void>(self.bindrenderbuffer) == (dummy_pfnglbindrenderbufferproc as *const c_void) {&null::<PFNGLBINDRENDERBUFFERPROC>()} else {&self.bindrenderbuffer}})
			.field("deleterenderbuffers", unsafe{if transmute::<_, *const c_void>(self.deleterenderbuffers) == (dummy_pfngldeleterenderbuffersproc as *const c_void) {&null::<PFNGLDELETERENDERBUFFERSPROC>()} else {&self.deleterenderbuffers}})
			.field("genrenderbuffers", unsafe{if transmute::<_, *const c_void>(self.genrenderbuffers) == (dummy_pfnglgenrenderbuffersproc as *const c_void) {&null::<PFNGLGENRENDERBUFFERSPROC>()} else {&self.genrenderbuffers}})
			.field("renderbufferstorage", unsafe{if transmute::<_, *const c_void>(self.renderbufferstorage) == (dummy_pfnglrenderbufferstorageproc as *const c_void) {&null::<PFNGLRENDERBUFFERSTORAGEPROC>()} else {&self.renderbufferstorage}})
			.field("getrenderbufferparameteriv", unsafe{if transmute::<_, *const c_void>(self.getrenderbufferparameteriv) == (dummy_pfnglgetrenderbufferparameterivproc as *const c_void) {&null::<PFNGLGETRENDERBUFFERPARAMETERIVPROC>()} else {&self.getrenderbufferparameteriv}})
			.field("isframebuffer", unsafe{if transmute::<_, *const c_void>(self.isframebuffer) == (dummy_pfnglisframebufferproc as *const c_void) {&null::<PFNGLISFRAMEBUFFERPROC>()} else {&self.isframebuffer}})
			.field("bindframebuffer", unsafe{if transmute::<_, *const c_void>(self.bindframebuffer) == (dummy_pfnglbindframebufferproc as *const c_void) {&null::<PFNGLBINDFRAMEBUFFERPROC>()} else {&self.bindframebuffer}})
			.field("deleteframebuffers", unsafe{if transmute::<_, *const c_void>(self.deleteframebuffers) == (dummy_pfngldeleteframebuffersproc as *const c_void) {&null::<PFNGLDELETEFRAMEBUFFERSPROC>()} else {&self.deleteframebuffers}})
			.field("genframebuffers", unsafe{if transmute::<_, *const c_void>(self.genframebuffers) == (dummy_pfnglgenframebuffersproc as *const c_void) {&null::<PFNGLGENFRAMEBUFFERSPROC>()} else {&self.genframebuffers}})
			.field("checkframebufferstatus", unsafe{if transmute::<_, *const c_void>(self.checkframebufferstatus) == (dummy_pfnglcheckframebufferstatusproc as *const c_void) {&null::<PFNGLCHECKFRAMEBUFFERSTATUSPROC>()} else {&self.checkframebufferstatus}})
			.field("framebuffertexture1d", unsafe{if transmute::<_, *const c_void>(self.framebuffertexture1d) == (dummy_pfnglframebuffertexture1dproc as *const c_void) {&null::<PFNGLFRAMEBUFFERTEXTURE1DPROC>()} else {&self.framebuffertexture1d}})
			.field("framebuffertexture2d", unsafe{if transmute::<_, *const c_void>(self.framebuffertexture2d) == (dummy_pfnglframebuffertexture2dproc as *const c_void) {&null::<PFNGLFRAMEBUFFERTEXTURE2DPROC>()} else {&self.framebuffertexture2d}})
			.field("framebuffertexture3d", unsafe{if transmute::<_, *const c_void>(self.framebuffertexture3d) == (dummy_pfnglframebuffertexture3dproc as *const c_void) {&null::<PFNGLFRAMEBUFFERTEXTURE3DPROC>()} else {&self.framebuffertexture3d}})
			.field("framebufferrenderbuffer", unsafe{if transmute::<_, *const c_void>(self.framebufferrenderbuffer) == (dummy_pfnglframebufferrenderbufferproc as *const c_void) {&null::<PFNGLFRAMEBUFFERRENDERBUFFERPROC>()} else {&self.framebufferrenderbuffer}})
			.field("getframebufferattachmentparameteriv", unsafe{if transmute::<_, *const c_void>(self.getframebufferattachmentparameteriv) == (dummy_pfnglgetframebufferattachmentparameterivproc as *const c_void) {&null::<PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC>()} else {&self.getframebufferattachmentparameteriv}})
			.field("generatemipmap", unsafe{if transmute::<_, *const c_void>(self.generatemipmap) == (dummy_pfnglgeneratemipmapproc as *const c_void) {&null::<PFNGLGENERATEMIPMAPPROC>()} else {&self.generatemipmap}})
			.field("blitframebuffer", unsafe{if transmute::<_, *const c_void>(self.blitframebuffer) == (dummy_pfnglblitframebufferproc as *const c_void) {&null::<PFNGLBLITFRAMEBUFFERPROC>()} else {&self.blitframebuffer}})
			.field("renderbufferstoragemultisample", unsafe{if transmute::<_, *const c_void>(self.renderbufferstoragemultisample) == (dummy_pfnglrenderbufferstoragemultisampleproc as *const c_void) {&null::<PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC>()} else {&self.renderbufferstoragemultisample}})
			.field("framebuffertexturelayer", unsafe{if transmute::<_, *const c_void>(self.framebuffertexturelayer) == (dummy_pfnglframebuffertexturelayerproc as *const c_void) {&null::<PFNGLFRAMEBUFFERTEXTURELAYERPROC>()} else {&self.framebuffertexturelayer}})
			.field("mapbufferrange", unsafe{if transmute::<_, *const c_void>(self.mapbufferrange) == (dummy_pfnglmapbufferrangeproc as *const c_void) {&null::<PFNGLMAPBUFFERRANGEPROC>()} else {&self.mapbufferrange}})
			.field("flushmappedbufferrange", unsafe{if transmute::<_, *const c_void>(self.flushmappedbufferrange) == (dummy_pfnglflushmappedbufferrangeproc as *const c_void) {&null::<PFNGLFLUSHMAPPEDBUFFERRANGEPROC>()} else {&self.flushmappedbufferrange}})
			.field("bindvertexarray", unsafe{if transmute::<_, *const c_void>(self.bindvertexarray) == (dummy_pfnglbindvertexarrayproc as *const c_void) {&null::<PFNGLBINDVERTEXARRAYPROC>()} else {&self.bindvertexarray}})
			.field("deletevertexarrays", unsafe{if transmute::<_, *const c_void>(self.deletevertexarrays) == (dummy_pfngldeletevertexarraysproc as *const c_void) {&null::<PFNGLDELETEVERTEXARRAYSPROC>()} else {&self.deletevertexarrays}})
			.field("genvertexarrays", unsafe{if transmute::<_, *const c_void>(self.genvertexarrays) == (dummy_pfnglgenvertexarraysproc as *const c_void) {&null::<PFNGLGENVERTEXARRAYSPROC>()} else {&self.genvertexarrays}})
			.field("isvertexarray", unsafe{if transmute::<_, *const c_void>(self.isvertexarray) == (dummy_pfnglisvertexarrayproc as *const c_void) {&null::<PFNGLISVERTEXARRAYPROC>()} else {&self.isvertexarray}})
			.finish()
		} else {
			f.debug_struct("Version30")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}
type PFNGLDRAWARRAYSINSTANCEDPROC = extern "system" fn(GLenum, GLint, GLsizei, GLsizei);
type PFNGLDRAWELEMENTSINSTANCEDPROC = extern "system" fn(GLenum, GLsizei, GLenum, *const c_void, GLsizei);
type PFNGLTEXBUFFERPROC = extern "system" fn(GLenum, GLenum, GLuint);
type PFNGLPRIMITIVERESTARTINDEXPROC = extern "system" fn(GLuint);
type PFNGLCOPYBUFFERSUBDATAPROC = extern "system" fn(GLenum, GLenum, GLintptr, GLintptr, GLsizeiptr);
type PFNGLGETUNIFORMINDICESPROC = extern "system" fn(GLuint, GLsizei, *const *const GLchar, *mut GLuint);
type PFNGLGETACTIVEUNIFORMSIVPROC = extern "system" fn(GLuint, GLsizei, *const GLuint, GLenum, *mut GLint);
type PFNGLGETACTIVEUNIFORMNAMEPROC = extern "system" fn(GLuint, GLuint, GLsizei, *mut GLsizei, *mut GLchar);
type PFNGLGETUNIFORMBLOCKINDEXPROC = extern "system" fn(GLuint, *const GLchar) -> GLuint;
type PFNGLGETACTIVEUNIFORMBLOCKIVPROC = extern "system" fn(GLuint, GLuint, GLenum, *mut GLint);
type PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC = extern "system" fn(GLuint, GLuint, GLsizei, *mut GLsizei, *mut GLchar);
type PFNGLUNIFORMBLOCKBINDINGPROC = extern "system" fn(GLuint, GLuint, GLuint);
extern "system" fn dummy_pfngldrawarraysinstancedproc (_: GLenum, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glDrawArraysInstanced()` is null.")
}
extern "system" fn dummy_pfngldrawelementsinstancedproc (_: GLenum, _: GLsizei, _: GLenum, _: *const c_void, _: GLsizei) {
	panic!("OpenGL function pointer `glDrawElementsInstanced()` is null.")
}
extern "system" fn dummy_pfngltexbufferproc (_: GLenum, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glTexBuffer()` is null.")
}
extern "system" fn dummy_pfnglprimitiverestartindexproc (_: GLuint) {
	panic!("OpenGL function pointer `glPrimitiveRestartIndex()` is null.")
}
extern "system" fn dummy_pfnglcopybuffersubdataproc (_: GLenum, _: GLenum, _: GLintptr, _: GLintptr, _: GLsizeiptr) {
	panic!("OpenGL function pointer `glCopyBufferSubData()` is null.")
}
extern "system" fn dummy_pfnglgetuniformindicesproc (_: GLuint, _: GLsizei, _: *const *const GLchar, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetUniformIndices()` is null.")
}
extern "system" fn dummy_pfnglgetactiveuniformsivproc (_: GLuint, _: GLsizei, _: *const GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetActiveUniformsiv()` is null.")
}
extern "system" fn dummy_pfnglgetactiveuniformnameproc (_: GLuint, _: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetActiveUniformName()` is null.")
}
extern "system" fn dummy_pfnglgetuniformblockindexproc (_: GLuint, _: *const GLchar) -> GLuint {
	panic!("OpenGL function pointer `glGetUniformBlockIndex()` is null.")
}
extern "system" fn dummy_pfnglgetactiveuniformblockivproc (_: GLuint, _: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetActiveUniformBlockiv()` is null.")
}
extern "system" fn dummy_pfnglgetactiveuniformblocknameproc (_: GLuint, _: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetActiveUniformBlockName()` is null.")
}
extern "system" fn dummy_pfngluniformblockbindingproc (_: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glUniformBlockBinding()` is null.")
}
pub const GL_SAMPLER_2D_RECT: GLenum = 0x8B63;
pub const GL_SAMPLER_2D_RECT_SHADOW: GLenum = 0x8B64;
pub const GL_SAMPLER_BUFFER: GLenum = 0x8DC2;
pub const GL_INT_SAMPLER_2D_RECT: GLenum = 0x8DCD;
pub const GL_INT_SAMPLER_BUFFER: GLenum = 0x8DD0;
pub const GL_UNSIGNED_INT_SAMPLER_2D_RECT: GLenum = 0x8DD5;
pub const GL_UNSIGNED_INT_SAMPLER_BUFFER: GLenum = 0x8DD8;
pub const GL_TEXTURE_BUFFER: GLenum = 0x8C2A;
pub const GL_MAX_TEXTURE_BUFFER_SIZE: GLenum = 0x8C2B;
pub const GL_TEXTURE_BINDING_BUFFER: GLenum = 0x8C2C;
pub const GL_TEXTURE_BUFFER_DATA_STORE_BINDING: GLenum = 0x8C2D;
pub const GL_TEXTURE_RECTANGLE: GLenum = 0x84F5;
pub const GL_TEXTURE_BINDING_RECTANGLE: GLenum = 0x84F6;
pub const GL_PROXY_TEXTURE_RECTANGLE: GLenum = 0x84F7;
pub const GL_MAX_RECTANGLE_TEXTURE_SIZE: GLenum = 0x84F8;
pub const GL_R8_SNORM: GLenum = 0x8F94;
pub const GL_RG8_SNORM: GLenum = 0x8F95;
pub const GL_RGB8_SNORM: GLenum = 0x8F96;
pub const GL_RGBA8_SNORM: GLenum = 0x8F97;
pub const GL_R16_SNORM: GLenum = 0x8F98;
pub const GL_RG16_SNORM: GLenum = 0x8F99;
pub const GL_RGB16_SNORM: GLenum = 0x8F9A;
pub const GL_RGBA16_SNORM: GLenum = 0x8F9B;
pub const GL_SIGNED_NORMALIZED: GLenum = 0x8F9C;
pub const GL_PRIMITIVE_RESTART: GLenum = 0x8F9D;
pub const GL_PRIMITIVE_RESTART_INDEX: GLenum = 0x8F9E;
pub const GL_COPY_READ_BUFFER: GLenum = 0x8F36;
pub const GL_COPY_WRITE_BUFFER: GLenum = 0x8F37;
pub const GL_UNIFORM_BUFFER: GLenum = 0x8A11;
pub const GL_UNIFORM_BUFFER_BINDING: GLenum = 0x8A28;
pub const GL_UNIFORM_BUFFER_START: GLenum = 0x8A29;
pub const GL_UNIFORM_BUFFER_SIZE: GLenum = 0x8A2A;
pub const GL_MAX_VERTEX_UNIFORM_BLOCKS: GLenum = 0x8A2B;
pub const GL_MAX_GEOMETRY_UNIFORM_BLOCKS: GLenum = 0x8A2C;
pub const GL_MAX_FRAGMENT_UNIFORM_BLOCKS: GLenum = 0x8A2D;
pub const GL_MAX_COMBINED_UNIFORM_BLOCKS: GLenum = 0x8A2E;
pub const GL_MAX_UNIFORM_BUFFER_BINDINGS: GLenum = 0x8A2F;
pub const GL_MAX_UNIFORM_BLOCK_SIZE: GLenum = 0x8A30;
pub const GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: GLenum = 0x8A31;
pub const GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS: GLenum = 0x8A32;
pub const GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: GLenum = 0x8A33;
pub const GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT: GLenum = 0x8A34;
pub const GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH: GLenum = 0x8A35;
pub const GL_ACTIVE_UNIFORM_BLOCKS: GLenum = 0x8A36;
pub const GL_UNIFORM_TYPE: GLenum = 0x8A37;
pub const GL_UNIFORM_SIZE: GLenum = 0x8A38;
pub const GL_UNIFORM_NAME_LENGTH: GLenum = 0x8A39;
pub const GL_UNIFORM_BLOCK_INDEX: GLenum = 0x8A3A;
pub const GL_UNIFORM_OFFSET: GLenum = 0x8A3B;
pub const GL_UNIFORM_ARRAY_STRIDE: GLenum = 0x8A3C;
pub const GL_UNIFORM_MATRIX_STRIDE: GLenum = 0x8A3D;
pub const GL_UNIFORM_IS_ROW_MAJOR: GLenum = 0x8A3E;
pub const GL_UNIFORM_BLOCK_BINDING: GLenum = 0x8A3F;
pub const GL_UNIFORM_BLOCK_DATA_SIZE: GLenum = 0x8A40;
pub const GL_UNIFORM_BLOCK_NAME_LENGTH: GLenum = 0x8A41;
pub const GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS: GLenum = 0x8A42;
pub const GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: GLenum = 0x8A43;
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: GLenum = 0x8A44;
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER: GLenum = 0x8A45;
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: GLenum = 0x8A46;
pub const GL_INVALID_INDEX: GLuint = 0xFFFFFFFFu32;

pub trait GL_3_1 {
	fn glGetError(&self) -> GLenum;
	fn glDrawArraysInstanced(&self, mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei) -> Result<()>;
	fn glDrawElementsInstanced(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei) -> Result<()>;
	fn glTexBuffer(&self, target: GLenum, internalformat: GLenum, buffer: GLuint) -> Result<()>;
	fn glPrimitiveRestartIndex(&self, index: GLuint) -> Result<()>;
	fn glCopyBufferSubData(&self, readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr) -> Result<()>;
	fn glGetUniformIndices(&self, program: GLuint, uniformCount: GLsizei, uniformNames: *const *const GLchar, uniformIndices: *mut GLuint) -> Result<()>;
	fn glGetActiveUniformsiv(&self, program: GLuint, uniformCount: GLsizei, uniformIndices: *const GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glGetActiveUniformName(&self, program: GLuint, uniformIndex: GLuint, bufSize: GLsizei, length: *mut GLsizei, uniformName: *mut GLchar) -> Result<()>;
	fn glGetUniformBlockIndex(&self, program: GLuint, uniformBlockName: *const GLchar) -> Result<GLuint>;
	fn glGetActiveUniformBlockiv(&self, program: GLuint, uniformBlockIndex: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glGetActiveUniformBlockName(&self, program: GLuint, uniformBlockIndex: GLuint, bufSize: GLsizei, length: *mut GLsizei, uniformBlockName: *mut GLchar) -> Result<()>;
	fn glUniformBlockBinding(&self, program: GLuint, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint) -> Result<()>;
}

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version31 {
	available: bool,
	geterror: PFNGLGETERRORPROC,
	drawarraysinstanced: PFNGLDRAWARRAYSINSTANCEDPROC,
	drawelementsinstanced: PFNGLDRAWELEMENTSINSTANCEDPROC,
	texbuffer: PFNGLTEXBUFFERPROC,
	primitiverestartindex: PFNGLPRIMITIVERESTARTINDEXPROC,
	copybuffersubdata: PFNGLCOPYBUFFERSUBDATAPROC,
	getuniformindices: PFNGLGETUNIFORMINDICESPROC,
	getactiveuniformsiv: PFNGLGETACTIVEUNIFORMSIVPROC,
	getactiveuniformname: PFNGLGETACTIVEUNIFORMNAMEPROC,
	getuniformblockindex: PFNGLGETUNIFORMBLOCKINDEXPROC,
	getactiveuniformblockiv: PFNGLGETACTIVEUNIFORMBLOCKIVPROC,
	getactiveuniformblockname: PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC,
	uniformblockbinding: PFNGLUNIFORMBLOCKBINDINGPROC,
}

impl GL_3_1 for Version31 {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	#[inline(always)]
	fn glDrawArraysInstanced(&self, mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawArraysInstanced", catch_unwind(||(self.drawarraysinstanced)(mode, first, count, instancecount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawArraysInstanced", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawElementsInstanced(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawElementsInstanced", catch_unwind(||(self.drawelementsinstanced)(mode, count, type_, indices, instancecount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsInstanced", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexBuffer(&self, target: GLenum, internalformat: GLenum, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glTexBuffer", catch_unwind(||(self.texbuffer)(target, internalformat, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPrimitiveRestartIndex(&self, index: GLuint) -> Result<()> {
		let ret = process_catch("glPrimitiveRestartIndex", catch_unwind(||(self.primitiverestartindex)(index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPrimitiveRestartIndex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyBufferSubData(&self, readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glCopyBufferSubData", catch_unwind(||(self.copybuffersubdata)(readTarget, writeTarget, readOffset, writeOffset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyBufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetUniformIndices(&self, program: GLuint, uniformCount: GLsizei, uniformNames: *const *const GLchar, uniformIndices: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetUniformIndices", catch_unwind(||(self.getuniformindices)(program, uniformCount, uniformNames, uniformIndices)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformIndices", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveUniformsiv(&self, program: GLuint, uniformCount: GLsizei, uniformIndices: *const GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetActiveUniformsiv", catch_unwind(||(self.getactiveuniformsiv)(program, uniformCount, uniformIndices, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniformsiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveUniformName(&self, program: GLuint, uniformIndex: GLuint, bufSize: GLsizei, length: *mut GLsizei, uniformName: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveUniformName", catch_unwind(||(self.getactiveuniformname)(program, uniformIndex, bufSize, length, uniformName)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniformName", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetUniformBlockIndex(&self, program: GLuint, uniformBlockName: *const GLchar) -> Result<GLuint> {
		let ret = process_catch("glGetUniformBlockIndex", catch_unwind(||(self.getuniformblockindex)(program, uniformBlockName)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformBlockIndex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveUniformBlockiv(&self, program: GLuint, uniformBlockIndex: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetActiveUniformBlockiv", catch_unwind(||(self.getactiveuniformblockiv)(program, uniformBlockIndex, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniformBlockiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveUniformBlockName(&self, program: GLuint, uniformBlockIndex: GLuint, bufSize: GLsizei, length: *mut GLsizei, uniformBlockName: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveUniformBlockName", catch_unwind(||(self.getactiveuniformblockname)(program, uniformBlockIndex, bufSize, length, uniformBlockName)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniformBlockName", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformBlockBinding(&self, program: GLuint, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint) -> Result<()> {
		let ret = process_catch("glUniformBlockBinding", catch_unwind(||(self.uniformblockbinding)(program, uniformBlockIndex, uniformBlockBinding)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformBlockBinding", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version31 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (3, 1, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			drawarraysinstanced: {let proc = get_proc_address("glDrawArraysInstanced"); if proc == null() {dummy_pfngldrawarraysinstancedproc} else {unsafe{transmute(proc)}}},
			drawelementsinstanced: {let proc = get_proc_address("glDrawElementsInstanced"); if proc == null() {dummy_pfngldrawelementsinstancedproc} else {unsafe{transmute(proc)}}},
			texbuffer: {let proc = get_proc_address("glTexBuffer"); if proc == null() {dummy_pfngltexbufferproc} else {unsafe{transmute(proc)}}},
			primitiverestartindex: {let proc = get_proc_address("glPrimitiveRestartIndex"); if proc == null() {dummy_pfnglprimitiverestartindexproc} else {unsafe{transmute(proc)}}},
			copybuffersubdata: {let proc = get_proc_address("glCopyBufferSubData"); if proc == null() {dummy_pfnglcopybuffersubdataproc} else {unsafe{transmute(proc)}}},
			getuniformindices: {let proc = get_proc_address("glGetUniformIndices"); if proc == null() {dummy_pfnglgetuniformindicesproc} else {unsafe{transmute(proc)}}},
			getactiveuniformsiv: {let proc = get_proc_address("glGetActiveUniformsiv"); if proc == null() {dummy_pfnglgetactiveuniformsivproc} else {unsafe{transmute(proc)}}},
			getactiveuniformname: {let proc = get_proc_address("glGetActiveUniformName"); if proc == null() {dummy_pfnglgetactiveuniformnameproc} else {unsafe{transmute(proc)}}},
			getuniformblockindex: {let proc = get_proc_address("glGetUniformBlockIndex"); if proc == null() {dummy_pfnglgetuniformblockindexproc} else {unsafe{transmute(proc)}}},
			getactiveuniformblockiv: {let proc = get_proc_address("glGetActiveUniformBlockiv"); if proc == null() {dummy_pfnglgetactiveuniformblockivproc} else {unsafe{transmute(proc)}}},
			getactiveuniformblockname: {let proc = get_proc_address("glGetActiveUniformBlockName"); if proc == null() {dummy_pfnglgetactiveuniformblocknameproc} else {unsafe{transmute(proc)}}},
			uniformblockbinding: {let proc = get_proc_address("glUniformBlockBinding"); if proc == null() {dummy_pfngluniformblockbindingproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version31 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			drawarraysinstanced: dummy_pfngldrawarraysinstancedproc,
			drawelementsinstanced: dummy_pfngldrawelementsinstancedproc,
			texbuffer: dummy_pfngltexbufferproc,
			primitiverestartindex: dummy_pfnglprimitiverestartindexproc,
			copybuffersubdata: dummy_pfnglcopybuffersubdataproc,
			getuniformindices: dummy_pfnglgetuniformindicesproc,
			getactiveuniformsiv: dummy_pfnglgetactiveuniformsivproc,
			getactiveuniformname: dummy_pfnglgetactiveuniformnameproc,
			getuniformblockindex: dummy_pfnglgetuniformblockindexproc,
			getactiveuniformblockiv: dummy_pfnglgetactiveuniformblockivproc,
			getactiveuniformblockname: dummy_pfnglgetactiveuniformblocknameproc,
			uniformblockbinding: dummy_pfngluniformblockbindingproc,
		}
	}
}
impl Debug for Version31 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version31")
			.field("available", &self.available)
			.field("drawarraysinstanced", unsafe{if transmute::<_, *const c_void>(self.drawarraysinstanced) == (dummy_pfngldrawarraysinstancedproc as *const c_void) {&null::<PFNGLDRAWARRAYSINSTANCEDPROC>()} else {&self.drawarraysinstanced}})
			.field("drawelementsinstanced", unsafe{if transmute::<_, *const c_void>(self.drawelementsinstanced) == (dummy_pfngldrawelementsinstancedproc as *const c_void) {&null::<PFNGLDRAWELEMENTSINSTANCEDPROC>()} else {&self.drawelementsinstanced}})
			.field("texbuffer", unsafe{if transmute::<_, *const c_void>(self.texbuffer) == (dummy_pfngltexbufferproc as *const c_void) {&null::<PFNGLTEXBUFFERPROC>()} else {&self.texbuffer}})
			.field("primitiverestartindex", unsafe{if transmute::<_, *const c_void>(self.primitiverestartindex) == (dummy_pfnglprimitiverestartindexproc as *const c_void) {&null::<PFNGLPRIMITIVERESTARTINDEXPROC>()} else {&self.primitiverestartindex}})
			.field("copybuffersubdata", unsafe{if transmute::<_, *const c_void>(self.copybuffersubdata) == (dummy_pfnglcopybuffersubdataproc as *const c_void) {&null::<PFNGLCOPYBUFFERSUBDATAPROC>()} else {&self.copybuffersubdata}})
			.field("getuniformindices", unsafe{if transmute::<_, *const c_void>(self.getuniformindices) == (dummy_pfnglgetuniformindicesproc as *const c_void) {&null::<PFNGLGETUNIFORMINDICESPROC>()} else {&self.getuniformindices}})
			.field("getactiveuniformsiv", unsafe{if transmute::<_, *const c_void>(self.getactiveuniformsiv) == (dummy_pfnglgetactiveuniformsivproc as *const c_void) {&null::<PFNGLGETACTIVEUNIFORMSIVPROC>()} else {&self.getactiveuniformsiv}})
			.field("getactiveuniformname", unsafe{if transmute::<_, *const c_void>(self.getactiveuniformname) == (dummy_pfnglgetactiveuniformnameproc as *const c_void) {&null::<PFNGLGETACTIVEUNIFORMNAMEPROC>()} else {&self.getactiveuniformname}})
			.field("getuniformblockindex", unsafe{if transmute::<_, *const c_void>(self.getuniformblockindex) == (dummy_pfnglgetuniformblockindexproc as *const c_void) {&null::<PFNGLGETUNIFORMBLOCKINDEXPROC>()} else {&self.getuniformblockindex}})
			.field("getactiveuniformblockiv", unsafe{if transmute::<_, *const c_void>(self.getactiveuniformblockiv) == (dummy_pfnglgetactiveuniformblockivproc as *const c_void) {&null::<PFNGLGETACTIVEUNIFORMBLOCKIVPROC>()} else {&self.getactiveuniformblockiv}})
			.field("getactiveuniformblockname", unsafe{if transmute::<_, *const c_void>(self.getactiveuniformblockname) == (dummy_pfnglgetactiveuniformblocknameproc as *const c_void) {&null::<PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC>()} else {&self.getactiveuniformblockname}})
			.field("uniformblockbinding", unsafe{if transmute::<_, *const c_void>(self.uniformblockbinding) == (dummy_pfngluniformblockbindingproc as *const c_void) {&null::<PFNGLUNIFORMBLOCKBINDINGPROC>()} else {&self.uniformblockbinding}})
			.finish()
		} else {
			f.debug_struct("Version31")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}
pub type GLsync = *mut c_void;
pub type GLuint64 = khronos_uint64_t;
pub type GLint64 = khronos_int64_t;
type PFNGLDRAWELEMENTSBASEVERTEXPROC = extern "system" fn(GLenum, GLsizei, GLenum, *const c_void, GLint);
type PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC = extern "system" fn(GLenum, GLuint, GLuint, GLsizei, GLenum, *const c_void, GLint);
type PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC = extern "system" fn(GLenum, GLsizei, GLenum, *const c_void, GLsizei, GLint);
type PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC = extern "system" fn(GLenum, *const GLsizei, GLenum, *const *const c_void, GLsizei, *const GLint);
type PFNGLPROVOKINGVERTEXPROC = extern "system" fn(GLenum);
type PFNGLFENCESYNCPROC = extern "system" fn(GLenum, GLbitfield) -> GLsync;
type PFNGLISSYNCPROC = extern "system" fn(GLsync) -> GLboolean;
type PFNGLDELETESYNCPROC = extern "system" fn(GLsync);
type PFNGLCLIENTWAITSYNCPROC = extern "system" fn(GLsync, GLbitfield, GLuint64) -> GLenum;
type PFNGLWAITSYNCPROC = extern "system" fn(GLsync, GLbitfield, GLuint64);
type PFNGLGETINTEGER64VPROC = extern "system" fn(GLenum, *mut GLint64);
type PFNGLGETSYNCIVPROC = extern "system" fn(GLsync, GLenum, GLsizei, *mut GLsizei, *mut GLint);
type PFNGLGETINTEGER64I_VPROC = extern "system" fn(GLenum, GLuint, *mut GLint64);
type PFNGLGETBUFFERPARAMETERI64VPROC = extern "system" fn(GLenum, GLenum, *mut GLint64);
type PFNGLFRAMEBUFFERTEXTUREPROC = extern "system" fn(GLenum, GLenum, GLuint, GLint);
type PFNGLTEXIMAGE2DMULTISAMPLEPROC = extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLboolean);
type PFNGLTEXIMAGE3DMULTISAMPLEPROC = extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei, GLboolean);
type PFNGLGETMULTISAMPLEFVPROC = extern "system" fn(GLenum, GLuint, *mut GLfloat);
type PFNGLSAMPLEMASKIPROC = extern "system" fn(GLuint, GLbitfield);
extern "system" fn dummy_pfngldrawelementsbasevertexproc (_: GLenum, _: GLsizei, _: GLenum, _: *const c_void, _: GLint) {
	panic!("OpenGL function pointer `glDrawElementsBaseVertex()` is null.")
}
extern "system" fn dummy_pfngldrawrangeelementsbasevertexproc (_: GLenum, _: GLuint, _: GLuint, _: GLsizei, _: GLenum, _: *const c_void, _: GLint) {
	panic!("OpenGL function pointer `glDrawRangeElementsBaseVertex()` is null.")
}
extern "system" fn dummy_pfngldrawelementsinstancedbasevertexproc (_: GLenum, _: GLsizei, _: GLenum, _: *const c_void, _: GLsizei, _: GLint) {
	panic!("OpenGL function pointer `glDrawElementsInstancedBaseVertex()` is null.")
}
extern "system" fn dummy_pfnglmultidrawelementsbasevertexproc (_: GLenum, _: *const GLsizei, _: GLenum, _: *const *const c_void, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glMultiDrawElementsBaseVertex()` is null.")
}
extern "system" fn dummy_pfnglprovokingvertexproc (_: GLenum) {
	panic!("OpenGL function pointer `glProvokingVertex()` is null.")
}
extern "system" fn dummy_pfnglfencesyncproc (_: GLenum, _: GLbitfield) -> GLsync {
	panic!("OpenGL function pointer `glFenceSync()` is null.")
}
extern "system" fn dummy_pfnglissyncproc (_: GLsync) -> GLboolean {
	panic!("OpenGL function pointer `glIsSync()` is null.")
}
extern "system" fn dummy_pfngldeletesyncproc (_: GLsync) {
	panic!("OpenGL function pointer `glDeleteSync()` is null.")
}
extern "system" fn dummy_pfnglclientwaitsyncproc (_: GLsync, _: GLbitfield, _: GLuint64) -> GLenum {
	panic!("OpenGL function pointer `glClientWaitSync()` is null.")
}
extern "system" fn dummy_pfnglwaitsyncproc (_: GLsync, _: GLbitfield, _: GLuint64) {
	panic!("OpenGL function pointer `glWaitSync()` is null.")
}
extern "system" fn dummy_pfnglgetinteger64vproc (_: GLenum, _: *mut GLint64) {
	panic!("OpenGL function pointer `glGetInteger64v()` is null.")
}
extern "system" fn dummy_pfnglgetsyncivproc (_: GLsync, _: GLenum, _: GLsizei, _: *mut GLsizei, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetSynciv()` is null.")
}
extern "system" fn dummy_pfnglgetinteger64i_vproc (_: GLenum, _: GLuint, _: *mut GLint64) {
	panic!("OpenGL function pointer `glGetInteger64i_v()` is null.")
}
extern "system" fn dummy_pfnglgetbufferparameteri64vproc (_: GLenum, _: GLenum, _: *mut GLint64) {
	panic!("OpenGL function pointer `glGetBufferParameteri64v()` is null.")
}
extern "system" fn dummy_pfnglframebuffertextureproc (_: GLenum, _: GLenum, _: GLuint, _: GLint) {
	panic!("OpenGL function pointer `glFramebufferTexture()` is null.")
}
extern "system" fn dummy_pfnglteximage2dmultisampleproc (_: GLenum, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei, _: GLboolean) {
	panic!("OpenGL function pointer `glTexImage2DMultisample()` is null.")
}
extern "system" fn dummy_pfnglteximage3dmultisampleproc (_: GLenum, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei, _: GLsizei, _: GLboolean) {
	panic!("OpenGL function pointer `glTexImage3DMultisample()` is null.")
}
extern "system" fn dummy_pfnglgetmultisamplefvproc (_: GLenum, _: GLuint, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetMultisamplefv()` is null.")
}
extern "system" fn dummy_pfnglsamplemaskiproc (_: GLuint, _: GLbitfield) {
	panic!("OpenGL function pointer `glSampleMaski()` is null.")
}
pub const GL_CONTEXT_CORE_PROFILE_BIT: GLbitfield = 0x00000001;
pub const GL_CONTEXT_COMPATIBILITY_PROFILE_BIT: GLbitfield = 0x00000002;
pub const GL_LINES_ADJACENCY: GLenum = 0x000A;
pub const GL_LINE_STRIP_ADJACENCY: GLenum = 0x000B;
pub const GL_TRIANGLES_ADJACENCY: GLenum = 0x000C;
pub const GL_TRIANGLE_STRIP_ADJACENCY: GLenum = 0x000D;
pub const GL_PROGRAM_POINT_SIZE: GLenum = 0x8642;
pub const GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS: GLenum = 0x8C29;
pub const GL_FRAMEBUFFER_ATTACHMENT_LAYERED: GLenum = 0x8DA7;
pub const GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS: GLenum = 0x8DA8;
pub const GL_GEOMETRY_SHADER: GLenum = 0x8DD9;
pub const GL_GEOMETRY_VERTICES_OUT: GLenum = 0x8916;
pub const GL_GEOMETRY_INPUT_TYPE: GLenum = 0x8917;
pub const GL_GEOMETRY_OUTPUT_TYPE: GLenum = 0x8918;
pub const GL_MAX_GEOMETRY_UNIFORM_COMPONENTS: GLenum = 0x8DDF;
pub const GL_MAX_GEOMETRY_OUTPUT_VERTICES: GLenum = 0x8DE0;
pub const GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS: GLenum = 0x8DE1;
pub const GL_MAX_VERTEX_OUTPUT_COMPONENTS: GLenum = 0x9122;
pub const GL_MAX_GEOMETRY_INPUT_COMPONENTS: GLenum = 0x9123;
pub const GL_MAX_GEOMETRY_OUTPUT_COMPONENTS: GLenum = 0x9124;
pub const GL_MAX_FRAGMENT_INPUT_COMPONENTS: GLenum = 0x9125;
pub const GL_CONTEXT_PROFILE_MASK: GLenum = 0x9126;
pub const GL_DEPTH_CLAMP: GLenum = 0x864F;
pub const GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION: GLenum = 0x8E4C;
pub const GL_FIRST_VERTEX_CONVENTION: GLenum = 0x8E4D;
pub const GL_LAST_VERTEX_CONVENTION: GLenum = 0x8E4E;
pub const GL_PROVOKING_VERTEX: GLenum = 0x8E4F;
pub const GL_TEXTURE_CUBE_MAP_SEAMLESS: GLenum = 0x884F;
pub const GL_MAX_SERVER_WAIT_TIMEOUT: GLenum = 0x9111;
pub const GL_OBJECT_TYPE: GLenum = 0x9112;
pub const GL_SYNC_CONDITION: GLenum = 0x9113;
pub const GL_SYNC_STATUS: GLenum = 0x9114;
pub const GL_SYNC_FLAGS: GLenum = 0x9115;
pub const GL_SYNC_FENCE: GLenum = 0x9116;
pub const GL_SYNC_GPU_COMMANDS_COMPLETE: GLenum = 0x9117;
pub const GL_UNSIGNALED: GLenum = 0x9118;
pub const GL_SIGNALED: GLenum = 0x9119;
pub const GL_ALREADY_SIGNALED: GLenum = 0x911A;
pub const GL_TIMEOUT_EXPIRED: GLenum = 0x911B;
pub const GL_CONDITION_SATISFIED: GLenum = 0x911C;
pub const GL_WAIT_FAILED: GLenum = 0x911D;
pub const GL_TIMEOUT_IGNORED: GLuint64 = 0xFFFFFFFFFFFFFFFFu64;
pub const GL_SYNC_FLUSH_COMMANDS_BIT: GLbitfield = 0x00000001;
pub const GL_SAMPLE_POSITION: GLenum = 0x8E50;
pub const GL_SAMPLE_MASK: GLenum = 0x8E51;
pub const GL_SAMPLE_MASK_VALUE: GLenum = 0x8E52;
pub const GL_MAX_SAMPLE_MASK_WORDS: GLenum = 0x8E59;
pub const GL_TEXTURE_2D_MULTISAMPLE: GLenum = 0x9100;
pub const GL_PROXY_TEXTURE_2D_MULTISAMPLE: GLenum = 0x9101;
pub const GL_TEXTURE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9102;
pub const GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9103;
pub const GL_TEXTURE_BINDING_2D_MULTISAMPLE: GLenum = 0x9104;
pub const GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY: GLenum = 0x9105;
pub const GL_TEXTURE_SAMPLES: GLenum = 0x9106;
pub const GL_TEXTURE_FIXED_SAMPLE_LOCATIONS: GLenum = 0x9107;
pub const GL_SAMPLER_2D_MULTISAMPLE: GLenum = 0x9108;
pub const GL_INT_SAMPLER_2D_MULTISAMPLE: GLenum = 0x9109;
pub const GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE: GLenum = 0x910A;
pub const GL_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910B;
pub const GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910C;
pub const GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: GLenum = 0x910D;
pub const GL_MAX_COLOR_TEXTURE_SAMPLES: GLenum = 0x910E;
pub const GL_MAX_DEPTH_TEXTURE_SAMPLES: GLenum = 0x910F;
pub const GL_MAX_INTEGER_SAMPLES: GLenum = 0x9110;

pub trait GL_3_2 {
	fn glGetError(&self) -> GLenum;
	fn glDrawElementsBaseVertex(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, basevertex: GLint) -> Result<()>;
	fn glDrawRangeElementsBaseVertex(&self, mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type_: GLenum, indices: *const c_void, basevertex: GLint) -> Result<()>;
	fn glDrawElementsInstancedBaseVertex(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei, basevertex: GLint) -> Result<()>;
	fn glMultiDrawElementsBaseVertex(&self, mode: GLenum, count: *const GLsizei, type_: GLenum, indices: *const *const c_void, drawcount: GLsizei, basevertex: *const GLint) -> Result<()>;
	fn glProvokingVertex(&self, mode: GLenum) -> Result<()>;
	fn glFenceSync(&self, condition: GLenum, flags: GLbitfield) -> Result<GLsync>;
	fn glIsSync(&self, sync: GLsync) -> Result<GLboolean>;
	fn glDeleteSync(&self, sync: GLsync) -> Result<()>;
	fn glClientWaitSync(&self, sync: GLsync, flags: GLbitfield, timeout: GLuint64) -> Result<GLenum>;
	fn glWaitSync(&self, sync: GLsync, flags: GLbitfield, timeout: GLuint64) -> Result<()>;
	fn glGetInteger64v(&self, pname: GLenum, data: *mut GLint64) -> Result<()>;
	fn glGetSynciv(&self, sync: GLsync, pname: GLenum, count: GLsizei, length: *mut GLsizei, values: *mut GLint) -> Result<()>;
	fn glGetInteger64i_v(&self, target: GLenum, index: GLuint, data: *mut GLint64) -> Result<()>;
	fn glGetBufferParameteri64v(&self, target: GLenum, pname: GLenum, params: *mut GLint64) -> Result<()>;
	fn glFramebufferTexture(&self, target: GLenum, attachment: GLenum, texture: GLuint, level: GLint) -> Result<()>;
	fn glTexImage2DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean) -> Result<()>;
	fn glTexImage3DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean) -> Result<()>;
	fn glGetMultisamplefv(&self, pname: GLenum, index: GLuint, val: *mut GLfloat) -> Result<()>;
	fn glSampleMaski(&self, maskNumber: GLuint, mask: GLbitfield) -> Result<()>;
}

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version32 {
	available: bool,
	geterror: PFNGLGETERRORPROC,
	drawelementsbasevertex: PFNGLDRAWELEMENTSBASEVERTEXPROC,
	drawrangeelementsbasevertex: PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC,
	drawelementsinstancedbasevertex: PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC,
	multidrawelementsbasevertex: PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC,
	provokingvertex: PFNGLPROVOKINGVERTEXPROC,
	fencesync: PFNGLFENCESYNCPROC,
	issync: PFNGLISSYNCPROC,
	deletesync: PFNGLDELETESYNCPROC,
	clientwaitsync: PFNGLCLIENTWAITSYNCPROC,
	waitsync: PFNGLWAITSYNCPROC,
	getinteger64v: PFNGLGETINTEGER64VPROC,
	getsynciv: PFNGLGETSYNCIVPROC,
	getinteger64i_v: PFNGLGETINTEGER64I_VPROC,
	getbufferparameteri64v: PFNGLGETBUFFERPARAMETERI64VPROC,
	framebuffertexture: PFNGLFRAMEBUFFERTEXTUREPROC,
	teximage2dmultisample: PFNGLTEXIMAGE2DMULTISAMPLEPROC,
	teximage3dmultisample: PFNGLTEXIMAGE3DMULTISAMPLEPROC,
	getmultisamplefv: PFNGLGETMULTISAMPLEFVPROC,
	samplemaski: PFNGLSAMPLEMASKIPROC,
}

impl GL_3_2 for Version32 {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	#[inline(always)]
	fn glDrawElementsBaseVertex(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, basevertex: GLint) -> Result<()> {
		let ret = process_catch("glDrawElementsBaseVertex", catch_unwind(||(self.drawelementsbasevertex)(mode, count, type_, indices, basevertex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsBaseVertex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawRangeElementsBaseVertex(&self, mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type_: GLenum, indices: *const c_void, basevertex: GLint) -> Result<()> {
		let ret = process_catch("glDrawRangeElementsBaseVertex", catch_unwind(||(self.drawrangeelementsbasevertex)(mode, start, end, count, type_, indices, basevertex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawRangeElementsBaseVertex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawElementsInstancedBaseVertex(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei, basevertex: GLint) -> Result<()> {
		let ret = process_catch("glDrawElementsInstancedBaseVertex", catch_unwind(||(self.drawelementsinstancedbasevertex)(mode, count, type_, indices, instancecount, basevertex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsInstancedBaseVertex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiDrawElementsBaseVertex(&self, mode: GLenum, count: *const GLsizei, type_: GLenum, indices: *const *const c_void, drawcount: GLsizei, basevertex: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiDrawElementsBaseVertex", catch_unwind(||(self.multidrawelementsbasevertex)(mode, count, type_, indices, drawcount, basevertex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawElementsBaseVertex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProvokingVertex(&self, mode: GLenum) -> Result<()> {
		let ret = process_catch("glProvokingVertex", catch_unwind(||(self.provokingvertex)(mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProvokingVertex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFenceSync(&self, condition: GLenum, flags: GLbitfield) -> Result<GLsync> {
		let ret = process_catch("glFenceSync", catch_unwind(||(self.fencesync)(condition, flags)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFenceSync", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsSync(&self, sync: GLsync) -> Result<GLboolean> {
		let ret = process_catch("glIsSync", catch_unwind(||(self.issync)(sync)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsSync", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteSync(&self, sync: GLsync) -> Result<()> {
		let ret = process_catch("glDeleteSync", catch_unwind(||(self.deletesync)(sync)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteSync", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClientWaitSync(&self, sync: GLsync, flags: GLbitfield, timeout: GLuint64) -> Result<GLenum> {
		let ret = process_catch("glClientWaitSync", catch_unwind(||(self.clientwaitsync)(sync, flags, timeout)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClientWaitSync", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWaitSync(&self, sync: GLsync, flags: GLbitfield, timeout: GLuint64) -> Result<()> {
		let ret = process_catch("glWaitSync", catch_unwind(||(self.waitsync)(sync, flags, timeout)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWaitSync", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetInteger64v(&self, pname: GLenum, data: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetInteger64v", catch_unwind(||(self.getinteger64v)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetInteger64v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetSynciv(&self, sync: GLsync, pname: GLenum, count: GLsizei, length: *mut GLsizei, values: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetSynciv", catch_unwind(||(self.getsynciv)(sync, pname, count, length, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSynciv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetInteger64i_v(&self, target: GLenum, index: GLuint, data: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetInteger64i_v", catch_unwind(||(self.getinteger64i_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetInteger64i_v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetBufferParameteri64v(&self, target: GLenum, pname: GLenum, params: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetBufferParameteri64v", catch_unwind(||(self.getbufferparameteri64v)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBufferParameteri64v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFramebufferTexture(&self, target: GLenum, attachment: GLenum, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTexture", catch_unwind(||(self.framebuffertexture)(target, attachment, texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTexture", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexImage2DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTexImage2DMultisample", catch_unwind(||(self.teximage2dmultisample)(target, samples, internalformat, width, height, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage2DMultisample", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexImage3DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTexImage3DMultisample", catch_unwind(||(self.teximage3dmultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage3DMultisample", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetMultisamplefv(&self, pname: GLenum, index: GLuint, val: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetMultisamplefv", catch_unwind(||(self.getmultisamplefv)(pname, index, val)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetMultisamplefv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSampleMaski(&self, maskNumber: GLuint, mask: GLbitfield) -> Result<()> {
		let ret = process_catch("glSampleMaski", catch_unwind(||(self.samplemaski)(maskNumber, mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSampleMaski", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version32 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (3, 2, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			drawelementsbasevertex: {let proc = get_proc_address("glDrawElementsBaseVertex"); if proc == null() {dummy_pfngldrawelementsbasevertexproc} else {unsafe{transmute(proc)}}},
			drawrangeelementsbasevertex: {let proc = get_proc_address("glDrawRangeElementsBaseVertex"); if proc == null() {dummy_pfngldrawrangeelementsbasevertexproc} else {unsafe{transmute(proc)}}},
			drawelementsinstancedbasevertex: {let proc = get_proc_address("glDrawElementsInstancedBaseVertex"); if proc == null() {dummy_pfngldrawelementsinstancedbasevertexproc} else {unsafe{transmute(proc)}}},
			multidrawelementsbasevertex: {let proc = get_proc_address("glMultiDrawElementsBaseVertex"); if proc == null() {dummy_pfnglmultidrawelementsbasevertexproc} else {unsafe{transmute(proc)}}},
			provokingvertex: {let proc = get_proc_address("glProvokingVertex"); if proc == null() {dummy_pfnglprovokingvertexproc} else {unsafe{transmute(proc)}}},
			fencesync: {let proc = get_proc_address("glFenceSync"); if proc == null() {dummy_pfnglfencesyncproc} else {unsafe{transmute(proc)}}},
			issync: {let proc = get_proc_address("glIsSync"); if proc == null() {dummy_pfnglissyncproc} else {unsafe{transmute(proc)}}},
			deletesync: {let proc = get_proc_address("glDeleteSync"); if proc == null() {dummy_pfngldeletesyncproc} else {unsafe{transmute(proc)}}},
			clientwaitsync: {let proc = get_proc_address("glClientWaitSync"); if proc == null() {dummy_pfnglclientwaitsyncproc} else {unsafe{transmute(proc)}}},
			waitsync: {let proc = get_proc_address("glWaitSync"); if proc == null() {dummy_pfnglwaitsyncproc} else {unsafe{transmute(proc)}}},
			getinteger64v: {let proc = get_proc_address("glGetInteger64v"); if proc == null() {dummy_pfnglgetinteger64vproc} else {unsafe{transmute(proc)}}},
			getsynciv: {let proc = get_proc_address("glGetSynciv"); if proc == null() {dummy_pfnglgetsyncivproc} else {unsafe{transmute(proc)}}},
			getinteger64i_v: {let proc = get_proc_address("glGetInteger64i_v"); if proc == null() {dummy_pfnglgetinteger64i_vproc} else {unsafe{transmute(proc)}}},
			getbufferparameteri64v: {let proc = get_proc_address("glGetBufferParameteri64v"); if proc == null() {dummy_pfnglgetbufferparameteri64vproc} else {unsafe{transmute(proc)}}},
			framebuffertexture: {let proc = get_proc_address("glFramebufferTexture"); if proc == null() {dummy_pfnglframebuffertextureproc} else {unsafe{transmute(proc)}}},
			teximage2dmultisample: {let proc = get_proc_address("glTexImage2DMultisample"); if proc == null() {dummy_pfnglteximage2dmultisampleproc} else {unsafe{transmute(proc)}}},
			teximage3dmultisample: {let proc = get_proc_address("glTexImage3DMultisample"); if proc == null() {dummy_pfnglteximage3dmultisampleproc} else {unsafe{transmute(proc)}}},
			getmultisamplefv: {let proc = get_proc_address("glGetMultisamplefv"); if proc == null() {dummy_pfnglgetmultisamplefvproc} else {unsafe{transmute(proc)}}},
			samplemaski: {let proc = get_proc_address("glSampleMaski"); if proc == null() {dummy_pfnglsamplemaskiproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version32 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			drawelementsbasevertex: dummy_pfngldrawelementsbasevertexproc,
			drawrangeelementsbasevertex: dummy_pfngldrawrangeelementsbasevertexproc,
			drawelementsinstancedbasevertex: dummy_pfngldrawelementsinstancedbasevertexproc,
			multidrawelementsbasevertex: dummy_pfnglmultidrawelementsbasevertexproc,
			provokingvertex: dummy_pfnglprovokingvertexproc,
			fencesync: dummy_pfnglfencesyncproc,
			issync: dummy_pfnglissyncproc,
			deletesync: dummy_pfngldeletesyncproc,
			clientwaitsync: dummy_pfnglclientwaitsyncproc,
			waitsync: dummy_pfnglwaitsyncproc,
			getinteger64v: dummy_pfnglgetinteger64vproc,
			getsynciv: dummy_pfnglgetsyncivproc,
			getinteger64i_v: dummy_pfnglgetinteger64i_vproc,
			getbufferparameteri64v: dummy_pfnglgetbufferparameteri64vproc,
			framebuffertexture: dummy_pfnglframebuffertextureproc,
			teximage2dmultisample: dummy_pfnglteximage2dmultisampleproc,
			teximage3dmultisample: dummy_pfnglteximage3dmultisampleproc,
			getmultisamplefv: dummy_pfnglgetmultisamplefvproc,
			samplemaski: dummy_pfnglsamplemaskiproc,
		}
	}
}
impl Debug for Version32 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version32")
			.field("available", &self.available)
			.field("drawelementsbasevertex", unsafe{if transmute::<_, *const c_void>(self.drawelementsbasevertex) == (dummy_pfngldrawelementsbasevertexproc as *const c_void) {&null::<PFNGLDRAWELEMENTSBASEVERTEXPROC>()} else {&self.drawelementsbasevertex}})
			.field("drawrangeelementsbasevertex", unsafe{if transmute::<_, *const c_void>(self.drawrangeelementsbasevertex) == (dummy_pfngldrawrangeelementsbasevertexproc as *const c_void) {&null::<PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC>()} else {&self.drawrangeelementsbasevertex}})
			.field("drawelementsinstancedbasevertex", unsafe{if transmute::<_, *const c_void>(self.drawelementsinstancedbasevertex) == (dummy_pfngldrawelementsinstancedbasevertexproc as *const c_void) {&null::<PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC>()} else {&self.drawelementsinstancedbasevertex}})
			.field("multidrawelementsbasevertex", unsafe{if transmute::<_, *const c_void>(self.multidrawelementsbasevertex) == (dummy_pfnglmultidrawelementsbasevertexproc as *const c_void) {&null::<PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC>()} else {&self.multidrawelementsbasevertex}})
			.field("provokingvertex", unsafe{if transmute::<_, *const c_void>(self.provokingvertex) == (dummy_pfnglprovokingvertexproc as *const c_void) {&null::<PFNGLPROVOKINGVERTEXPROC>()} else {&self.provokingvertex}})
			.field("fencesync", unsafe{if transmute::<_, *const c_void>(self.fencesync) == (dummy_pfnglfencesyncproc as *const c_void) {&null::<PFNGLFENCESYNCPROC>()} else {&self.fencesync}})
			.field("issync", unsafe{if transmute::<_, *const c_void>(self.issync) == (dummy_pfnglissyncproc as *const c_void) {&null::<PFNGLISSYNCPROC>()} else {&self.issync}})
			.field("deletesync", unsafe{if transmute::<_, *const c_void>(self.deletesync) == (dummy_pfngldeletesyncproc as *const c_void) {&null::<PFNGLDELETESYNCPROC>()} else {&self.deletesync}})
			.field("clientwaitsync", unsafe{if transmute::<_, *const c_void>(self.clientwaitsync) == (dummy_pfnglclientwaitsyncproc as *const c_void) {&null::<PFNGLCLIENTWAITSYNCPROC>()} else {&self.clientwaitsync}})
			.field("waitsync", unsafe{if transmute::<_, *const c_void>(self.waitsync) == (dummy_pfnglwaitsyncproc as *const c_void) {&null::<PFNGLWAITSYNCPROC>()} else {&self.waitsync}})
			.field("getinteger64v", unsafe{if transmute::<_, *const c_void>(self.getinteger64v) == (dummy_pfnglgetinteger64vproc as *const c_void) {&null::<PFNGLGETINTEGER64VPROC>()} else {&self.getinteger64v}})
			.field("getsynciv", unsafe{if transmute::<_, *const c_void>(self.getsynciv) == (dummy_pfnglgetsyncivproc as *const c_void) {&null::<PFNGLGETSYNCIVPROC>()} else {&self.getsynciv}})
			.field("getinteger64i_v", unsafe{if transmute::<_, *const c_void>(self.getinteger64i_v) == (dummy_pfnglgetinteger64i_vproc as *const c_void) {&null::<PFNGLGETINTEGER64I_VPROC>()} else {&self.getinteger64i_v}})
			.field("getbufferparameteri64v", unsafe{if transmute::<_, *const c_void>(self.getbufferparameteri64v) == (dummy_pfnglgetbufferparameteri64vproc as *const c_void) {&null::<PFNGLGETBUFFERPARAMETERI64VPROC>()} else {&self.getbufferparameteri64v}})
			.field("framebuffertexture", unsafe{if transmute::<_, *const c_void>(self.framebuffertexture) == (dummy_pfnglframebuffertextureproc as *const c_void) {&null::<PFNGLFRAMEBUFFERTEXTUREPROC>()} else {&self.framebuffertexture}})
			.field("teximage2dmultisample", unsafe{if transmute::<_, *const c_void>(self.teximage2dmultisample) == (dummy_pfnglteximage2dmultisampleproc as *const c_void) {&null::<PFNGLTEXIMAGE2DMULTISAMPLEPROC>()} else {&self.teximage2dmultisample}})
			.field("teximage3dmultisample", unsafe{if transmute::<_, *const c_void>(self.teximage3dmultisample) == (dummy_pfnglteximage3dmultisampleproc as *const c_void) {&null::<PFNGLTEXIMAGE3DMULTISAMPLEPROC>()} else {&self.teximage3dmultisample}})
			.field("getmultisamplefv", unsafe{if transmute::<_, *const c_void>(self.getmultisamplefv) == (dummy_pfnglgetmultisamplefvproc as *const c_void) {&null::<PFNGLGETMULTISAMPLEFVPROC>()} else {&self.getmultisamplefv}})
			.field("samplemaski", unsafe{if transmute::<_, *const c_void>(self.samplemaski) == (dummy_pfnglsamplemaskiproc as *const c_void) {&null::<PFNGLSAMPLEMASKIPROC>()} else {&self.samplemaski}})
			.finish()
		} else {
			f.debug_struct("Version32")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}
type PFNGLBINDFRAGDATALOCATIONINDEXEDPROC = extern "system" fn(GLuint, GLuint, GLuint, *const GLchar);
type PFNGLGETFRAGDATAINDEXPROC = extern "system" fn(GLuint, *const GLchar) -> GLint;
type PFNGLGENSAMPLERSPROC = extern "system" fn(GLsizei, *mut GLuint);
type PFNGLDELETESAMPLERSPROC = extern "system" fn(GLsizei, *const GLuint);
type PFNGLISSAMPLERPROC = extern "system" fn(GLuint) -> GLboolean;
type PFNGLBINDSAMPLERPROC = extern "system" fn(GLuint, GLuint);
type PFNGLSAMPLERPARAMETERIPROC = extern "system" fn(GLuint, GLenum, GLint);
type PFNGLSAMPLERPARAMETERIVPROC = extern "system" fn(GLuint, GLenum, *const GLint);
type PFNGLSAMPLERPARAMETERFPROC = extern "system" fn(GLuint, GLenum, GLfloat);
type PFNGLSAMPLERPARAMETERFVPROC = extern "system" fn(GLuint, GLenum, *const GLfloat);
type PFNGLSAMPLERPARAMETERIIVPROC = extern "system" fn(GLuint, GLenum, *const GLint);
type PFNGLSAMPLERPARAMETERIUIVPROC = extern "system" fn(GLuint, GLenum, *const GLuint);
type PFNGLGETSAMPLERPARAMETERIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);
type PFNGLGETSAMPLERPARAMETERIIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);
type PFNGLGETSAMPLERPARAMETERFVPROC = extern "system" fn(GLuint, GLenum, *mut GLfloat);
type PFNGLGETSAMPLERPARAMETERIUIVPROC = extern "system" fn(GLuint, GLenum, *mut GLuint);
type PFNGLQUERYCOUNTERPROC = extern "system" fn(GLuint, GLenum);
type PFNGLGETQUERYOBJECTI64VPROC = extern "system" fn(GLuint, GLenum, *mut GLint64);
type PFNGLGETQUERYOBJECTUI64VPROC = extern "system" fn(GLuint, GLenum, *mut GLuint64);
type PFNGLVERTEXATTRIBDIVISORPROC = extern "system" fn(GLuint, GLuint);
type PFNGLVERTEXATTRIBP1UIPROC = extern "system" fn(GLuint, GLenum, GLboolean, GLuint);
type PFNGLVERTEXATTRIBP1UIVPROC = extern "system" fn(GLuint, GLenum, GLboolean, *const GLuint);
type PFNGLVERTEXATTRIBP2UIPROC = extern "system" fn(GLuint, GLenum, GLboolean, GLuint);
type PFNGLVERTEXATTRIBP2UIVPROC = extern "system" fn(GLuint, GLenum, GLboolean, *const GLuint);
type PFNGLVERTEXATTRIBP3UIPROC = extern "system" fn(GLuint, GLenum, GLboolean, GLuint);
type PFNGLVERTEXATTRIBP3UIVPROC = extern "system" fn(GLuint, GLenum, GLboolean, *const GLuint);
type PFNGLVERTEXATTRIBP4UIPROC = extern "system" fn(GLuint, GLenum, GLboolean, GLuint);
type PFNGLVERTEXATTRIBP4UIVPROC = extern "system" fn(GLuint, GLenum, GLboolean, *const GLuint);
type PFNGLVERTEXP2UIPROC = extern "system" fn(GLenum, GLuint);
type PFNGLVERTEXP2UIVPROC = extern "system" fn(GLenum, *const GLuint);
type PFNGLVERTEXP3UIPROC = extern "system" fn(GLenum, GLuint);
type PFNGLVERTEXP3UIVPROC = extern "system" fn(GLenum, *const GLuint);
type PFNGLVERTEXP4UIPROC = extern "system" fn(GLenum, GLuint);
type PFNGLVERTEXP4UIVPROC = extern "system" fn(GLenum, *const GLuint);
type PFNGLTEXCOORDP1UIPROC = extern "system" fn(GLenum, GLuint);
type PFNGLTEXCOORDP1UIVPROC = extern "system" fn(GLenum, *const GLuint);
type PFNGLTEXCOORDP2UIPROC = extern "system" fn(GLenum, GLuint);
type PFNGLTEXCOORDP2UIVPROC = extern "system" fn(GLenum, *const GLuint);
type PFNGLTEXCOORDP3UIPROC = extern "system" fn(GLenum, GLuint);
type PFNGLTEXCOORDP3UIVPROC = extern "system" fn(GLenum, *const GLuint);
type PFNGLTEXCOORDP4UIPROC = extern "system" fn(GLenum, GLuint);
type PFNGLTEXCOORDP4UIVPROC = extern "system" fn(GLenum, *const GLuint);
type PFNGLMULTITEXCOORDP1UIPROC = extern "system" fn(GLenum, GLenum, GLuint);
type PFNGLMULTITEXCOORDP1UIVPROC = extern "system" fn(GLenum, GLenum, *const GLuint);
type PFNGLMULTITEXCOORDP2UIPROC = extern "system" fn(GLenum, GLenum, GLuint);
type PFNGLMULTITEXCOORDP2UIVPROC = extern "system" fn(GLenum, GLenum, *const GLuint);
type PFNGLMULTITEXCOORDP3UIPROC = extern "system" fn(GLenum, GLenum, GLuint);
type PFNGLMULTITEXCOORDP3UIVPROC = extern "system" fn(GLenum, GLenum, *const GLuint);
type PFNGLMULTITEXCOORDP4UIPROC = extern "system" fn(GLenum, GLenum, GLuint);
type PFNGLMULTITEXCOORDP4UIVPROC = extern "system" fn(GLenum, GLenum, *const GLuint);
type PFNGLNORMALP3UIPROC = extern "system" fn(GLenum, GLuint);
type PFNGLNORMALP3UIVPROC = extern "system" fn(GLenum, *const GLuint);
type PFNGLCOLORP3UIPROC = extern "system" fn(GLenum, GLuint);
type PFNGLCOLORP3UIVPROC = extern "system" fn(GLenum, *const GLuint);
type PFNGLCOLORP4UIPROC = extern "system" fn(GLenum, GLuint);
type PFNGLCOLORP4UIVPROC = extern "system" fn(GLenum, *const GLuint);
type PFNGLSECONDARYCOLORP3UIPROC = extern "system" fn(GLenum, GLuint);
type PFNGLSECONDARYCOLORP3UIVPROC = extern "system" fn(GLenum, *const GLuint);
extern "system" fn dummy_pfnglbindfragdatalocationindexedproc (_: GLuint, _: GLuint, _: GLuint, _: *const GLchar) {
	panic!("OpenGL function pointer `glBindFragDataLocationIndexed()` is null.")
}
extern "system" fn dummy_pfnglgetfragdataindexproc (_: GLuint, _: *const GLchar) -> GLint {
	panic!("OpenGL function pointer `glGetFragDataIndex()` is null.")
}
extern "system" fn dummy_pfnglgensamplersproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGenSamplers()` is null.")
}
extern "system" fn dummy_pfngldeletesamplersproc (_: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glDeleteSamplers()` is null.")
}
extern "system" fn dummy_pfnglissamplerproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsSampler()` is null.")
}
extern "system" fn dummy_pfnglbindsamplerproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glBindSampler()` is null.")
}
extern "system" fn dummy_pfnglsamplerparameteriproc (_: GLuint, _: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glSamplerParameteri()` is null.")
}
extern "system" fn dummy_pfnglsamplerparameterivproc (_: GLuint, _: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glSamplerParameteriv()` is null.")
}
extern "system" fn dummy_pfnglsamplerparameterfproc (_: GLuint, _: GLenum, _: GLfloat) {
	panic!("OpenGL function pointer `glSamplerParameterf()` is null.")
}
extern "system" fn dummy_pfnglsamplerparameterfvproc (_: GLuint, _: GLenum, _: *const GLfloat) {
	panic!("OpenGL function pointer `glSamplerParameterfv()` is null.")
}
extern "system" fn dummy_pfnglsamplerparameteriivproc (_: GLuint, _: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glSamplerParameterIiv()` is null.")
}
extern "system" fn dummy_pfnglsamplerparameteriuivproc (_: GLuint, _: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glSamplerParameterIuiv()` is null.")
}
extern "system" fn dummy_pfnglgetsamplerparameterivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetSamplerParameteriv()` is null.")
}
extern "system" fn dummy_pfnglgetsamplerparameteriivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetSamplerParameterIiv()` is null.")
}
extern "system" fn dummy_pfnglgetsamplerparameterfvproc (_: GLuint, _: GLenum, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetSamplerParameterfv()` is null.")
}
extern "system" fn dummy_pfnglgetsamplerparameteriuivproc (_: GLuint, _: GLenum, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetSamplerParameterIuiv()` is null.")
}
extern "system" fn dummy_pfnglquerycounterproc (_: GLuint, _: GLenum) {
	panic!("OpenGL function pointer `glQueryCounter()` is null.")
}
extern "system" fn dummy_pfnglgetqueryobjecti64vproc (_: GLuint, _: GLenum, _: *mut GLint64) {
	panic!("OpenGL function pointer `glGetQueryObjecti64v()` is null.")
}
extern "system" fn dummy_pfnglgetqueryobjectui64vproc (_: GLuint, _: GLenum, _: *mut GLuint64) {
	panic!("OpenGL function pointer `glGetQueryObjectui64v()` is null.")
}
extern "system" fn dummy_pfnglvertexattribdivisorproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribDivisor()` is null.")
}
extern "system" fn dummy_pfnglvertexattribp1uiproc (_: GLuint, _: GLenum, _: GLboolean, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribP1ui()` is null.")
}
extern "system" fn dummy_pfnglvertexattribp1uivproc (_: GLuint, _: GLenum, _: GLboolean, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttribP1uiv()` is null.")
}
extern "system" fn dummy_pfnglvertexattribp2uiproc (_: GLuint, _: GLenum, _: GLboolean, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribP2ui()` is null.")
}
extern "system" fn dummy_pfnglvertexattribp2uivproc (_: GLuint, _: GLenum, _: GLboolean, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttribP2uiv()` is null.")
}
extern "system" fn dummy_pfnglvertexattribp3uiproc (_: GLuint, _: GLenum, _: GLboolean, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribP3ui()` is null.")
}
extern "system" fn dummy_pfnglvertexattribp3uivproc (_: GLuint, _: GLenum, _: GLboolean, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttribP3uiv()` is null.")
}
extern "system" fn dummy_pfnglvertexattribp4uiproc (_: GLuint, _: GLenum, _: GLboolean, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribP4ui()` is null.")
}
extern "system" fn dummy_pfnglvertexattribp4uivproc (_: GLuint, _: GLenum, _: GLboolean, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexAttribP4uiv()` is null.")
}
extern "system" fn dummy_pfnglvertexp2uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glVertexP2ui()` is null.")
}
extern "system" fn dummy_pfnglvertexp2uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexP2uiv()` is null.")
}
extern "system" fn dummy_pfnglvertexp3uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glVertexP3ui()` is null.")
}
extern "system" fn dummy_pfnglvertexp3uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexP3uiv()` is null.")
}
extern "system" fn dummy_pfnglvertexp4uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glVertexP4ui()` is null.")
}
extern "system" fn dummy_pfnglvertexp4uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glVertexP4uiv()` is null.")
}
extern "system" fn dummy_pfngltexcoordp1uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glTexCoordP1ui()` is null.")
}
extern "system" fn dummy_pfngltexcoordp1uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glTexCoordP1uiv()` is null.")
}
extern "system" fn dummy_pfngltexcoordp2uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glTexCoordP2ui()` is null.")
}
extern "system" fn dummy_pfngltexcoordp2uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glTexCoordP2uiv()` is null.")
}
extern "system" fn dummy_pfngltexcoordp3uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glTexCoordP3ui()` is null.")
}
extern "system" fn dummy_pfngltexcoordp3uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glTexCoordP3uiv()` is null.")
}
extern "system" fn dummy_pfngltexcoordp4uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glTexCoordP4ui()` is null.")
}
extern "system" fn dummy_pfngltexcoordp4uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glTexCoordP4uiv()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoordp1uiproc (_: GLenum, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glMultiTexCoordP1ui()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoordp1uivproc (_: GLenum, _: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glMultiTexCoordP1uiv()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoordp2uiproc (_: GLenum, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glMultiTexCoordP2ui()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoordp2uivproc (_: GLenum, _: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glMultiTexCoordP2uiv()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoordp3uiproc (_: GLenum, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glMultiTexCoordP3ui()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoordp3uivproc (_: GLenum, _: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glMultiTexCoordP3uiv()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoordp4uiproc (_: GLenum, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glMultiTexCoordP4ui()` is null.")
}
extern "system" fn dummy_pfnglmultitexcoordp4uivproc (_: GLenum, _: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glMultiTexCoordP4uiv()` is null.")
}
extern "system" fn dummy_pfnglnormalp3uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glNormalP3ui()` is null.")
}
extern "system" fn dummy_pfnglnormalp3uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glNormalP3uiv()` is null.")
}
extern "system" fn dummy_pfnglcolorp3uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glColorP3ui()` is null.")
}
extern "system" fn dummy_pfnglcolorp3uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glColorP3uiv()` is null.")
}
extern "system" fn dummy_pfnglcolorp4uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glColorP4ui()` is null.")
}
extern "system" fn dummy_pfnglcolorp4uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glColorP4uiv()` is null.")
}
extern "system" fn dummy_pfnglsecondarycolorp3uiproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glSecondaryColorP3ui()` is null.")
}
extern "system" fn dummy_pfnglsecondarycolorp3uivproc (_: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glSecondaryColorP3uiv()` is null.")
}
pub const GL_VERTEX_ATTRIB_ARRAY_DIVISOR: GLenum = 0x88FE;
pub const GL_SRC1_COLOR: GLenum = 0x88F9;
pub const GL_ONE_MINUS_SRC1_COLOR: GLenum = 0x88FA;
pub const GL_ONE_MINUS_SRC1_ALPHA: GLenum = 0x88FB;
pub const GL_MAX_DUAL_SOURCE_DRAW_BUFFERS: GLenum = 0x88FC;
pub const GL_ANY_SAMPLES_PASSED: GLenum = 0x8C2F;
pub const GL_SAMPLER_BINDING: GLenum = 0x8919;
pub const GL_RGB10_A2UI: GLenum = 0x906F;
pub const GL_TEXTURE_SWIZZLE_R: GLenum = 0x8E42;
pub const GL_TEXTURE_SWIZZLE_G: GLenum = 0x8E43;
pub const GL_TEXTURE_SWIZZLE_B: GLenum = 0x8E44;
pub const GL_TEXTURE_SWIZZLE_A: GLenum = 0x8E45;
pub const GL_TEXTURE_SWIZZLE_RGBA: GLenum = 0x8E46;
pub const GL_TIME_ELAPSED: GLenum = 0x88BF;
pub const GL_TIMESTAMP: GLenum = 0x8E28;
pub const GL_INT_2_10_10_10_REV: GLenum = 0x8D9F;

pub trait GL_3_3 {
	fn glGetError(&self) -> GLenum;
	fn glBindFragDataLocationIndexed(&self, program: GLuint, colorNumber: GLuint, index: GLuint, name: *const GLchar) -> Result<()>;
	fn glGetFragDataIndex(&self, program: GLuint, name: *const GLchar) -> Result<GLint>;
	fn glGenSamplers(&self, count: GLsizei, samplers: *mut GLuint) -> Result<()>;
	fn glDeleteSamplers(&self, count: GLsizei, samplers: *const GLuint) -> Result<()>;
	fn glIsSampler(&self, sampler: GLuint) -> Result<GLboolean>;
	fn glBindSampler(&self, unit: GLuint, sampler: GLuint) -> Result<()>;
	fn glSamplerParameteri(&self, sampler: GLuint, pname: GLenum, param: GLint) -> Result<()>;
	fn glSamplerParameteriv(&self, sampler: GLuint, pname: GLenum, param: *const GLint) -> Result<()>;
	fn glSamplerParameterf(&self, sampler: GLuint, pname: GLenum, param: GLfloat) -> Result<()>;
	fn glSamplerParameterfv(&self, sampler: GLuint, pname: GLenum, param: *const GLfloat) -> Result<()>;
	fn glSamplerParameterIiv(&self, sampler: GLuint, pname: GLenum, param: *const GLint) -> Result<()>;
	fn glSamplerParameterIuiv(&self, sampler: GLuint, pname: GLenum, param: *const GLuint) -> Result<()>;
	fn glGetSamplerParameteriv(&self, sampler: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glGetSamplerParameterIiv(&self, sampler: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glGetSamplerParameterfv(&self, sampler: GLuint, pname: GLenum, params: *mut GLfloat) -> Result<()>;
	fn glGetSamplerParameterIuiv(&self, sampler: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()>;
	fn glQueryCounter(&self, id: GLuint, target: GLenum) -> Result<()>;
	fn glGetQueryObjecti64v(&self, id: GLuint, pname: GLenum, params: *mut GLint64) -> Result<()>;
	fn glGetQueryObjectui64v(&self, id: GLuint, pname: GLenum, params: *mut GLuint64) -> Result<()>;
	fn glVertexAttribDivisor(&self, index: GLuint, divisor: GLuint) -> Result<()>;
	fn glVertexAttribP1ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()>;
	fn glVertexAttribP1uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()>;
	fn glVertexAttribP2ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()>;
	fn glVertexAttribP2uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()>;
	fn glVertexAttribP3ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()>;
	fn glVertexAttribP3uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()>;
	fn glVertexAttribP4ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()>;
	fn glVertexAttribP4uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()>;
	fn glVertexP2ui(&self, type_: GLenum, value: GLuint) -> Result<()>;
	fn glVertexP2uiv(&self, type_: GLenum, value: *const GLuint) -> Result<()>;
	fn glVertexP3ui(&self, type_: GLenum, value: GLuint) -> Result<()>;
	fn glVertexP3uiv(&self, type_: GLenum, value: *const GLuint) -> Result<()>;
	fn glVertexP4ui(&self, type_: GLenum, value: GLuint) -> Result<()>;
	fn glVertexP4uiv(&self, type_: GLenum, value: *const GLuint) -> Result<()>;
	fn glTexCoordP1ui(&self, type_: GLenum, coords: GLuint) -> Result<()>;
	fn glTexCoordP1uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()>;
	fn glTexCoordP2ui(&self, type_: GLenum, coords: GLuint) -> Result<()>;
	fn glTexCoordP2uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()>;
	fn glTexCoordP3ui(&self, type_: GLenum, coords: GLuint) -> Result<()>;
	fn glTexCoordP3uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()>;
	fn glTexCoordP4ui(&self, type_: GLenum, coords: GLuint) -> Result<()>;
	fn glTexCoordP4uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()>;
	fn glMultiTexCoordP1ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()>;
	fn glMultiTexCoordP1uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()>;
	fn glMultiTexCoordP2ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()>;
	fn glMultiTexCoordP2uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()>;
	fn glMultiTexCoordP3ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()>;
	fn glMultiTexCoordP3uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()>;
	fn glMultiTexCoordP4ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()>;
	fn glMultiTexCoordP4uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()>;
	fn glNormalP3ui(&self, type_: GLenum, coords: GLuint) -> Result<()>;
	fn glNormalP3uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()>;
	fn glColorP3ui(&self, type_: GLenum, color: GLuint) -> Result<()>;
	fn glColorP3uiv(&self, type_: GLenum, color: *const GLuint) -> Result<()>;
	fn glColorP4ui(&self, type_: GLenum, color: GLuint) -> Result<()>;
	fn glColorP4uiv(&self, type_: GLenum, color: *const GLuint) -> Result<()>;
	fn glSecondaryColorP3ui(&self, type_: GLenum, color: GLuint) -> Result<()>;
	fn glSecondaryColorP3uiv(&self, type_: GLenum, color: *const GLuint) -> Result<()>;
}

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version33 {
	available: bool,
	geterror: PFNGLGETERRORPROC,
	bindfragdatalocationindexed: PFNGLBINDFRAGDATALOCATIONINDEXEDPROC,
	getfragdataindex: PFNGLGETFRAGDATAINDEXPROC,
	gensamplers: PFNGLGENSAMPLERSPROC,
	deletesamplers: PFNGLDELETESAMPLERSPROC,
	issampler: PFNGLISSAMPLERPROC,
	bindsampler: PFNGLBINDSAMPLERPROC,
	samplerparameteri: PFNGLSAMPLERPARAMETERIPROC,
	samplerparameteriv: PFNGLSAMPLERPARAMETERIVPROC,
	samplerparameterf: PFNGLSAMPLERPARAMETERFPROC,
	samplerparameterfv: PFNGLSAMPLERPARAMETERFVPROC,
	samplerparameteriiv: PFNGLSAMPLERPARAMETERIIVPROC,
	samplerparameteriuiv: PFNGLSAMPLERPARAMETERIUIVPROC,
	getsamplerparameteriv: PFNGLGETSAMPLERPARAMETERIVPROC,
	getsamplerparameteriiv: PFNGLGETSAMPLERPARAMETERIIVPROC,
	getsamplerparameterfv: PFNGLGETSAMPLERPARAMETERFVPROC,
	getsamplerparameteriuiv: PFNGLGETSAMPLERPARAMETERIUIVPROC,
	querycounter: PFNGLQUERYCOUNTERPROC,
	getqueryobjecti64v: PFNGLGETQUERYOBJECTI64VPROC,
	getqueryobjectui64v: PFNGLGETQUERYOBJECTUI64VPROC,
	vertexattribdivisor: PFNGLVERTEXATTRIBDIVISORPROC,
	vertexattribp1ui: PFNGLVERTEXATTRIBP1UIPROC,
	vertexattribp1uiv: PFNGLVERTEXATTRIBP1UIVPROC,
	vertexattribp2ui: PFNGLVERTEXATTRIBP2UIPROC,
	vertexattribp2uiv: PFNGLVERTEXATTRIBP2UIVPROC,
	vertexattribp3ui: PFNGLVERTEXATTRIBP3UIPROC,
	vertexattribp3uiv: PFNGLVERTEXATTRIBP3UIVPROC,
	vertexattribp4ui: PFNGLVERTEXATTRIBP4UIPROC,
	vertexattribp4uiv: PFNGLVERTEXATTRIBP4UIVPROC,
	vertexp2ui: PFNGLVERTEXP2UIPROC,
	vertexp2uiv: PFNGLVERTEXP2UIVPROC,
	vertexp3ui: PFNGLVERTEXP3UIPROC,
	vertexp3uiv: PFNGLVERTEXP3UIVPROC,
	vertexp4ui: PFNGLVERTEXP4UIPROC,
	vertexp4uiv: PFNGLVERTEXP4UIVPROC,
	texcoordp1ui: PFNGLTEXCOORDP1UIPROC,
	texcoordp1uiv: PFNGLTEXCOORDP1UIVPROC,
	texcoordp2ui: PFNGLTEXCOORDP2UIPROC,
	texcoordp2uiv: PFNGLTEXCOORDP2UIVPROC,
	texcoordp3ui: PFNGLTEXCOORDP3UIPROC,
	texcoordp3uiv: PFNGLTEXCOORDP3UIVPROC,
	texcoordp4ui: PFNGLTEXCOORDP4UIPROC,
	texcoordp4uiv: PFNGLTEXCOORDP4UIVPROC,
	multitexcoordp1ui: PFNGLMULTITEXCOORDP1UIPROC,
	multitexcoordp1uiv: PFNGLMULTITEXCOORDP1UIVPROC,
	multitexcoordp2ui: PFNGLMULTITEXCOORDP2UIPROC,
	multitexcoordp2uiv: PFNGLMULTITEXCOORDP2UIVPROC,
	multitexcoordp3ui: PFNGLMULTITEXCOORDP3UIPROC,
	multitexcoordp3uiv: PFNGLMULTITEXCOORDP3UIVPROC,
	multitexcoordp4ui: PFNGLMULTITEXCOORDP4UIPROC,
	multitexcoordp4uiv: PFNGLMULTITEXCOORDP4UIVPROC,
	normalp3ui: PFNGLNORMALP3UIPROC,
	normalp3uiv: PFNGLNORMALP3UIVPROC,
	colorp3ui: PFNGLCOLORP3UIPROC,
	colorp3uiv: PFNGLCOLORP3UIVPROC,
	colorp4ui: PFNGLCOLORP4UIPROC,
	colorp4uiv: PFNGLCOLORP4UIVPROC,
	secondarycolorp3ui: PFNGLSECONDARYCOLORP3UIPROC,
	secondarycolorp3uiv: PFNGLSECONDARYCOLORP3UIVPROC,
}

impl GL_3_3 for Version33 {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	#[inline(always)]
	fn glBindFragDataLocationIndexed(&self, program: GLuint, colorNumber: GLuint, index: GLuint, name: *const GLchar) -> Result<()> {
		let ret = process_catch("glBindFragDataLocationIndexed", catch_unwind(||(self.bindfragdatalocationindexed)(program, colorNumber, index, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindFragDataLocationIndexed", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetFragDataIndex(&self, program: GLuint, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetFragDataIndex", catch_unwind(||(self.getfragdataindex)(program, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFragDataIndex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenSamplers(&self, count: GLsizei, samplers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenSamplers", catch_unwind(||(self.gensamplers)(count, samplers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenSamplers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteSamplers(&self, count: GLsizei, samplers: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteSamplers", catch_unwind(||(self.deletesamplers)(count, samplers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteSamplers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsSampler(&self, sampler: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsSampler", catch_unwind(||(self.issampler)(sampler)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsSampler", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindSampler(&self, unit: GLuint, sampler: GLuint) -> Result<()> {
		let ret = process_catch("glBindSampler", catch_unwind(||(self.bindsampler)(unit, sampler)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindSampler", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSamplerParameteri(&self, sampler: GLuint, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glSamplerParameteri", catch_unwind(||(self.samplerparameteri)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameteri", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSamplerParameteriv(&self, sampler: GLuint, pname: GLenum, param: *const GLint) -> Result<()> {
		let ret = process_catch("glSamplerParameteriv", catch_unwind(||(self.samplerparameteriv)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSamplerParameterf(&self, sampler: GLuint, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glSamplerParameterf", catch_unwind(||(self.samplerparameterf)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameterf", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSamplerParameterfv(&self, sampler: GLuint, pname: GLenum, param: *const GLfloat) -> Result<()> {
		let ret = process_catch("glSamplerParameterfv", catch_unwind(||(self.samplerparameterfv)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSamplerParameterIiv(&self, sampler: GLuint, pname: GLenum, param: *const GLint) -> Result<()> {
		let ret = process_catch("glSamplerParameterIiv", catch_unwind(||(self.samplerparameteriiv)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameterIiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSamplerParameterIuiv(&self, sampler: GLuint, pname: GLenum, param: *const GLuint) -> Result<()> {
		let ret = process_catch("glSamplerParameterIuiv", catch_unwind(||(self.samplerparameteriuiv)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameterIuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetSamplerParameteriv(&self, sampler: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetSamplerParameteriv", catch_unwind(||(self.getsamplerparameteriv)(sampler, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSamplerParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetSamplerParameterIiv(&self, sampler: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetSamplerParameterIiv", catch_unwind(||(self.getsamplerparameteriiv)(sampler, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSamplerParameterIiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetSamplerParameterfv(&self, sampler: GLuint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetSamplerParameterfv", catch_unwind(||(self.getsamplerparameterfv)(sampler, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSamplerParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetSamplerParameterIuiv(&self, sampler: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetSamplerParameterIuiv", catch_unwind(||(self.getsamplerparameteriuiv)(sampler, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSamplerParameterIuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glQueryCounter(&self, id: GLuint, target: GLenum) -> Result<()> {
		let ret = process_catch("glQueryCounter", catch_unwind(||(self.querycounter)(id, target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glQueryCounter", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryObjecti64v(&self, id: GLuint, pname: GLenum, params: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetQueryObjecti64v", catch_unwind(||(self.getqueryobjecti64v)(id, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryObjecti64v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryObjectui64v(&self, id: GLuint, pname: GLenum, params: *mut GLuint64) -> Result<()> {
		let ret = process_catch("glGetQueryObjectui64v", catch_unwind(||(self.getqueryobjectui64v)(id, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryObjectui64v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribDivisor(&self, index: GLuint, divisor: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribDivisor", catch_unwind(||(self.vertexattribdivisor)(index, divisor)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribDivisor", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribP1ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP1ui", catch_unwind(||(self.vertexattribp1ui)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP1ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribP1uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP1uiv", catch_unwind(||(self.vertexattribp1uiv)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP1uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribP2ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP2ui", catch_unwind(||(self.vertexattribp2ui)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP2ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribP2uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP2uiv", catch_unwind(||(self.vertexattribp2uiv)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP2uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribP3ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP3ui", catch_unwind(||(self.vertexattribp3ui)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribP3uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP3uiv", catch_unwind(||(self.vertexattribp3uiv)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribP4ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP4ui", catch_unwind(||(self.vertexattribp4ui)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP4ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribP4uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP4uiv", catch_unwind(||(self.vertexattribp4uiv)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP4uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexP2ui(&self, type_: GLenum, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexP2ui", catch_unwind(||(self.vertexp2ui)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP2ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexP2uiv(&self, type_: GLenum, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexP2uiv", catch_unwind(||(self.vertexp2uiv)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP2uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexP3ui(&self, type_: GLenum, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexP3ui", catch_unwind(||(self.vertexp3ui)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexP3uiv(&self, type_: GLenum, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexP3uiv", catch_unwind(||(self.vertexp3uiv)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexP4ui(&self, type_: GLenum, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexP4ui", catch_unwind(||(self.vertexp4ui)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP4ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexP4uiv(&self, type_: GLenum, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexP4uiv", catch_unwind(||(self.vertexp4uiv)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP4uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexCoordP1ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP1ui", catch_unwind(||(self.texcoordp1ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP1ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexCoordP1uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP1uiv", catch_unwind(||(self.texcoordp1uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP1uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexCoordP2ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP2ui", catch_unwind(||(self.texcoordp2ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP2ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexCoordP2uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP2uiv", catch_unwind(||(self.texcoordp2uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP2uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexCoordP3ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP3ui", catch_unwind(||(self.texcoordp3ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexCoordP3uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP3uiv", catch_unwind(||(self.texcoordp3uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexCoordP4ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP4ui", catch_unwind(||(self.texcoordp4ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP4ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexCoordP4uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP4uiv", catch_unwind(||(self.texcoordp4uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP4uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoordP1ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP1ui", catch_unwind(||(self.multitexcoordp1ui)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP1ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoordP1uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP1uiv", catch_unwind(||(self.multitexcoordp1uiv)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP1uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoordP2ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP2ui", catch_unwind(||(self.multitexcoordp2ui)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP2ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoordP2uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP2uiv", catch_unwind(||(self.multitexcoordp2uiv)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP2uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoordP3ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP3ui", catch_unwind(||(self.multitexcoordp3ui)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoordP3uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP3uiv", catch_unwind(||(self.multitexcoordp3uiv)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoordP4ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP4ui", catch_unwind(||(self.multitexcoordp4ui)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP4ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoordP4uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP4uiv", catch_unwind(||(self.multitexcoordp4uiv)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP4uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNormalP3ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glNormalP3ui", catch_unwind(||(self.normalp3ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNormalP3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNormalP3uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glNormalP3uiv", catch_unwind(||(self.normalp3uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNormalP3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glColorP3ui(&self, type_: GLenum, color: GLuint) -> Result<()> {
		let ret = process_catch("glColorP3ui", catch_unwind(||(self.colorp3ui)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorP3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glColorP3uiv(&self, type_: GLenum, color: *const GLuint) -> Result<()> {
		let ret = process_catch("glColorP3uiv", catch_unwind(||(self.colorp3uiv)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorP3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glColorP4ui(&self, type_: GLenum, color: GLuint) -> Result<()> {
		let ret = process_catch("glColorP4ui", catch_unwind(||(self.colorp4ui)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorP4ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glColorP4uiv(&self, type_: GLenum, color: *const GLuint) -> Result<()> {
		let ret = process_catch("glColorP4uiv", catch_unwind(||(self.colorp4uiv)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorP4uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColorP3ui(&self, type_: GLenum, color: GLuint) -> Result<()> {
		let ret = process_catch("glSecondaryColorP3ui", catch_unwind(||(self.secondarycolorp3ui)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColorP3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColorP3uiv(&self, type_: GLenum, color: *const GLuint) -> Result<()> {
		let ret = process_catch("glSecondaryColorP3uiv", catch_unwind(||(self.secondarycolorp3uiv)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColorP3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version33 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (3, 3, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			bindfragdatalocationindexed: {let proc = get_proc_address("glBindFragDataLocationIndexed"); if proc == null() {dummy_pfnglbindfragdatalocationindexedproc} else {unsafe{transmute(proc)}}},
			getfragdataindex: {let proc = get_proc_address("glGetFragDataIndex"); if proc == null() {dummy_pfnglgetfragdataindexproc} else {unsafe{transmute(proc)}}},
			gensamplers: {let proc = get_proc_address("glGenSamplers"); if proc == null() {dummy_pfnglgensamplersproc} else {unsafe{transmute(proc)}}},
			deletesamplers: {let proc = get_proc_address("glDeleteSamplers"); if proc == null() {dummy_pfngldeletesamplersproc} else {unsafe{transmute(proc)}}},
			issampler: {let proc = get_proc_address("glIsSampler"); if proc == null() {dummy_pfnglissamplerproc} else {unsafe{transmute(proc)}}},
			bindsampler: {let proc = get_proc_address("glBindSampler"); if proc == null() {dummy_pfnglbindsamplerproc} else {unsafe{transmute(proc)}}},
			samplerparameteri: {let proc = get_proc_address("glSamplerParameteri"); if proc == null() {dummy_pfnglsamplerparameteriproc} else {unsafe{transmute(proc)}}},
			samplerparameteriv: {let proc = get_proc_address("glSamplerParameteriv"); if proc == null() {dummy_pfnglsamplerparameterivproc} else {unsafe{transmute(proc)}}},
			samplerparameterf: {let proc = get_proc_address("glSamplerParameterf"); if proc == null() {dummy_pfnglsamplerparameterfproc} else {unsafe{transmute(proc)}}},
			samplerparameterfv: {let proc = get_proc_address("glSamplerParameterfv"); if proc == null() {dummy_pfnglsamplerparameterfvproc} else {unsafe{transmute(proc)}}},
			samplerparameteriiv: {let proc = get_proc_address("glSamplerParameterIiv"); if proc == null() {dummy_pfnglsamplerparameteriivproc} else {unsafe{transmute(proc)}}},
			samplerparameteriuiv: {let proc = get_proc_address("glSamplerParameterIuiv"); if proc == null() {dummy_pfnglsamplerparameteriuivproc} else {unsafe{transmute(proc)}}},
			getsamplerparameteriv: {let proc = get_proc_address("glGetSamplerParameteriv"); if proc == null() {dummy_pfnglgetsamplerparameterivproc} else {unsafe{transmute(proc)}}},
			getsamplerparameteriiv: {let proc = get_proc_address("glGetSamplerParameterIiv"); if proc == null() {dummy_pfnglgetsamplerparameteriivproc} else {unsafe{transmute(proc)}}},
			getsamplerparameterfv: {let proc = get_proc_address("glGetSamplerParameterfv"); if proc == null() {dummy_pfnglgetsamplerparameterfvproc} else {unsafe{transmute(proc)}}},
			getsamplerparameteriuiv: {let proc = get_proc_address("glGetSamplerParameterIuiv"); if proc == null() {dummy_pfnglgetsamplerparameteriuivproc} else {unsafe{transmute(proc)}}},
			querycounter: {let proc = get_proc_address("glQueryCounter"); if proc == null() {dummy_pfnglquerycounterproc} else {unsafe{transmute(proc)}}},
			getqueryobjecti64v: {let proc = get_proc_address("glGetQueryObjecti64v"); if proc == null() {dummy_pfnglgetqueryobjecti64vproc} else {unsafe{transmute(proc)}}},
			getqueryobjectui64v: {let proc = get_proc_address("glGetQueryObjectui64v"); if proc == null() {dummy_pfnglgetqueryobjectui64vproc} else {unsafe{transmute(proc)}}},
			vertexattribdivisor: {let proc = get_proc_address("glVertexAttribDivisor"); if proc == null() {dummy_pfnglvertexattribdivisorproc} else {unsafe{transmute(proc)}}},
			vertexattribp1ui: {let proc = get_proc_address("glVertexAttribP1ui"); if proc == null() {dummy_pfnglvertexattribp1uiproc} else {unsafe{transmute(proc)}}},
			vertexattribp1uiv: {let proc = get_proc_address("glVertexAttribP1uiv"); if proc == null() {dummy_pfnglvertexattribp1uivproc} else {unsafe{transmute(proc)}}},
			vertexattribp2ui: {let proc = get_proc_address("glVertexAttribP2ui"); if proc == null() {dummy_pfnglvertexattribp2uiproc} else {unsafe{transmute(proc)}}},
			vertexattribp2uiv: {let proc = get_proc_address("glVertexAttribP2uiv"); if proc == null() {dummy_pfnglvertexattribp2uivproc} else {unsafe{transmute(proc)}}},
			vertexattribp3ui: {let proc = get_proc_address("glVertexAttribP3ui"); if proc == null() {dummy_pfnglvertexattribp3uiproc} else {unsafe{transmute(proc)}}},
			vertexattribp3uiv: {let proc = get_proc_address("glVertexAttribP3uiv"); if proc == null() {dummy_pfnglvertexattribp3uivproc} else {unsafe{transmute(proc)}}},
			vertexattribp4ui: {let proc = get_proc_address("glVertexAttribP4ui"); if proc == null() {dummy_pfnglvertexattribp4uiproc} else {unsafe{transmute(proc)}}},
			vertexattribp4uiv: {let proc = get_proc_address("glVertexAttribP4uiv"); if proc == null() {dummy_pfnglvertexattribp4uivproc} else {unsafe{transmute(proc)}}},
			vertexp2ui: {let proc = get_proc_address("glVertexP2ui"); if proc == null() {dummy_pfnglvertexp2uiproc} else {unsafe{transmute(proc)}}},
			vertexp2uiv: {let proc = get_proc_address("glVertexP2uiv"); if proc == null() {dummy_pfnglvertexp2uivproc} else {unsafe{transmute(proc)}}},
			vertexp3ui: {let proc = get_proc_address("glVertexP3ui"); if proc == null() {dummy_pfnglvertexp3uiproc} else {unsafe{transmute(proc)}}},
			vertexp3uiv: {let proc = get_proc_address("glVertexP3uiv"); if proc == null() {dummy_pfnglvertexp3uivproc} else {unsafe{transmute(proc)}}},
			vertexp4ui: {let proc = get_proc_address("glVertexP4ui"); if proc == null() {dummy_pfnglvertexp4uiproc} else {unsafe{transmute(proc)}}},
			vertexp4uiv: {let proc = get_proc_address("glVertexP4uiv"); if proc == null() {dummy_pfnglvertexp4uivproc} else {unsafe{transmute(proc)}}},
			texcoordp1ui: {let proc = get_proc_address("glTexCoordP1ui"); if proc == null() {dummy_pfngltexcoordp1uiproc} else {unsafe{transmute(proc)}}},
			texcoordp1uiv: {let proc = get_proc_address("glTexCoordP1uiv"); if proc == null() {dummy_pfngltexcoordp1uivproc} else {unsafe{transmute(proc)}}},
			texcoordp2ui: {let proc = get_proc_address("glTexCoordP2ui"); if proc == null() {dummy_pfngltexcoordp2uiproc} else {unsafe{transmute(proc)}}},
			texcoordp2uiv: {let proc = get_proc_address("glTexCoordP2uiv"); if proc == null() {dummy_pfngltexcoordp2uivproc} else {unsafe{transmute(proc)}}},
			texcoordp3ui: {let proc = get_proc_address("glTexCoordP3ui"); if proc == null() {dummy_pfngltexcoordp3uiproc} else {unsafe{transmute(proc)}}},
			texcoordp3uiv: {let proc = get_proc_address("glTexCoordP3uiv"); if proc == null() {dummy_pfngltexcoordp3uivproc} else {unsafe{transmute(proc)}}},
			texcoordp4ui: {let proc = get_proc_address("glTexCoordP4ui"); if proc == null() {dummy_pfngltexcoordp4uiproc} else {unsafe{transmute(proc)}}},
			texcoordp4uiv: {let proc = get_proc_address("glTexCoordP4uiv"); if proc == null() {dummy_pfngltexcoordp4uivproc} else {unsafe{transmute(proc)}}},
			multitexcoordp1ui: {let proc = get_proc_address("glMultiTexCoordP1ui"); if proc == null() {dummy_pfnglmultitexcoordp1uiproc} else {unsafe{transmute(proc)}}},
			multitexcoordp1uiv: {let proc = get_proc_address("glMultiTexCoordP1uiv"); if proc == null() {dummy_pfnglmultitexcoordp1uivproc} else {unsafe{transmute(proc)}}},
			multitexcoordp2ui: {let proc = get_proc_address("glMultiTexCoordP2ui"); if proc == null() {dummy_pfnglmultitexcoordp2uiproc} else {unsafe{transmute(proc)}}},
			multitexcoordp2uiv: {let proc = get_proc_address("glMultiTexCoordP2uiv"); if proc == null() {dummy_pfnglmultitexcoordp2uivproc} else {unsafe{transmute(proc)}}},
			multitexcoordp3ui: {let proc = get_proc_address("glMultiTexCoordP3ui"); if proc == null() {dummy_pfnglmultitexcoordp3uiproc} else {unsafe{transmute(proc)}}},
			multitexcoordp3uiv: {let proc = get_proc_address("glMultiTexCoordP3uiv"); if proc == null() {dummy_pfnglmultitexcoordp3uivproc} else {unsafe{transmute(proc)}}},
			multitexcoordp4ui: {let proc = get_proc_address("glMultiTexCoordP4ui"); if proc == null() {dummy_pfnglmultitexcoordp4uiproc} else {unsafe{transmute(proc)}}},
			multitexcoordp4uiv: {let proc = get_proc_address("glMultiTexCoordP4uiv"); if proc == null() {dummy_pfnglmultitexcoordp4uivproc} else {unsafe{transmute(proc)}}},
			normalp3ui: {let proc = get_proc_address("glNormalP3ui"); if proc == null() {dummy_pfnglnormalp3uiproc} else {unsafe{transmute(proc)}}},
			normalp3uiv: {let proc = get_proc_address("glNormalP3uiv"); if proc == null() {dummy_pfnglnormalp3uivproc} else {unsafe{transmute(proc)}}},
			colorp3ui: {let proc = get_proc_address("glColorP3ui"); if proc == null() {dummy_pfnglcolorp3uiproc} else {unsafe{transmute(proc)}}},
			colorp3uiv: {let proc = get_proc_address("glColorP3uiv"); if proc == null() {dummy_pfnglcolorp3uivproc} else {unsafe{transmute(proc)}}},
			colorp4ui: {let proc = get_proc_address("glColorP4ui"); if proc == null() {dummy_pfnglcolorp4uiproc} else {unsafe{transmute(proc)}}},
			colorp4uiv: {let proc = get_proc_address("glColorP4uiv"); if proc == null() {dummy_pfnglcolorp4uivproc} else {unsafe{transmute(proc)}}},
			secondarycolorp3ui: {let proc = get_proc_address("glSecondaryColorP3ui"); if proc == null() {dummy_pfnglsecondarycolorp3uiproc} else {unsafe{transmute(proc)}}},
			secondarycolorp3uiv: {let proc = get_proc_address("glSecondaryColorP3uiv"); if proc == null() {dummy_pfnglsecondarycolorp3uivproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version33 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			bindfragdatalocationindexed: dummy_pfnglbindfragdatalocationindexedproc,
			getfragdataindex: dummy_pfnglgetfragdataindexproc,
			gensamplers: dummy_pfnglgensamplersproc,
			deletesamplers: dummy_pfngldeletesamplersproc,
			issampler: dummy_pfnglissamplerproc,
			bindsampler: dummy_pfnglbindsamplerproc,
			samplerparameteri: dummy_pfnglsamplerparameteriproc,
			samplerparameteriv: dummy_pfnglsamplerparameterivproc,
			samplerparameterf: dummy_pfnglsamplerparameterfproc,
			samplerparameterfv: dummy_pfnglsamplerparameterfvproc,
			samplerparameteriiv: dummy_pfnglsamplerparameteriivproc,
			samplerparameteriuiv: dummy_pfnglsamplerparameteriuivproc,
			getsamplerparameteriv: dummy_pfnglgetsamplerparameterivproc,
			getsamplerparameteriiv: dummy_pfnglgetsamplerparameteriivproc,
			getsamplerparameterfv: dummy_pfnglgetsamplerparameterfvproc,
			getsamplerparameteriuiv: dummy_pfnglgetsamplerparameteriuivproc,
			querycounter: dummy_pfnglquerycounterproc,
			getqueryobjecti64v: dummy_pfnglgetqueryobjecti64vproc,
			getqueryobjectui64v: dummy_pfnglgetqueryobjectui64vproc,
			vertexattribdivisor: dummy_pfnglvertexattribdivisorproc,
			vertexattribp1ui: dummy_pfnglvertexattribp1uiproc,
			vertexattribp1uiv: dummy_pfnglvertexattribp1uivproc,
			vertexattribp2ui: dummy_pfnglvertexattribp2uiproc,
			vertexattribp2uiv: dummy_pfnglvertexattribp2uivproc,
			vertexattribp3ui: dummy_pfnglvertexattribp3uiproc,
			vertexattribp3uiv: dummy_pfnglvertexattribp3uivproc,
			vertexattribp4ui: dummy_pfnglvertexattribp4uiproc,
			vertexattribp4uiv: dummy_pfnglvertexattribp4uivproc,
			vertexp2ui: dummy_pfnglvertexp2uiproc,
			vertexp2uiv: dummy_pfnglvertexp2uivproc,
			vertexp3ui: dummy_pfnglvertexp3uiproc,
			vertexp3uiv: dummy_pfnglvertexp3uivproc,
			vertexp4ui: dummy_pfnglvertexp4uiproc,
			vertexp4uiv: dummy_pfnglvertexp4uivproc,
			texcoordp1ui: dummy_pfngltexcoordp1uiproc,
			texcoordp1uiv: dummy_pfngltexcoordp1uivproc,
			texcoordp2ui: dummy_pfngltexcoordp2uiproc,
			texcoordp2uiv: dummy_pfngltexcoordp2uivproc,
			texcoordp3ui: dummy_pfngltexcoordp3uiproc,
			texcoordp3uiv: dummy_pfngltexcoordp3uivproc,
			texcoordp4ui: dummy_pfngltexcoordp4uiproc,
			texcoordp4uiv: dummy_pfngltexcoordp4uivproc,
			multitexcoordp1ui: dummy_pfnglmultitexcoordp1uiproc,
			multitexcoordp1uiv: dummy_pfnglmultitexcoordp1uivproc,
			multitexcoordp2ui: dummy_pfnglmultitexcoordp2uiproc,
			multitexcoordp2uiv: dummy_pfnglmultitexcoordp2uivproc,
			multitexcoordp3ui: dummy_pfnglmultitexcoordp3uiproc,
			multitexcoordp3uiv: dummy_pfnglmultitexcoordp3uivproc,
			multitexcoordp4ui: dummy_pfnglmultitexcoordp4uiproc,
			multitexcoordp4uiv: dummy_pfnglmultitexcoordp4uivproc,
			normalp3ui: dummy_pfnglnormalp3uiproc,
			normalp3uiv: dummy_pfnglnormalp3uivproc,
			colorp3ui: dummy_pfnglcolorp3uiproc,
			colorp3uiv: dummy_pfnglcolorp3uivproc,
			colorp4ui: dummy_pfnglcolorp4uiproc,
			colorp4uiv: dummy_pfnglcolorp4uivproc,
			secondarycolorp3ui: dummy_pfnglsecondarycolorp3uiproc,
			secondarycolorp3uiv: dummy_pfnglsecondarycolorp3uivproc,
		}
	}
}
impl Debug for Version33 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version33")
			.field("available", &self.available)
			.field("bindfragdatalocationindexed", unsafe{if transmute::<_, *const c_void>(self.bindfragdatalocationindexed) == (dummy_pfnglbindfragdatalocationindexedproc as *const c_void) {&null::<PFNGLBINDFRAGDATALOCATIONINDEXEDPROC>()} else {&self.bindfragdatalocationindexed}})
			.field("getfragdataindex", unsafe{if transmute::<_, *const c_void>(self.getfragdataindex) == (dummy_pfnglgetfragdataindexproc as *const c_void) {&null::<PFNGLGETFRAGDATAINDEXPROC>()} else {&self.getfragdataindex}})
			.field("gensamplers", unsafe{if transmute::<_, *const c_void>(self.gensamplers) == (dummy_pfnglgensamplersproc as *const c_void) {&null::<PFNGLGENSAMPLERSPROC>()} else {&self.gensamplers}})
			.field("deletesamplers", unsafe{if transmute::<_, *const c_void>(self.deletesamplers) == (dummy_pfngldeletesamplersproc as *const c_void) {&null::<PFNGLDELETESAMPLERSPROC>()} else {&self.deletesamplers}})
			.field("issampler", unsafe{if transmute::<_, *const c_void>(self.issampler) == (dummy_pfnglissamplerproc as *const c_void) {&null::<PFNGLISSAMPLERPROC>()} else {&self.issampler}})
			.field("bindsampler", unsafe{if transmute::<_, *const c_void>(self.bindsampler) == (dummy_pfnglbindsamplerproc as *const c_void) {&null::<PFNGLBINDSAMPLERPROC>()} else {&self.bindsampler}})
			.field("samplerparameteri", unsafe{if transmute::<_, *const c_void>(self.samplerparameteri) == (dummy_pfnglsamplerparameteriproc as *const c_void) {&null::<PFNGLSAMPLERPARAMETERIPROC>()} else {&self.samplerparameteri}})
			.field("samplerparameteriv", unsafe{if transmute::<_, *const c_void>(self.samplerparameteriv) == (dummy_pfnglsamplerparameterivproc as *const c_void) {&null::<PFNGLSAMPLERPARAMETERIVPROC>()} else {&self.samplerparameteriv}})
			.field("samplerparameterf", unsafe{if transmute::<_, *const c_void>(self.samplerparameterf) == (dummy_pfnglsamplerparameterfproc as *const c_void) {&null::<PFNGLSAMPLERPARAMETERFPROC>()} else {&self.samplerparameterf}})
			.field("samplerparameterfv", unsafe{if transmute::<_, *const c_void>(self.samplerparameterfv) == (dummy_pfnglsamplerparameterfvproc as *const c_void) {&null::<PFNGLSAMPLERPARAMETERFVPROC>()} else {&self.samplerparameterfv}})
			.field("samplerparameteriiv", unsafe{if transmute::<_, *const c_void>(self.samplerparameteriiv) == (dummy_pfnglsamplerparameteriivproc as *const c_void) {&null::<PFNGLSAMPLERPARAMETERIIVPROC>()} else {&self.samplerparameteriiv}})
			.field("samplerparameteriuiv", unsafe{if transmute::<_, *const c_void>(self.samplerparameteriuiv) == (dummy_pfnglsamplerparameteriuivproc as *const c_void) {&null::<PFNGLSAMPLERPARAMETERIUIVPROC>()} else {&self.samplerparameteriuiv}})
			.field("getsamplerparameteriv", unsafe{if transmute::<_, *const c_void>(self.getsamplerparameteriv) == (dummy_pfnglgetsamplerparameterivproc as *const c_void) {&null::<PFNGLGETSAMPLERPARAMETERIVPROC>()} else {&self.getsamplerparameteriv}})
			.field("getsamplerparameteriiv", unsafe{if transmute::<_, *const c_void>(self.getsamplerparameteriiv) == (dummy_pfnglgetsamplerparameteriivproc as *const c_void) {&null::<PFNGLGETSAMPLERPARAMETERIIVPROC>()} else {&self.getsamplerparameteriiv}})
			.field("getsamplerparameterfv", unsafe{if transmute::<_, *const c_void>(self.getsamplerparameterfv) == (dummy_pfnglgetsamplerparameterfvproc as *const c_void) {&null::<PFNGLGETSAMPLERPARAMETERFVPROC>()} else {&self.getsamplerparameterfv}})
			.field("getsamplerparameteriuiv", unsafe{if transmute::<_, *const c_void>(self.getsamplerparameteriuiv) == (dummy_pfnglgetsamplerparameteriuivproc as *const c_void) {&null::<PFNGLGETSAMPLERPARAMETERIUIVPROC>()} else {&self.getsamplerparameteriuiv}})
			.field("querycounter", unsafe{if transmute::<_, *const c_void>(self.querycounter) == (dummy_pfnglquerycounterproc as *const c_void) {&null::<PFNGLQUERYCOUNTERPROC>()} else {&self.querycounter}})
			.field("getqueryobjecti64v", unsafe{if transmute::<_, *const c_void>(self.getqueryobjecti64v) == (dummy_pfnglgetqueryobjecti64vproc as *const c_void) {&null::<PFNGLGETQUERYOBJECTI64VPROC>()} else {&self.getqueryobjecti64v}})
			.field("getqueryobjectui64v", unsafe{if transmute::<_, *const c_void>(self.getqueryobjectui64v) == (dummy_pfnglgetqueryobjectui64vproc as *const c_void) {&null::<PFNGLGETQUERYOBJECTUI64VPROC>()} else {&self.getqueryobjectui64v}})
			.field("vertexattribdivisor", unsafe{if transmute::<_, *const c_void>(self.vertexattribdivisor) == (dummy_pfnglvertexattribdivisorproc as *const c_void) {&null::<PFNGLVERTEXATTRIBDIVISORPROC>()} else {&self.vertexattribdivisor}})
			.field("vertexattribp1ui", unsafe{if transmute::<_, *const c_void>(self.vertexattribp1ui) == (dummy_pfnglvertexattribp1uiproc as *const c_void) {&null::<PFNGLVERTEXATTRIBP1UIPROC>()} else {&self.vertexattribp1ui}})
			.field("vertexattribp1uiv", unsafe{if transmute::<_, *const c_void>(self.vertexattribp1uiv) == (dummy_pfnglvertexattribp1uivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBP1UIVPROC>()} else {&self.vertexattribp1uiv}})
			.field("vertexattribp2ui", unsafe{if transmute::<_, *const c_void>(self.vertexattribp2ui) == (dummy_pfnglvertexattribp2uiproc as *const c_void) {&null::<PFNGLVERTEXATTRIBP2UIPROC>()} else {&self.vertexattribp2ui}})
			.field("vertexattribp2uiv", unsafe{if transmute::<_, *const c_void>(self.vertexattribp2uiv) == (dummy_pfnglvertexattribp2uivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBP2UIVPROC>()} else {&self.vertexattribp2uiv}})
			.field("vertexattribp3ui", unsafe{if transmute::<_, *const c_void>(self.vertexattribp3ui) == (dummy_pfnglvertexattribp3uiproc as *const c_void) {&null::<PFNGLVERTEXATTRIBP3UIPROC>()} else {&self.vertexattribp3ui}})
			.field("vertexattribp3uiv", unsafe{if transmute::<_, *const c_void>(self.vertexattribp3uiv) == (dummy_pfnglvertexattribp3uivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBP3UIVPROC>()} else {&self.vertexattribp3uiv}})
			.field("vertexattribp4ui", unsafe{if transmute::<_, *const c_void>(self.vertexattribp4ui) == (dummy_pfnglvertexattribp4uiproc as *const c_void) {&null::<PFNGLVERTEXATTRIBP4UIPROC>()} else {&self.vertexattribp4ui}})
			.field("vertexattribp4uiv", unsafe{if transmute::<_, *const c_void>(self.vertexattribp4uiv) == (dummy_pfnglvertexattribp4uivproc as *const c_void) {&null::<PFNGLVERTEXATTRIBP4UIVPROC>()} else {&self.vertexattribp4uiv}})
			.field("vertexp2ui", unsafe{if transmute::<_, *const c_void>(self.vertexp2ui) == (dummy_pfnglvertexp2uiproc as *const c_void) {&null::<PFNGLVERTEXP2UIPROC>()} else {&self.vertexp2ui}})
			.field("vertexp2uiv", unsafe{if transmute::<_, *const c_void>(self.vertexp2uiv) == (dummy_pfnglvertexp2uivproc as *const c_void) {&null::<PFNGLVERTEXP2UIVPROC>()} else {&self.vertexp2uiv}})
			.field("vertexp3ui", unsafe{if transmute::<_, *const c_void>(self.vertexp3ui) == (dummy_pfnglvertexp3uiproc as *const c_void) {&null::<PFNGLVERTEXP3UIPROC>()} else {&self.vertexp3ui}})
			.field("vertexp3uiv", unsafe{if transmute::<_, *const c_void>(self.vertexp3uiv) == (dummy_pfnglvertexp3uivproc as *const c_void) {&null::<PFNGLVERTEXP3UIVPROC>()} else {&self.vertexp3uiv}})
			.field("vertexp4ui", unsafe{if transmute::<_, *const c_void>(self.vertexp4ui) == (dummy_pfnglvertexp4uiproc as *const c_void) {&null::<PFNGLVERTEXP4UIPROC>()} else {&self.vertexp4ui}})
			.field("vertexp4uiv", unsafe{if transmute::<_, *const c_void>(self.vertexp4uiv) == (dummy_pfnglvertexp4uivproc as *const c_void) {&null::<PFNGLVERTEXP4UIVPROC>()} else {&self.vertexp4uiv}})
			.field("texcoordp1ui", unsafe{if transmute::<_, *const c_void>(self.texcoordp1ui) == (dummy_pfngltexcoordp1uiproc as *const c_void) {&null::<PFNGLTEXCOORDP1UIPROC>()} else {&self.texcoordp1ui}})
			.field("texcoordp1uiv", unsafe{if transmute::<_, *const c_void>(self.texcoordp1uiv) == (dummy_pfngltexcoordp1uivproc as *const c_void) {&null::<PFNGLTEXCOORDP1UIVPROC>()} else {&self.texcoordp1uiv}})
			.field("texcoordp2ui", unsafe{if transmute::<_, *const c_void>(self.texcoordp2ui) == (dummy_pfngltexcoordp2uiproc as *const c_void) {&null::<PFNGLTEXCOORDP2UIPROC>()} else {&self.texcoordp2ui}})
			.field("texcoordp2uiv", unsafe{if transmute::<_, *const c_void>(self.texcoordp2uiv) == (dummy_pfngltexcoordp2uivproc as *const c_void) {&null::<PFNGLTEXCOORDP2UIVPROC>()} else {&self.texcoordp2uiv}})
			.field("texcoordp3ui", unsafe{if transmute::<_, *const c_void>(self.texcoordp3ui) == (dummy_pfngltexcoordp3uiproc as *const c_void) {&null::<PFNGLTEXCOORDP3UIPROC>()} else {&self.texcoordp3ui}})
			.field("texcoordp3uiv", unsafe{if transmute::<_, *const c_void>(self.texcoordp3uiv) == (dummy_pfngltexcoordp3uivproc as *const c_void) {&null::<PFNGLTEXCOORDP3UIVPROC>()} else {&self.texcoordp3uiv}})
			.field("texcoordp4ui", unsafe{if transmute::<_, *const c_void>(self.texcoordp4ui) == (dummy_pfngltexcoordp4uiproc as *const c_void) {&null::<PFNGLTEXCOORDP4UIPROC>()} else {&self.texcoordp4ui}})
			.field("texcoordp4uiv", unsafe{if transmute::<_, *const c_void>(self.texcoordp4uiv) == (dummy_pfngltexcoordp4uivproc as *const c_void) {&null::<PFNGLTEXCOORDP4UIVPROC>()} else {&self.texcoordp4uiv}})
			.field("multitexcoordp1ui", unsafe{if transmute::<_, *const c_void>(self.multitexcoordp1ui) == (dummy_pfnglmultitexcoordp1uiproc as *const c_void) {&null::<PFNGLMULTITEXCOORDP1UIPROC>()} else {&self.multitexcoordp1ui}})
			.field("multitexcoordp1uiv", unsafe{if transmute::<_, *const c_void>(self.multitexcoordp1uiv) == (dummy_pfnglmultitexcoordp1uivproc as *const c_void) {&null::<PFNGLMULTITEXCOORDP1UIVPROC>()} else {&self.multitexcoordp1uiv}})
			.field("multitexcoordp2ui", unsafe{if transmute::<_, *const c_void>(self.multitexcoordp2ui) == (dummy_pfnglmultitexcoordp2uiproc as *const c_void) {&null::<PFNGLMULTITEXCOORDP2UIPROC>()} else {&self.multitexcoordp2ui}})
			.field("multitexcoordp2uiv", unsafe{if transmute::<_, *const c_void>(self.multitexcoordp2uiv) == (dummy_pfnglmultitexcoordp2uivproc as *const c_void) {&null::<PFNGLMULTITEXCOORDP2UIVPROC>()} else {&self.multitexcoordp2uiv}})
			.field("multitexcoordp3ui", unsafe{if transmute::<_, *const c_void>(self.multitexcoordp3ui) == (dummy_pfnglmultitexcoordp3uiproc as *const c_void) {&null::<PFNGLMULTITEXCOORDP3UIPROC>()} else {&self.multitexcoordp3ui}})
			.field("multitexcoordp3uiv", unsafe{if transmute::<_, *const c_void>(self.multitexcoordp3uiv) == (dummy_pfnglmultitexcoordp3uivproc as *const c_void) {&null::<PFNGLMULTITEXCOORDP3UIVPROC>()} else {&self.multitexcoordp3uiv}})
			.field("multitexcoordp4ui", unsafe{if transmute::<_, *const c_void>(self.multitexcoordp4ui) == (dummy_pfnglmultitexcoordp4uiproc as *const c_void) {&null::<PFNGLMULTITEXCOORDP4UIPROC>()} else {&self.multitexcoordp4ui}})
			.field("multitexcoordp4uiv", unsafe{if transmute::<_, *const c_void>(self.multitexcoordp4uiv) == (dummy_pfnglmultitexcoordp4uivproc as *const c_void) {&null::<PFNGLMULTITEXCOORDP4UIVPROC>()} else {&self.multitexcoordp4uiv}})
			.field("normalp3ui", unsafe{if transmute::<_, *const c_void>(self.normalp3ui) == (dummy_pfnglnormalp3uiproc as *const c_void) {&null::<PFNGLNORMALP3UIPROC>()} else {&self.normalp3ui}})
			.field("normalp3uiv", unsafe{if transmute::<_, *const c_void>(self.normalp3uiv) == (dummy_pfnglnormalp3uivproc as *const c_void) {&null::<PFNGLNORMALP3UIVPROC>()} else {&self.normalp3uiv}})
			.field("colorp3ui", unsafe{if transmute::<_, *const c_void>(self.colorp3ui) == (dummy_pfnglcolorp3uiproc as *const c_void) {&null::<PFNGLCOLORP3UIPROC>()} else {&self.colorp3ui}})
			.field("colorp3uiv", unsafe{if transmute::<_, *const c_void>(self.colorp3uiv) == (dummy_pfnglcolorp3uivproc as *const c_void) {&null::<PFNGLCOLORP3UIVPROC>()} else {&self.colorp3uiv}})
			.field("colorp4ui", unsafe{if transmute::<_, *const c_void>(self.colorp4ui) == (dummy_pfnglcolorp4uiproc as *const c_void) {&null::<PFNGLCOLORP4UIPROC>()} else {&self.colorp4ui}})
			.field("colorp4uiv", unsafe{if transmute::<_, *const c_void>(self.colorp4uiv) == (dummy_pfnglcolorp4uivproc as *const c_void) {&null::<PFNGLCOLORP4UIVPROC>()} else {&self.colorp4uiv}})
			.field("secondarycolorp3ui", unsafe{if transmute::<_, *const c_void>(self.secondarycolorp3ui) == (dummy_pfnglsecondarycolorp3uiproc as *const c_void) {&null::<PFNGLSECONDARYCOLORP3UIPROC>()} else {&self.secondarycolorp3ui}})
			.field("secondarycolorp3uiv", unsafe{if transmute::<_, *const c_void>(self.secondarycolorp3uiv) == (dummy_pfnglsecondarycolorp3uivproc as *const c_void) {&null::<PFNGLSECONDARYCOLORP3UIVPROC>()} else {&self.secondarycolorp3uiv}})
			.finish()
		} else {
			f.debug_struct("Version33")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}
type PFNGLMINSAMPLESHADINGPROC = extern "system" fn(GLfloat);
type PFNGLBLENDEQUATIONIPROC = extern "system" fn(GLuint, GLenum);
type PFNGLBLENDEQUATIONSEPARATEIPROC = extern "system" fn(GLuint, GLenum, GLenum);
type PFNGLBLENDFUNCIPROC = extern "system" fn(GLuint, GLenum, GLenum);
type PFNGLBLENDFUNCSEPARATEIPROC = extern "system" fn(GLuint, GLenum, GLenum, GLenum, GLenum);
type PFNGLDRAWARRAYSINDIRECTPROC = extern "system" fn(GLenum, *const c_void);
type PFNGLDRAWELEMENTSINDIRECTPROC = extern "system" fn(GLenum, GLenum, *const c_void);
type PFNGLUNIFORM1DPROC = extern "system" fn(GLint, GLdouble);
type PFNGLUNIFORM2DPROC = extern "system" fn(GLint, GLdouble, GLdouble);
type PFNGLUNIFORM3DPROC = extern "system" fn(GLint, GLdouble, GLdouble, GLdouble);
type PFNGLUNIFORM4DPROC = extern "system" fn(GLint, GLdouble, GLdouble, GLdouble, GLdouble);
type PFNGLUNIFORM1DVPROC = extern "system" fn(GLint, GLsizei, *const GLdouble);
type PFNGLUNIFORM2DVPROC = extern "system" fn(GLint, GLsizei, *const GLdouble);
type PFNGLUNIFORM3DVPROC = extern "system" fn(GLint, GLsizei, *const GLdouble);
type PFNGLUNIFORM4DVPROC = extern "system" fn(GLint, GLsizei, *const GLdouble);
type PFNGLUNIFORMMATRIX2DVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble);
type PFNGLUNIFORMMATRIX3DVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble);
type PFNGLUNIFORMMATRIX4DVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble);
type PFNGLUNIFORMMATRIX2X3DVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble);
type PFNGLUNIFORMMATRIX2X4DVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble);
type PFNGLUNIFORMMATRIX3X2DVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble);
type PFNGLUNIFORMMATRIX3X4DVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble);
type PFNGLUNIFORMMATRIX4X2DVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble);
type PFNGLUNIFORMMATRIX4X3DVPROC = extern "system" fn(GLint, GLsizei, GLboolean, *const GLdouble);
type PFNGLGETUNIFORMDVPROC = extern "system" fn(GLuint, GLint, *mut GLdouble);
type PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC = extern "system" fn(GLuint, GLenum, *const GLchar) -> GLint;
type PFNGLGETSUBROUTINEINDEXPROC = extern "system" fn(GLuint, GLenum, *const GLchar) -> GLuint;
type PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC = extern "system" fn(GLuint, GLenum, GLuint, GLenum, *mut GLint);
type PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC = extern "system" fn(GLuint, GLenum, GLuint, GLsizei, *mut GLsizei, *mut GLchar);
type PFNGLGETACTIVESUBROUTINENAMEPROC = extern "system" fn(GLuint, GLenum, GLuint, GLsizei, *mut GLsizei, *mut GLchar);
type PFNGLUNIFORMSUBROUTINESUIVPROC = extern "system" fn(GLenum, GLsizei, *const GLuint);
type PFNGLGETUNIFORMSUBROUTINEUIVPROC = extern "system" fn(GLenum, GLint, *mut GLuint);
type PFNGLGETPROGRAMSTAGEIVPROC = extern "system" fn(GLuint, GLenum, GLenum, *mut GLint);
type PFNGLPATCHPARAMETERIPROC = extern "system" fn(GLenum, GLint);
type PFNGLPATCHPARAMETERFVPROC = extern "system" fn(GLenum, *const GLfloat);
type PFNGLBINDTRANSFORMFEEDBACKPROC = extern "system" fn(GLenum, GLuint);
type PFNGLDELETETRANSFORMFEEDBACKSPROC = extern "system" fn(GLsizei, *const GLuint);
type PFNGLGENTRANSFORMFEEDBACKSPROC = extern "system" fn(GLsizei, *mut GLuint);
type PFNGLISTRANSFORMFEEDBACKPROC = extern "system" fn(GLuint) -> GLboolean;
type PFNGLPAUSETRANSFORMFEEDBACKPROC = extern "system" fn();
type PFNGLRESUMETRANSFORMFEEDBACKPROC = extern "system" fn();
type PFNGLDRAWTRANSFORMFEEDBACKPROC = extern "system" fn(GLenum, GLuint);
type PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC = extern "system" fn(GLenum, GLuint, GLuint);
type PFNGLBEGINQUERYINDEXEDPROC = extern "system" fn(GLenum, GLuint, GLuint);
type PFNGLENDQUERYINDEXEDPROC = extern "system" fn(GLenum, GLuint);
type PFNGLGETQUERYINDEXEDIVPROC = extern "system" fn(GLenum, GLuint, GLenum, *mut GLint);
extern "system" fn dummy_pfnglminsampleshadingproc (_: GLfloat) {
	panic!("OpenGL function pointer `glMinSampleShading()` is null.")
}
extern "system" fn dummy_pfnglblendequationiproc (_: GLuint, _: GLenum) {
	panic!("OpenGL function pointer `glBlendEquationi()` is null.")
}
extern "system" fn dummy_pfnglblendequationseparateiproc (_: GLuint, _: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glBlendEquationSeparatei()` is null.")
}
extern "system" fn dummy_pfnglblendfunciproc (_: GLuint, _: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glBlendFunci()` is null.")
}
extern "system" fn dummy_pfnglblendfuncseparateiproc (_: GLuint, _: GLenum, _: GLenum, _: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glBlendFuncSeparatei()` is null.")
}
extern "system" fn dummy_pfngldrawarraysindirectproc (_: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glDrawArraysIndirect()` is null.")
}
extern "system" fn dummy_pfngldrawelementsindirectproc (_: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glDrawElementsIndirect()` is null.")
}
extern "system" fn dummy_pfngluniform1dproc (_: GLint, _: GLdouble) {
	panic!("OpenGL function pointer `glUniform1d()` is null.")
}
extern "system" fn dummy_pfngluniform2dproc (_: GLint, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glUniform2d()` is null.")
}
extern "system" fn dummy_pfngluniform3dproc (_: GLint, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glUniform3d()` is null.")
}
extern "system" fn dummy_pfngluniform4dproc (_: GLint, _: GLdouble, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glUniform4d()` is null.")
}
extern "system" fn dummy_pfngluniform1dvproc (_: GLint, _: GLsizei, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniform1dv()` is null.")
}
extern "system" fn dummy_pfngluniform2dvproc (_: GLint, _: GLsizei, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniform2dv()` is null.")
}
extern "system" fn dummy_pfngluniform3dvproc (_: GLint, _: GLsizei, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniform3dv()` is null.")
}
extern "system" fn dummy_pfngluniform4dvproc (_: GLint, _: GLsizei, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniform4dv()` is null.")
}
extern "system" fn dummy_pfngluniformmatrix2dvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniformMatrix2dv()` is null.")
}
extern "system" fn dummy_pfngluniformmatrix3dvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniformMatrix3dv()` is null.")
}
extern "system" fn dummy_pfngluniformmatrix4dvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniformMatrix4dv()` is null.")
}
extern "system" fn dummy_pfngluniformmatrix2x3dvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniformMatrix2x3dv()` is null.")
}
extern "system" fn dummy_pfngluniformmatrix2x4dvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniformMatrix2x4dv()` is null.")
}
extern "system" fn dummy_pfngluniformmatrix3x2dvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniformMatrix3x2dv()` is null.")
}
extern "system" fn dummy_pfngluniformmatrix3x4dvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniformMatrix3x4dv()` is null.")
}
extern "system" fn dummy_pfngluniformmatrix4x2dvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniformMatrix4x2dv()` is null.")
}
extern "system" fn dummy_pfngluniformmatrix4x3dvproc (_: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glUniformMatrix4x3dv()` is null.")
}
extern "system" fn dummy_pfnglgetuniformdvproc (_: GLuint, _: GLint, _: *mut GLdouble) {
	panic!("OpenGL function pointer `glGetUniformdv()` is null.")
}
extern "system" fn dummy_pfnglgetsubroutineuniformlocationproc (_: GLuint, _: GLenum, _: *const GLchar) -> GLint {
	panic!("OpenGL function pointer `glGetSubroutineUniformLocation()` is null.")
}
extern "system" fn dummy_pfnglgetsubroutineindexproc (_: GLuint, _: GLenum, _: *const GLchar) -> GLuint {
	panic!("OpenGL function pointer `glGetSubroutineIndex()` is null.")
}
extern "system" fn dummy_pfnglgetactivesubroutineuniformivproc (_: GLuint, _: GLenum, _: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetActiveSubroutineUniformiv()` is null.")
}
extern "system" fn dummy_pfnglgetactivesubroutineuniformnameproc (_: GLuint, _: GLenum, _: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetActiveSubroutineUniformName()` is null.")
}
extern "system" fn dummy_pfnglgetactivesubroutinenameproc (_: GLuint, _: GLenum, _: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetActiveSubroutineName()` is null.")
}
extern "system" fn dummy_pfngluniformsubroutinesuivproc (_: GLenum, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glUniformSubroutinesuiv()` is null.")
}
extern "system" fn dummy_pfnglgetuniformsubroutineuivproc (_: GLenum, _: GLint, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetUniformSubroutineuiv()` is null.")
}
extern "system" fn dummy_pfnglgetprogramstageivproc (_: GLuint, _: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetProgramStageiv()` is null.")
}
extern "system" fn dummy_pfnglpatchparameteriproc (_: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glPatchParameteri()` is null.")
}
extern "system" fn dummy_pfnglpatchparameterfvproc (_: GLenum, _: *const GLfloat) {
	panic!("OpenGL function pointer `glPatchParameterfv()` is null.")
}
extern "system" fn dummy_pfnglbindtransformfeedbackproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glBindTransformFeedback()` is null.")
}
extern "system" fn dummy_pfngldeletetransformfeedbacksproc (_: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glDeleteTransformFeedbacks()` is null.")
}
extern "system" fn dummy_pfnglgentransformfeedbacksproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGenTransformFeedbacks()` is null.")
}
extern "system" fn dummy_pfnglistransformfeedbackproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsTransformFeedback()` is null.")
}
extern "system" fn dummy_pfnglpausetransformfeedbackproc () {
	panic!("OpenGL function pointer `glPauseTransformFeedback()` is null.")
}
extern "system" fn dummy_pfnglresumetransformfeedbackproc () {
	panic!("OpenGL function pointer `glResumeTransformFeedback()` is null.")
}
extern "system" fn dummy_pfngldrawtransformfeedbackproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glDrawTransformFeedback()` is null.")
}
extern "system" fn dummy_pfngldrawtransformfeedbackstreamproc (_: GLenum, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glDrawTransformFeedbackStream()` is null.")
}
extern "system" fn dummy_pfnglbeginqueryindexedproc (_: GLenum, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glBeginQueryIndexed()` is null.")
}
extern "system" fn dummy_pfnglendqueryindexedproc (_: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glEndQueryIndexed()` is null.")
}
extern "system" fn dummy_pfnglgetqueryindexedivproc (_: GLenum, _: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetQueryIndexediv()` is null.")
}
pub const GL_SAMPLE_SHADING: GLenum = 0x8C36;
pub const GL_MIN_SAMPLE_SHADING_VALUE: GLenum = 0x8C37;
pub const GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET: GLenum = 0x8E5E;
pub const GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET: GLenum = 0x8E5F;
pub const GL_TEXTURE_CUBE_MAP_ARRAY: GLenum = 0x9009;
pub const GL_TEXTURE_BINDING_CUBE_MAP_ARRAY: GLenum = 0x900A;
pub const GL_PROXY_TEXTURE_CUBE_MAP_ARRAY: GLenum = 0x900B;
pub const GL_SAMPLER_CUBE_MAP_ARRAY: GLenum = 0x900C;
pub const GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW: GLenum = 0x900D;
pub const GL_INT_SAMPLER_CUBE_MAP_ARRAY: GLenum = 0x900E;
pub const GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY: GLenum = 0x900F;
pub const GL_DRAW_INDIRECT_BUFFER: GLenum = 0x8F3F;
pub const GL_DRAW_INDIRECT_BUFFER_BINDING: GLenum = 0x8F43;
pub const GL_GEOMETRY_SHADER_INVOCATIONS: GLenum = 0x887F;
pub const GL_MAX_GEOMETRY_SHADER_INVOCATIONS: GLenum = 0x8E5A;
pub const GL_MIN_FRAGMENT_INTERPOLATION_OFFSET: GLenum = 0x8E5B;
pub const GL_MAX_FRAGMENT_INTERPOLATION_OFFSET: GLenum = 0x8E5C;
pub const GL_FRAGMENT_INTERPOLATION_OFFSET_BITS: GLenum = 0x8E5D;
pub const GL_MAX_VERTEX_STREAMS: GLenum = 0x8E71;
pub const GL_DOUBLE_VEC2: GLenum = 0x8FFC;
pub const GL_DOUBLE_VEC3: GLenum = 0x8FFD;
pub const GL_DOUBLE_VEC4: GLenum = 0x8FFE;
pub const GL_DOUBLE_MAT2: GLenum = 0x8F46;
pub const GL_DOUBLE_MAT3: GLenum = 0x8F47;
pub const GL_DOUBLE_MAT4: GLenum = 0x8F48;
pub const GL_DOUBLE_MAT2x3: GLenum = 0x8F49;
pub const GL_DOUBLE_MAT2x4: GLenum = 0x8F4A;
pub const GL_DOUBLE_MAT3x2: GLenum = 0x8F4B;
pub const GL_DOUBLE_MAT3x4: GLenum = 0x8F4C;
pub const GL_DOUBLE_MAT4x2: GLenum = 0x8F4D;
pub const GL_DOUBLE_MAT4x3: GLenum = 0x8F4E;
pub const GL_ACTIVE_SUBROUTINES: GLenum = 0x8DE5;
pub const GL_ACTIVE_SUBROUTINE_UNIFORMS: GLenum = 0x8DE6;
pub const GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS: GLenum = 0x8E47;
pub const GL_ACTIVE_SUBROUTINE_MAX_LENGTH: GLenum = 0x8E48;
pub const GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH: GLenum = 0x8E49;
pub const GL_MAX_SUBROUTINES: GLenum = 0x8DE7;
pub const GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS: GLenum = 0x8DE8;
pub const GL_NUM_COMPATIBLE_SUBROUTINES: GLenum = 0x8E4A;
pub const GL_COMPATIBLE_SUBROUTINES: GLenum = 0x8E4B;
pub const GL_PATCHES: GLenum = 0x000E;
pub const GL_PATCH_VERTICES: GLenum = 0x8E72;
pub const GL_PATCH_DEFAULT_INNER_LEVEL: GLenum = 0x8E73;
pub const GL_PATCH_DEFAULT_OUTER_LEVEL: GLenum = 0x8E74;
pub const GL_TESS_CONTROL_OUTPUT_VERTICES: GLenum = 0x8E75;
pub const GL_TESS_GEN_MODE: GLenum = 0x8E76;
pub const GL_TESS_GEN_SPACING: GLenum = 0x8E77;
pub const GL_TESS_GEN_VERTEX_ORDER: GLenum = 0x8E78;
pub const GL_TESS_GEN_POINT_MODE: GLenum = 0x8E79;
pub const GL_ISOLINES: GLenum = 0x8E7A;
pub const GL_FRACTIONAL_ODD: GLenum = 0x8E7B;
pub const GL_FRACTIONAL_EVEN: GLenum = 0x8E7C;
pub const GL_MAX_PATCH_VERTICES: GLenum = 0x8E7D;
pub const GL_MAX_TESS_GEN_LEVEL: GLenum = 0x8E7E;
pub const GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS: GLenum = 0x8E7F;
pub const GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS: GLenum = 0x8E80;
pub const GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS: GLenum = 0x8E81;
pub const GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS: GLenum = 0x8E82;
pub const GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS: GLenum = 0x8E83;
pub const GL_MAX_TESS_PATCH_COMPONENTS: GLenum = 0x8E84;
pub const GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS: GLenum = 0x8E85;
pub const GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS: GLenum = 0x8E86;
pub const GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS: GLenum = 0x8E89;
pub const GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS: GLenum = 0x8E8A;
pub const GL_MAX_TESS_CONTROL_INPUT_COMPONENTS: GLenum = 0x886C;
pub const GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS: GLenum = 0x886D;
pub const GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS: GLenum = 0x8E1E;
pub const GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS: GLenum = 0x8E1F;
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER: GLenum = 0x84F0;
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER: GLenum = 0x84F1;
pub const GL_TESS_EVALUATION_SHADER: GLenum = 0x8E87;
pub const GL_TESS_CONTROL_SHADER: GLenum = 0x8E88;
pub const GL_TRANSFORM_FEEDBACK: GLenum = 0x8E22;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED: GLenum = 0x8E23;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE: GLenum = 0x8E24;
pub const GL_TRANSFORM_FEEDBACK_BINDING: GLenum = 0x8E25;
pub const GL_MAX_TRANSFORM_FEEDBACK_BUFFERS: GLenum = 0x8E70;

pub trait GL_4_0 {
	fn glGetError(&self) -> GLenum;
	fn glMinSampleShading(&self, value: GLfloat) -> Result<()>;
	fn glBlendEquationi(&self, buf: GLuint, mode: GLenum) -> Result<()>;
	fn glBlendEquationSeparatei(&self, buf: GLuint, modeRGB: GLenum, modeAlpha: GLenum) -> Result<()>;
	fn glBlendFunci(&self, buf: GLuint, src: GLenum, dst: GLenum) -> Result<()>;
	fn glBlendFuncSeparatei(&self, buf: GLuint, srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum) -> Result<()>;
	fn glDrawArraysIndirect(&self, mode: GLenum, indirect: *const c_void) -> Result<()>;
	fn glDrawElementsIndirect(&self, mode: GLenum, type_: GLenum, indirect: *const c_void) -> Result<()>;
	fn glUniform1d(&self, location: GLint, x: GLdouble) -> Result<()>;
	fn glUniform2d(&self, location: GLint, x: GLdouble, y: GLdouble) -> Result<()>;
	fn glUniform3d(&self, location: GLint, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()>;
	fn glUniform4d(&self, location: GLint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble) -> Result<()>;
	fn glUniform1dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()>;
	fn glUniform2dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()>;
	fn glUniform3dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()>;
	fn glUniform4dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()>;
	fn glUniformMatrix2dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;
	fn glUniformMatrix3dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;
	fn glUniformMatrix4dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;
	fn glUniformMatrix2x3dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;
	fn glUniformMatrix2x4dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;
	fn glUniformMatrix3x2dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;
	fn glUniformMatrix3x4dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;
	fn glUniformMatrix4x2dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;
	fn glUniformMatrix4x3dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;
	fn glGetUniformdv(&self, program: GLuint, location: GLint, params: *mut GLdouble) -> Result<()>;
	fn glGetSubroutineUniformLocation(&self, program: GLuint, shadertype: GLenum, name: *const GLchar) -> Result<GLint>;
	fn glGetSubroutineIndex(&self, program: GLuint, shadertype: GLenum, name: *const GLchar) -> Result<GLuint>;
	fn glGetActiveSubroutineUniformiv(&self, program: GLuint, shadertype: GLenum, index: GLuint, pname: GLenum, values: *mut GLint) -> Result<()>;
	fn glGetActiveSubroutineUniformName(&self, program: GLuint, shadertype: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar) -> Result<()>;
	fn glGetActiveSubroutineName(&self, program: GLuint, shadertype: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar) -> Result<()>;
	fn glUniformSubroutinesuiv(&self, shadertype: GLenum, count: GLsizei, indices: *const GLuint) -> Result<()>;
	fn glGetUniformSubroutineuiv(&self, shadertype: GLenum, location: GLint, params: *mut GLuint) -> Result<()>;
	fn glGetProgramStageiv(&self, program: GLuint, shadertype: GLenum, pname: GLenum, values: *mut GLint) -> Result<()>;
	fn glPatchParameteri(&self, pname: GLenum, value: GLint) -> Result<()>;
	fn glPatchParameterfv(&self, pname: GLenum, values: *const GLfloat) -> Result<()>;
	fn glBindTransformFeedback(&self, target: GLenum, id: GLuint) -> Result<()>;
	fn glDeleteTransformFeedbacks(&self, n: GLsizei, ids: *const GLuint) -> Result<()>;
	fn glGenTransformFeedbacks(&self, n: GLsizei, ids: *mut GLuint) -> Result<()>;
	fn glIsTransformFeedback(&self, id: GLuint) -> Result<GLboolean>;
	fn glPauseTransformFeedback(&self) -> Result<()>;
	fn glResumeTransformFeedback(&self) -> Result<()>;
	fn glDrawTransformFeedback(&self, mode: GLenum, id: GLuint) -> Result<()>;
	fn glDrawTransformFeedbackStream(&self, mode: GLenum, id: GLuint, stream: GLuint) -> Result<()>;
	fn glBeginQueryIndexed(&self, target: GLenum, index: GLuint, id: GLuint) -> Result<()>;
	fn glEndQueryIndexed(&self, target: GLenum, index: GLuint) -> Result<()>;
	fn glGetQueryIndexediv(&self, target: GLenum, index: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;
}

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version40 {
	available: bool,
	geterror: PFNGLGETERRORPROC,
	minsampleshading: PFNGLMINSAMPLESHADINGPROC,
	blendequationi: PFNGLBLENDEQUATIONIPROC,
	blendequationseparatei: PFNGLBLENDEQUATIONSEPARATEIPROC,
	blendfunci: PFNGLBLENDFUNCIPROC,
	blendfuncseparatei: PFNGLBLENDFUNCSEPARATEIPROC,
	drawarraysindirect: PFNGLDRAWARRAYSINDIRECTPROC,
	drawelementsindirect: PFNGLDRAWELEMENTSINDIRECTPROC,
	uniform1d: PFNGLUNIFORM1DPROC,
	uniform2d: PFNGLUNIFORM2DPROC,
	uniform3d: PFNGLUNIFORM3DPROC,
	uniform4d: PFNGLUNIFORM4DPROC,
	uniform1dv: PFNGLUNIFORM1DVPROC,
	uniform2dv: PFNGLUNIFORM2DVPROC,
	uniform3dv: PFNGLUNIFORM3DVPROC,
	uniform4dv: PFNGLUNIFORM4DVPROC,
	uniformmatrix2dv: PFNGLUNIFORMMATRIX2DVPROC,
	uniformmatrix3dv: PFNGLUNIFORMMATRIX3DVPROC,
	uniformmatrix4dv: PFNGLUNIFORMMATRIX4DVPROC,
	uniformmatrix2x3dv: PFNGLUNIFORMMATRIX2X3DVPROC,
	uniformmatrix2x4dv: PFNGLUNIFORMMATRIX2X4DVPROC,
	uniformmatrix3x2dv: PFNGLUNIFORMMATRIX3X2DVPROC,
	uniformmatrix3x4dv: PFNGLUNIFORMMATRIX3X4DVPROC,
	uniformmatrix4x2dv: PFNGLUNIFORMMATRIX4X2DVPROC,
	uniformmatrix4x3dv: PFNGLUNIFORMMATRIX4X3DVPROC,
	getuniformdv: PFNGLGETUNIFORMDVPROC,
	getsubroutineuniformlocation: PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC,
	getsubroutineindex: PFNGLGETSUBROUTINEINDEXPROC,
	getactivesubroutineuniformiv: PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC,
	getactivesubroutineuniformname: PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC,
	getactivesubroutinename: PFNGLGETACTIVESUBROUTINENAMEPROC,
	uniformsubroutinesuiv: PFNGLUNIFORMSUBROUTINESUIVPROC,
	getuniformsubroutineuiv: PFNGLGETUNIFORMSUBROUTINEUIVPROC,
	getprogramstageiv: PFNGLGETPROGRAMSTAGEIVPROC,
	patchparameteri: PFNGLPATCHPARAMETERIPROC,
	patchparameterfv: PFNGLPATCHPARAMETERFVPROC,
	bindtransformfeedback: PFNGLBINDTRANSFORMFEEDBACKPROC,
	deletetransformfeedbacks: PFNGLDELETETRANSFORMFEEDBACKSPROC,
	gentransformfeedbacks: PFNGLGENTRANSFORMFEEDBACKSPROC,
	istransformfeedback: PFNGLISTRANSFORMFEEDBACKPROC,
	pausetransformfeedback: PFNGLPAUSETRANSFORMFEEDBACKPROC,
	resumetransformfeedback: PFNGLRESUMETRANSFORMFEEDBACKPROC,
	drawtransformfeedback: PFNGLDRAWTRANSFORMFEEDBACKPROC,
	drawtransformfeedbackstream: PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC,
	beginqueryindexed: PFNGLBEGINQUERYINDEXEDPROC,
	endqueryindexed: PFNGLENDQUERYINDEXEDPROC,
	getqueryindexediv: PFNGLGETQUERYINDEXEDIVPROC,
}

impl GL_4_0 for Version40 {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	#[inline(always)]
	fn glMinSampleShading(&self, value: GLfloat) -> Result<()> {
		let ret = process_catch("glMinSampleShading", catch_unwind(||(self.minsampleshading)(value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMinSampleShading", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBlendEquationi(&self, buf: GLuint, mode: GLenum) -> Result<()> {
		let ret = process_catch("glBlendEquationi", catch_unwind(||(self.blendequationi)(buf, mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendEquationi", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBlendEquationSeparatei(&self, buf: GLuint, modeRGB: GLenum, modeAlpha: GLenum) -> Result<()> {
		let ret = process_catch("glBlendEquationSeparatei", catch_unwind(||(self.blendequationseparatei)(buf, modeRGB, modeAlpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendEquationSeparatei", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBlendFunci(&self, buf: GLuint, src: GLenum, dst: GLenum) -> Result<()> {
		let ret = process_catch("glBlendFunci", catch_unwind(||(self.blendfunci)(buf, src, dst)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendFunci", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBlendFuncSeparatei(&self, buf: GLuint, srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum) -> Result<()> {
		let ret = process_catch("glBlendFuncSeparatei", catch_unwind(||(self.blendfuncseparatei)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendFuncSeparatei", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawArraysIndirect(&self, mode: GLenum, indirect: *const c_void) -> Result<()> {
		let ret = process_catch("glDrawArraysIndirect", catch_unwind(||(self.drawarraysindirect)(mode, indirect)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawArraysIndirect", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawElementsIndirect(&self, mode: GLenum, type_: GLenum, indirect: *const c_void) -> Result<()> {
		let ret = process_catch("glDrawElementsIndirect", catch_unwind(||(self.drawelementsindirect)(mode, type_, indirect)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsIndirect", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform1d(&self, location: GLint, x: GLdouble) -> Result<()> {
		let ret = process_catch("glUniform1d", catch_unwind(||(self.uniform1d)(location, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform2d(&self, location: GLint, x: GLdouble, y: GLdouble) -> Result<()> {
		let ret = process_catch("glUniform2d", catch_unwind(||(self.uniform2d)(location, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform3d(&self, location: GLint, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()> {
		let ret = process_catch("glUniform3d", catch_unwind(||(self.uniform3d)(location, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform4d(&self, location: GLint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble) -> Result<()> {
		let ret = process_catch("glUniform4d", catch_unwind(||(self.uniform4d)(location, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform1dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniform1dv", catch_unwind(||(self.uniform1dv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform2dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniform2dv", catch_unwind(||(self.uniform2dv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform3dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniform3dv", catch_unwind(||(self.uniform3dv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform4dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniform4dv", catch_unwind(||(self.uniform4dv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix2dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix2dv", catch_unwind(||(self.uniformmatrix2dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix3dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix3dv", catch_unwind(||(self.uniformmatrix3dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix4dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix4dv", catch_unwind(||(self.uniformmatrix4dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix2x3dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix2x3dv", catch_unwind(||(self.uniformmatrix2x3dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2x3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix2x4dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix2x4dv", catch_unwind(||(self.uniformmatrix2x4dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2x4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix3x2dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix3x2dv", catch_unwind(||(self.uniformmatrix3x2dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3x2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix3x4dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix3x4dv", catch_unwind(||(self.uniformmatrix3x4dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3x4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix4x2dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix4x2dv", catch_unwind(||(self.uniformmatrix4x2dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4x2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix4x3dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix4x3dv", catch_unwind(||(self.uniformmatrix4x3dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4x3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetUniformdv(&self, program: GLuint, location: GLint, params: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetUniformdv", catch_unwind(||(self.getuniformdv)(program, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformdv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetSubroutineUniformLocation(&self, program: GLuint, shadertype: GLenum, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetSubroutineUniformLocation", catch_unwind(||(self.getsubroutineuniformlocation)(program, shadertype, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSubroutineUniformLocation", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetSubroutineIndex(&self, program: GLuint, shadertype: GLenum, name: *const GLchar) -> Result<GLuint> {
		let ret = process_catch("glGetSubroutineIndex", catch_unwind(||(self.getsubroutineindex)(program, shadertype, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSubroutineIndex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveSubroutineUniformiv(&self, program: GLuint, shadertype: GLenum, index: GLuint, pname: GLenum, values: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetActiveSubroutineUniformiv", catch_unwind(||(self.getactivesubroutineuniformiv)(program, shadertype, index, pname, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveSubroutineUniformiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveSubroutineUniformName(&self, program: GLuint, shadertype: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveSubroutineUniformName", catch_unwind(||(self.getactivesubroutineuniformname)(program, shadertype, index, bufSize, length, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveSubroutineUniformName", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveSubroutineName(&self, program: GLuint, shadertype: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveSubroutineName", catch_unwind(||(self.getactivesubroutinename)(program, shadertype, index, bufSize, length, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveSubroutineName", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformSubroutinesuiv(&self, shadertype: GLenum, count: GLsizei, indices: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniformSubroutinesuiv", catch_unwind(||(self.uniformsubroutinesuiv)(shadertype, count, indices)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformSubroutinesuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetUniformSubroutineuiv(&self, shadertype: GLenum, location: GLint, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetUniformSubroutineuiv", catch_unwind(||(self.getuniformsubroutineuiv)(shadertype, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformSubroutineuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramStageiv(&self, program: GLuint, shadertype: GLenum, pname: GLenum, values: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramStageiv", catch_unwind(||(self.getprogramstageiv)(program, shadertype, pname, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramStageiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPatchParameteri(&self, pname: GLenum, value: GLint) -> Result<()> {
		let ret = process_catch("glPatchParameteri", catch_unwind(||(self.patchparameteri)(pname, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPatchParameteri", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPatchParameterfv(&self, pname: GLenum, values: *const GLfloat) -> Result<()> {
		let ret = process_catch("glPatchParameterfv", catch_unwind(||(self.patchparameterfv)(pname, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPatchParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindTransformFeedback(&self, target: GLenum, id: GLuint) -> Result<()> {
		let ret = process_catch("glBindTransformFeedback", catch_unwind(||(self.bindtransformfeedback)(target, id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindTransformFeedback", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteTransformFeedbacks(&self, n: GLsizei, ids: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteTransformFeedbacks", catch_unwind(||(self.deletetransformfeedbacks)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteTransformFeedbacks", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenTransformFeedbacks(&self, n: GLsizei, ids: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenTransformFeedbacks", catch_unwind(||(self.gentransformfeedbacks)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenTransformFeedbacks", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsTransformFeedback(&self, id: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsTransformFeedback", catch_unwind(||(self.istransformfeedback)(id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsTransformFeedback", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPauseTransformFeedback(&self) -> Result<()> {
		let ret = process_catch("glPauseTransformFeedback", catch_unwind(||(self.pausetransformfeedback)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPauseTransformFeedback", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glResumeTransformFeedback(&self) -> Result<()> {
		let ret = process_catch("glResumeTransformFeedback", catch_unwind(||(self.resumetransformfeedback)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glResumeTransformFeedback", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawTransformFeedback(&self, mode: GLenum, id: GLuint) -> Result<()> {
		let ret = process_catch("glDrawTransformFeedback", catch_unwind(||(self.drawtransformfeedback)(mode, id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawTransformFeedback", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawTransformFeedbackStream(&self, mode: GLenum, id: GLuint, stream: GLuint) -> Result<()> {
		let ret = process_catch("glDrawTransformFeedbackStream", catch_unwind(||(self.drawtransformfeedbackstream)(mode, id, stream)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawTransformFeedbackStream", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBeginQueryIndexed(&self, target: GLenum, index: GLuint, id: GLuint) -> Result<()> {
		let ret = process_catch("glBeginQueryIndexed", catch_unwind(||(self.beginqueryindexed)(target, index, id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBeginQueryIndexed", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glEndQueryIndexed(&self, target: GLenum, index: GLuint) -> Result<()> {
		let ret = process_catch("glEndQueryIndexed", catch_unwind(||(self.endqueryindexed)(target, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEndQueryIndexed", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryIndexediv(&self, target: GLenum, index: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetQueryIndexediv", catch_unwind(||(self.getqueryindexediv)(target, index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryIndexediv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version40 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (4, 0, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			minsampleshading: {let proc = get_proc_address("glMinSampleShading"); if proc == null() {dummy_pfnglminsampleshadingproc} else {unsafe{transmute(proc)}}},
			blendequationi: {let proc = get_proc_address("glBlendEquationi"); if proc == null() {dummy_pfnglblendequationiproc} else {unsafe{transmute(proc)}}},
			blendequationseparatei: {let proc = get_proc_address("glBlendEquationSeparatei"); if proc == null() {dummy_pfnglblendequationseparateiproc} else {unsafe{transmute(proc)}}},
			blendfunci: {let proc = get_proc_address("glBlendFunci"); if proc == null() {dummy_pfnglblendfunciproc} else {unsafe{transmute(proc)}}},
			blendfuncseparatei: {let proc = get_proc_address("glBlendFuncSeparatei"); if proc == null() {dummy_pfnglblendfuncseparateiproc} else {unsafe{transmute(proc)}}},
			drawarraysindirect: {let proc = get_proc_address("glDrawArraysIndirect"); if proc == null() {dummy_pfngldrawarraysindirectproc} else {unsafe{transmute(proc)}}},
			drawelementsindirect: {let proc = get_proc_address("glDrawElementsIndirect"); if proc == null() {dummy_pfngldrawelementsindirectproc} else {unsafe{transmute(proc)}}},
			uniform1d: {let proc = get_proc_address("glUniform1d"); if proc == null() {dummy_pfngluniform1dproc} else {unsafe{transmute(proc)}}},
			uniform2d: {let proc = get_proc_address("glUniform2d"); if proc == null() {dummy_pfngluniform2dproc} else {unsafe{transmute(proc)}}},
			uniform3d: {let proc = get_proc_address("glUniform3d"); if proc == null() {dummy_pfngluniform3dproc} else {unsafe{transmute(proc)}}},
			uniform4d: {let proc = get_proc_address("glUniform4d"); if proc == null() {dummy_pfngluniform4dproc} else {unsafe{transmute(proc)}}},
			uniform1dv: {let proc = get_proc_address("glUniform1dv"); if proc == null() {dummy_pfngluniform1dvproc} else {unsafe{transmute(proc)}}},
			uniform2dv: {let proc = get_proc_address("glUniform2dv"); if proc == null() {dummy_pfngluniform2dvproc} else {unsafe{transmute(proc)}}},
			uniform3dv: {let proc = get_proc_address("glUniform3dv"); if proc == null() {dummy_pfngluniform3dvproc} else {unsafe{transmute(proc)}}},
			uniform4dv: {let proc = get_proc_address("glUniform4dv"); if proc == null() {dummy_pfngluniform4dvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix2dv: {let proc = get_proc_address("glUniformMatrix2dv"); if proc == null() {dummy_pfngluniformmatrix2dvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix3dv: {let proc = get_proc_address("glUniformMatrix3dv"); if proc == null() {dummy_pfngluniformmatrix3dvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix4dv: {let proc = get_proc_address("glUniformMatrix4dv"); if proc == null() {dummy_pfngluniformmatrix4dvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix2x3dv: {let proc = get_proc_address("glUniformMatrix2x3dv"); if proc == null() {dummy_pfngluniformmatrix2x3dvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix2x4dv: {let proc = get_proc_address("glUniformMatrix2x4dv"); if proc == null() {dummy_pfngluniformmatrix2x4dvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix3x2dv: {let proc = get_proc_address("glUniformMatrix3x2dv"); if proc == null() {dummy_pfngluniformmatrix3x2dvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix3x4dv: {let proc = get_proc_address("glUniformMatrix3x4dv"); if proc == null() {dummy_pfngluniformmatrix3x4dvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix4x2dv: {let proc = get_proc_address("glUniformMatrix4x2dv"); if proc == null() {dummy_pfngluniformmatrix4x2dvproc} else {unsafe{transmute(proc)}}},
			uniformmatrix4x3dv: {let proc = get_proc_address("glUniformMatrix4x3dv"); if proc == null() {dummy_pfngluniformmatrix4x3dvproc} else {unsafe{transmute(proc)}}},
			getuniformdv: {let proc = get_proc_address("glGetUniformdv"); if proc == null() {dummy_pfnglgetuniformdvproc} else {unsafe{transmute(proc)}}},
			getsubroutineuniformlocation: {let proc = get_proc_address("glGetSubroutineUniformLocation"); if proc == null() {dummy_pfnglgetsubroutineuniformlocationproc} else {unsafe{transmute(proc)}}},
			getsubroutineindex: {let proc = get_proc_address("glGetSubroutineIndex"); if proc == null() {dummy_pfnglgetsubroutineindexproc} else {unsafe{transmute(proc)}}},
			getactivesubroutineuniformiv: {let proc = get_proc_address("glGetActiveSubroutineUniformiv"); if proc == null() {dummy_pfnglgetactivesubroutineuniformivproc} else {unsafe{transmute(proc)}}},
			getactivesubroutineuniformname: {let proc = get_proc_address("glGetActiveSubroutineUniformName"); if proc == null() {dummy_pfnglgetactivesubroutineuniformnameproc} else {unsafe{transmute(proc)}}},
			getactivesubroutinename: {let proc = get_proc_address("glGetActiveSubroutineName"); if proc == null() {dummy_pfnglgetactivesubroutinenameproc} else {unsafe{transmute(proc)}}},
			uniformsubroutinesuiv: {let proc = get_proc_address("glUniformSubroutinesuiv"); if proc == null() {dummy_pfngluniformsubroutinesuivproc} else {unsafe{transmute(proc)}}},
			getuniformsubroutineuiv: {let proc = get_proc_address("glGetUniformSubroutineuiv"); if proc == null() {dummy_pfnglgetuniformsubroutineuivproc} else {unsafe{transmute(proc)}}},
			getprogramstageiv: {let proc = get_proc_address("glGetProgramStageiv"); if proc == null() {dummy_pfnglgetprogramstageivproc} else {unsafe{transmute(proc)}}},
			patchparameteri: {let proc = get_proc_address("glPatchParameteri"); if proc == null() {dummy_pfnglpatchparameteriproc} else {unsafe{transmute(proc)}}},
			patchparameterfv: {let proc = get_proc_address("glPatchParameterfv"); if proc == null() {dummy_pfnglpatchparameterfvproc} else {unsafe{transmute(proc)}}},
			bindtransformfeedback: {let proc = get_proc_address("glBindTransformFeedback"); if proc == null() {dummy_pfnglbindtransformfeedbackproc} else {unsafe{transmute(proc)}}},
			deletetransformfeedbacks: {let proc = get_proc_address("glDeleteTransformFeedbacks"); if proc == null() {dummy_pfngldeletetransformfeedbacksproc} else {unsafe{transmute(proc)}}},
			gentransformfeedbacks: {let proc = get_proc_address("glGenTransformFeedbacks"); if proc == null() {dummy_pfnglgentransformfeedbacksproc} else {unsafe{transmute(proc)}}},
			istransformfeedback: {let proc = get_proc_address("glIsTransformFeedback"); if proc == null() {dummy_pfnglistransformfeedbackproc} else {unsafe{transmute(proc)}}},
			pausetransformfeedback: {let proc = get_proc_address("glPauseTransformFeedback"); if proc == null() {dummy_pfnglpausetransformfeedbackproc} else {unsafe{transmute(proc)}}},
			resumetransformfeedback: {let proc = get_proc_address("glResumeTransformFeedback"); if proc == null() {dummy_pfnglresumetransformfeedbackproc} else {unsafe{transmute(proc)}}},
			drawtransformfeedback: {let proc = get_proc_address("glDrawTransformFeedback"); if proc == null() {dummy_pfngldrawtransformfeedbackproc} else {unsafe{transmute(proc)}}},
			drawtransformfeedbackstream: {let proc = get_proc_address("glDrawTransformFeedbackStream"); if proc == null() {dummy_pfngldrawtransformfeedbackstreamproc} else {unsafe{transmute(proc)}}},
			beginqueryindexed: {let proc = get_proc_address("glBeginQueryIndexed"); if proc == null() {dummy_pfnglbeginqueryindexedproc} else {unsafe{transmute(proc)}}},
			endqueryindexed: {let proc = get_proc_address("glEndQueryIndexed"); if proc == null() {dummy_pfnglendqueryindexedproc} else {unsafe{transmute(proc)}}},
			getqueryindexediv: {let proc = get_proc_address("glGetQueryIndexediv"); if proc == null() {dummy_pfnglgetqueryindexedivproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version40 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			minsampleshading: dummy_pfnglminsampleshadingproc,
			blendequationi: dummy_pfnglblendequationiproc,
			blendequationseparatei: dummy_pfnglblendequationseparateiproc,
			blendfunci: dummy_pfnglblendfunciproc,
			blendfuncseparatei: dummy_pfnglblendfuncseparateiproc,
			drawarraysindirect: dummy_pfngldrawarraysindirectproc,
			drawelementsindirect: dummy_pfngldrawelementsindirectproc,
			uniform1d: dummy_pfngluniform1dproc,
			uniform2d: dummy_pfngluniform2dproc,
			uniform3d: dummy_pfngluniform3dproc,
			uniform4d: dummy_pfngluniform4dproc,
			uniform1dv: dummy_pfngluniform1dvproc,
			uniform2dv: dummy_pfngluniform2dvproc,
			uniform3dv: dummy_pfngluniform3dvproc,
			uniform4dv: dummy_pfngluniform4dvproc,
			uniformmatrix2dv: dummy_pfngluniformmatrix2dvproc,
			uniformmatrix3dv: dummy_pfngluniformmatrix3dvproc,
			uniformmatrix4dv: dummy_pfngluniformmatrix4dvproc,
			uniformmatrix2x3dv: dummy_pfngluniformmatrix2x3dvproc,
			uniformmatrix2x4dv: dummy_pfngluniformmatrix2x4dvproc,
			uniformmatrix3x2dv: dummy_pfngluniformmatrix3x2dvproc,
			uniformmatrix3x4dv: dummy_pfngluniformmatrix3x4dvproc,
			uniformmatrix4x2dv: dummy_pfngluniformmatrix4x2dvproc,
			uniformmatrix4x3dv: dummy_pfngluniformmatrix4x3dvproc,
			getuniformdv: dummy_pfnglgetuniformdvproc,
			getsubroutineuniformlocation: dummy_pfnglgetsubroutineuniformlocationproc,
			getsubroutineindex: dummy_pfnglgetsubroutineindexproc,
			getactivesubroutineuniformiv: dummy_pfnglgetactivesubroutineuniformivproc,
			getactivesubroutineuniformname: dummy_pfnglgetactivesubroutineuniformnameproc,
			getactivesubroutinename: dummy_pfnglgetactivesubroutinenameproc,
			uniformsubroutinesuiv: dummy_pfngluniformsubroutinesuivproc,
			getuniformsubroutineuiv: dummy_pfnglgetuniformsubroutineuivproc,
			getprogramstageiv: dummy_pfnglgetprogramstageivproc,
			patchparameteri: dummy_pfnglpatchparameteriproc,
			patchparameterfv: dummy_pfnglpatchparameterfvproc,
			bindtransformfeedback: dummy_pfnglbindtransformfeedbackproc,
			deletetransformfeedbacks: dummy_pfngldeletetransformfeedbacksproc,
			gentransformfeedbacks: dummy_pfnglgentransformfeedbacksproc,
			istransformfeedback: dummy_pfnglistransformfeedbackproc,
			pausetransformfeedback: dummy_pfnglpausetransformfeedbackproc,
			resumetransformfeedback: dummy_pfnglresumetransformfeedbackproc,
			drawtransformfeedback: dummy_pfngldrawtransformfeedbackproc,
			drawtransformfeedbackstream: dummy_pfngldrawtransformfeedbackstreamproc,
			beginqueryindexed: dummy_pfnglbeginqueryindexedproc,
			endqueryindexed: dummy_pfnglendqueryindexedproc,
			getqueryindexediv: dummy_pfnglgetqueryindexedivproc,
		}
	}
}
impl Debug for Version40 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version40")
			.field("available", &self.available)
			.field("minsampleshading", unsafe{if transmute::<_, *const c_void>(self.minsampleshading) == (dummy_pfnglminsampleshadingproc as *const c_void) {&null::<PFNGLMINSAMPLESHADINGPROC>()} else {&self.minsampleshading}})
			.field("blendequationi", unsafe{if transmute::<_, *const c_void>(self.blendequationi) == (dummy_pfnglblendequationiproc as *const c_void) {&null::<PFNGLBLENDEQUATIONIPROC>()} else {&self.blendequationi}})
			.field("blendequationseparatei", unsafe{if transmute::<_, *const c_void>(self.blendequationseparatei) == (dummy_pfnglblendequationseparateiproc as *const c_void) {&null::<PFNGLBLENDEQUATIONSEPARATEIPROC>()} else {&self.blendequationseparatei}})
			.field("blendfunci", unsafe{if transmute::<_, *const c_void>(self.blendfunci) == (dummy_pfnglblendfunciproc as *const c_void) {&null::<PFNGLBLENDFUNCIPROC>()} else {&self.blendfunci}})
			.field("blendfuncseparatei", unsafe{if transmute::<_, *const c_void>(self.blendfuncseparatei) == (dummy_pfnglblendfuncseparateiproc as *const c_void) {&null::<PFNGLBLENDFUNCSEPARATEIPROC>()} else {&self.blendfuncseparatei}})
			.field("drawarraysindirect", unsafe{if transmute::<_, *const c_void>(self.drawarraysindirect) == (dummy_pfngldrawarraysindirectproc as *const c_void) {&null::<PFNGLDRAWARRAYSINDIRECTPROC>()} else {&self.drawarraysindirect}})
			.field("drawelementsindirect", unsafe{if transmute::<_, *const c_void>(self.drawelementsindirect) == (dummy_pfngldrawelementsindirectproc as *const c_void) {&null::<PFNGLDRAWELEMENTSINDIRECTPROC>()} else {&self.drawelementsindirect}})
			.field("uniform1d", unsafe{if transmute::<_, *const c_void>(self.uniform1d) == (dummy_pfngluniform1dproc as *const c_void) {&null::<PFNGLUNIFORM1DPROC>()} else {&self.uniform1d}})
			.field("uniform2d", unsafe{if transmute::<_, *const c_void>(self.uniform2d) == (dummy_pfngluniform2dproc as *const c_void) {&null::<PFNGLUNIFORM2DPROC>()} else {&self.uniform2d}})
			.field("uniform3d", unsafe{if transmute::<_, *const c_void>(self.uniform3d) == (dummy_pfngluniform3dproc as *const c_void) {&null::<PFNGLUNIFORM3DPROC>()} else {&self.uniform3d}})
			.field("uniform4d", unsafe{if transmute::<_, *const c_void>(self.uniform4d) == (dummy_pfngluniform4dproc as *const c_void) {&null::<PFNGLUNIFORM4DPROC>()} else {&self.uniform4d}})
			.field("uniform1dv", unsafe{if transmute::<_, *const c_void>(self.uniform1dv) == (dummy_pfngluniform1dvproc as *const c_void) {&null::<PFNGLUNIFORM1DVPROC>()} else {&self.uniform1dv}})
			.field("uniform2dv", unsafe{if transmute::<_, *const c_void>(self.uniform2dv) == (dummy_pfngluniform2dvproc as *const c_void) {&null::<PFNGLUNIFORM2DVPROC>()} else {&self.uniform2dv}})
			.field("uniform3dv", unsafe{if transmute::<_, *const c_void>(self.uniform3dv) == (dummy_pfngluniform3dvproc as *const c_void) {&null::<PFNGLUNIFORM3DVPROC>()} else {&self.uniform3dv}})
			.field("uniform4dv", unsafe{if transmute::<_, *const c_void>(self.uniform4dv) == (dummy_pfngluniform4dvproc as *const c_void) {&null::<PFNGLUNIFORM4DVPROC>()} else {&self.uniform4dv}})
			.field("uniformmatrix2dv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix2dv) == (dummy_pfngluniformmatrix2dvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX2DVPROC>()} else {&self.uniformmatrix2dv}})
			.field("uniformmatrix3dv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix3dv) == (dummy_pfngluniformmatrix3dvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX3DVPROC>()} else {&self.uniformmatrix3dv}})
			.field("uniformmatrix4dv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix4dv) == (dummy_pfngluniformmatrix4dvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX4DVPROC>()} else {&self.uniformmatrix4dv}})
			.field("uniformmatrix2x3dv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix2x3dv) == (dummy_pfngluniformmatrix2x3dvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX2X3DVPROC>()} else {&self.uniformmatrix2x3dv}})
			.field("uniformmatrix2x4dv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix2x4dv) == (dummy_pfngluniformmatrix2x4dvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX2X4DVPROC>()} else {&self.uniformmatrix2x4dv}})
			.field("uniformmatrix3x2dv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix3x2dv) == (dummy_pfngluniformmatrix3x2dvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX3X2DVPROC>()} else {&self.uniformmatrix3x2dv}})
			.field("uniformmatrix3x4dv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix3x4dv) == (dummy_pfngluniformmatrix3x4dvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX3X4DVPROC>()} else {&self.uniformmatrix3x4dv}})
			.field("uniformmatrix4x2dv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix4x2dv) == (dummy_pfngluniformmatrix4x2dvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX4X2DVPROC>()} else {&self.uniformmatrix4x2dv}})
			.field("uniformmatrix4x3dv", unsafe{if transmute::<_, *const c_void>(self.uniformmatrix4x3dv) == (dummy_pfngluniformmatrix4x3dvproc as *const c_void) {&null::<PFNGLUNIFORMMATRIX4X3DVPROC>()} else {&self.uniformmatrix4x3dv}})
			.field("getuniformdv", unsafe{if transmute::<_, *const c_void>(self.getuniformdv) == (dummy_pfnglgetuniformdvproc as *const c_void) {&null::<PFNGLGETUNIFORMDVPROC>()} else {&self.getuniformdv}})
			.field("getsubroutineuniformlocation", unsafe{if transmute::<_, *const c_void>(self.getsubroutineuniformlocation) == (dummy_pfnglgetsubroutineuniformlocationproc as *const c_void) {&null::<PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC>()} else {&self.getsubroutineuniformlocation}})
			.field("getsubroutineindex", unsafe{if transmute::<_, *const c_void>(self.getsubroutineindex) == (dummy_pfnglgetsubroutineindexproc as *const c_void) {&null::<PFNGLGETSUBROUTINEINDEXPROC>()} else {&self.getsubroutineindex}})
			.field("getactivesubroutineuniformiv", unsafe{if transmute::<_, *const c_void>(self.getactivesubroutineuniformiv) == (dummy_pfnglgetactivesubroutineuniformivproc as *const c_void) {&null::<PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC>()} else {&self.getactivesubroutineuniformiv}})
			.field("getactivesubroutineuniformname", unsafe{if transmute::<_, *const c_void>(self.getactivesubroutineuniformname) == (dummy_pfnglgetactivesubroutineuniformnameproc as *const c_void) {&null::<PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC>()} else {&self.getactivesubroutineuniformname}})
			.field("getactivesubroutinename", unsafe{if transmute::<_, *const c_void>(self.getactivesubroutinename) == (dummy_pfnglgetactivesubroutinenameproc as *const c_void) {&null::<PFNGLGETACTIVESUBROUTINENAMEPROC>()} else {&self.getactivesubroutinename}})
			.field("uniformsubroutinesuiv", unsafe{if transmute::<_, *const c_void>(self.uniformsubroutinesuiv) == (dummy_pfngluniformsubroutinesuivproc as *const c_void) {&null::<PFNGLUNIFORMSUBROUTINESUIVPROC>()} else {&self.uniformsubroutinesuiv}})
			.field("getuniformsubroutineuiv", unsafe{if transmute::<_, *const c_void>(self.getuniformsubroutineuiv) == (dummy_pfnglgetuniformsubroutineuivproc as *const c_void) {&null::<PFNGLGETUNIFORMSUBROUTINEUIVPROC>()} else {&self.getuniformsubroutineuiv}})
			.field("getprogramstageiv", unsafe{if transmute::<_, *const c_void>(self.getprogramstageiv) == (dummy_pfnglgetprogramstageivproc as *const c_void) {&null::<PFNGLGETPROGRAMSTAGEIVPROC>()} else {&self.getprogramstageiv}})
			.field("patchparameteri", unsafe{if transmute::<_, *const c_void>(self.patchparameteri) == (dummy_pfnglpatchparameteriproc as *const c_void) {&null::<PFNGLPATCHPARAMETERIPROC>()} else {&self.patchparameteri}})
			.field("patchparameterfv", unsafe{if transmute::<_, *const c_void>(self.patchparameterfv) == (dummy_pfnglpatchparameterfvproc as *const c_void) {&null::<PFNGLPATCHPARAMETERFVPROC>()} else {&self.patchparameterfv}})
			.field("bindtransformfeedback", unsafe{if transmute::<_, *const c_void>(self.bindtransformfeedback) == (dummy_pfnglbindtransformfeedbackproc as *const c_void) {&null::<PFNGLBINDTRANSFORMFEEDBACKPROC>()} else {&self.bindtransformfeedback}})
			.field("deletetransformfeedbacks", unsafe{if transmute::<_, *const c_void>(self.deletetransformfeedbacks) == (dummy_pfngldeletetransformfeedbacksproc as *const c_void) {&null::<PFNGLDELETETRANSFORMFEEDBACKSPROC>()} else {&self.deletetransformfeedbacks}})
			.field("gentransformfeedbacks", unsafe{if transmute::<_, *const c_void>(self.gentransformfeedbacks) == (dummy_pfnglgentransformfeedbacksproc as *const c_void) {&null::<PFNGLGENTRANSFORMFEEDBACKSPROC>()} else {&self.gentransformfeedbacks}})
			.field("istransformfeedback", unsafe{if transmute::<_, *const c_void>(self.istransformfeedback) == (dummy_pfnglistransformfeedbackproc as *const c_void) {&null::<PFNGLISTRANSFORMFEEDBACKPROC>()} else {&self.istransformfeedback}})
			.field("pausetransformfeedback", unsafe{if transmute::<_, *const c_void>(self.pausetransformfeedback) == (dummy_pfnglpausetransformfeedbackproc as *const c_void) {&null::<PFNGLPAUSETRANSFORMFEEDBACKPROC>()} else {&self.pausetransformfeedback}})
			.field("resumetransformfeedback", unsafe{if transmute::<_, *const c_void>(self.resumetransformfeedback) == (dummy_pfnglresumetransformfeedbackproc as *const c_void) {&null::<PFNGLRESUMETRANSFORMFEEDBACKPROC>()} else {&self.resumetransformfeedback}})
			.field("drawtransformfeedback", unsafe{if transmute::<_, *const c_void>(self.drawtransformfeedback) == (dummy_pfngldrawtransformfeedbackproc as *const c_void) {&null::<PFNGLDRAWTRANSFORMFEEDBACKPROC>()} else {&self.drawtransformfeedback}})
			.field("drawtransformfeedbackstream", unsafe{if transmute::<_, *const c_void>(self.drawtransformfeedbackstream) == (dummy_pfngldrawtransformfeedbackstreamproc as *const c_void) {&null::<PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC>()} else {&self.drawtransformfeedbackstream}})
			.field("beginqueryindexed", unsafe{if transmute::<_, *const c_void>(self.beginqueryindexed) == (dummy_pfnglbeginqueryindexedproc as *const c_void) {&null::<PFNGLBEGINQUERYINDEXEDPROC>()} else {&self.beginqueryindexed}})
			.field("endqueryindexed", unsafe{if transmute::<_, *const c_void>(self.endqueryindexed) == (dummy_pfnglendqueryindexedproc as *const c_void) {&null::<PFNGLENDQUERYINDEXEDPROC>()} else {&self.endqueryindexed}})
			.field("getqueryindexediv", unsafe{if transmute::<_, *const c_void>(self.getqueryindexediv) == (dummy_pfnglgetqueryindexedivproc as *const c_void) {&null::<PFNGLGETQUERYINDEXEDIVPROC>()} else {&self.getqueryindexediv}})
			.finish()
		} else {
			f.debug_struct("Version40")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}
type PFNGLRELEASESHADERCOMPILERPROC = extern "system" fn();
type PFNGLSHADERBINARYPROC = extern "system" fn(GLsizei, *const GLuint, GLenum, *const c_void, GLsizei);
type PFNGLGETSHADERPRECISIONFORMATPROC = extern "system" fn(GLenum, GLenum, *mut GLint, *mut GLint);
type PFNGLDEPTHRANGEFPROC = extern "system" fn(GLfloat, GLfloat);
type PFNGLCLEARDEPTHFPROC = extern "system" fn(GLfloat);
type PFNGLGETPROGRAMBINARYPROC = extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLenum, *mut c_void);
type PFNGLPROGRAMBINARYPROC = extern "system" fn(GLuint, GLenum, *const c_void, GLsizei);
type PFNGLPROGRAMPARAMETERIPROC = extern "system" fn(GLuint, GLenum, GLint);
type PFNGLUSEPROGRAMSTAGESPROC = extern "system" fn(GLuint, GLbitfield, GLuint);
type PFNGLACTIVESHADERPROGRAMPROC = extern "system" fn(GLuint, GLuint);
type PFNGLCREATESHADERPROGRAMVPROC = extern "system" fn(GLenum, GLsizei, *const *const GLchar) -> GLuint;
type PFNGLBINDPROGRAMPIPELINEPROC = extern "system" fn(GLuint);
type PFNGLDELETEPROGRAMPIPELINESPROC = extern "system" fn(GLsizei, *const GLuint);
type PFNGLGENPROGRAMPIPELINESPROC = extern "system" fn(GLsizei, *mut GLuint);
type PFNGLISPROGRAMPIPELINEPROC = extern "system" fn(GLuint) -> GLboolean;
type PFNGLGETPROGRAMPIPELINEIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);
type PFNGLPROGRAMUNIFORM1IPROC = extern "system" fn(GLuint, GLint, GLint);
type PFNGLPROGRAMUNIFORM1IVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLint);
type PFNGLPROGRAMUNIFORM1FPROC = extern "system" fn(GLuint, GLint, GLfloat);
type PFNGLPROGRAMUNIFORM1FVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat);
type PFNGLPROGRAMUNIFORM1DPROC = extern "system" fn(GLuint, GLint, GLdouble);
type PFNGLPROGRAMUNIFORM1DVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLdouble);
type PFNGLPROGRAMUNIFORM1UIPROC = extern "system" fn(GLuint, GLint, GLuint);
type PFNGLPROGRAMUNIFORM1UIVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLuint);
type PFNGLPROGRAMUNIFORM2IPROC = extern "system" fn(GLuint, GLint, GLint, GLint);
type PFNGLPROGRAMUNIFORM2IVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLint);
type PFNGLPROGRAMUNIFORM2FPROC = extern "system" fn(GLuint, GLint, GLfloat, GLfloat);
type PFNGLPROGRAMUNIFORM2FVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat);
type PFNGLPROGRAMUNIFORM2DPROC = extern "system" fn(GLuint, GLint, GLdouble, GLdouble);
type PFNGLPROGRAMUNIFORM2DVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLdouble);
type PFNGLPROGRAMUNIFORM2UIPROC = extern "system" fn(GLuint, GLint, GLuint, GLuint);
type PFNGLPROGRAMUNIFORM2UIVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLuint);
type PFNGLPROGRAMUNIFORM3IPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint);
type PFNGLPROGRAMUNIFORM3IVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLint);
type PFNGLPROGRAMUNIFORM3FPROC = extern "system" fn(GLuint, GLint, GLfloat, GLfloat, GLfloat);
type PFNGLPROGRAMUNIFORM3FVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat);
type PFNGLPROGRAMUNIFORM3DPROC = extern "system" fn(GLuint, GLint, GLdouble, GLdouble, GLdouble);
type PFNGLPROGRAMUNIFORM3DVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLdouble);
type PFNGLPROGRAMUNIFORM3UIPROC = extern "system" fn(GLuint, GLint, GLuint, GLuint, GLuint);
type PFNGLPROGRAMUNIFORM3UIVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLuint);
type PFNGLPROGRAMUNIFORM4IPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLint);
type PFNGLPROGRAMUNIFORM4IVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLint);
type PFNGLPROGRAMUNIFORM4FPROC = extern "system" fn(GLuint, GLint, GLfloat, GLfloat, GLfloat, GLfloat);
type PFNGLPROGRAMUNIFORM4FVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLfloat);
type PFNGLPROGRAMUNIFORM4DPROC = extern "system" fn(GLuint, GLint, GLdouble, GLdouble, GLdouble, GLdouble);
type PFNGLPROGRAMUNIFORM4DVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLdouble);
type PFNGLPROGRAMUNIFORM4UIPROC = extern "system" fn(GLuint, GLint, GLuint, GLuint, GLuint, GLuint);
type PFNGLPROGRAMUNIFORM4UIVPROC = extern "system" fn(GLuint, GLint, GLsizei, *const GLuint);
type PFNGLPROGRAMUNIFORMMATRIX2FVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat);
type PFNGLPROGRAMUNIFORMMATRIX3FVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat);
type PFNGLPROGRAMUNIFORMMATRIX4FVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat);
type PFNGLPROGRAMUNIFORMMATRIX2DVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble);
type PFNGLPROGRAMUNIFORMMATRIX3DVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble);
type PFNGLPROGRAMUNIFORMMATRIX4DVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble);
type PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat);
type PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat);
type PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat);
type PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat);
type PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat);
type PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLfloat);
type PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble);
type PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble);
type PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble);
type PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble);
type PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble);
type PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC = extern "system" fn(GLuint, GLint, GLsizei, GLboolean, *const GLdouble);
type PFNGLVALIDATEPROGRAMPIPELINEPROC = extern "system" fn(GLuint);
type PFNGLGETPROGRAMPIPELINEINFOLOGPROC = extern "system" fn(GLuint, GLsizei, *mut GLsizei, *mut GLchar);
type PFNGLVERTEXATTRIBL1DPROC = extern "system" fn(GLuint, GLdouble);
type PFNGLVERTEXATTRIBL2DPROC = extern "system" fn(GLuint, GLdouble, GLdouble);
type PFNGLVERTEXATTRIBL3DPROC = extern "system" fn(GLuint, GLdouble, GLdouble, GLdouble);
type PFNGLVERTEXATTRIBL4DPROC = extern "system" fn(GLuint, GLdouble, GLdouble, GLdouble, GLdouble);
type PFNGLVERTEXATTRIBL1DVPROC = extern "system" fn(GLuint, *const GLdouble);
type PFNGLVERTEXATTRIBL2DVPROC = extern "system" fn(GLuint, *const GLdouble);
type PFNGLVERTEXATTRIBL3DVPROC = extern "system" fn(GLuint, *const GLdouble);
type PFNGLVERTEXATTRIBL4DVPROC = extern "system" fn(GLuint, *const GLdouble);
type PFNGLVERTEXATTRIBLPOINTERPROC = extern "system" fn(GLuint, GLint, GLenum, GLsizei, *const c_void);
type PFNGLGETVERTEXATTRIBLDVPROC = extern "system" fn(GLuint, GLenum, *mut GLdouble);
type PFNGLVIEWPORTARRAYVPROC = extern "system" fn(GLuint, GLsizei, *const GLfloat);
type PFNGLVIEWPORTINDEXEDFPROC = extern "system" fn(GLuint, GLfloat, GLfloat, GLfloat, GLfloat);
type PFNGLVIEWPORTINDEXEDFVPROC = extern "system" fn(GLuint, *const GLfloat);
type PFNGLSCISSORARRAYVPROC = extern "system" fn(GLuint, GLsizei, *const GLint);
type PFNGLSCISSORINDEXEDPROC = extern "system" fn(GLuint, GLint, GLint, GLsizei, GLsizei);
type PFNGLSCISSORINDEXEDVPROC = extern "system" fn(GLuint, *const GLint);
type PFNGLDEPTHRANGEARRAYVPROC = extern "system" fn(GLuint, GLsizei, *const GLdouble);
type PFNGLDEPTHRANGEINDEXEDPROC = extern "system" fn(GLuint, GLdouble, GLdouble);
type PFNGLGETFLOATI_VPROC = extern "system" fn(GLenum, GLuint, *mut GLfloat);
type PFNGLGETDOUBLEI_VPROC = extern "system" fn(GLenum, GLuint, *mut GLdouble);
extern "system" fn dummy_pfnglreleaseshadercompilerproc () {
	panic!("OpenGL function pointer `glReleaseShaderCompiler()` is null.")
}
extern "system" fn dummy_pfnglshaderbinaryproc (_: GLsizei, _: *const GLuint, _: GLenum, _: *const c_void, _: GLsizei) {
	panic!("OpenGL function pointer `glShaderBinary()` is null.")
}
extern "system" fn dummy_pfnglgetshaderprecisionformatproc (_: GLenum, _: GLenum, _: *mut GLint, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetShaderPrecisionFormat()` is null.")
}
extern "system" fn dummy_pfngldepthrangefproc (_: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glDepthRangef()` is null.")
}
extern "system" fn dummy_pfnglcleardepthfproc (_: GLfloat) {
	panic!("OpenGL function pointer `glClearDepthf()` is null.")
}
extern "system" fn dummy_pfnglgetprogrambinaryproc (_: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLenum, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetProgramBinary()` is null.")
}
extern "system" fn dummy_pfnglprogrambinaryproc (_: GLuint, _: GLenum, _: *const c_void, _: GLsizei) {
	panic!("OpenGL function pointer `glProgramBinary()` is null.")
}
extern "system" fn dummy_pfnglprogramparameteriproc (_: GLuint, _: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glProgramParameteri()` is null.")
}
extern "system" fn dummy_pfngluseprogramstagesproc (_: GLuint, _: GLbitfield, _: GLuint) {
	panic!("OpenGL function pointer `glUseProgramStages()` is null.")
}
extern "system" fn dummy_pfnglactiveshaderprogramproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glActiveShaderProgram()` is null.")
}
extern "system" fn dummy_pfnglcreateshaderprogramvproc (_: GLenum, _: GLsizei, _: *const *const GLchar) -> GLuint {
	panic!("OpenGL function pointer `glCreateShaderProgramv()` is null.")
}
extern "system" fn dummy_pfnglbindprogrampipelineproc (_: GLuint) {
	panic!("OpenGL function pointer `glBindProgramPipeline()` is null.")
}
extern "system" fn dummy_pfngldeleteprogrampipelinesproc (_: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glDeleteProgramPipelines()` is null.")
}
extern "system" fn dummy_pfnglgenprogrampipelinesproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGenProgramPipelines()` is null.")
}
extern "system" fn dummy_pfnglisprogrampipelineproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glIsProgramPipeline()` is null.")
}
extern "system" fn dummy_pfnglgetprogrampipelineivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetProgramPipelineiv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform1iproc (_: GLuint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glProgramUniform1i()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform1ivproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glProgramUniform1iv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform1fproc (_: GLuint, _: GLint, _: GLfloat) {
	panic!("OpenGL function pointer `glProgramUniform1f()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform1fvproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniform1fv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform1dproc (_: GLuint, _: GLint, _: GLdouble) {
	panic!("OpenGL function pointer `glProgramUniform1d()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform1dvproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniform1dv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform1uiproc (_: GLuint, _: GLint, _: GLuint) {
	panic!("OpenGL function pointer `glProgramUniform1ui()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform1uivproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glProgramUniform1uiv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform2iproc (_: GLuint, _: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glProgramUniform2i()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform2ivproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glProgramUniform2iv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform2fproc (_: GLuint, _: GLint, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glProgramUniform2f()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform2fvproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniform2fv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform2dproc (_: GLuint, _: GLint, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glProgramUniform2d()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform2dvproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniform2dv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform2uiproc (_: GLuint, _: GLint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glProgramUniform2ui()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform2uivproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glProgramUniform2uiv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform3iproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glProgramUniform3i()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform3ivproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glProgramUniform3iv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform3fproc (_: GLuint, _: GLint, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glProgramUniform3f()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform3fvproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniform3fv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform3dproc (_: GLuint, _: GLint, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glProgramUniform3d()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform3dvproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniform3dv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform3uiproc (_: GLuint, _: GLint, _: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glProgramUniform3ui()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform3uivproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glProgramUniform3uiv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform4iproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glProgramUniform4i()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform4ivproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glProgramUniform4iv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform4fproc (_: GLuint, _: GLint, _: GLfloat, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glProgramUniform4f()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform4fvproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniform4fv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform4dproc (_: GLuint, _: GLint, _: GLdouble, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glProgramUniform4d()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform4dvproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniform4dv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform4uiproc (_: GLuint, _: GLint, _: GLuint, _: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glProgramUniform4ui()` is null.")
}
extern "system" fn dummy_pfnglprogramuniform4uivproc (_: GLuint, _: GLint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glProgramUniform4uiv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniformmatrix2fvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniformMatrix2fv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniformmatrix3fvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniformMatrix3fv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniformmatrix4fvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniformMatrix4fv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniformmatrix2dvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniformMatrix2dv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniformmatrix3dvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniformMatrix3dv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniformmatrix4dvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniformMatrix4dv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniformmatrix2x3fvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniformMatrix2x3fv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniformmatrix3x2fvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniformMatrix3x2fv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniformmatrix2x4fvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniformMatrix2x4fv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniformmatrix4x2fvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniformMatrix4x2fv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniformmatrix3x4fvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniformMatrix3x4fv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniformmatrix4x3fvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLfloat) {
	panic!("OpenGL function pointer `glProgramUniformMatrix4x3fv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniformmatrix2x3dvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniformMatrix2x3dv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniformmatrix3x2dvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniformMatrix3x2dv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniformmatrix2x4dvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniformMatrix2x4dv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniformmatrix4x2dvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniformMatrix4x2dv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniformmatrix3x4dvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniformMatrix3x4dv()` is null.")
}
extern "system" fn dummy_pfnglprogramuniformmatrix4x3dvproc (_: GLuint, _: GLint, _: GLsizei, _: GLboolean, _: *const GLdouble) {
	panic!("OpenGL function pointer `glProgramUniformMatrix4x3dv()` is null.")
}
extern "system" fn dummy_pfnglvalidateprogrampipelineproc (_: GLuint) {
	panic!("OpenGL function pointer `glValidateProgramPipeline()` is null.")
}
extern "system" fn dummy_pfnglgetprogrampipelineinfologproc (_: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetProgramPipelineInfoLog()` is null.")
}
extern "system" fn dummy_pfnglvertexattribl1dproc (_: GLuint, _: GLdouble) {
	panic!("OpenGL function pointer `glVertexAttribL1d()` is null.")
}
extern "system" fn dummy_pfnglvertexattribl2dproc (_: GLuint, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glVertexAttribL2d()` is null.")
}
extern "system" fn dummy_pfnglvertexattribl3dproc (_: GLuint, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glVertexAttribL3d()` is null.")
}
extern "system" fn dummy_pfnglvertexattribl4dproc (_: GLuint, _: GLdouble, _: GLdouble, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glVertexAttribL4d()` is null.")
}
extern "system" fn dummy_pfnglvertexattribl1dvproc (_: GLuint, _: *const GLdouble) {
	panic!("OpenGL function pointer `glVertexAttribL1dv()` is null.")
}
extern "system" fn dummy_pfnglvertexattribl2dvproc (_: GLuint, _: *const GLdouble) {
	panic!("OpenGL function pointer `glVertexAttribL2dv()` is null.")
}
extern "system" fn dummy_pfnglvertexattribl3dvproc (_: GLuint, _: *const GLdouble) {
	panic!("OpenGL function pointer `glVertexAttribL3dv()` is null.")
}
extern "system" fn dummy_pfnglvertexattribl4dvproc (_: GLuint, _: *const GLdouble) {
	panic!("OpenGL function pointer `glVertexAttribL4dv()` is null.")
}
extern "system" fn dummy_pfnglvertexattriblpointerproc (_: GLuint, _: GLint, _: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glVertexAttribLPointer()` is null.")
}
extern "system" fn dummy_pfnglgetvertexattribldvproc (_: GLuint, _: GLenum, _: *mut GLdouble) {
	panic!("OpenGL function pointer `glGetVertexAttribLdv()` is null.")
}
extern "system" fn dummy_pfnglviewportarrayvproc (_: GLuint, _: GLsizei, _: *const GLfloat) {
	panic!("OpenGL function pointer `glViewportArrayv()` is null.")
}
extern "system" fn dummy_pfnglviewportindexedfproc (_: GLuint, _: GLfloat, _: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glViewportIndexedf()` is null.")
}
extern "system" fn dummy_pfnglviewportindexedfvproc (_: GLuint, _: *const GLfloat) {
	panic!("OpenGL function pointer `glViewportIndexedfv()` is null.")
}
extern "system" fn dummy_pfnglscissorarrayvproc (_: GLuint, _: GLsizei, _: *const GLint) {
	panic!("OpenGL function pointer `glScissorArrayv()` is null.")
}
extern "system" fn dummy_pfnglscissorindexedproc (_: GLuint, _: GLint, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glScissorIndexed()` is null.")
}
extern "system" fn dummy_pfnglscissorindexedvproc (_: GLuint, _: *const GLint) {
	panic!("OpenGL function pointer `glScissorIndexedv()` is null.")
}
extern "system" fn dummy_pfngldepthrangearrayvproc (_: GLuint, _: GLsizei, _: *const GLdouble) {
	panic!("OpenGL function pointer `glDepthRangeArrayv()` is null.")
}
extern "system" fn dummy_pfngldepthrangeindexedproc (_: GLuint, _: GLdouble, _: GLdouble) {
	panic!("OpenGL function pointer `glDepthRangeIndexed()` is null.")
}
extern "system" fn dummy_pfnglgetfloati_vproc (_: GLenum, _: GLuint, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetFloati_v()` is null.")
}
extern "system" fn dummy_pfnglgetdoublei_vproc (_: GLenum, _: GLuint, _: *mut GLdouble) {
	panic!("OpenGL function pointer `glGetDoublei_v()` is null.")
}
pub const GL_FIXED: GLenum = 0x140C;
pub const GL_IMPLEMENTATION_COLOR_READ_TYPE: GLenum = 0x8B9A;
pub const GL_IMPLEMENTATION_COLOR_READ_FORMAT: GLenum = 0x8B9B;
pub const GL_LOW_FLOAT: GLenum = 0x8DF0;
pub const GL_MEDIUM_FLOAT: GLenum = 0x8DF1;
pub const GL_HIGH_FLOAT: GLenum = 0x8DF2;
pub const GL_LOW_INT: GLenum = 0x8DF3;
pub const GL_MEDIUM_INT: GLenum = 0x8DF4;
pub const GL_HIGH_INT: GLenum = 0x8DF5;
pub const GL_SHADER_COMPILER: GLenum = 0x8DFA;
pub const GL_SHADER_BINARY_FORMATS: GLenum = 0x8DF8;
pub const GL_NUM_SHADER_BINARY_FORMATS: GLenum = 0x8DF9;
pub const GL_MAX_VERTEX_UNIFORM_VECTORS: GLenum = 0x8DFB;
pub const GL_MAX_VARYING_VECTORS: GLenum = 0x8DFC;
pub const GL_MAX_FRAGMENT_UNIFORM_VECTORS: GLenum = 0x8DFD;
pub const GL_RGB565: GLenum = 0x8D62;
pub const GL_PROGRAM_BINARY_RETRIEVABLE_HINT: GLenum = 0x8257;
pub const GL_PROGRAM_BINARY_LENGTH: GLenum = 0x8741;
pub const GL_NUM_PROGRAM_BINARY_FORMATS: GLenum = 0x87FE;
pub const GL_PROGRAM_BINARY_FORMATS: GLenum = 0x87FF;
pub const GL_VERTEX_SHADER_BIT: GLbitfield = 0x00000001;
pub const GL_FRAGMENT_SHADER_BIT: GLbitfield = 0x00000002;
pub const GL_GEOMETRY_SHADER_BIT: GLbitfield = 0x00000004;
pub const GL_TESS_CONTROL_SHADER_BIT: GLbitfield = 0x00000008;
pub const GL_TESS_EVALUATION_SHADER_BIT: GLbitfield = 0x00000010;
pub const GL_ALL_SHADER_BITS: GLbitfield = 0xFFFFFFFF;
pub const GL_PROGRAM_SEPARABLE: GLenum = 0x8258;
pub const GL_ACTIVE_PROGRAM: GLenum = 0x8259;
pub const GL_PROGRAM_PIPELINE_BINDING: GLenum = 0x825A;
pub const GL_MAX_VIEWPORTS: GLenum = 0x825B;
pub const GL_VIEWPORT_SUBPIXEL_BITS: GLenum = 0x825C;
pub const GL_VIEWPORT_BOUNDS_RANGE: GLenum = 0x825D;
pub const GL_LAYER_PROVOKING_VERTEX: GLenum = 0x825E;
pub const GL_VIEWPORT_INDEX_PROVOKING_VERTEX: GLenum = 0x825F;
pub const GL_UNDEFINED_VERTEX: GLenum = 0x8260;

pub trait GL_4_1 {
	fn glGetError(&self) -> GLenum;
	fn glReleaseShaderCompiler(&self) -> Result<()>;
	fn glShaderBinary(&self, count: GLsizei, shaders: *const GLuint, binaryFormat: GLenum, binary: *const c_void, length: GLsizei) -> Result<()>;
	fn glGetShaderPrecisionFormat(&self, shadertype: GLenum, precisiontype: GLenum, range: *mut GLint, precision: *mut GLint) -> Result<()>;
	fn glDepthRangef(&self, n: GLfloat, f: GLfloat) -> Result<()>;
	fn glClearDepthf(&self, d: GLfloat) -> Result<()>;
	fn glGetProgramBinary(&self, program: GLuint, bufSize: GLsizei, length: *mut GLsizei, binaryFormat: *mut GLenum, binary: *mut c_void) -> Result<()>;
	fn glProgramBinary(&self, program: GLuint, binaryFormat: GLenum, binary: *const c_void, length: GLsizei) -> Result<()>;
	fn glProgramParameteri(&self, program: GLuint, pname: GLenum, value: GLint) -> Result<()>;
	fn glUseProgramStages(&self, pipeline: GLuint, stages: GLbitfield, program: GLuint) -> Result<()>;
	fn glActiveShaderProgram(&self, pipeline: GLuint, program: GLuint) -> Result<()>;
	fn glCreateShaderProgramv(&self, type_: GLenum, count: GLsizei, strings: *const *const GLchar) -> Result<GLuint>;
	fn glBindProgramPipeline(&self, pipeline: GLuint) -> Result<()>;
	fn glDeleteProgramPipelines(&self, n: GLsizei, pipelines: *const GLuint) -> Result<()>;
	fn glGenProgramPipelines(&self, n: GLsizei, pipelines: *mut GLuint) -> Result<()>;
	fn glIsProgramPipeline(&self, pipeline: GLuint) -> Result<GLboolean>;
	fn glGetProgramPipelineiv(&self, pipeline: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glProgramUniform1i(&self, program: GLuint, location: GLint, v0: GLint) -> Result<()>;
	fn glProgramUniform1iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()>;
	fn glProgramUniform1f(&self, program: GLuint, location: GLint, v0: GLfloat) -> Result<()>;
	fn glProgramUniform1fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()>;
	fn glProgramUniform1d(&self, program: GLuint, location: GLint, v0: GLdouble) -> Result<()>;
	fn glProgramUniform1dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()>;
	fn glProgramUniform1ui(&self, program: GLuint, location: GLint, v0: GLuint) -> Result<()>;
	fn glProgramUniform1uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()>;
	fn glProgramUniform2i(&self, program: GLuint, location: GLint, v0: GLint, v1: GLint) -> Result<()>;
	fn glProgramUniform2iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()>;
	fn glProgramUniform2f(&self, program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat) -> Result<()>;
	fn glProgramUniform2fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()>;
	fn glProgramUniform2d(&self, program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble) -> Result<()>;
	fn glProgramUniform2dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()>;
	fn glProgramUniform2ui(&self, program: GLuint, location: GLint, v0: GLuint, v1: GLuint) -> Result<()>;
	fn glProgramUniform2uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()>;
	fn glProgramUniform3i(&self, program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint) -> Result<()>;
	fn glProgramUniform3iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()>;
	fn glProgramUniform3f(&self, program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat) -> Result<()>;
	fn glProgramUniform3fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()>;
	fn glProgramUniform3d(&self, program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble) -> Result<()>;
	fn glProgramUniform3dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()>;
	fn glProgramUniform3ui(&self, program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint) -> Result<()>;
	fn glProgramUniform3uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()>;
	fn glProgramUniform4i(&self, program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint) -> Result<()>;
	fn glProgramUniform4iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()>;
	fn glProgramUniform4f(&self, program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat) -> Result<()>;
	fn glProgramUniform4fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()>;
	fn glProgramUniform4d(&self, program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble, v3: GLdouble) -> Result<()>;
	fn glProgramUniform4dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()>;
	fn glProgramUniform4ui(&self, program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint) -> Result<()>;
	fn glProgramUniform4uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()>;
	fn glProgramUniformMatrix2fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;
	fn glProgramUniformMatrix3fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;
	fn glProgramUniformMatrix4fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;
	fn glProgramUniformMatrix2dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;
	fn glProgramUniformMatrix3dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;
	fn glProgramUniformMatrix4dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;
	fn glProgramUniformMatrix2x3fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;
	fn glProgramUniformMatrix3x2fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;
	fn glProgramUniformMatrix2x4fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;
	fn glProgramUniformMatrix4x2fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;
	fn glProgramUniformMatrix3x4fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;
	fn glProgramUniformMatrix4x3fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()>;
	fn glProgramUniformMatrix2x3dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;
	fn glProgramUniformMatrix3x2dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;
	fn glProgramUniformMatrix2x4dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;
	fn glProgramUniformMatrix4x2dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;
	fn glProgramUniformMatrix3x4dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;
	fn glProgramUniformMatrix4x3dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()>;
	fn glValidateProgramPipeline(&self, pipeline: GLuint) -> Result<()>;
	fn glGetProgramPipelineInfoLog(&self, pipeline: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> Result<()>;
	fn glVertexAttribL1d(&self, index: GLuint, x: GLdouble) -> Result<()>;
	fn glVertexAttribL2d(&self, index: GLuint, x: GLdouble, y: GLdouble) -> Result<()>;
	fn glVertexAttribL3d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()>;
	fn glVertexAttribL4d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble) -> Result<()>;
	fn glVertexAttribL1dv(&self, index: GLuint, v: *const GLdouble) -> Result<()>;
	fn glVertexAttribL2dv(&self, index: GLuint, v: *const GLdouble) -> Result<()>;
	fn glVertexAttribL3dv(&self, index: GLuint, v: *const GLdouble) -> Result<()>;
	fn glVertexAttribL4dv(&self, index: GLuint, v: *const GLdouble) -> Result<()>;
	fn glVertexAttribLPointer(&self, index: GLuint, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()>;
	fn glGetVertexAttribLdv(&self, index: GLuint, pname: GLenum, params: *mut GLdouble) -> Result<()>;
	fn glViewportArrayv(&self, first: GLuint, count: GLsizei, v: *const GLfloat) -> Result<()>;
	fn glViewportIndexedf(&self, index: GLuint, x: GLfloat, y: GLfloat, w: GLfloat, h: GLfloat) -> Result<()>;
	fn glViewportIndexedfv(&self, index: GLuint, v: *const GLfloat) -> Result<()>;
	fn glScissorArrayv(&self, first: GLuint, count: GLsizei, v: *const GLint) -> Result<()>;
	fn glScissorIndexed(&self, index: GLuint, left: GLint, bottom: GLint, width: GLsizei, height: GLsizei) -> Result<()>;
	fn glScissorIndexedv(&self, index: GLuint, v: *const GLint) -> Result<()>;
	fn glDepthRangeArrayv(&self, first: GLuint, count: GLsizei, v: *const GLdouble) -> Result<()>;
	fn glDepthRangeIndexed(&self, index: GLuint, n: GLdouble, f: GLdouble) -> Result<()>;
	fn glGetFloati_v(&self, target: GLenum, index: GLuint, data: *mut GLfloat) -> Result<()>;
	fn glGetDoublei_v(&self, target: GLenum, index: GLuint, data: *mut GLdouble) -> Result<()>;
}

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version41 {
	available: bool,
	geterror: PFNGLGETERRORPROC,
	releaseshadercompiler: PFNGLRELEASESHADERCOMPILERPROC,
	shaderbinary: PFNGLSHADERBINARYPROC,
	getshaderprecisionformat: PFNGLGETSHADERPRECISIONFORMATPROC,
	depthrangef: PFNGLDEPTHRANGEFPROC,
	cleardepthf: PFNGLCLEARDEPTHFPROC,
	getprogrambinary: PFNGLGETPROGRAMBINARYPROC,
	programbinary: PFNGLPROGRAMBINARYPROC,
	programparameteri: PFNGLPROGRAMPARAMETERIPROC,
	useprogramstages: PFNGLUSEPROGRAMSTAGESPROC,
	activeshaderprogram: PFNGLACTIVESHADERPROGRAMPROC,
	createshaderprogramv: PFNGLCREATESHADERPROGRAMVPROC,
	bindprogrampipeline: PFNGLBINDPROGRAMPIPELINEPROC,
	deleteprogrampipelines: PFNGLDELETEPROGRAMPIPELINESPROC,
	genprogrampipelines: PFNGLGENPROGRAMPIPELINESPROC,
	isprogrampipeline: PFNGLISPROGRAMPIPELINEPROC,
	getprogrampipelineiv: PFNGLGETPROGRAMPIPELINEIVPROC,
	programuniform1i: PFNGLPROGRAMUNIFORM1IPROC,
	programuniform1iv: PFNGLPROGRAMUNIFORM1IVPROC,
	programuniform1f: PFNGLPROGRAMUNIFORM1FPROC,
	programuniform1fv: PFNGLPROGRAMUNIFORM1FVPROC,
	programuniform1d: PFNGLPROGRAMUNIFORM1DPROC,
	programuniform1dv: PFNGLPROGRAMUNIFORM1DVPROC,
	programuniform1ui: PFNGLPROGRAMUNIFORM1UIPROC,
	programuniform1uiv: PFNGLPROGRAMUNIFORM1UIVPROC,
	programuniform2i: PFNGLPROGRAMUNIFORM2IPROC,
	programuniform2iv: PFNGLPROGRAMUNIFORM2IVPROC,
	programuniform2f: PFNGLPROGRAMUNIFORM2FPROC,
	programuniform2fv: PFNGLPROGRAMUNIFORM2FVPROC,
	programuniform2d: PFNGLPROGRAMUNIFORM2DPROC,
	programuniform2dv: PFNGLPROGRAMUNIFORM2DVPROC,
	programuniform2ui: PFNGLPROGRAMUNIFORM2UIPROC,
	programuniform2uiv: PFNGLPROGRAMUNIFORM2UIVPROC,
	programuniform3i: PFNGLPROGRAMUNIFORM3IPROC,
	programuniform3iv: PFNGLPROGRAMUNIFORM3IVPROC,
	programuniform3f: PFNGLPROGRAMUNIFORM3FPROC,
	programuniform3fv: PFNGLPROGRAMUNIFORM3FVPROC,
	programuniform3d: PFNGLPROGRAMUNIFORM3DPROC,
	programuniform3dv: PFNGLPROGRAMUNIFORM3DVPROC,
	programuniform3ui: PFNGLPROGRAMUNIFORM3UIPROC,
	programuniform3uiv: PFNGLPROGRAMUNIFORM3UIVPROC,
	programuniform4i: PFNGLPROGRAMUNIFORM4IPROC,
	programuniform4iv: PFNGLPROGRAMUNIFORM4IVPROC,
	programuniform4f: PFNGLPROGRAMUNIFORM4FPROC,
	programuniform4fv: PFNGLPROGRAMUNIFORM4FVPROC,
	programuniform4d: PFNGLPROGRAMUNIFORM4DPROC,
	programuniform4dv: PFNGLPROGRAMUNIFORM4DVPROC,
	programuniform4ui: PFNGLPROGRAMUNIFORM4UIPROC,
	programuniform4uiv: PFNGLPROGRAMUNIFORM4UIVPROC,
	programuniformmatrix2fv: PFNGLPROGRAMUNIFORMMATRIX2FVPROC,
	programuniformmatrix3fv: PFNGLPROGRAMUNIFORMMATRIX3FVPROC,
	programuniformmatrix4fv: PFNGLPROGRAMUNIFORMMATRIX4FVPROC,
	programuniformmatrix2dv: PFNGLPROGRAMUNIFORMMATRIX2DVPROC,
	programuniformmatrix3dv: PFNGLPROGRAMUNIFORMMATRIX3DVPROC,
	programuniformmatrix4dv: PFNGLPROGRAMUNIFORMMATRIX4DVPROC,
	programuniformmatrix2x3fv: PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC,
	programuniformmatrix3x2fv: PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC,
	programuniformmatrix2x4fv: PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC,
	programuniformmatrix4x2fv: PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC,
	programuniformmatrix3x4fv: PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC,
	programuniformmatrix4x3fv: PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC,
	programuniformmatrix2x3dv: PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC,
	programuniformmatrix3x2dv: PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC,
	programuniformmatrix2x4dv: PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC,
	programuniformmatrix4x2dv: PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC,
	programuniformmatrix3x4dv: PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC,
	programuniformmatrix4x3dv: PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC,
	validateprogrampipeline: PFNGLVALIDATEPROGRAMPIPELINEPROC,
	getprogrampipelineinfolog: PFNGLGETPROGRAMPIPELINEINFOLOGPROC,
	vertexattribl1d: PFNGLVERTEXATTRIBL1DPROC,
	vertexattribl2d: PFNGLVERTEXATTRIBL2DPROC,
	vertexattribl3d: PFNGLVERTEXATTRIBL3DPROC,
	vertexattribl4d: PFNGLVERTEXATTRIBL4DPROC,
	vertexattribl1dv: PFNGLVERTEXATTRIBL1DVPROC,
	vertexattribl2dv: PFNGLVERTEXATTRIBL2DVPROC,
	vertexattribl3dv: PFNGLVERTEXATTRIBL3DVPROC,
	vertexattribl4dv: PFNGLVERTEXATTRIBL4DVPROC,
	vertexattriblpointer: PFNGLVERTEXATTRIBLPOINTERPROC,
	getvertexattribldv: PFNGLGETVERTEXATTRIBLDVPROC,
	viewportarrayv: PFNGLVIEWPORTARRAYVPROC,
	viewportindexedf: PFNGLVIEWPORTINDEXEDFPROC,
	viewportindexedfv: PFNGLVIEWPORTINDEXEDFVPROC,
	scissorarrayv: PFNGLSCISSORARRAYVPROC,
	scissorindexed: PFNGLSCISSORINDEXEDPROC,
	scissorindexedv: PFNGLSCISSORINDEXEDVPROC,
	depthrangearrayv: PFNGLDEPTHRANGEARRAYVPROC,
	depthrangeindexed: PFNGLDEPTHRANGEINDEXEDPROC,
	getfloati_v: PFNGLGETFLOATI_VPROC,
	getdoublei_v: PFNGLGETDOUBLEI_VPROC,
}

impl GL_4_1 for Version41 {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	#[inline(always)]
	fn glReleaseShaderCompiler(&self) -> Result<()> {
		let ret = process_catch("glReleaseShaderCompiler", catch_unwind(||(self.releaseshadercompiler)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glReleaseShaderCompiler", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glShaderBinary(&self, count: GLsizei, shaders: *const GLuint, binaryFormat: GLenum, binary: *const c_void, length: GLsizei) -> Result<()> {
		let ret = process_catch("glShaderBinary", catch_unwind(||(self.shaderbinary)(count, shaders, binaryFormat, binary, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glShaderBinary", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetShaderPrecisionFormat(&self, shadertype: GLenum, precisiontype: GLenum, range: *mut GLint, precision: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetShaderPrecisionFormat", catch_unwind(||(self.getshaderprecisionformat)(shadertype, precisiontype, range, precision)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetShaderPrecisionFormat", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDepthRangef(&self, n: GLfloat, f: GLfloat) -> Result<()> {
		let ret = process_catch("glDepthRangef", catch_unwind(||(self.depthrangef)(n, f)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthRangef", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearDepthf(&self, d: GLfloat) -> Result<()> {
		let ret = process_catch("glClearDepthf", catch_unwind(||(self.cleardepthf)(d)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearDepthf", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramBinary(&self, program: GLuint, bufSize: GLsizei, length: *mut GLsizei, binaryFormat: *mut GLenum, binary: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetProgramBinary", catch_unwind(||(self.getprogrambinary)(program, bufSize, length, binaryFormat, binary)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramBinary", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramBinary(&self, program: GLuint, binaryFormat: GLenum, binary: *const c_void, length: GLsizei) -> Result<()> {
		let ret = process_catch("glProgramBinary", catch_unwind(||(self.programbinary)(program, binaryFormat, binary, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramBinary", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramParameteri(&self, program: GLuint, pname: GLenum, value: GLint) -> Result<()> {
		let ret = process_catch("glProgramParameteri", catch_unwind(||(self.programparameteri)(program, pname, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramParameteri", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUseProgramStages(&self, pipeline: GLuint, stages: GLbitfield, program: GLuint) -> Result<()> {
		let ret = process_catch("glUseProgramStages", catch_unwind(||(self.useprogramstages)(pipeline, stages, program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUseProgramStages", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glActiveShaderProgram(&self, pipeline: GLuint, program: GLuint) -> Result<()> {
		let ret = process_catch("glActiveShaderProgram", catch_unwind(||(self.activeshaderprogram)(pipeline, program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glActiveShaderProgram", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateShaderProgramv(&self, type_: GLenum, count: GLsizei, strings: *const *const GLchar) -> Result<GLuint> {
		let ret = process_catch("glCreateShaderProgramv", catch_unwind(||(self.createshaderprogramv)(type_, count, strings)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateShaderProgramv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindProgramPipeline(&self, pipeline: GLuint) -> Result<()> {
		let ret = process_catch("glBindProgramPipeline", catch_unwind(||(self.bindprogrampipeline)(pipeline)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindProgramPipeline", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteProgramPipelines(&self, n: GLsizei, pipelines: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteProgramPipelines", catch_unwind(||(self.deleteprogrampipelines)(n, pipelines)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteProgramPipelines", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenProgramPipelines(&self, n: GLsizei, pipelines: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenProgramPipelines", catch_unwind(||(self.genprogrampipelines)(n, pipelines)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenProgramPipelines", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsProgramPipeline(&self, pipeline: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsProgramPipeline", catch_unwind(||(self.isprogrampipeline)(pipeline)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsProgramPipeline", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramPipelineiv(&self, pipeline: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramPipelineiv", catch_unwind(||(self.getprogrampipelineiv)(pipeline, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramPipelineiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform1i(&self, program: GLuint, location: GLint, v0: GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform1i", catch_unwind(||(self.programuniform1i)(program, location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform1iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform1iv", catch_unwind(||(self.programuniform1iv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform1f(&self, program: GLuint, location: GLint, v0: GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform1f", catch_unwind(||(self.programuniform1f)(program, location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform1fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform1fv", catch_unwind(||(self.programuniform1fv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform1d(&self, program: GLuint, location: GLint, v0: GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform1d", catch_unwind(||(self.programuniform1d)(program, location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform1dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform1dv", catch_unwind(||(self.programuniform1dv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform1ui(&self, program: GLuint, location: GLint, v0: GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform1ui", catch_unwind(||(self.programuniform1ui)(program, location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform1uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform1uiv", catch_unwind(||(self.programuniform1uiv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform2i(&self, program: GLuint, location: GLint, v0: GLint, v1: GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform2i", catch_unwind(||(self.programuniform2i)(program, location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform2iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform2iv", catch_unwind(||(self.programuniform2iv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform2f(&self, program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform2f", catch_unwind(||(self.programuniform2f)(program, location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform2fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform2fv", catch_unwind(||(self.programuniform2fv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform2d(&self, program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform2d", catch_unwind(||(self.programuniform2d)(program, location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform2dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform2dv", catch_unwind(||(self.programuniform2dv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform2ui(&self, program: GLuint, location: GLint, v0: GLuint, v1: GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform2ui", catch_unwind(||(self.programuniform2ui)(program, location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform2uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform2uiv", catch_unwind(||(self.programuniform2uiv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform3i(&self, program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform3i", catch_unwind(||(self.programuniform3i)(program, location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform3iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform3iv", catch_unwind(||(self.programuniform3iv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform3f(&self, program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform3f", catch_unwind(||(self.programuniform3f)(program, location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform3fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform3fv", catch_unwind(||(self.programuniform3fv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform3d(&self, program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform3d", catch_unwind(||(self.programuniform3d)(program, location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform3dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform3dv", catch_unwind(||(self.programuniform3dv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform3ui(&self, program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform3ui", catch_unwind(||(self.programuniform3ui)(program, location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform3uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform3uiv", catch_unwind(||(self.programuniform3uiv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform4i(&self, program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform4i", catch_unwind(||(self.programuniform4i)(program, location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4i", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform4iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform4iv", catch_unwind(||(self.programuniform4iv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform4f(&self, program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform4f", catch_unwind(||(self.programuniform4f)(program, location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4f", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform4fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform4fv", catch_unwind(||(self.programuniform4fv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform4d(&self, program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble, v3: GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform4d", catch_unwind(||(self.programuniform4d)(program, location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform4dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform4dv", catch_unwind(||(self.programuniform4dv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform4ui(&self, program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform4ui", catch_unwind(||(self.programuniform4ui)(program, location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4ui", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform4uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform4uiv", catch_unwind(||(self.programuniform4uiv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4uiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix2fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2fv", catch_unwind(||(self.programuniformmatrix2fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix3fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3fv", catch_unwind(||(self.programuniformmatrix3fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix4fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4fv", catch_unwind(||(self.programuniformmatrix4fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix2dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2dv", catch_unwind(||(self.programuniformmatrix2dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix3dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3dv", catch_unwind(||(self.programuniformmatrix3dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix4dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4dv", catch_unwind(||(self.programuniformmatrix4dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix2x3fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2x3fv", catch_unwind(||(self.programuniformmatrix2x3fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2x3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix3x2fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3x2fv", catch_unwind(||(self.programuniformmatrix3x2fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3x2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix2x4fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2x4fv", catch_unwind(||(self.programuniformmatrix2x4fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2x4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix4x2fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4x2fv", catch_unwind(||(self.programuniformmatrix4x2fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4x2fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix3x4fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3x4fv", catch_unwind(||(self.programuniformmatrix3x4fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3x4fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix4x3fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4x3fv", catch_unwind(||(self.programuniformmatrix4x3fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4x3fv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix2x3dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2x3dv", catch_unwind(||(self.programuniformmatrix2x3dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2x3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix3x2dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3x2dv", catch_unwind(||(self.programuniformmatrix3x2dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3x2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix2x4dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2x4dv", catch_unwind(||(self.programuniformmatrix2x4dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2x4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix4x2dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4x2dv", catch_unwind(||(self.programuniformmatrix4x2dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4x2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix3x4dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3x4dv", catch_unwind(||(self.programuniformmatrix3x4dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3x4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix4x3dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4x3dv", catch_unwind(||(self.programuniformmatrix4x3dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4x3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glValidateProgramPipeline(&self, pipeline: GLuint) -> Result<()> {
		let ret = process_catch("glValidateProgramPipeline", catch_unwind(||(self.validateprogrampipeline)(pipeline)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glValidateProgramPipeline", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramPipelineInfoLog(&self, pipeline: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetProgramPipelineInfoLog", catch_unwind(||(self.getprogrampipelineinfolog)(pipeline, bufSize, length, infoLog)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramPipelineInfoLog", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribL1d(&self, index: GLuint, x: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL1d", catch_unwind(||(self.vertexattribl1d)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL1d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribL2d(&self, index: GLuint, x: GLdouble, y: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL2d", catch_unwind(||(self.vertexattribl2d)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL2d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribL3d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL3d", catch_unwind(||(self.vertexattribl3d)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL3d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribL4d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL4d", catch_unwind(||(self.vertexattribl4d)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL4d", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribL1dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL1dv", catch_unwind(||(self.vertexattribl1dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL1dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribL2dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL2dv", catch_unwind(||(self.vertexattribl2dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL2dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribL3dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL3dv", catch_unwind(||(self.vertexattribl3dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL3dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribL4dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL4dv", catch_unwind(||(self.vertexattribl4dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL4dv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribLPointer(&self, index: GLuint, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glVertexAttribLPointer", catch_unwind(||(self.vertexattriblpointer)(index, size, type_, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribLPointer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexAttribLdv(&self, index: GLuint, pname: GLenum, params: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetVertexAttribLdv", catch_unwind(||(self.getvertexattribldv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribLdv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glViewportArrayv(&self, first: GLuint, count: GLsizei, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glViewportArrayv", catch_unwind(||(self.viewportarrayv)(first, count, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glViewportArrayv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glViewportIndexedf(&self, index: GLuint, x: GLfloat, y: GLfloat, w: GLfloat, h: GLfloat) -> Result<()> {
		let ret = process_catch("glViewportIndexedf", catch_unwind(||(self.viewportindexedf)(index, x, y, w, h)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glViewportIndexedf", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glViewportIndexedfv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glViewportIndexedfv", catch_unwind(||(self.viewportindexedfv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glViewportIndexedfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glScissorArrayv(&self, first: GLuint, count: GLsizei, v: *const GLint) -> Result<()> {
		let ret = process_catch("glScissorArrayv", catch_unwind(||(self.scissorarrayv)(first, count, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glScissorArrayv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glScissorIndexed(&self, index: GLuint, left: GLint, bottom: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glScissorIndexed", catch_unwind(||(self.scissorindexed)(index, left, bottom, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glScissorIndexed", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glScissorIndexedv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glScissorIndexedv", catch_unwind(||(self.scissorindexedv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glScissorIndexedv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDepthRangeArrayv(&self, first: GLuint, count: GLsizei, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glDepthRangeArrayv", catch_unwind(||(self.depthrangearrayv)(first, count, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthRangeArrayv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDepthRangeIndexed(&self, index: GLuint, n: GLdouble, f: GLdouble) -> Result<()> {
		let ret = process_catch("glDepthRangeIndexed", catch_unwind(||(self.depthrangeindexed)(index, n, f)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthRangeIndexed", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetFloati_v(&self, target: GLenum, index: GLuint, data: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetFloati_v", catch_unwind(||(self.getfloati_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFloati_v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetDoublei_v(&self, target: GLenum, index: GLuint, data: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetDoublei_v", catch_unwind(||(self.getdoublei_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetDoublei_v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version41 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (4, 1, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			releaseshadercompiler: {let proc = get_proc_address("glReleaseShaderCompiler"); if proc == null() {dummy_pfnglreleaseshadercompilerproc} else {unsafe{transmute(proc)}}},
			shaderbinary: {let proc = get_proc_address("glShaderBinary"); if proc == null() {dummy_pfnglshaderbinaryproc} else {unsafe{transmute(proc)}}},
			getshaderprecisionformat: {let proc = get_proc_address("glGetShaderPrecisionFormat"); if proc == null() {dummy_pfnglgetshaderprecisionformatproc} else {unsafe{transmute(proc)}}},
			depthrangef: {let proc = get_proc_address("glDepthRangef"); if proc == null() {dummy_pfngldepthrangefproc} else {unsafe{transmute(proc)}}},
			cleardepthf: {let proc = get_proc_address("glClearDepthf"); if proc == null() {dummy_pfnglcleardepthfproc} else {unsafe{transmute(proc)}}},
			getprogrambinary: {let proc = get_proc_address("glGetProgramBinary"); if proc == null() {dummy_pfnglgetprogrambinaryproc} else {unsafe{transmute(proc)}}},
			programbinary: {let proc = get_proc_address("glProgramBinary"); if proc == null() {dummy_pfnglprogrambinaryproc} else {unsafe{transmute(proc)}}},
			programparameteri: {let proc = get_proc_address("glProgramParameteri"); if proc == null() {dummy_pfnglprogramparameteriproc} else {unsafe{transmute(proc)}}},
			useprogramstages: {let proc = get_proc_address("glUseProgramStages"); if proc == null() {dummy_pfngluseprogramstagesproc} else {unsafe{transmute(proc)}}},
			activeshaderprogram: {let proc = get_proc_address("glActiveShaderProgram"); if proc == null() {dummy_pfnglactiveshaderprogramproc} else {unsafe{transmute(proc)}}},
			createshaderprogramv: {let proc = get_proc_address("glCreateShaderProgramv"); if proc == null() {dummy_pfnglcreateshaderprogramvproc} else {unsafe{transmute(proc)}}},
			bindprogrampipeline: {let proc = get_proc_address("glBindProgramPipeline"); if proc == null() {dummy_pfnglbindprogrampipelineproc} else {unsafe{transmute(proc)}}},
			deleteprogrampipelines: {let proc = get_proc_address("glDeleteProgramPipelines"); if proc == null() {dummy_pfngldeleteprogrampipelinesproc} else {unsafe{transmute(proc)}}},
			genprogrampipelines: {let proc = get_proc_address("glGenProgramPipelines"); if proc == null() {dummy_pfnglgenprogrampipelinesproc} else {unsafe{transmute(proc)}}},
			isprogrampipeline: {let proc = get_proc_address("glIsProgramPipeline"); if proc == null() {dummy_pfnglisprogrampipelineproc} else {unsafe{transmute(proc)}}},
			getprogrampipelineiv: {let proc = get_proc_address("glGetProgramPipelineiv"); if proc == null() {dummy_pfnglgetprogrampipelineivproc} else {unsafe{transmute(proc)}}},
			programuniform1i: {let proc = get_proc_address("glProgramUniform1i"); if proc == null() {dummy_pfnglprogramuniform1iproc} else {unsafe{transmute(proc)}}},
			programuniform1iv: {let proc = get_proc_address("glProgramUniform1iv"); if proc == null() {dummy_pfnglprogramuniform1ivproc} else {unsafe{transmute(proc)}}},
			programuniform1f: {let proc = get_proc_address("glProgramUniform1f"); if proc == null() {dummy_pfnglprogramuniform1fproc} else {unsafe{transmute(proc)}}},
			programuniform1fv: {let proc = get_proc_address("glProgramUniform1fv"); if proc == null() {dummy_pfnglprogramuniform1fvproc} else {unsafe{transmute(proc)}}},
			programuniform1d: {let proc = get_proc_address("glProgramUniform1d"); if proc == null() {dummy_pfnglprogramuniform1dproc} else {unsafe{transmute(proc)}}},
			programuniform1dv: {let proc = get_proc_address("glProgramUniform1dv"); if proc == null() {dummy_pfnglprogramuniform1dvproc} else {unsafe{transmute(proc)}}},
			programuniform1ui: {let proc = get_proc_address("glProgramUniform1ui"); if proc == null() {dummy_pfnglprogramuniform1uiproc} else {unsafe{transmute(proc)}}},
			programuniform1uiv: {let proc = get_proc_address("glProgramUniform1uiv"); if proc == null() {dummy_pfnglprogramuniform1uivproc} else {unsafe{transmute(proc)}}},
			programuniform2i: {let proc = get_proc_address("glProgramUniform2i"); if proc == null() {dummy_pfnglprogramuniform2iproc} else {unsafe{transmute(proc)}}},
			programuniform2iv: {let proc = get_proc_address("glProgramUniform2iv"); if proc == null() {dummy_pfnglprogramuniform2ivproc} else {unsafe{transmute(proc)}}},
			programuniform2f: {let proc = get_proc_address("glProgramUniform2f"); if proc == null() {dummy_pfnglprogramuniform2fproc} else {unsafe{transmute(proc)}}},
			programuniform2fv: {let proc = get_proc_address("glProgramUniform2fv"); if proc == null() {dummy_pfnglprogramuniform2fvproc} else {unsafe{transmute(proc)}}},
			programuniform2d: {let proc = get_proc_address("glProgramUniform2d"); if proc == null() {dummy_pfnglprogramuniform2dproc} else {unsafe{transmute(proc)}}},
			programuniform2dv: {let proc = get_proc_address("glProgramUniform2dv"); if proc == null() {dummy_pfnglprogramuniform2dvproc} else {unsafe{transmute(proc)}}},
			programuniform2ui: {let proc = get_proc_address("glProgramUniform2ui"); if proc == null() {dummy_pfnglprogramuniform2uiproc} else {unsafe{transmute(proc)}}},
			programuniform2uiv: {let proc = get_proc_address("glProgramUniform2uiv"); if proc == null() {dummy_pfnglprogramuniform2uivproc} else {unsafe{transmute(proc)}}},
			programuniform3i: {let proc = get_proc_address("glProgramUniform3i"); if proc == null() {dummy_pfnglprogramuniform3iproc} else {unsafe{transmute(proc)}}},
			programuniform3iv: {let proc = get_proc_address("glProgramUniform3iv"); if proc == null() {dummy_pfnglprogramuniform3ivproc} else {unsafe{transmute(proc)}}},
			programuniform3f: {let proc = get_proc_address("glProgramUniform3f"); if proc == null() {dummy_pfnglprogramuniform3fproc} else {unsafe{transmute(proc)}}},
			programuniform3fv: {let proc = get_proc_address("glProgramUniform3fv"); if proc == null() {dummy_pfnglprogramuniform3fvproc} else {unsafe{transmute(proc)}}},
			programuniform3d: {let proc = get_proc_address("glProgramUniform3d"); if proc == null() {dummy_pfnglprogramuniform3dproc} else {unsafe{transmute(proc)}}},
			programuniform3dv: {let proc = get_proc_address("glProgramUniform3dv"); if proc == null() {dummy_pfnglprogramuniform3dvproc} else {unsafe{transmute(proc)}}},
			programuniform3ui: {let proc = get_proc_address("glProgramUniform3ui"); if proc == null() {dummy_pfnglprogramuniform3uiproc} else {unsafe{transmute(proc)}}},
			programuniform3uiv: {let proc = get_proc_address("glProgramUniform3uiv"); if proc == null() {dummy_pfnglprogramuniform3uivproc} else {unsafe{transmute(proc)}}},
			programuniform4i: {let proc = get_proc_address("glProgramUniform4i"); if proc == null() {dummy_pfnglprogramuniform4iproc} else {unsafe{transmute(proc)}}},
			programuniform4iv: {let proc = get_proc_address("glProgramUniform4iv"); if proc == null() {dummy_pfnglprogramuniform4ivproc} else {unsafe{transmute(proc)}}},
			programuniform4f: {let proc = get_proc_address("glProgramUniform4f"); if proc == null() {dummy_pfnglprogramuniform4fproc} else {unsafe{transmute(proc)}}},
			programuniform4fv: {let proc = get_proc_address("glProgramUniform4fv"); if proc == null() {dummy_pfnglprogramuniform4fvproc} else {unsafe{transmute(proc)}}},
			programuniform4d: {let proc = get_proc_address("glProgramUniform4d"); if proc == null() {dummy_pfnglprogramuniform4dproc} else {unsafe{transmute(proc)}}},
			programuniform4dv: {let proc = get_proc_address("glProgramUniform4dv"); if proc == null() {dummy_pfnglprogramuniform4dvproc} else {unsafe{transmute(proc)}}},
			programuniform4ui: {let proc = get_proc_address("glProgramUniform4ui"); if proc == null() {dummy_pfnglprogramuniform4uiproc} else {unsafe{transmute(proc)}}},
			programuniform4uiv: {let proc = get_proc_address("glProgramUniform4uiv"); if proc == null() {dummy_pfnglprogramuniform4uivproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix2fv: {let proc = get_proc_address("glProgramUniformMatrix2fv"); if proc == null() {dummy_pfnglprogramuniformmatrix2fvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix3fv: {let proc = get_proc_address("glProgramUniformMatrix3fv"); if proc == null() {dummy_pfnglprogramuniformmatrix3fvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix4fv: {let proc = get_proc_address("glProgramUniformMatrix4fv"); if proc == null() {dummy_pfnglprogramuniformmatrix4fvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix2dv: {let proc = get_proc_address("glProgramUniformMatrix2dv"); if proc == null() {dummy_pfnglprogramuniformmatrix2dvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix3dv: {let proc = get_proc_address("glProgramUniformMatrix3dv"); if proc == null() {dummy_pfnglprogramuniformmatrix3dvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix4dv: {let proc = get_proc_address("glProgramUniformMatrix4dv"); if proc == null() {dummy_pfnglprogramuniformmatrix4dvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix2x3fv: {let proc = get_proc_address("glProgramUniformMatrix2x3fv"); if proc == null() {dummy_pfnglprogramuniformmatrix2x3fvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix3x2fv: {let proc = get_proc_address("glProgramUniformMatrix3x2fv"); if proc == null() {dummy_pfnglprogramuniformmatrix3x2fvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix2x4fv: {let proc = get_proc_address("glProgramUniformMatrix2x4fv"); if proc == null() {dummy_pfnglprogramuniformmatrix2x4fvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix4x2fv: {let proc = get_proc_address("glProgramUniformMatrix4x2fv"); if proc == null() {dummy_pfnglprogramuniformmatrix4x2fvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix3x4fv: {let proc = get_proc_address("glProgramUniformMatrix3x4fv"); if proc == null() {dummy_pfnglprogramuniformmatrix3x4fvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix4x3fv: {let proc = get_proc_address("glProgramUniformMatrix4x3fv"); if proc == null() {dummy_pfnglprogramuniformmatrix4x3fvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix2x3dv: {let proc = get_proc_address("glProgramUniformMatrix2x3dv"); if proc == null() {dummy_pfnglprogramuniformmatrix2x3dvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix3x2dv: {let proc = get_proc_address("glProgramUniformMatrix3x2dv"); if proc == null() {dummy_pfnglprogramuniformmatrix3x2dvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix2x4dv: {let proc = get_proc_address("glProgramUniformMatrix2x4dv"); if proc == null() {dummy_pfnglprogramuniformmatrix2x4dvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix4x2dv: {let proc = get_proc_address("glProgramUniformMatrix4x2dv"); if proc == null() {dummy_pfnglprogramuniformmatrix4x2dvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix3x4dv: {let proc = get_proc_address("glProgramUniformMatrix3x4dv"); if proc == null() {dummy_pfnglprogramuniformmatrix3x4dvproc} else {unsafe{transmute(proc)}}},
			programuniformmatrix4x3dv: {let proc = get_proc_address("glProgramUniformMatrix4x3dv"); if proc == null() {dummy_pfnglprogramuniformmatrix4x3dvproc} else {unsafe{transmute(proc)}}},
			validateprogrampipeline: {let proc = get_proc_address("glValidateProgramPipeline"); if proc == null() {dummy_pfnglvalidateprogrampipelineproc} else {unsafe{transmute(proc)}}},
			getprogrampipelineinfolog: {let proc = get_proc_address("glGetProgramPipelineInfoLog"); if proc == null() {dummy_pfnglgetprogrampipelineinfologproc} else {unsafe{transmute(proc)}}},
			vertexattribl1d: {let proc = get_proc_address("glVertexAttribL1d"); if proc == null() {dummy_pfnglvertexattribl1dproc} else {unsafe{transmute(proc)}}},
			vertexattribl2d: {let proc = get_proc_address("glVertexAttribL2d"); if proc == null() {dummy_pfnglvertexattribl2dproc} else {unsafe{transmute(proc)}}},
			vertexattribl3d: {let proc = get_proc_address("glVertexAttribL3d"); if proc == null() {dummy_pfnglvertexattribl3dproc} else {unsafe{transmute(proc)}}},
			vertexattribl4d: {let proc = get_proc_address("glVertexAttribL4d"); if proc == null() {dummy_pfnglvertexattribl4dproc} else {unsafe{transmute(proc)}}},
			vertexattribl1dv: {let proc = get_proc_address("glVertexAttribL1dv"); if proc == null() {dummy_pfnglvertexattribl1dvproc} else {unsafe{transmute(proc)}}},
			vertexattribl2dv: {let proc = get_proc_address("glVertexAttribL2dv"); if proc == null() {dummy_pfnglvertexattribl2dvproc} else {unsafe{transmute(proc)}}},
			vertexattribl3dv: {let proc = get_proc_address("glVertexAttribL3dv"); if proc == null() {dummy_pfnglvertexattribl3dvproc} else {unsafe{transmute(proc)}}},
			vertexattribl4dv: {let proc = get_proc_address("glVertexAttribL4dv"); if proc == null() {dummy_pfnglvertexattribl4dvproc} else {unsafe{transmute(proc)}}},
			vertexattriblpointer: {let proc = get_proc_address("glVertexAttribLPointer"); if proc == null() {dummy_pfnglvertexattriblpointerproc} else {unsafe{transmute(proc)}}},
			getvertexattribldv: {let proc = get_proc_address("glGetVertexAttribLdv"); if proc == null() {dummy_pfnglgetvertexattribldvproc} else {unsafe{transmute(proc)}}},
			viewportarrayv: {let proc = get_proc_address("glViewportArrayv"); if proc == null() {dummy_pfnglviewportarrayvproc} else {unsafe{transmute(proc)}}},
			viewportindexedf: {let proc = get_proc_address("glViewportIndexedf"); if proc == null() {dummy_pfnglviewportindexedfproc} else {unsafe{transmute(proc)}}},
			viewportindexedfv: {let proc = get_proc_address("glViewportIndexedfv"); if proc == null() {dummy_pfnglviewportindexedfvproc} else {unsafe{transmute(proc)}}},
			scissorarrayv: {let proc = get_proc_address("glScissorArrayv"); if proc == null() {dummy_pfnglscissorarrayvproc} else {unsafe{transmute(proc)}}},
			scissorindexed: {let proc = get_proc_address("glScissorIndexed"); if proc == null() {dummy_pfnglscissorindexedproc} else {unsafe{transmute(proc)}}},
			scissorindexedv: {let proc = get_proc_address("glScissorIndexedv"); if proc == null() {dummy_pfnglscissorindexedvproc} else {unsafe{transmute(proc)}}},
			depthrangearrayv: {let proc = get_proc_address("glDepthRangeArrayv"); if proc == null() {dummy_pfngldepthrangearrayvproc} else {unsafe{transmute(proc)}}},
			depthrangeindexed: {let proc = get_proc_address("glDepthRangeIndexed"); if proc == null() {dummy_pfngldepthrangeindexedproc} else {unsafe{transmute(proc)}}},
			getfloati_v: {let proc = get_proc_address("glGetFloati_v"); if proc == null() {dummy_pfnglgetfloati_vproc} else {unsafe{transmute(proc)}}},
			getdoublei_v: {let proc = get_proc_address("glGetDoublei_v"); if proc == null() {dummy_pfnglgetdoublei_vproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version41 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			releaseshadercompiler: dummy_pfnglreleaseshadercompilerproc,
			shaderbinary: dummy_pfnglshaderbinaryproc,
			getshaderprecisionformat: dummy_pfnglgetshaderprecisionformatproc,
			depthrangef: dummy_pfngldepthrangefproc,
			cleardepthf: dummy_pfnglcleardepthfproc,
			getprogrambinary: dummy_pfnglgetprogrambinaryproc,
			programbinary: dummy_pfnglprogrambinaryproc,
			programparameteri: dummy_pfnglprogramparameteriproc,
			useprogramstages: dummy_pfngluseprogramstagesproc,
			activeshaderprogram: dummy_pfnglactiveshaderprogramproc,
			createshaderprogramv: dummy_pfnglcreateshaderprogramvproc,
			bindprogrampipeline: dummy_pfnglbindprogrampipelineproc,
			deleteprogrampipelines: dummy_pfngldeleteprogrampipelinesproc,
			genprogrampipelines: dummy_pfnglgenprogrampipelinesproc,
			isprogrampipeline: dummy_pfnglisprogrampipelineproc,
			getprogrampipelineiv: dummy_pfnglgetprogrampipelineivproc,
			programuniform1i: dummy_pfnglprogramuniform1iproc,
			programuniform1iv: dummy_pfnglprogramuniform1ivproc,
			programuniform1f: dummy_pfnglprogramuniform1fproc,
			programuniform1fv: dummy_pfnglprogramuniform1fvproc,
			programuniform1d: dummy_pfnglprogramuniform1dproc,
			programuniform1dv: dummy_pfnglprogramuniform1dvproc,
			programuniform1ui: dummy_pfnglprogramuniform1uiproc,
			programuniform1uiv: dummy_pfnglprogramuniform1uivproc,
			programuniform2i: dummy_pfnglprogramuniform2iproc,
			programuniform2iv: dummy_pfnglprogramuniform2ivproc,
			programuniform2f: dummy_pfnglprogramuniform2fproc,
			programuniform2fv: dummy_pfnglprogramuniform2fvproc,
			programuniform2d: dummy_pfnglprogramuniform2dproc,
			programuniform2dv: dummy_pfnglprogramuniform2dvproc,
			programuniform2ui: dummy_pfnglprogramuniform2uiproc,
			programuniform2uiv: dummy_pfnglprogramuniform2uivproc,
			programuniform3i: dummy_pfnglprogramuniform3iproc,
			programuniform3iv: dummy_pfnglprogramuniform3ivproc,
			programuniform3f: dummy_pfnglprogramuniform3fproc,
			programuniform3fv: dummy_pfnglprogramuniform3fvproc,
			programuniform3d: dummy_pfnglprogramuniform3dproc,
			programuniform3dv: dummy_pfnglprogramuniform3dvproc,
			programuniform3ui: dummy_pfnglprogramuniform3uiproc,
			programuniform3uiv: dummy_pfnglprogramuniform3uivproc,
			programuniform4i: dummy_pfnglprogramuniform4iproc,
			programuniform4iv: dummy_pfnglprogramuniform4ivproc,
			programuniform4f: dummy_pfnglprogramuniform4fproc,
			programuniform4fv: dummy_pfnglprogramuniform4fvproc,
			programuniform4d: dummy_pfnglprogramuniform4dproc,
			programuniform4dv: dummy_pfnglprogramuniform4dvproc,
			programuniform4ui: dummy_pfnglprogramuniform4uiproc,
			programuniform4uiv: dummy_pfnglprogramuniform4uivproc,
			programuniformmatrix2fv: dummy_pfnglprogramuniformmatrix2fvproc,
			programuniformmatrix3fv: dummy_pfnglprogramuniformmatrix3fvproc,
			programuniformmatrix4fv: dummy_pfnglprogramuniformmatrix4fvproc,
			programuniformmatrix2dv: dummy_pfnglprogramuniformmatrix2dvproc,
			programuniformmatrix3dv: dummy_pfnglprogramuniformmatrix3dvproc,
			programuniformmatrix4dv: dummy_pfnglprogramuniformmatrix4dvproc,
			programuniformmatrix2x3fv: dummy_pfnglprogramuniformmatrix2x3fvproc,
			programuniformmatrix3x2fv: dummy_pfnglprogramuniformmatrix3x2fvproc,
			programuniformmatrix2x4fv: dummy_pfnglprogramuniformmatrix2x4fvproc,
			programuniformmatrix4x2fv: dummy_pfnglprogramuniformmatrix4x2fvproc,
			programuniformmatrix3x4fv: dummy_pfnglprogramuniformmatrix3x4fvproc,
			programuniformmatrix4x3fv: dummy_pfnglprogramuniformmatrix4x3fvproc,
			programuniformmatrix2x3dv: dummy_pfnglprogramuniformmatrix2x3dvproc,
			programuniformmatrix3x2dv: dummy_pfnglprogramuniformmatrix3x2dvproc,
			programuniformmatrix2x4dv: dummy_pfnglprogramuniformmatrix2x4dvproc,
			programuniformmatrix4x2dv: dummy_pfnglprogramuniformmatrix4x2dvproc,
			programuniformmatrix3x4dv: dummy_pfnglprogramuniformmatrix3x4dvproc,
			programuniformmatrix4x3dv: dummy_pfnglprogramuniformmatrix4x3dvproc,
			validateprogrampipeline: dummy_pfnglvalidateprogrampipelineproc,
			getprogrampipelineinfolog: dummy_pfnglgetprogrampipelineinfologproc,
			vertexattribl1d: dummy_pfnglvertexattribl1dproc,
			vertexattribl2d: dummy_pfnglvertexattribl2dproc,
			vertexattribl3d: dummy_pfnglvertexattribl3dproc,
			vertexattribl4d: dummy_pfnglvertexattribl4dproc,
			vertexattribl1dv: dummy_pfnglvertexattribl1dvproc,
			vertexattribl2dv: dummy_pfnglvertexattribl2dvproc,
			vertexattribl3dv: dummy_pfnglvertexattribl3dvproc,
			vertexattribl4dv: dummy_pfnglvertexattribl4dvproc,
			vertexattriblpointer: dummy_pfnglvertexattriblpointerproc,
			getvertexattribldv: dummy_pfnglgetvertexattribldvproc,
			viewportarrayv: dummy_pfnglviewportarrayvproc,
			viewportindexedf: dummy_pfnglviewportindexedfproc,
			viewportindexedfv: dummy_pfnglviewportindexedfvproc,
			scissorarrayv: dummy_pfnglscissorarrayvproc,
			scissorindexed: dummy_pfnglscissorindexedproc,
			scissorindexedv: dummy_pfnglscissorindexedvproc,
			depthrangearrayv: dummy_pfngldepthrangearrayvproc,
			depthrangeindexed: dummy_pfngldepthrangeindexedproc,
			getfloati_v: dummy_pfnglgetfloati_vproc,
			getdoublei_v: dummy_pfnglgetdoublei_vproc,
		}
	}
}
impl Debug for Version41 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version41")
			.field("available", &self.available)
			.field("releaseshadercompiler", unsafe{if transmute::<_, *const c_void>(self.releaseshadercompiler) == (dummy_pfnglreleaseshadercompilerproc as *const c_void) {&null::<PFNGLRELEASESHADERCOMPILERPROC>()} else {&self.releaseshadercompiler}})
			.field("shaderbinary", unsafe{if transmute::<_, *const c_void>(self.shaderbinary) == (dummy_pfnglshaderbinaryproc as *const c_void) {&null::<PFNGLSHADERBINARYPROC>()} else {&self.shaderbinary}})
			.field("getshaderprecisionformat", unsafe{if transmute::<_, *const c_void>(self.getshaderprecisionformat) == (dummy_pfnglgetshaderprecisionformatproc as *const c_void) {&null::<PFNGLGETSHADERPRECISIONFORMATPROC>()} else {&self.getshaderprecisionformat}})
			.field("depthrangef", unsafe{if transmute::<_, *const c_void>(self.depthrangef) == (dummy_pfngldepthrangefproc as *const c_void) {&null::<PFNGLDEPTHRANGEFPROC>()} else {&self.depthrangef}})
			.field("cleardepthf", unsafe{if transmute::<_, *const c_void>(self.cleardepthf) == (dummy_pfnglcleardepthfproc as *const c_void) {&null::<PFNGLCLEARDEPTHFPROC>()} else {&self.cleardepthf}})
			.field("getprogrambinary", unsafe{if transmute::<_, *const c_void>(self.getprogrambinary) == (dummy_pfnglgetprogrambinaryproc as *const c_void) {&null::<PFNGLGETPROGRAMBINARYPROC>()} else {&self.getprogrambinary}})
			.field("programbinary", unsafe{if transmute::<_, *const c_void>(self.programbinary) == (dummy_pfnglprogrambinaryproc as *const c_void) {&null::<PFNGLPROGRAMBINARYPROC>()} else {&self.programbinary}})
			.field("programparameteri", unsafe{if transmute::<_, *const c_void>(self.programparameteri) == (dummy_pfnglprogramparameteriproc as *const c_void) {&null::<PFNGLPROGRAMPARAMETERIPROC>()} else {&self.programparameteri}})
			.field("useprogramstages", unsafe{if transmute::<_, *const c_void>(self.useprogramstages) == (dummy_pfngluseprogramstagesproc as *const c_void) {&null::<PFNGLUSEPROGRAMSTAGESPROC>()} else {&self.useprogramstages}})
			.field("activeshaderprogram", unsafe{if transmute::<_, *const c_void>(self.activeshaderprogram) == (dummy_pfnglactiveshaderprogramproc as *const c_void) {&null::<PFNGLACTIVESHADERPROGRAMPROC>()} else {&self.activeshaderprogram}})
			.field("createshaderprogramv", unsafe{if transmute::<_, *const c_void>(self.createshaderprogramv) == (dummy_pfnglcreateshaderprogramvproc as *const c_void) {&null::<PFNGLCREATESHADERPROGRAMVPROC>()} else {&self.createshaderprogramv}})
			.field("bindprogrampipeline", unsafe{if transmute::<_, *const c_void>(self.bindprogrampipeline) == (dummy_pfnglbindprogrampipelineproc as *const c_void) {&null::<PFNGLBINDPROGRAMPIPELINEPROC>()} else {&self.bindprogrampipeline}})
			.field("deleteprogrampipelines", unsafe{if transmute::<_, *const c_void>(self.deleteprogrampipelines) == (dummy_pfngldeleteprogrampipelinesproc as *const c_void) {&null::<PFNGLDELETEPROGRAMPIPELINESPROC>()} else {&self.deleteprogrampipelines}})
			.field("genprogrampipelines", unsafe{if transmute::<_, *const c_void>(self.genprogrampipelines) == (dummy_pfnglgenprogrampipelinesproc as *const c_void) {&null::<PFNGLGENPROGRAMPIPELINESPROC>()} else {&self.genprogrampipelines}})
			.field("isprogrampipeline", unsafe{if transmute::<_, *const c_void>(self.isprogrampipeline) == (dummy_pfnglisprogrampipelineproc as *const c_void) {&null::<PFNGLISPROGRAMPIPELINEPROC>()} else {&self.isprogrampipeline}})
			.field("getprogrampipelineiv", unsafe{if transmute::<_, *const c_void>(self.getprogrampipelineiv) == (dummy_pfnglgetprogrampipelineivproc as *const c_void) {&null::<PFNGLGETPROGRAMPIPELINEIVPROC>()} else {&self.getprogrampipelineiv}})
			.field("programuniform1i", unsafe{if transmute::<_, *const c_void>(self.programuniform1i) == (dummy_pfnglprogramuniform1iproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM1IPROC>()} else {&self.programuniform1i}})
			.field("programuniform1iv", unsafe{if transmute::<_, *const c_void>(self.programuniform1iv) == (dummy_pfnglprogramuniform1ivproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM1IVPROC>()} else {&self.programuniform1iv}})
			.field("programuniform1f", unsafe{if transmute::<_, *const c_void>(self.programuniform1f) == (dummy_pfnglprogramuniform1fproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM1FPROC>()} else {&self.programuniform1f}})
			.field("programuniform1fv", unsafe{if transmute::<_, *const c_void>(self.programuniform1fv) == (dummy_pfnglprogramuniform1fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM1FVPROC>()} else {&self.programuniform1fv}})
			.field("programuniform1d", unsafe{if transmute::<_, *const c_void>(self.programuniform1d) == (dummy_pfnglprogramuniform1dproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM1DPROC>()} else {&self.programuniform1d}})
			.field("programuniform1dv", unsafe{if transmute::<_, *const c_void>(self.programuniform1dv) == (dummy_pfnglprogramuniform1dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM1DVPROC>()} else {&self.programuniform1dv}})
			.field("programuniform1ui", unsafe{if transmute::<_, *const c_void>(self.programuniform1ui) == (dummy_pfnglprogramuniform1uiproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM1UIPROC>()} else {&self.programuniform1ui}})
			.field("programuniform1uiv", unsafe{if transmute::<_, *const c_void>(self.programuniform1uiv) == (dummy_pfnglprogramuniform1uivproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM1UIVPROC>()} else {&self.programuniform1uiv}})
			.field("programuniform2i", unsafe{if transmute::<_, *const c_void>(self.programuniform2i) == (dummy_pfnglprogramuniform2iproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM2IPROC>()} else {&self.programuniform2i}})
			.field("programuniform2iv", unsafe{if transmute::<_, *const c_void>(self.programuniform2iv) == (dummy_pfnglprogramuniform2ivproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM2IVPROC>()} else {&self.programuniform2iv}})
			.field("programuniform2f", unsafe{if transmute::<_, *const c_void>(self.programuniform2f) == (dummy_pfnglprogramuniform2fproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM2FPROC>()} else {&self.programuniform2f}})
			.field("programuniform2fv", unsafe{if transmute::<_, *const c_void>(self.programuniform2fv) == (dummy_pfnglprogramuniform2fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM2FVPROC>()} else {&self.programuniform2fv}})
			.field("programuniform2d", unsafe{if transmute::<_, *const c_void>(self.programuniform2d) == (dummy_pfnglprogramuniform2dproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM2DPROC>()} else {&self.programuniform2d}})
			.field("programuniform2dv", unsafe{if transmute::<_, *const c_void>(self.programuniform2dv) == (dummy_pfnglprogramuniform2dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM2DVPROC>()} else {&self.programuniform2dv}})
			.field("programuniform2ui", unsafe{if transmute::<_, *const c_void>(self.programuniform2ui) == (dummy_pfnglprogramuniform2uiproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM2UIPROC>()} else {&self.programuniform2ui}})
			.field("programuniform2uiv", unsafe{if transmute::<_, *const c_void>(self.programuniform2uiv) == (dummy_pfnglprogramuniform2uivproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM2UIVPROC>()} else {&self.programuniform2uiv}})
			.field("programuniform3i", unsafe{if transmute::<_, *const c_void>(self.programuniform3i) == (dummy_pfnglprogramuniform3iproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM3IPROC>()} else {&self.programuniform3i}})
			.field("programuniform3iv", unsafe{if transmute::<_, *const c_void>(self.programuniform3iv) == (dummy_pfnglprogramuniform3ivproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM3IVPROC>()} else {&self.programuniform3iv}})
			.field("programuniform3f", unsafe{if transmute::<_, *const c_void>(self.programuniform3f) == (dummy_pfnglprogramuniform3fproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM3FPROC>()} else {&self.programuniform3f}})
			.field("programuniform3fv", unsafe{if transmute::<_, *const c_void>(self.programuniform3fv) == (dummy_pfnglprogramuniform3fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM3FVPROC>()} else {&self.programuniform3fv}})
			.field("programuniform3d", unsafe{if transmute::<_, *const c_void>(self.programuniform3d) == (dummy_pfnglprogramuniform3dproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM3DPROC>()} else {&self.programuniform3d}})
			.field("programuniform3dv", unsafe{if transmute::<_, *const c_void>(self.programuniform3dv) == (dummy_pfnglprogramuniform3dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM3DVPROC>()} else {&self.programuniform3dv}})
			.field("programuniform3ui", unsafe{if transmute::<_, *const c_void>(self.programuniform3ui) == (dummy_pfnglprogramuniform3uiproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM3UIPROC>()} else {&self.programuniform3ui}})
			.field("programuniform3uiv", unsafe{if transmute::<_, *const c_void>(self.programuniform3uiv) == (dummy_pfnglprogramuniform3uivproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM3UIVPROC>()} else {&self.programuniform3uiv}})
			.field("programuniform4i", unsafe{if transmute::<_, *const c_void>(self.programuniform4i) == (dummy_pfnglprogramuniform4iproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM4IPROC>()} else {&self.programuniform4i}})
			.field("programuniform4iv", unsafe{if transmute::<_, *const c_void>(self.programuniform4iv) == (dummy_pfnglprogramuniform4ivproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM4IVPROC>()} else {&self.programuniform4iv}})
			.field("programuniform4f", unsafe{if transmute::<_, *const c_void>(self.programuniform4f) == (dummy_pfnglprogramuniform4fproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM4FPROC>()} else {&self.programuniform4f}})
			.field("programuniform4fv", unsafe{if transmute::<_, *const c_void>(self.programuniform4fv) == (dummy_pfnglprogramuniform4fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM4FVPROC>()} else {&self.programuniform4fv}})
			.field("programuniform4d", unsafe{if transmute::<_, *const c_void>(self.programuniform4d) == (dummy_pfnglprogramuniform4dproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM4DPROC>()} else {&self.programuniform4d}})
			.field("programuniform4dv", unsafe{if transmute::<_, *const c_void>(self.programuniform4dv) == (dummy_pfnglprogramuniform4dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM4DVPROC>()} else {&self.programuniform4dv}})
			.field("programuniform4ui", unsafe{if transmute::<_, *const c_void>(self.programuniform4ui) == (dummy_pfnglprogramuniform4uiproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM4UIPROC>()} else {&self.programuniform4ui}})
			.field("programuniform4uiv", unsafe{if transmute::<_, *const c_void>(self.programuniform4uiv) == (dummy_pfnglprogramuniform4uivproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORM4UIVPROC>()} else {&self.programuniform4uiv}})
			.field("programuniformmatrix2fv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix2fv) == (dummy_pfnglprogramuniformmatrix2fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX2FVPROC>()} else {&self.programuniformmatrix2fv}})
			.field("programuniformmatrix3fv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix3fv) == (dummy_pfnglprogramuniformmatrix3fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX3FVPROC>()} else {&self.programuniformmatrix3fv}})
			.field("programuniformmatrix4fv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix4fv) == (dummy_pfnglprogramuniformmatrix4fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX4FVPROC>()} else {&self.programuniformmatrix4fv}})
			.field("programuniformmatrix2dv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix2dv) == (dummy_pfnglprogramuniformmatrix2dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX2DVPROC>()} else {&self.programuniformmatrix2dv}})
			.field("programuniformmatrix3dv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix3dv) == (dummy_pfnglprogramuniformmatrix3dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX3DVPROC>()} else {&self.programuniformmatrix3dv}})
			.field("programuniformmatrix4dv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix4dv) == (dummy_pfnglprogramuniformmatrix4dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX4DVPROC>()} else {&self.programuniformmatrix4dv}})
			.field("programuniformmatrix2x3fv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix2x3fv) == (dummy_pfnglprogramuniformmatrix2x3fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC>()} else {&self.programuniformmatrix2x3fv}})
			.field("programuniformmatrix3x2fv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix3x2fv) == (dummy_pfnglprogramuniformmatrix3x2fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC>()} else {&self.programuniformmatrix3x2fv}})
			.field("programuniformmatrix2x4fv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix2x4fv) == (dummy_pfnglprogramuniformmatrix2x4fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC>()} else {&self.programuniformmatrix2x4fv}})
			.field("programuniformmatrix4x2fv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix4x2fv) == (dummy_pfnglprogramuniformmatrix4x2fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC>()} else {&self.programuniformmatrix4x2fv}})
			.field("programuniformmatrix3x4fv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix3x4fv) == (dummy_pfnglprogramuniformmatrix3x4fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC>()} else {&self.programuniformmatrix3x4fv}})
			.field("programuniformmatrix4x3fv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix4x3fv) == (dummy_pfnglprogramuniformmatrix4x3fvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC>()} else {&self.programuniformmatrix4x3fv}})
			.field("programuniformmatrix2x3dv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix2x3dv) == (dummy_pfnglprogramuniformmatrix2x3dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC>()} else {&self.programuniformmatrix2x3dv}})
			.field("programuniformmatrix3x2dv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix3x2dv) == (dummy_pfnglprogramuniformmatrix3x2dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC>()} else {&self.programuniformmatrix3x2dv}})
			.field("programuniformmatrix2x4dv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix2x4dv) == (dummy_pfnglprogramuniformmatrix2x4dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC>()} else {&self.programuniformmatrix2x4dv}})
			.field("programuniformmatrix4x2dv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix4x2dv) == (dummy_pfnglprogramuniformmatrix4x2dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC>()} else {&self.programuniformmatrix4x2dv}})
			.field("programuniformmatrix3x4dv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix3x4dv) == (dummy_pfnglprogramuniformmatrix3x4dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC>()} else {&self.programuniformmatrix3x4dv}})
			.field("programuniformmatrix4x3dv", unsafe{if transmute::<_, *const c_void>(self.programuniformmatrix4x3dv) == (dummy_pfnglprogramuniformmatrix4x3dvproc as *const c_void) {&null::<PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC>()} else {&self.programuniformmatrix4x3dv}})
			.field("validateprogrampipeline", unsafe{if transmute::<_, *const c_void>(self.validateprogrampipeline) == (dummy_pfnglvalidateprogrampipelineproc as *const c_void) {&null::<PFNGLVALIDATEPROGRAMPIPELINEPROC>()} else {&self.validateprogrampipeline}})
			.field("getprogrampipelineinfolog", unsafe{if transmute::<_, *const c_void>(self.getprogrampipelineinfolog) == (dummy_pfnglgetprogrampipelineinfologproc as *const c_void) {&null::<PFNGLGETPROGRAMPIPELINEINFOLOGPROC>()} else {&self.getprogrampipelineinfolog}})
			.field("vertexattribl1d", unsafe{if transmute::<_, *const c_void>(self.vertexattribl1d) == (dummy_pfnglvertexattribl1dproc as *const c_void) {&null::<PFNGLVERTEXATTRIBL1DPROC>()} else {&self.vertexattribl1d}})
			.field("vertexattribl2d", unsafe{if transmute::<_, *const c_void>(self.vertexattribl2d) == (dummy_pfnglvertexattribl2dproc as *const c_void) {&null::<PFNGLVERTEXATTRIBL2DPROC>()} else {&self.vertexattribl2d}})
			.field("vertexattribl3d", unsafe{if transmute::<_, *const c_void>(self.vertexattribl3d) == (dummy_pfnglvertexattribl3dproc as *const c_void) {&null::<PFNGLVERTEXATTRIBL3DPROC>()} else {&self.vertexattribl3d}})
			.field("vertexattribl4d", unsafe{if transmute::<_, *const c_void>(self.vertexattribl4d) == (dummy_pfnglvertexattribl4dproc as *const c_void) {&null::<PFNGLVERTEXATTRIBL4DPROC>()} else {&self.vertexattribl4d}})
			.field("vertexattribl1dv", unsafe{if transmute::<_, *const c_void>(self.vertexattribl1dv) == (dummy_pfnglvertexattribl1dvproc as *const c_void) {&null::<PFNGLVERTEXATTRIBL1DVPROC>()} else {&self.vertexattribl1dv}})
			.field("vertexattribl2dv", unsafe{if transmute::<_, *const c_void>(self.vertexattribl2dv) == (dummy_pfnglvertexattribl2dvproc as *const c_void) {&null::<PFNGLVERTEXATTRIBL2DVPROC>()} else {&self.vertexattribl2dv}})
			.field("vertexattribl3dv", unsafe{if transmute::<_, *const c_void>(self.vertexattribl3dv) == (dummy_pfnglvertexattribl3dvproc as *const c_void) {&null::<PFNGLVERTEXATTRIBL3DVPROC>()} else {&self.vertexattribl3dv}})
			.field("vertexattribl4dv", unsafe{if transmute::<_, *const c_void>(self.vertexattribl4dv) == (dummy_pfnglvertexattribl4dvproc as *const c_void) {&null::<PFNGLVERTEXATTRIBL4DVPROC>()} else {&self.vertexattribl4dv}})
			.field("vertexattriblpointer", unsafe{if transmute::<_, *const c_void>(self.vertexattriblpointer) == (dummy_pfnglvertexattriblpointerproc as *const c_void) {&null::<PFNGLVERTEXATTRIBLPOINTERPROC>()} else {&self.vertexattriblpointer}})
			.field("getvertexattribldv", unsafe{if transmute::<_, *const c_void>(self.getvertexattribldv) == (dummy_pfnglgetvertexattribldvproc as *const c_void) {&null::<PFNGLGETVERTEXATTRIBLDVPROC>()} else {&self.getvertexattribldv}})
			.field("viewportarrayv", unsafe{if transmute::<_, *const c_void>(self.viewportarrayv) == (dummy_pfnglviewportarrayvproc as *const c_void) {&null::<PFNGLVIEWPORTARRAYVPROC>()} else {&self.viewportarrayv}})
			.field("viewportindexedf", unsafe{if transmute::<_, *const c_void>(self.viewportindexedf) == (dummy_pfnglviewportindexedfproc as *const c_void) {&null::<PFNGLVIEWPORTINDEXEDFPROC>()} else {&self.viewportindexedf}})
			.field("viewportindexedfv", unsafe{if transmute::<_, *const c_void>(self.viewportindexedfv) == (dummy_pfnglviewportindexedfvproc as *const c_void) {&null::<PFNGLVIEWPORTINDEXEDFVPROC>()} else {&self.viewportindexedfv}})
			.field("scissorarrayv", unsafe{if transmute::<_, *const c_void>(self.scissorarrayv) == (dummy_pfnglscissorarrayvproc as *const c_void) {&null::<PFNGLSCISSORARRAYVPROC>()} else {&self.scissorarrayv}})
			.field("scissorindexed", unsafe{if transmute::<_, *const c_void>(self.scissorindexed) == (dummy_pfnglscissorindexedproc as *const c_void) {&null::<PFNGLSCISSORINDEXEDPROC>()} else {&self.scissorindexed}})
			.field("scissorindexedv", unsafe{if transmute::<_, *const c_void>(self.scissorindexedv) == (dummy_pfnglscissorindexedvproc as *const c_void) {&null::<PFNGLSCISSORINDEXEDVPROC>()} else {&self.scissorindexedv}})
			.field("depthrangearrayv", unsafe{if transmute::<_, *const c_void>(self.depthrangearrayv) == (dummy_pfngldepthrangearrayvproc as *const c_void) {&null::<PFNGLDEPTHRANGEARRAYVPROC>()} else {&self.depthrangearrayv}})
			.field("depthrangeindexed", unsafe{if transmute::<_, *const c_void>(self.depthrangeindexed) == (dummy_pfngldepthrangeindexedproc as *const c_void) {&null::<PFNGLDEPTHRANGEINDEXEDPROC>()} else {&self.depthrangeindexed}})
			.field("getfloati_v", unsafe{if transmute::<_, *const c_void>(self.getfloati_v) == (dummy_pfnglgetfloati_vproc as *const c_void) {&null::<PFNGLGETFLOATI_VPROC>()} else {&self.getfloati_v}})
			.field("getdoublei_v", unsafe{if transmute::<_, *const c_void>(self.getdoublei_v) == (dummy_pfnglgetdoublei_vproc as *const c_void) {&null::<PFNGLGETDOUBLEI_VPROC>()} else {&self.getdoublei_v}})
			.finish()
		} else {
			f.debug_struct("Version41")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}
type PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC = extern "system" fn(GLenum, GLint, GLsizei, GLsizei, GLuint);
type PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC = extern "system" fn(GLenum, GLsizei, GLenum, *const c_void, GLsizei, GLuint);
type PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC = extern "system" fn(GLenum, GLsizei, GLenum, *const c_void, GLsizei, GLint, GLuint);
type PFNGLGETINTERNALFORMATIVPROC = extern "system" fn(GLenum, GLenum, GLenum, GLsizei, *mut GLint);
type PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC = extern "system" fn(GLuint, GLuint, GLenum, *mut GLint);
type PFNGLBINDIMAGETEXTUREPROC = extern "system" fn(GLuint, GLuint, GLint, GLboolean, GLint, GLenum, GLenum);
type PFNGLMEMORYBARRIERPROC = extern "system" fn(GLbitfield);
type PFNGLTEXSTORAGE1DPROC = extern "system" fn(GLenum, GLsizei, GLenum, GLsizei);
type PFNGLTEXSTORAGE2DPROC = extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei);
type PFNGLTEXSTORAGE3DPROC = extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei);
type PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC = extern "system" fn(GLenum, GLuint, GLsizei);
type PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC = extern "system" fn(GLenum, GLuint, GLuint, GLsizei);
extern "system" fn dummy_pfngldrawarraysinstancedbaseinstanceproc (_: GLenum, _: GLint, _: GLsizei, _: GLsizei, _: GLuint) {
	panic!("OpenGL function pointer `glDrawArraysInstancedBaseInstance()` is null.")
}
extern "system" fn dummy_pfngldrawelementsinstancedbaseinstanceproc (_: GLenum, _: GLsizei, _: GLenum, _: *const c_void, _: GLsizei, _: GLuint) {
	panic!("OpenGL function pointer `glDrawElementsInstancedBaseInstance()` is null.")
}
extern "system" fn dummy_pfngldrawelementsinstancedbasevertexbaseinstanceproc (_: GLenum, _: GLsizei, _: GLenum, _: *const c_void, _: GLsizei, _: GLint, _: GLuint) {
	panic!("OpenGL function pointer `glDrawElementsInstancedBaseVertexBaseInstance()` is null.")
}
extern "system" fn dummy_pfnglgetinternalformativproc (_: GLenum, _: GLenum, _: GLenum, _: GLsizei, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetInternalformativ()` is null.")
}
extern "system" fn dummy_pfnglgetactiveatomiccounterbufferivproc (_: GLuint, _: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetActiveAtomicCounterBufferiv()` is null.")
}
extern "system" fn dummy_pfnglbindimagetextureproc (_: GLuint, _: GLuint, _: GLint, _: GLboolean, _: GLint, _: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glBindImageTexture()` is null.")
}
extern "system" fn dummy_pfnglmemorybarrierproc (_: GLbitfield) {
	panic!("OpenGL function pointer `glMemoryBarrier()` is null.")
}
extern "system" fn dummy_pfngltexstorage1dproc (_: GLenum, _: GLsizei, _: GLenum, _: GLsizei) {
	panic!("OpenGL function pointer `glTexStorage1D()` is null.")
}
extern "system" fn dummy_pfngltexstorage2dproc (_: GLenum, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glTexStorage2D()` is null.")
}
extern "system" fn dummy_pfngltexstorage3dproc (_: GLenum, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glTexStorage3D()` is null.")
}
extern "system" fn dummy_pfngldrawtransformfeedbackinstancedproc (_: GLenum, _: GLuint, _: GLsizei) {
	panic!("OpenGL function pointer `glDrawTransformFeedbackInstanced()` is null.")
}
extern "system" fn dummy_pfngldrawtransformfeedbackstreaminstancedproc (_: GLenum, _: GLuint, _: GLuint, _: GLsizei) {
	panic!("OpenGL function pointer `glDrawTransformFeedbackStreamInstanced()` is null.")
}
pub const GL_COPY_READ_BUFFER_BINDING: GLenum = 0x8F36;
pub const GL_COPY_WRITE_BUFFER_BINDING: GLenum = 0x8F37;
pub const GL_TRANSFORM_FEEDBACK_ACTIVE: GLenum = 0x8E24;
pub const GL_TRANSFORM_FEEDBACK_PAUSED: GLenum = 0x8E23;
pub const GL_UNPACK_COMPRESSED_BLOCK_WIDTH: GLenum = 0x9127;
pub const GL_UNPACK_COMPRESSED_BLOCK_HEIGHT: GLenum = 0x9128;
pub const GL_UNPACK_COMPRESSED_BLOCK_DEPTH: GLenum = 0x9129;
pub const GL_UNPACK_COMPRESSED_BLOCK_SIZE: GLenum = 0x912A;
pub const GL_PACK_COMPRESSED_BLOCK_WIDTH: GLenum = 0x912B;
pub const GL_PACK_COMPRESSED_BLOCK_HEIGHT: GLenum = 0x912C;
pub const GL_PACK_COMPRESSED_BLOCK_DEPTH: GLenum = 0x912D;
pub const GL_PACK_COMPRESSED_BLOCK_SIZE: GLenum = 0x912E;
pub const GL_NUM_SAMPLE_COUNTS: GLenum = 0x9380;
pub const GL_MIN_MAP_BUFFER_ALIGNMENT: GLenum = 0x90BC;
pub const GL_ATOMIC_COUNTER_BUFFER: GLenum = 0x92C0;
pub const GL_ATOMIC_COUNTER_BUFFER_BINDING: GLenum = 0x92C1;
pub const GL_ATOMIC_COUNTER_BUFFER_START: GLenum = 0x92C2;
pub const GL_ATOMIC_COUNTER_BUFFER_SIZE: GLenum = 0x92C3;
pub const GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE: GLenum = 0x92C4;
pub const GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS: GLenum = 0x92C5;
pub const GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES: GLenum = 0x92C6;
pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER: GLenum = 0x92C7;
pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER: GLenum = 0x92C8;
pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER: GLenum = 0x92C9;
pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER: GLenum = 0x92CA;
pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER: GLenum = 0x92CB;
pub const GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CC;
pub const GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CD;
pub const GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CE;
pub const GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92CF;
pub const GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92D0;
pub const GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92D1;
pub const GL_MAX_VERTEX_ATOMIC_COUNTERS: GLenum = 0x92D2;
pub const GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS: GLenum = 0x92D3;
pub const GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS: GLenum = 0x92D4;
pub const GL_MAX_GEOMETRY_ATOMIC_COUNTERS: GLenum = 0x92D5;
pub const GL_MAX_FRAGMENT_ATOMIC_COUNTERS: GLenum = 0x92D6;
pub const GL_MAX_COMBINED_ATOMIC_COUNTERS: GLenum = 0x92D7;
pub const GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE: GLenum = 0x92D8;
pub const GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS: GLenum = 0x92DC;
pub const GL_ACTIVE_ATOMIC_COUNTER_BUFFERS: GLenum = 0x92D9;
pub const GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX: GLenum = 0x92DA;
pub const GL_UNSIGNED_INT_ATOMIC_COUNTER: GLenum = 0x92DB;
pub const GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT: GLbitfield = 0x00000001;
pub const GL_ELEMENT_ARRAY_BARRIER_BIT: GLbitfield = 0x00000002;
pub const GL_UNIFORM_BARRIER_BIT: GLbitfield = 0x00000004;
pub const GL_TEXTURE_FETCH_BARRIER_BIT: GLbitfield = 0x00000008;
pub const GL_SHADER_IMAGE_ACCESS_BARRIER_BIT: GLbitfield = 0x00000020;
pub const GL_COMMAND_BARRIER_BIT: GLbitfield = 0x00000040;
pub const GL_PIXEL_BUFFER_BARRIER_BIT: GLbitfield = 0x00000080;
pub const GL_TEXTURE_UPDATE_BARRIER_BIT: GLbitfield = 0x00000100;
pub const GL_BUFFER_UPDATE_BARRIER_BIT: GLbitfield = 0x00000200;
pub const GL_FRAMEBUFFER_BARRIER_BIT: GLbitfield = 0x00000400;
pub const GL_TRANSFORM_FEEDBACK_BARRIER_BIT: GLbitfield = 0x00000800;
pub const GL_ATOMIC_COUNTER_BARRIER_BIT: GLbitfield = 0x00001000;
pub const GL_ALL_BARRIER_BITS: GLbitfield = 0xFFFFFFFF;
pub const GL_MAX_IMAGE_UNITS: GLenum = 0x8F38;
pub const GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS: GLenum = 0x8F39;
pub const GL_IMAGE_BINDING_NAME: GLenum = 0x8F3A;
pub const GL_IMAGE_BINDING_LEVEL: GLenum = 0x8F3B;
pub const GL_IMAGE_BINDING_LAYERED: GLenum = 0x8F3C;
pub const GL_IMAGE_BINDING_LAYER: GLenum = 0x8F3D;
pub const GL_IMAGE_BINDING_ACCESS: GLenum = 0x8F3E;
pub const GL_IMAGE_1D: GLenum = 0x904C;
pub const GL_IMAGE_2D: GLenum = 0x904D;
pub const GL_IMAGE_3D: GLenum = 0x904E;
pub const GL_IMAGE_2D_RECT: GLenum = 0x904F;
pub const GL_IMAGE_CUBE: GLenum = 0x9050;
pub const GL_IMAGE_BUFFER: GLenum = 0x9051;
pub const GL_IMAGE_1D_ARRAY: GLenum = 0x9052;
pub const GL_IMAGE_2D_ARRAY: GLenum = 0x9053;
pub const GL_IMAGE_CUBE_MAP_ARRAY: GLenum = 0x9054;
pub const GL_IMAGE_2D_MULTISAMPLE: GLenum = 0x9055;
pub const GL_IMAGE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9056;
pub const GL_INT_IMAGE_1D: GLenum = 0x9057;
pub const GL_INT_IMAGE_2D: GLenum = 0x9058;
pub const GL_INT_IMAGE_3D: GLenum = 0x9059;
pub const GL_INT_IMAGE_2D_RECT: GLenum = 0x905A;
pub const GL_INT_IMAGE_CUBE: GLenum = 0x905B;
pub const GL_INT_IMAGE_BUFFER: GLenum = 0x905C;
pub const GL_INT_IMAGE_1D_ARRAY: GLenum = 0x905D;
pub const GL_INT_IMAGE_2D_ARRAY: GLenum = 0x905E;
pub const GL_INT_IMAGE_CUBE_MAP_ARRAY: GLenum = 0x905F;
pub const GL_INT_IMAGE_2D_MULTISAMPLE: GLenum = 0x9060;
pub const GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY: GLenum = 0x9061;
pub const GL_UNSIGNED_INT_IMAGE_1D: GLenum = 0x9062;
pub const GL_UNSIGNED_INT_IMAGE_2D: GLenum = 0x9063;
pub const GL_UNSIGNED_INT_IMAGE_3D: GLenum = 0x9064;
pub const GL_UNSIGNED_INT_IMAGE_2D_RECT: GLenum = 0x9065;
pub const GL_UNSIGNED_INT_IMAGE_CUBE: GLenum = 0x9066;
pub const GL_UNSIGNED_INT_IMAGE_BUFFER: GLenum = 0x9067;
pub const GL_UNSIGNED_INT_IMAGE_1D_ARRAY: GLenum = 0x9068;
pub const GL_UNSIGNED_INT_IMAGE_2D_ARRAY: GLenum = 0x9069;
pub const GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY: GLenum = 0x906A;
pub const GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE: GLenum = 0x906B;
pub const GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY: GLenum = 0x906C;
pub const GL_MAX_IMAGE_SAMPLES: GLenum = 0x906D;
pub const GL_IMAGE_BINDING_FORMAT: GLenum = 0x906E;
pub const GL_IMAGE_FORMAT_COMPATIBILITY_TYPE: GLenum = 0x90C7;
pub const GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE: GLenum = 0x90C8;
pub const GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS: GLenum = 0x90C9;
pub const GL_MAX_VERTEX_IMAGE_UNIFORMS: GLenum = 0x90CA;
pub const GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS: GLenum = 0x90CB;
pub const GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS: GLenum = 0x90CC;
pub const GL_MAX_GEOMETRY_IMAGE_UNIFORMS: GLenum = 0x90CD;
pub const GL_MAX_FRAGMENT_IMAGE_UNIFORMS: GLenum = 0x90CE;
pub const GL_MAX_COMBINED_IMAGE_UNIFORMS: GLenum = 0x90CF;
pub const GL_COMPRESSED_RGBA_BPTC_UNORM: GLenum = 0x8E8C;
pub const GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM: GLenum = 0x8E8D;
pub const GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT: GLenum = 0x8E8E;
pub const GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT: GLenum = 0x8E8F;
pub const GL_TEXTURE_IMMUTABLE_FORMAT: GLenum = 0x912F;

pub trait GL_4_2 {
	fn glGetError(&self) -> GLenum;
	fn glDrawArraysInstancedBaseInstance(&self, mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei, baseinstance: GLuint) -> Result<()>;
	fn glDrawElementsInstancedBaseInstance(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei, baseinstance: GLuint) -> Result<()>;
	fn glDrawElementsInstancedBaseVertexBaseInstance(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei, basevertex: GLint, baseinstance: GLuint) -> Result<()>;
	fn glGetInternalformativ(&self, target: GLenum, internalformat: GLenum, pname: GLenum, count: GLsizei, params: *mut GLint) -> Result<()>;
	fn glGetActiveAtomicCounterBufferiv(&self, program: GLuint, bufferIndex: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glBindImageTexture(&self, unit: GLuint, texture: GLuint, level: GLint, layered: GLboolean, layer: GLint, access: GLenum, format: GLenum) -> Result<()>;
	fn glMemoryBarrier(&self, barriers: GLbitfield) -> Result<()>;
	fn glTexStorage1D(&self, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei) -> Result<()>;
	fn glTexStorage2D(&self, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()>;
	fn glTexStorage3D(&self, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei) -> Result<()>;
	fn glDrawTransformFeedbackInstanced(&self, mode: GLenum, id: GLuint, instancecount: GLsizei) -> Result<()>;
	fn glDrawTransformFeedbackStreamInstanced(&self, mode: GLenum, id: GLuint, stream: GLuint, instancecount: GLsizei) -> Result<()>;
}

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version42 {
	available: bool,
	geterror: PFNGLGETERRORPROC,
	drawarraysinstancedbaseinstance: PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC,
	drawelementsinstancedbaseinstance: PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC,
	drawelementsinstancedbasevertexbaseinstance: PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC,
	getinternalformativ: PFNGLGETINTERNALFORMATIVPROC,
	getactiveatomiccounterbufferiv: PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC,
	bindimagetexture: PFNGLBINDIMAGETEXTUREPROC,
	memorybarrier: PFNGLMEMORYBARRIERPROC,
	texstorage1d: PFNGLTEXSTORAGE1DPROC,
	texstorage2d: PFNGLTEXSTORAGE2DPROC,
	texstorage3d: PFNGLTEXSTORAGE3DPROC,
	drawtransformfeedbackinstanced: PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC,
	drawtransformfeedbackstreaminstanced: PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC,
}

impl GL_4_2 for Version42 {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	#[inline(always)]
	fn glDrawArraysInstancedBaseInstance(&self, mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei, baseinstance: GLuint) -> Result<()> {
		let ret = process_catch("glDrawArraysInstancedBaseInstance", catch_unwind(||(self.drawarraysinstancedbaseinstance)(mode, first, count, instancecount, baseinstance)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawArraysInstancedBaseInstance", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawElementsInstancedBaseInstance(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei, baseinstance: GLuint) -> Result<()> {
		let ret = process_catch("glDrawElementsInstancedBaseInstance", catch_unwind(||(self.drawelementsinstancedbaseinstance)(mode, count, type_, indices, instancecount, baseinstance)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsInstancedBaseInstance", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawElementsInstancedBaseVertexBaseInstance(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei, basevertex: GLint, baseinstance: GLuint) -> Result<()> {
		let ret = process_catch("glDrawElementsInstancedBaseVertexBaseInstance", catch_unwind(||(self.drawelementsinstancedbasevertexbaseinstance)(mode, count, type_, indices, instancecount, basevertex, baseinstance)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsInstancedBaseVertexBaseInstance", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetInternalformativ(&self, target: GLenum, internalformat: GLenum, pname: GLenum, count: GLsizei, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetInternalformativ", catch_unwind(||(self.getinternalformativ)(target, internalformat, pname, count, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetInternalformativ", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveAtomicCounterBufferiv(&self, program: GLuint, bufferIndex: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetActiveAtomicCounterBufferiv", catch_unwind(||(self.getactiveatomiccounterbufferiv)(program, bufferIndex, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveAtomicCounterBufferiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindImageTexture(&self, unit: GLuint, texture: GLuint, level: GLint, layered: GLboolean, layer: GLint, access: GLenum, format: GLenum) -> Result<()> {
		let ret = process_catch("glBindImageTexture", catch_unwind(||(self.bindimagetexture)(unit, texture, level, layered, layer, access, format)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindImageTexture", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMemoryBarrier(&self, barriers: GLbitfield) -> Result<()> {
		let ret = process_catch("glMemoryBarrier", catch_unwind(||(self.memorybarrier)(barriers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMemoryBarrier", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexStorage1D(&self, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei) -> Result<()> {
		let ret = process_catch("glTexStorage1D", catch_unwind(||(self.texstorage1d)(target, levels, internalformat, width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexStorage2D(&self, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glTexStorage2D", catch_unwind(||(self.texstorage2d)(target, levels, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexStorage3D(&self, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei) -> Result<()> {
		let ret = process_catch("glTexStorage3D", catch_unwind(||(self.texstorage3d)(target, levels, internalformat, width, height, depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawTransformFeedbackInstanced(&self, mode: GLenum, id: GLuint, instancecount: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawTransformFeedbackInstanced", catch_unwind(||(self.drawtransformfeedbackinstanced)(mode, id, instancecount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawTransformFeedbackInstanced", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawTransformFeedbackStreamInstanced(&self, mode: GLenum, id: GLuint, stream: GLuint, instancecount: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawTransformFeedbackStreamInstanced", catch_unwind(||(self.drawtransformfeedbackstreaminstanced)(mode, id, stream, instancecount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawTransformFeedbackStreamInstanced", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version42 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (4, 2, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			drawarraysinstancedbaseinstance: {let proc = get_proc_address("glDrawArraysInstancedBaseInstance"); if proc == null() {dummy_pfngldrawarraysinstancedbaseinstanceproc} else {unsafe{transmute(proc)}}},
			drawelementsinstancedbaseinstance: {let proc = get_proc_address("glDrawElementsInstancedBaseInstance"); if proc == null() {dummy_pfngldrawelementsinstancedbaseinstanceproc} else {unsafe{transmute(proc)}}},
			drawelementsinstancedbasevertexbaseinstance: {let proc = get_proc_address("glDrawElementsInstancedBaseVertexBaseInstance"); if proc == null() {dummy_pfngldrawelementsinstancedbasevertexbaseinstanceproc} else {unsafe{transmute(proc)}}},
			getinternalformativ: {let proc = get_proc_address("glGetInternalformativ"); if proc == null() {dummy_pfnglgetinternalformativproc} else {unsafe{transmute(proc)}}},
			getactiveatomiccounterbufferiv: {let proc = get_proc_address("glGetActiveAtomicCounterBufferiv"); if proc == null() {dummy_pfnglgetactiveatomiccounterbufferivproc} else {unsafe{transmute(proc)}}},
			bindimagetexture: {let proc = get_proc_address("glBindImageTexture"); if proc == null() {dummy_pfnglbindimagetextureproc} else {unsafe{transmute(proc)}}},
			memorybarrier: {let proc = get_proc_address("glMemoryBarrier"); if proc == null() {dummy_pfnglmemorybarrierproc} else {unsafe{transmute(proc)}}},
			texstorage1d: {let proc = get_proc_address("glTexStorage1D"); if proc == null() {dummy_pfngltexstorage1dproc} else {unsafe{transmute(proc)}}},
			texstorage2d: {let proc = get_proc_address("glTexStorage2D"); if proc == null() {dummy_pfngltexstorage2dproc} else {unsafe{transmute(proc)}}},
			texstorage3d: {let proc = get_proc_address("glTexStorage3D"); if proc == null() {dummy_pfngltexstorage3dproc} else {unsafe{transmute(proc)}}},
			drawtransformfeedbackinstanced: {let proc = get_proc_address("glDrawTransformFeedbackInstanced"); if proc == null() {dummy_pfngldrawtransformfeedbackinstancedproc} else {unsafe{transmute(proc)}}},
			drawtransformfeedbackstreaminstanced: {let proc = get_proc_address("glDrawTransformFeedbackStreamInstanced"); if proc == null() {dummy_pfngldrawtransformfeedbackstreaminstancedproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version42 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			drawarraysinstancedbaseinstance: dummy_pfngldrawarraysinstancedbaseinstanceproc,
			drawelementsinstancedbaseinstance: dummy_pfngldrawelementsinstancedbaseinstanceproc,
			drawelementsinstancedbasevertexbaseinstance: dummy_pfngldrawelementsinstancedbasevertexbaseinstanceproc,
			getinternalformativ: dummy_pfnglgetinternalformativproc,
			getactiveatomiccounterbufferiv: dummy_pfnglgetactiveatomiccounterbufferivproc,
			bindimagetexture: dummy_pfnglbindimagetextureproc,
			memorybarrier: dummy_pfnglmemorybarrierproc,
			texstorage1d: dummy_pfngltexstorage1dproc,
			texstorage2d: dummy_pfngltexstorage2dproc,
			texstorage3d: dummy_pfngltexstorage3dproc,
			drawtransformfeedbackinstanced: dummy_pfngldrawtransformfeedbackinstancedproc,
			drawtransformfeedbackstreaminstanced: dummy_pfngldrawtransformfeedbackstreaminstancedproc,
		}
	}
}
impl Debug for Version42 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version42")
			.field("available", &self.available)
			.field("drawarraysinstancedbaseinstance", unsafe{if transmute::<_, *const c_void>(self.drawarraysinstancedbaseinstance) == (dummy_pfngldrawarraysinstancedbaseinstanceproc as *const c_void) {&null::<PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC>()} else {&self.drawarraysinstancedbaseinstance}})
			.field("drawelementsinstancedbaseinstance", unsafe{if transmute::<_, *const c_void>(self.drawelementsinstancedbaseinstance) == (dummy_pfngldrawelementsinstancedbaseinstanceproc as *const c_void) {&null::<PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC>()} else {&self.drawelementsinstancedbaseinstance}})
			.field("drawelementsinstancedbasevertexbaseinstance", unsafe{if transmute::<_, *const c_void>(self.drawelementsinstancedbasevertexbaseinstance) == (dummy_pfngldrawelementsinstancedbasevertexbaseinstanceproc as *const c_void) {&null::<PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC>()} else {&self.drawelementsinstancedbasevertexbaseinstance}})
			.field("getinternalformativ", unsafe{if transmute::<_, *const c_void>(self.getinternalformativ) == (dummy_pfnglgetinternalformativproc as *const c_void) {&null::<PFNGLGETINTERNALFORMATIVPROC>()} else {&self.getinternalformativ}})
			.field("getactiveatomiccounterbufferiv", unsafe{if transmute::<_, *const c_void>(self.getactiveatomiccounterbufferiv) == (dummy_pfnglgetactiveatomiccounterbufferivproc as *const c_void) {&null::<PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC>()} else {&self.getactiveatomiccounterbufferiv}})
			.field("bindimagetexture", unsafe{if transmute::<_, *const c_void>(self.bindimagetexture) == (dummy_pfnglbindimagetextureproc as *const c_void) {&null::<PFNGLBINDIMAGETEXTUREPROC>()} else {&self.bindimagetexture}})
			.field("memorybarrier", unsafe{if transmute::<_, *const c_void>(self.memorybarrier) == (dummy_pfnglmemorybarrierproc as *const c_void) {&null::<PFNGLMEMORYBARRIERPROC>()} else {&self.memorybarrier}})
			.field("texstorage1d", unsafe{if transmute::<_, *const c_void>(self.texstorage1d) == (dummy_pfngltexstorage1dproc as *const c_void) {&null::<PFNGLTEXSTORAGE1DPROC>()} else {&self.texstorage1d}})
			.field("texstorage2d", unsafe{if transmute::<_, *const c_void>(self.texstorage2d) == (dummy_pfngltexstorage2dproc as *const c_void) {&null::<PFNGLTEXSTORAGE2DPROC>()} else {&self.texstorage2d}})
			.field("texstorage3d", unsafe{if transmute::<_, *const c_void>(self.texstorage3d) == (dummy_pfngltexstorage3dproc as *const c_void) {&null::<PFNGLTEXSTORAGE3DPROC>()} else {&self.texstorage3d}})
			.field("drawtransformfeedbackinstanced", unsafe{if transmute::<_, *const c_void>(self.drawtransformfeedbackinstanced) == (dummy_pfngldrawtransformfeedbackinstancedproc as *const c_void) {&null::<PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC>()} else {&self.drawtransformfeedbackinstanced}})
			.field("drawtransformfeedbackstreaminstanced", unsafe{if transmute::<_, *const c_void>(self.drawtransformfeedbackstreaminstanced) == (dummy_pfngldrawtransformfeedbackstreaminstancedproc as *const c_void) {&null::<PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC>()} else {&self.drawtransformfeedbackstreaminstanced}})
			.finish()
		} else {
			f.debug_struct("Version42")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}
type PFNGLCLEARBUFFERDATAPROC = extern "system" fn(GLenum, GLenum, GLenum, GLenum, *const c_void);
type PFNGLCLEARBUFFERSUBDATAPROC = extern "system" fn(GLenum, GLenum, GLintptr, GLsizeiptr, GLenum, GLenum, *const c_void);
type PFNGLDISPATCHCOMPUTEPROC = extern "system" fn(GLuint, GLuint, GLuint);
type PFNGLDISPATCHCOMPUTEINDIRECTPROC = extern "system" fn(GLintptr);
type PFNGLCOPYIMAGESUBDATAPROC = extern "system" fn(GLuint, GLenum, GLint, GLint, GLint, GLint, GLuint, GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei);
type PFNGLFRAMEBUFFERPARAMETERIPROC = extern "system" fn(GLenum, GLenum, GLint);
type PFNGLGETFRAMEBUFFERPARAMETERIVPROC = extern "system" fn(GLenum, GLenum, *mut GLint);
type PFNGLGETINTERNALFORMATI64VPROC = extern "system" fn(GLenum, GLenum, GLenum, GLsizei, *mut GLint64);
type PFNGLINVALIDATETEXSUBIMAGEPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei);
type PFNGLINVALIDATETEXIMAGEPROC = extern "system" fn(GLuint, GLint);
type PFNGLINVALIDATEBUFFERSUBDATAPROC = extern "system" fn(GLuint, GLintptr, GLsizeiptr);
type PFNGLINVALIDATEBUFFERDATAPROC = extern "system" fn(GLuint);
type PFNGLINVALIDATEFRAMEBUFFERPROC = extern "system" fn(GLenum, GLsizei, *const GLenum);
type PFNGLINVALIDATESUBFRAMEBUFFERPROC = extern "system" fn(GLenum, GLsizei, *const GLenum, GLint, GLint, GLsizei, GLsizei);
type PFNGLMULTIDRAWARRAYSINDIRECTPROC = extern "system" fn(GLenum, *const c_void, GLsizei, GLsizei);
type PFNGLMULTIDRAWELEMENTSINDIRECTPROC = extern "system" fn(GLenum, GLenum, *const c_void, GLsizei, GLsizei);
type PFNGLGETPROGRAMINTERFACEIVPROC = extern "system" fn(GLuint, GLenum, GLenum, *mut GLint);
type PFNGLGETPROGRAMRESOURCEINDEXPROC = extern "system" fn(GLuint, GLenum, *const GLchar) -> GLuint;
type PFNGLGETPROGRAMRESOURCENAMEPROC = extern "system" fn(GLuint, GLenum, GLuint, GLsizei, *mut GLsizei, *mut GLchar);
type PFNGLGETPROGRAMRESOURCEIVPROC = extern "system" fn(GLuint, GLenum, GLuint, GLsizei, *const GLenum, GLsizei, *mut GLsizei, *mut GLint);
type PFNGLGETPROGRAMRESOURCELOCATIONPROC = extern "system" fn(GLuint, GLenum, *const GLchar) -> GLint;
type PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC = extern "system" fn(GLuint, GLenum, *const GLchar) -> GLint;
type PFNGLSHADERSTORAGEBLOCKBINDINGPROC = extern "system" fn(GLuint, GLuint, GLuint);
type PFNGLTEXBUFFERRANGEPROC = extern "system" fn(GLenum, GLenum, GLuint, GLintptr, GLsizeiptr);
type PFNGLTEXSTORAGE2DMULTISAMPLEPROC = extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLboolean);
type PFNGLTEXSTORAGE3DMULTISAMPLEPROC = extern "system" fn(GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei, GLboolean);
type PFNGLTEXTUREVIEWPROC = extern "system" fn(GLuint, GLenum, GLuint, GLenum, GLuint, GLuint, GLuint, GLuint);
type PFNGLBINDVERTEXBUFFERPROC = extern "system" fn(GLuint, GLuint, GLintptr, GLsizei);
type PFNGLVERTEXATTRIBFORMATPROC = extern "system" fn(GLuint, GLint, GLenum, GLboolean, GLuint);
type PFNGLVERTEXATTRIBIFORMATPROC = extern "system" fn(GLuint, GLint, GLenum, GLuint);
type PFNGLVERTEXATTRIBLFORMATPROC = extern "system" fn(GLuint, GLint, GLenum, GLuint);
type PFNGLVERTEXATTRIBBINDINGPROC = extern "system" fn(GLuint, GLuint);
type PFNGLVERTEXBINDINGDIVISORPROC = extern "system" fn(GLuint, GLuint);
type PFNGLDEBUGMESSAGECONTROLPROC = extern "system" fn(GLenum, GLenum, GLenum, GLsizei, *const GLuint, GLboolean);
type PFNGLDEBUGMESSAGEINSERTPROC = extern "system" fn(GLenum, GLenum, GLuint, GLenum, GLsizei, *const GLchar);
type PFNGLDEBUGMESSAGECALLBACKPROC = extern "system" fn(GLDEBUGPROC, *const c_void);
type PFNGLGETDEBUGMESSAGELOGPROC = extern "system" fn(GLuint, GLsizei, *mut GLenum, *mut GLenum, *mut GLuint, *mut GLenum, *mut GLsizei, *mut GLchar) -> GLuint;
type PFNGLPUSHDEBUGGROUPPROC = extern "system" fn(GLenum, GLuint, GLsizei, *const GLchar);
type PFNGLPOPDEBUGGROUPPROC = extern "system" fn();
type PFNGLOBJECTLABELPROC = extern "system" fn(GLenum, GLuint, GLsizei, *const GLchar);
type PFNGLGETOBJECTLABELPROC = extern "system" fn(GLenum, GLuint, GLsizei, *mut GLsizei, *mut GLchar);
type PFNGLOBJECTPTRLABELPROC = extern "system" fn(*const c_void, GLsizei, *const GLchar);
type PFNGLGETOBJECTPTRLABELPROC = extern "system" fn(*const c_void, GLsizei, *mut GLsizei, *mut GLchar);
extern "system" fn dummy_pfnglclearbufferdataproc (_: GLenum, _: GLenum, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glClearBufferData()` is null.")
}
extern "system" fn dummy_pfnglclearbuffersubdataproc (_: GLenum, _: GLenum, _: GLintptr, _: GLsizeiptr, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glClearBufferSubData()` is null.")
}
extern "system" fn dummy_pfngldispatchcomputeproc (_: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glDispatchCompute()` is null.")
}
extern "system" fn dummy_pfngldispatchcomputeindirectproc (_: GLintptr) {
	panic!("OpenGL function pointer `glDispatchComputeIndirect()` is null.")
}
extern "system" fn dummy_pfnglcopyimagesubdataproc (_: GLuint, _: GLenum, _: GLint, _: GLint, _: GLint, _: GLint, _: GLuint, _: GLenum, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glCopyImageSubData()` is null.")
}
extern "system" fn dummy_pfnglframebufferparameteriproc (_: GLenum, _: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glFramebufferParameteri()` is null.")
}
extern "system" fn dummy_pfnglgetframebufferparameterivproc (_: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetFramebufferParameteriv()` is null.")
}
extern "system" fn dummy_pfnglgetinternalformati64vproc (_: GLenum, _: GLenum, _: GLenum, _: GLsizei, _: *mut GLint64) {
	panic!("OpenGL function pointer `glGetInternalformati64v()` is null.")
}
extern "system" fn dummy_pfnglinvalidatetexsubimageproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glInvalidateTexSubImage()` is null.")
}
extern "system" fn dummy_pfnglinvalidateteximageproc (_: GLuint, _: GLint) {
	panic!("OpenGL function pointer `glInvalidateTexImage()` is null.")
}
extern "system" fn dummy_pfnglinvalidatebuffersubdataproc (_: GLuint, _: GLintptr, _: GLsizeiptr) {
	panic!("OpenGL function pointer `glInvalidateBufferSubData()` is null.")
}
extern "system" fn dummy_pfnglinvalidatebufferdataproc (_: GLuint) {
	panic!("OpenGL function pointer `glInvalidateBufferData()` is null.")
}
extern "system" fn dummy_pfnglinvalidateframebufferproc (_: GLenum, _: GLsizei, _: *const GLenum) {
	panic!("OpenGL function pointer `glInvalidateFramebuffer()` is null.")
}
extern "system" fn dummy_pfnglinvalidatesubframebufferproc (_: GLenum, _: GLsizei, _: *const GLenum, _: GLint, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glInvalidateSubFramebuffer()` is null.")
}
extern "system" fn dummy_pfnglmultidrawarraysindirectproc (_: GLenum, _: *const c_void, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glMultiDrawArraysIndirect()` is null.")
}
extern "system" fn dummy_pfnglmultidrawelementsindirectproc (_: GLenum, _: GLenum, _: *const c_void, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glMultiDrawElementsIndirect()` is null.")
}
extern "system" fn dummy_pfnglgetprograminterfaceivproc (_: GLuint, _: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetProgramInterfaceiv()` is null.")
}
extern "system" fn dummy_pfnglgetprogramresourceindexproc (_: GLuint, _: GLenum, _: *const GLchar) -> GLuint {
	panic!("OpenGL function pointer `glGetProgramResourceIndex()` is null.")
}
extern "system" fn dummy_pfnglgetprogramresourcenameproc (_: GLuint, _: GLenum, _: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetProgramResourceName()` is null.")
}
extern "system" fn dummy_pfnglgetprogramresourceivproc (_: GLuint, _: GLenum, _: GLuint, _: GLsizei, _: *const GLenum, _: GLsizei, _: *mut GLsizei, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetProgramResourceiv()` is null.")
}
extern "system" fn dummy_pfnglgetprogramresourcelocationproc (_: GLuint, _: GLenum, _: *const GLchar) -> GLint {
	panic!("OpenGL function pointer `glGetProgramResourceLocation()` is null.")
}
extern "system" fn dummy_pfnglgetprogramresourcelocationindexproc (_: GLuint, _: GLenum, _: *const GLchar) -> GLint {
	panic!("OpenGL function pointer `glGetProgramResourceLocationIndex()` is null.")
}
extern "system" fn dummy_pfnglshaderstorageblockbindingproc (_: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glShaderStorageBlockBinding()` is null.")
}
extern "system" fn dummy_pfngltexbufferrangeproc (_: GLenum, _: GLenum, _: GLuint, _: GLintptr, _: GLsizeiptr) {
	panic!("OpenGL function pointer `glTexBufferRange()` is null.")
}
extern "system" fn dummy_pfngltexstorage2dmultisampleproc (_: GLenum, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei, _: GLboolean) {
	panic!("OpenGL function pointer `glTexStorage2DMultisample()` is null.")
}
extern "system" fn dummy_pfngltexstorage3dmultisampleproc (_: GLenum, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei, _: GLsizei, _: GLboolean) {
	panic!("OpenGL function pointer `glTexStorage3DMultisample()` is null.")
}
extern "system" fn dummy_pfngltextureviewproc (_: GLuint, _: GLenum, _: GLuint, _: GLenum, _: GLuint, _: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glTextureView()` is null.")
}
extern "system" fn dummy_pfnglbindvertexbufferproc (_: GLuint, _: GLuint, _: GLintptr, _: GLsizei) {
	panic!("OpenGL function pointer `glBindVertexBuffer()` is null.")
}
extern "system" fn dummy_pfnglvertexattribformatproc (_: GLuint, _: GLint, _: GLenum, _: GLboolean, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribFormat()` is null.")
}
extern "system" fn dummy_pfnglvertexattribiformatproc (_: GLuint, _: GLint, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribIFormat()` is null.")
}
extern "system" fn dummy_pfnglvertexattriblformatproc (_: GLuint, _: GLint, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribLFormat()` is null.")
}
extern "system" fn dummy_pfnglvertexattribbindingproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexAttribBinding()` is null.")
}
extern "system" fn dummy_pfnglvertexbindingdivisorproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexBindingDivisor()` is null.")
}
extern "system" fn dummy_pfngldebugmessagecontrolproc (_: GLenum, _: GLenum, _: GLenum, _: GLsizei, _: *const GLuint, _: GLboolean) {
	panic!("OpenGL function pointer `glDebugMessageControl()` is null.")
}
extern "system" fn dummy_pfngldebugmessageinsertproc (_: GLenum, _: GLenum, _: GLuint, _: GLenum, _: GLsizei, _: *const GLchar) {
	panic!("OpenGL function pointer `glDebugMessageInsert()` is null.")
}
extern "system" fn dummy_pfngldebugmessagecallbackproc (_: GLDEBUGPROC, _: *const c_void) {
	panic!("OpenGL function pointer `glDebugMessageCallback()` is null.")
}
extern "system" fn dummy_pfnglgetdebugmessagelogproc (_: GLuint, _: GLsizei, _: *mut GLenum, _: *mut GLenum, _: *mut GLuint, _: *mut GLenum, _: *mut GLsizei, _: *mut GLchar) -> GLuint {
	panic!("OpenGL function pointer `glGetDebugMessageLog()` is null.")
}
extern "system" fn dummy_pfnglpushdebuggroupproc (_: GLenum, _: GLuint, _: GLsizei, _: *const GLchar) {
	panic!("OpenGL function pointer `glPushDebugGroup()` is null.")
}
extern "system" fn dummy_pfnglpopdebuggroupproc () {
	panic!("OpenGL function pointer `glPopDebugGroup()` is null.")
}
extern "system" fn dummy_pfnglobjectlabelproc (_: GLenum, _: GLuint, _: GLsizei, _: *const GLchar) {
	panic!("OpenGL function pointer `glObjectLabel()` is null.")
}
extern "system" fn dummy_pfnglgetobjectlabelproc (_: GLenum, _: GLuint, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetObjectLabel()` is null.")
}
extern "system" fn dummy_pfnglobjectptrlabelproc (_: *const c_void, _: GLsizei, _: *const GLchar) {
	panic!("OpenGL function pointer `glObjectPtrLabel()` is null.")
}
extern "system" fn dummy_pfnglgetobjectptrlabelproc (_: *const c_void, _: GLsizei, _: *mut GLsizei, _: *mut GLchar) {
	panic!("OpenGL function pointer `glGetObjectPtrLabel()` is null.")
}
pub const GL_NUM_SHADING_LANGUAGE_VERSIONS: GLenum = 0x82E9;
pub const GL_VERTEX_ATTRIB_ARRAY_LONG: GLenum = 0x874E;
pub const GL_COMPRESSED_RGB8_ETC2: GLenum = 0x9274;
pub const GL_COMPRESSED_SRGB8_ETC2: GLenum = 0x9275;
pub const GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: GLenum = 0x9276;
pub const GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: GLenum = 0x9277;
pub const GL_COMPRESSED_RGBA8_ETC2_EAC: GLenum = 0x9278;
pub const GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: GLenum = 0x9279;
pub const GL_COMPRESSED_R11_EAC: GLenum = 0x9270;
pub const GL_COMPRESSED_SIGNED_R11_EAC: GLenum = 0x9271;
pub const GL_COMPRESSED_RG11_EAC: GLenum = 0x9272;
pub const GL_COMPRESSED_SIGNED_RG11_EAC: GLenum = 0x9273;
pub const GL_PRIMITIVE_RESTART_FIXED_INDEX: GLenum = 0x8D69;
pub const GL_ANY_SAMPLES_PASSED_CONSERVATIVE: GLenum = 0x8D6A;
pub const GL_MAX_ELEMENT_INDEX: GLenum = 0x8D6B;
pub const GL_COMPUTE_SHADER: GLenum = 0x91B9;
pub const GL_MAX_COMPUTE_UNIFORM_BLOCKS: GLenum = 0x91BB;
pub const GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS: GLenum = 0x91BC;
pub const GL_MAX_COMPUTE_IMAGE_UNIFORMS: GLenum = 0x91BD;
pub const GL_MAX_COMPUTE_SHARED_MEMORY_SIZE: GLenum = 0x8262;
pub const GL_MAX_COMPUTE_UNIFORM_COMPONENTS: GLenum = 0x8263;
pub const GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS: GLenum = 0x8264;
pub const GL_MAX_COMPUTE_ATOMIC_COUNTERS: GLenum = 0x8265;
pub const GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS: GLenum = 0x8266;
pub const GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS: GLenum = 0x90EB;
pub const GL_MAX_COMPUTE_WORK_GROUP_COUNT: GLenum = 0x91BE;
pub const GL_MAX_COMPUTE_WORK_GROUP_SIZE: GLenum = 0x91BF;
pub const GL_COMPUTE_WORK_GROUP_SIZE: GLenum = 0x8267;
pub const GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER: GLenum = 0x90EC;
pub const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER: GLenum = 0x90ED;
pub const GL_DISPATCH_INDIRECT_BUFFER: GLenum = 0x90EE;
pub const GL_DISPATCH_INDIRECT_BUFFER_BINDING: GLenum = 0x90EF;
pub const GL_COMPUTE_SHADER_BIT: GLbitfield = 0x00000020;
pub const GL_DEBUG_OUTPUT_SYNCHRONOUS: GLenum = 0x8242;
pub const GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH: GLenum = 0x8243;
pub const GL_DEBUG_CALLBACK_FUNCTION: GLenum = 0x8244;
pub const GL_DEBUG_CALLBACK_USER_PARAM: GLenum = 0x8245;
pub const GL_DEBUG_SOURCE_API: GLenum = 0x8246;
pub const GL_DEBUG_SOURCE_WINDOW_SYSTEM: GLenum = 0x8247;
pub const GL_DEBUG_SOURCE_SHADER_COMPILER: GLenum = 0x8248;
pub const GL_DEBUG_SOURCE_THIRD_PARTY: GLenum = 0x8249;
pub const GL_DEBUG_SOURCE_APPLICATION: GLenum = 0x824A;
pub const GL_DEBUG_SOURCE_OTHER: GLenum = 0x824B;
pub const GL_DEBUG_TYPE_ERROR: GLenum = 0x824C;
pub const GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: GLenum = 0x824D;
pub const GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: GLenum = 0x824E;
pub const GL_DEBUG_TYPE_PORTABILITY: GLenum = 0x824F;
pub const GL_DEBUG_TYPE_PERFORMANCE: GLenum = 0x8250;
pub const GL_DEBUG_TYPE_OTHER: GLenum = 0x8251;
pub const GL_MAX_DEBUG_MESSAGE_LENGTH: GLenum = 0x9143;
pub const GL_MAX_DEBUG_LOGGED_MESSAGES: GLenum = 0x9144;
pub const GL_DEBUG_LOGGED_MESSAGES: GLenum = 0x9145;
pub const GL_DEBUG_SEVERITY_HIGH: GLenum = 0x9146;
pub const GL_DEBUG_SEVERITY_MEDIUM: GLenum = 0x9147;
pub const GL_DEBUG_SEVERITY_LOW: GLenum = 0x9148;
pub const GL_DEBUG_TYPE_MARKER: GLenum = 0x8268;
pub const GL_DEBUG_TYPE_PUSH_GROUP: GLenum = 0x8269;
pub const GL_DEBUG_TYPE_POP_GROUP: GLenum = 0x826A;
pub const GL_DEBUG_SEVERITY_NOTIFICATION: GLenum = 0x826B;
pub const GL_MAX_DEBUG_GROUP_STACK_DEPTH: GLenum = 0x826C;
pub const GL_DEBUG_GROUP_STACK_DEPTH: GLenum = 0x826D;
pub const GL_BUFFER: GLenum = 0x82E0;
pub const GL_SHADER: GLenum = 0x82E1;
pub const GL_PROGRAM: GLenum = 0x82E2;
pub const GL_QUERY: GLenum = 0x82E3;
pub const GL_PROGRAM_PIPELINE: GLenum = 0x82E4;
pub const GL_SAMPLER: GLenum = 0x82E6;
pub const GL_MAX_LABEL_LENGTH: GLenum = 0x82E8;
pub const GL_DEBUG_OUTPUT: GLenum = 0x92E0;
pub const GL_CONTEXT_FLAG_DEBUG_BIT: GLbitfield = 0x00000002;
pub const GL_MAX_UNIFORM_LOCATIONS: GLenum = 0x826E;
pub const GL_FRAMEBUFFER_DEFAULT_WIDTH: GLenum = 0x9310;
pub const GL_FRAMEBUFFER_DEFAULT_HEIGHT: GLenum = 0x9311;
pub const GL_FRAMEBUFFER_DEFAULT_LAYERS: GLenum = 0x9312;
pub const GL_FRAMEBUFFER_DEFAULT_SAMPLES: GLenum = 0x9313;
pub const GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS: GLenum = 0x9314;
pub const GL_MAX_FRAMEBUFFER_WIDTH: GLenum = 0x9315;
pub const GL_MAX_FRAMEBUFFER_HEIGHT: GLenum = 0x9316;
pub const GL_MAX_FRAMEBUFFER_LAYERS: GLenum = 0x9317;
pub const GL_MAX_FRAMEBUFFER_SAMPLES: GLenum = 0x9318;
pub const GL_INTERNALFORMAT_SUPPORTED: GLenum = 0x826F;
pub const GL_INTERNALFORMAT_PREFERRED: GLenum = 0x8270;
pub const GL_INTERNALFORMAT_RED_SIZE: GLenum = 0x8271;
pub const GL_INTERNALFORMAT_GREEN_SIZE: GLenum = 0x8272;
pub const GL_INTERNALFORMAT_BLUE_SIZE: GLenum = 0x8273;
pub const GL_INTERNALFORMAT_ALPHA_SIZE: GLenum = 0x8274;
pub const GL_INTERNALFORMAT_DEPTH_SIZE: GLenum = 0x8275;
pub const GL_INTERNALFORMAT_STENCIL_SIZE: GLenum = 0x8276;
pub const GL_INTERNALFORMAT_SHARED_SIZE: GLenum = 0x8277;
pub const GL_INTERNALFORMAT_RED_TYPE: GLenum = 0x8278;
pub const GL_INTERNALFORMAT_GREEN_TYPE: GLenum = 0x8279;
pub const GL_INTERNALFORMAT_BLUE_TYPE: GLenum = 0x827A;
pub const GL_INTERNALFORMAT_ALPHA_TYPE: GLenum = 0x827B;
pub const GL_INTERNALFORMAT_DEPTH_TYPE: GLenum = 0x827C;
pub const GL_INTERNALFORMAT_STENCIL_TYPE: GLenum = 0x827D;
pub const GL_MAX_WIDTH: GLenum = 0x827E;
pub const GL_MAX_HEIGHT: GLenum = 0x827F;
pub const GL_MAX_DEPTH: GLenum = 0x8280;
pub const GL_MAX_LAYERS: GLenum = 0x8281;
pub const GL_MAX_COMBINED_DIMENSIONS: GLenum = 0x8282;
pub const GL_COLOR_COMPONENTS: GLenum = 0x8283;
pub const GL_DEPTH_COMPONENTS: GLenum = 0x8284;
pub const GL_STENCIL_COMPONENTS: GLenum = 0x8285;
pub const GL_COLOR_RENDERABLE: GLenum = 0x8286;
pub const GL_DEPTH_RENDERABLE: GLenum = 0x8287;
pub const GL_STENCIL_RENDERABLE: GLenum = 0x8288;
pub const GL_FRAMEBUFFER_RENDERABLE: GLenum = 0x8289;
pub const GL_FRAMEBUFFER_RENDERABLE_LAYERED: GLenum = 0x828A;
pub const GL_FRAMEBUFFER_BLEND: GLenum = 0x828B;
pub const GL_READ_PIXELS: GLenum = 0x828C;
pub const GL_READ_PIXELS_FORMAT: GLenum = 0x828D;
pub const GL_READ_PIXELS_TYPE: GLenum = 0x828E;
pub const GL_TEXTURE_IMAGE_FORMAT: GLenum = 0x828F;
pub const GL_TEXTURE_IMAGE_TYPE: GLenum = 0x8290;
pub const GL_GET_TEXTURE_IMAGE_FORMAT: GLenum = 0x8291;
pub const GL_GET_TEXTURE_IMAGE_TYPE: GLenum = 0x8292;
pub const GL_MIPMAP: GLenum = 0x8293;
pub const GL_MANUAL_GENERATE_MIPMAP: GLenum = 0x8294;
pub const GL_AUTO_GENERATE_MIPMAP: GLenum = 0x8295;
pub const GL_COLOR_ENCODING: GLenum = 0x8296;
pub const GL_SRGB_READ: GLenum = 0x8297;
pub const GL_SRGB_WRITE: GLenum = 0x8298;
pub const GL_FILTER: GLenum = 0x829A;
pub const GL_VERTEX_TEXTURE: GLenum = 0x829B;
pub const GL_TESS_CONTROL_TEXTURE: GLenum = 0x829C;
pub const GL_TESS_EVALUATION_TEXTURE: GLenum = 0x829D;
pub const GL_GEOMETRY_TEXTURE: GLenum = 0x829E;
pub const GL_FRAGMENT_TEXTURE: GLenum = 0x829F;
pub const GL_COMPUTE_TEXTURE: GLenum = 0x82A0;
pub const GL_TEXTURE_SHADOW: GLenum = 0x82A1;
pub const GL_TEXTURE_GATHER: GLenum = 0x82A2;
pub const GL_TEXTURE_GATHER_SHADOW: GLenum = 0x82A3;
pub const GL_SHADER_IMAGE_LOAD: GLenum = 0x82A4;
pub const GL_SHADER_IMAGE_STORE: GLenum = 0x82A5;
pub const GL_SHADER_IMAGE_ATOMIC: GLenum = 0x82A6;
pub const GL_IMAGE_TEXEL_SIZE: GLenum = 0x82A7;
pub const GL_IMAGE_COMPATIBILITY_CLASS: GLenum = 0x82A8;
pub const GL_IMAGE_PIXEL_FORMAT: GLenum = 0x82A9;
pub const GL_IMAGE_PIXEL_TYPE: GLenum = 0x82AA;
pub const GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST: GLenum = 0x82AC;
pub const GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST: GLenum = 0x82AD;
pub const GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE: GLenum = 0x82AE;
pub const GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE: GLenum = 0x82AF;
pub const GL_TEXTURE_COMPRESSED_BLOCK_WIDTH: GLenum = 0x82B1;
pub const GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT: GLenum = 0x82B2;
pub const GL_TEXTURE_COMPRESSED_BLOCK_SIZE: GLenum = 0x82B3;
pub const GL_CLEAR_BUFFER: GLenum = 0x82B4;
pub const GL_TEXTURE_VIEW: GLenum = 0x82B5;
pub const GL_VIEW_COMPATIBILITY_CLASS: GLenum = 0x82B6;
pub const GL_FULL_SUPPORT: GLenum = 0x82B7;
pub const GL_CAVEAT_SUPPORT: GLenum = 0x82B8;
pub const GL_IMAGE_CLASS_4_X_32: GLenum = 0x82B9;
pub const GL_IMAGE_CLASS_2_X_32: GLenum = 0x82BA;
pub const GL_IMAGE_CLASS_1_X_32: GLenum = 0x82BB;
pub const GL_IMAGE_CLASS_4_X_16: GLenum = 0x82BC;
pub const GL_IMAGE_CLASS_2_X_16: GLenum = 0x82BD;
pub const GL_IMAGE_CLASS_1_X_16: GLenum = 0x82BE;
pub const GL_IMAGE_CLASS_4_X_8: GLenum = 0x82BF;
pub const GL_IMAGE_CLASS_2_X_8: GLenum = 0x82C0;
pub const GL_IMAGE_CLASS_1_X_8: GLenum = 0x82C1;
pub const GL_IMAGE_CLASS_11_11_10: GLenum = 0x82C2;
pub const GL_IMAGE_CLASS_10_10_10_2: GLenum = 0x82C3;
pub const GL_VIEW_CLASS_128_BITS: GLenum = 0x82C4;
pub const GL_VIEW_CLASS_96_BITS: GLenum = 0x82C5;
pub const GL_VIEW_CLASS_64_BITS: GLenum = 0x82C6;
pub const GL_VIEW_CLASS_48_BITS: GLenum = 0x82C7;
pub const GL_VIEW_CLASS_32_BITS: GLenum = 0x82C8;
pub const GL_VIEW_CLASS_24_BITS: GLenum = 0x82C9;
pub const GL_VIEW_CLASS_16_BITS: GLenum = 0x82CA;
pub const GL_VIEW_CLASS_8_BITS: GLenum = 0x82CB;
pub const GL_VIEW_CLASS_S3TC_DXT1_RGB: GLenum = 0x82CC;
pub const GL_VIEW_CLASS_S3TC_DXT1_RGBA: GLenum = 0x82CD;
pub const GL_VIEW_CLASS_S3TC_DXT3_RGBA: GLenum = 0x82CE;
pub const GL_VIEW_CLASS_S3TC_DXT5_RGBA: GLenum = 0x82CF;
pub const GL_VIEW_CLASS_RGTC1_RED: GLenum = 0x82D0;
pub const GL_VIEW_CLASS_RGTC2_RG: GLenum = 0x82D1;
pub const GL_VIEW_CLASS_BPTC_UNORM: GLenum = 0x82D2;
pub const GL_VIEW_CLASS_BPTC_FLOAT: GLenum = 0x82D3;
pub const GL_UNIFORM: GLenum = 0x92E1;
pub const GL_UNIFORM_BLOCK: GLenum = 0x92E2;
pub const GL_PROGRAM_INPUT: GLenum = 0x92E3;
pub const GL_PROGRAM_OUTPUT: GLenum = 0x92E4;
pub const GL_BUFFER_VARIABLE: GLenum = 0x92E5;
pub const GL_SHADER_STORAGE_BLOCK: GLenum = 0x92E6;
pub const GL_VERTEX_SUBROUTINE: GLenum = 0x92E8;
pub const GL_TESS_CONTROL_SUBROUTINE: GLenum = 0x92E9;
pub const GL_TESS_EVALUATION_SUBROUTINE: GLenum = 0x92EA;
pub const GL_GEOMETRY_SUBROUTINE: GLenum = 0x92EB;
pub const GL_FRAGMENT_SUBROUTINE: GLenum = 0x92EC;
pub const GL_COMPUTE_SUBROUTINE: GLenum = 0x92ED;
pub const GL_VERTEX_SUBROUTINE_UNIFORM: GLenum = 0x92EE;
pub const GL_TESS_CONTROL_SUBROUTINE_UNIFORM: GLenum = 0x92EF;
pub const GL_TESS_EVALUATION_SUBROUTINE_UNIFORM: GLenum = 0x92F0;
pub const GL_GEOMETRY_SUBROUTINE_UNIFORM: GLenum = 0x92F1;
pub const GL_FRAGMENT_SUBROUTINE_UNIFORM: GLenum = 0x92F2;
pub const GL_COMPUTE_SUBROUTINE_UNIFORM: GLenum = 0x92F3;
pub const GL_TRANSFORM_FEEDBACK_VARYING: GLenum = 0x92F4;
pub const GL_ACTIVE_RESOURCES: GLenum = 0x92F5;
pub const GL_MAX_NAME_LENGTH: GLenum = 0x92F6;
pub const GL_MAX_NUM_ACTIVE_VARIABLES: GLenum = 0x92F7;
pub const GL_MAX_NUM_COMPATIBLE_SUBROUTINES: GLenum = 0x92F8;
pub const GL_NAME_LENGTH: GLenum = 0x92F9;
pub const GL_TYPE: GLenum = 0x92FA;
pub const GL_ARRAY_SIZE: GLenum = 0x92FB;
pub const GL_OFFSET: GLenum = 0x92FC;
pub const GL_BLOCK_INDEX: GLenum = 0x92FD;
pub const GL_ARRAY_STRIDE: GLenum = 0x92FE;
pub const GL_MATRIX_STRIDE: GLenum = 0x92FF;
pub const GL_IS_ROW_MAJOR: GLenum = 0x9300;
pub const GL_ATOMIC_COUNTER_BUFFER_INDEX: GLenum = 0x9301;
pub const GL_BUFFER_BINDING: GLenum = 0x9302;
pub const GL_BUFFER_DATA_SIZE: GLenum = 0x9303;
pub const GL_NUM_ACTIVE_VARIABLES: GLenum = 0x9304;
pub const GL_ACTIVE_VARIABLES: GLenum = 0x9305;
pub const GL_REFERENCED_BY_VERTEX_SHADER: GLenum = 0x9306;
pub const GL_REFERENCED_BY_TESS_CONTROL_SHADER: GLenum = 0x9307;
pub const GL_REFERENCED_BY_TESS_EVALUATION_SHADER: GLenum = 0x9308;
pub const GL_REFERENCED_BY_GEOMETRY_SHADER: GLenum = 0x9309;
pub const GL_REFERENCED_BY_FRAGMENT_SHADER: GLenum = 0x930A;
pub const GL_REFERENCED_BY_COMPUTE_SHADER: GLenum = 0x930B;
pub const GL_TOP_LEVEL_ARRAY_SIZE: GLenum = 0x930C;
pub const GL_TOP_LEVEL_ARRAY_STRIDE: GLenum = 0x930D;
pub const GL_LOCATION: GLenum = 0x930E;
pub const GL_LOCATION_INDEX: GLenum = 0x930F;
pub const GL_IS_PER_PATCH: GLenum = 0x92E7;
pub const GL_SHADER_STORAGE_BUFFER: GLenum = 0x90D2;
pub const GL_SHADER_STORAGE_BUFFER_BINDING: GLenum = 0x90D3;
pub const GL_SHADER_STORAGE_BUFFER_START: GLenum = 0x90D4;
pub const GL_SHADER_STORAGE_BUFFER_SIZE: GLenum = 0x90D5;
pub const GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS: GLenum = 0x90D6;
pub const GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS: GLenum = 0x90D7;
pub const GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS: GLenum = 0x90D8;
pub const GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS: GLenum = 0x90D9;
pub const GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS: GLenum = 0x90DA;
pub const GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS: GLenum = 0x90DB;
pub const GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS: GLenum = 0x90DC;
pub const GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS: GLenum = 0x90DD;
pub const GL_MAX_SHADER_STORAGE_BLOCK_SIZE: GLenum = 0x90DE;
pub const GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT: GLenum = 0x90DF;
pub const GL_SHADER_STORAGE_BARRIER_BIT: GLbitfield = 0x00002000;
pub const GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES: GLenum = 0x8F39;
pub const GL_DEPTH_STENCIL_TEXTURE_MODE: GLenum = 0x90EA;
pub const GL_TEXTURE_BUFFER_OFFSET: GLenum = 0x919D;
pub const GL_TEXTURE_BUFFER_SIZE: GLenum = 0x919E;
pub const GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT: GLenum = 0x919F;
pub const GL_TEXTURE_VIEW_MIN_LEVEL: GLenum = 0x82DB;
pub const GL_TEXTURE_VIEW_NUM_LEVELS: GLenum = 0x82DC;
pub const GL_TEXTURE_VIEW_MIN_LAYER: GLenum = 0x82DD;
pub const GL_TEXTURE_VIEW_NUM_LAYERS: GLenum = 0x82DE;
pub const GL_TEXTURE_IMMUTABLE_LEVELS: GLenum = 0x82DF;
pub const GL_VERTEX_ATTRIB_BINDING: GLenum = 0x82D4;
pub const GL_VERTEX_ATTRIB_RELATIVE_OFFSET: GLenum = 0x82D5;
pub const GL_VERTEX_BINDING_DIVISOR: GLenum = 0x82D6;
pub const GL_VERTEX_BINDING_OFFSET: GLenum = 0x82D7;
pub const GL_VERTEX_BINDING_STRIDE: GLenum = 0x82D8;
pub const GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET: GLenum = 0x82D9;
pub const GL_MAX_VERTEX_ATTRIB_BINDINGS: GLenum = 0x82DA;
pub const GL_VERTEX_BINDING_BUFFER: GLenum = 0x8F4F;
pub const GL_DISPLAY_LIST: GLenum = 0x82E7;

pub trait GL_4_3 {
	fn glGetError(&self) -> GLenum;
	fn glClearBufferData(&self, target: GLenum, internalformat: GLenum, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()>;
	fn glClearBufferSubData(&self, target: GLenum, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()>;
	fn glDispatchCompute(&self, num_groups_x: GLuint, num_groups_y: GLuint, num_groups_z: GLuint) -> Result<()>;
	fn glDispatchComputeIndirect(&self, indirect: GLintptr) -> Result<()>;
	fn glCopyImageSubData(&self, srcName: GLuint, srcTarget: GLenum, srcLevel: GLint, srcX: GLint, srcY: GLint, srcZ: GLint, dstName: GLuint, dstTarget: GLenum, dstLevel: GLint, dstX: GLint, dstY: GLint, dstZ: GLint, srcWidth: GLsizei, srcHeight: GLsizei, srcDepth: GLsizei) -> Result<()>;
	fn glFramebufferParameteri(&self, target: GLenum, pname: GLenum, param: GLint) -> Result<()>;
	fn glGetFramebufferParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glGetInternalformati64v(&self, target: GLenum, internalformat: GLenum, pname: GLenum, count: GLsizei, params: *mut GLint64) -> Result<()>;
	fn glInvalidateTexSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei) -> Result<()>;
	fn glInvalidateTexImage(&self, texture: GLuint, level: GLint) -> Result<()>;
	fn glInvalidateBufferSubData(&self, buffer: GLuint, offset: GLintptr, length: GLsizeiptr) -> Result<()>;
	fn glInvalidateBufferData(&self, buffer: GLuint) -> Result<()>;
	fn glInvalidateFramebuffer(&self, target: GLenum, numAttachments: GLsizei, attachments: *const GLenum) -> Result<()>;
	fn glInvalidateSubFramebuffer(&self, target: GLenum, numAttachments: GLsizei, attachments: *const GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()>;
	fn glMultiDrawArraysIndirect(&self, mode: GLenum, indirect: *const c_void, drawcount: GLsizei, stride: GLsizei) -> Result<()>;
	fn glMultiDrawElementsIndirect(&self, mode: GLenum, type_: GLenum, indirect: *const c_void, drawcount: GLsizei, stride: GLsizei) -> Result<()>;
	fn glGetProgramInterfaceiv(&self, program: GLuint, programInterface: GLenum, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glGetProgramResourceIndex(&self, program: GLuint, programInterface: GLenum, name: *const GLchar) -> Result<GLuint>;
	fn glGetProgramResourceName(&self, program: GLuint, programInterface: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar) -> Result<()>;
	fn glGetProgramResourceiv(&self, program: GLuint, programInterface: GLenum, index: GLuint, propCount: GLsizei, props: *const GLenum, count: GLsizei, length: *mut GLsizei, params: *mut GLint) -> Result<()>;
	fn glGetProgramResourceLocation(&self, program: GLuint, programInterface: GLenum, name: *const GLchar) -> Result<GLint>;
	fn glGetProgramResourceLocationIndex(&self, program: GLuint, programInterface: GLenum, name: *const GLchar) -> Result<GLint>;
	fn glShaderStorageBlockBinding(&self, program: GLuint, storageBlockIndex: GLuint, storageBlockBinding: GLuint) -> Result<()>;
	fn glTexBufferRange(&self, target: GLenum, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()>;
	fn glTexStorage2DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean) -> Result<()>;
	fn glTexStorage3DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean) -> Result<()>;
	fn glTextureView(&self, texture: GLuint, target: GLenum, origtexture: GLuint, internalformat: GLenum, minlevel: GLuint, numlevels: GLuint, minlayer: GLuint, numlayers: GLuint) -> Result<()>;
	fn glBindVertexBuffer(&self, bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei) -> Result<()>;
	fn glVertexAttribFormat(&self, attribindex: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, relativeoffset: GLuint) -> Result<()>;
	fn glVertexAttribIFormat(&self, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()>;
	fn glVertexAttribLFormat(&self, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()>;
	fn glVertexAttribBinding(&self, attribindex: GLuint, bindingindex: GLuint) -> Result<()>;
	fn glVertexBindingDivisor(&self, bindingindex: GLuint, divisor: GLuint) -> Result<()>;
	fn glDebugMessageControl(&self, source: GLenum, type_: GLenum, severity: GLenum, count: GLsizei, ids: *const GLuint, enabled: GLboolean) -> Result<()>;
	fn glDebugMessageInsert(&self, source: GLenum, type_: GLenum, id: GLuint, severity: GLenum, length: GLsizei, buf: *const GLchar) -> Result<()>;
	fn glDebugMessageCallback(&self, callback: GLDEBUGPROC, userParam: *const c_void) -> Result<()>;
	fn glGetDebugMessageLog(&self, count: GLuint, bufSize: GLsizei, sources: *mut GLenum, types: *mut GLenum, ids: *mut GLuint, severities: *mut GLenum, lengths: *mut GLsizei, messageLog: *mut GLchar) -> Result<GLuint>;
	fn glPushDebugGroup(&self, source: GLenum, id: GLuint, length: GLsizei, message: *const GLchar) -> Result<()>;
	fn glPopDebugGroup(&self) -> Result<()>;
	fn glObjectLabel(&self, identifier: GLenum, name: GLuint, length: GLsizei, label: *const GLchar) -> Result<()>;
	fn glGetObjectLabel(&self, identifier: GLenum, name: GLuint, bufSize: GLsizei, length: *mut GLsizei, label: *mut GLchar) -> Result<()>;
	fn glObjectPtrLabel(&self, ptr: *const c_void, length: GLsizei, label: *const GLchar) -> Result<()>;
	fn glGetObjectPtrLabel(&self, ptr: *const c_void, bufSize: GLsizei, length: *mut GLsizei, label: *mut GLchar) -> Result<()>;
}

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version43 {
	available: bool,
	geterror: PFNGLGETERRORPROC,
	clearbufferdata: PFNGLCLEARBUFFERDATAPROC,
	clearbuffersubdata: PFNGLCLEARBUFFERSUBDATAPROC,
	dispatchcompute: PFNGLDISPATCHCOMPUTEPROC,
	dispatchcomputeindirect: PFNGLDISPATCHCOMPUTEINDIRECTPROC,
	copyimagesubdata: PFNGLCOPYIMAGESUBDATAPROC,
	framebufferparameteri: PFNGLFRAMEBUFFERPARAMETERIPROC,
	getframebufferparameteriv: PFNGLGETFRAMEBUFFERPARAMETERIVPROC,
	getinternalformati64v: PFNGLGETINTERNALFORMATI64VPROC,
	invalidatetexsubimage: PFNGLINVALIDATETEXSUBIMAGEPROC,
	invalidateteximage: PFNGLINVALIDATETEXIMAGEPROC,
	invalidatebuffersubdata: PFNGLINVALIDATEBUFFERSUBDATAPROC,
	invalidatebufferdata: PFNGLINVALIDATEBUFFERDATAPROC,
	invalidateframebuffer: PFNGLINVALIDATEFRAMEBUFFERPROC,
	invalidatesubframebuffer: PFNGLINVALIDATESUBFRAMEBUFFERPROC,
	multidrawarraysindirect: PFNGLMULTIDRAWARRAYSINDIRECTPROC,
	multidrawelementsindirect: PFNGLMULTIDRAWELEMENTSINDIRECTPROC,
	getprograminterfaceiv: PFNGLGETPROGRAMINTERFACEIVPROC,
	getprogramresourceindex: PFNGLGETPROGRAMRESOURCEINDEXPROC,
	getprogramresourcename: PFNGLGETPROGRAMRESOURCENAMEPROC,
	getprogramresourceiv: PFNGLGETPROGRAMRESOURCEIVPROC,
	getprogramresourcelocation: PFNGLGETPROGRAMRESOURCELOCATIONPROC,
	getprogramresourcelocationindex: PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC,
	shaderstorageblockbinding: PFNGLSHADERSTORAGEBLOCKBINDINGPROC,
	texbufferrange: PFNGLTEXBUFFERRANGEPROC,
	texstorage2dmultisample: PFNGLTEXSTORAGE2DMULTISAMPLEPROC,
	texstorage3dmultisample: PFNGLTEXSTORAGE3DMULTISAMPLEPROC,
	textureview: PFNGLTEXTUREVIEWPROC,
	bindvertexbuffer: PFNGLBINDVERTEXBUFFERPROC,
	vertexattribformat: PFNGLVERTEXATTRIBFORMATPROC,
	vertexattribiformat: PFNGLVERTEXATTRIBIFORMATPROC,
	vertexattriblformat: PFNGLVERTEXATTRIBLFORMATPROC,
	vertexattribbinding: PFNGLVERTEXATTRIBBINDINGPROC,
	vertexbindingdivisor: PFNGLVERTEXBINDINGDIVISORPROC,
	debugmessagecontrol: PFNGLDEBUGMESSAGECONTROLPROC,
	debugmessageinsert: PFNGLDEBUGMESSAGEINSERTPROC,
	debugmessagecallback: PFNGLDEBUGMESSAGECALLBACKPROC,
	getdebugmessagelog: PFNGLGETDEBUGMESSAGELOGPROC,
	pushdebuggroup: PFNGLPUSHDEBUGGROUPPROC,
	popdebuggroup: PFNGLPOPDEBUGGROUPPROC,
	objectlabel: PFNGLOBJECTLABELPROC,
	getobjectlabel: PFNGLGETOBJECTLABELPROC,
	objectptrlabel: PFNGLOBJECTPTRLABELPROC,
	getobjectptrlabel: PFNGLGETOBJECTPTRLABELPROC,
}

impl GL_4_3 for Version43 {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	#[inline(always)]
	fn glClearBufferData(&self, target: GLenum, internalformat: GLenum, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearBufferData", catch_unwind(||(self.clearbufferdata)(target, internalformat, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearBufferSubData(&self, target: GLenum, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearBufferSubData", catch_unwind(||(self.clearbuffersubdata)(target, internalformat, offset, size, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDispatchCompute(&self, num_groups_x: GLuint, num_groups_y: GLuint, num_groups_z: GLuint) -> Result<()> {
		let ret = process_catch("glDispatchCompute", catch_unwind(||(self.dispatchcompute)(num_groups_x, num_groups_y, num_groups_z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDispatchCompute", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDispatchComputeIndirect(&self, indirect: GLintptr) -> Result<()> {
		let ret = process_catch("glDispatchComputeIndirect", catch_unwind(||(self.dispatchcomputeindirect)(indirect)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDispatchComputeIndirect", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyImageSubData(&self, srcName: GLuint, srcTarget: GLenum, srcLevel: GLint, srcX: GLint, srcY: GLint, srcZ: GLint, dstName: GLuint, dstTarget: GLenum, dstLevel: GLint, dstX: GLint, dstY: GLint, dstZ: GLint, srcWidth: GLsizei, srcHeight: GLsizei, srcDepth: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyImageSubData", catch_unwind(||(self.copyimagesubdata)(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyImageSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFramebufferParameteri(&self, target: GLenum, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferParameteri", catch_unwind(||(self.framebufferparameteri)(target, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferParameteri", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetFramebufferParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetFramebufferParameteriv", catch_unwind(||(self.getframebufferparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFramebufferParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetInternalformati64v(&self, target: GLenum, internalformat: GLenum, pname: GLenum, count: GLsizei, params: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetInternalformati64v", catch_unwind(||(self.getinternalformati64v)(target, internalformat, pname, count, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetInternalformati64v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glInvalidateTexSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei) -> Result<()> {
		let ret = process_catch("glInvalidateTexSubImage", catch_unwind(||(self.invalidatetexsubimage)(texture, level, xoffset, yoffset, zoffset, width, height, depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateTexSubImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glInvalidateTexImage(&self, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glInvalidateTexImage", catch_unwind(||(self.invalidateteximage)(texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateTexImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glInvalidateBufferSubData(&self, buffer: GLuint, offset: GLintptr, length: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glInvalidateBufferSubData", catch_unwind(||(self.invalidatebuffersubdata)(buffer, offset, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateBufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glInvalidateBufferData(&self, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glInvalidateBufferData", catch_unwind(||(self.invalidatebufferdata)(buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateBufferData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glInvalidateFramebuffer(&self, target: GLenum, numAttachments: GLsizei, attachments: *const GLenum) -> Result<()> {
		let ret = process_catch("glInvalidateFramebuffer", catch_unwind(||(self.invalidateframebuffer)(target, numAttachments, attachments)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateFramebuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glInvalidateSubFramebuffer(&self, target: GLenum, numAttachments: GLsizei, attachments: *const GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glInvalidateSubFramebuffer", catch_unwind(||(self.invalidatesubframebuffer)(target, numAttachments, attachments, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateSubFramebuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiDrawArraysIndirect(&self, mode: GLenum, indirect: *const c_void, drawcount: GLsizei, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawArraysIndirect", catch_unwind(||(self.multidrawarraysindirect)(mode, indirect, drawcount, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawArraysIndirect", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiDrawElementsIndirect(&self, mode: GLenum, type_: GLenum, indirect: *const c_void, drawcount: GLsizei, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawElementsIndirect", catch_unwind(||(self.multidrawelementsindirect)(mode, type_, indirect, drawcount, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawElementsIndirect", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramInterfaceiv(&self, program: GLuint, programInterface: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramInterfaceiv", catch_unwind(||(self.getprograminterfaceiv)(program, programInterface, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramInterfaceiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramResourceIndex(&self, program: GLuint, programInterface: GLenum, name: *const GLchar) -> Result<GLuint> {
		let ret = process_catch("glGetProgramResourceIndex", catch_unwind(||(self.getprogramresourceindex)(program, programInterface, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceIndex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramResourceName(&self, program: GLuint, programInterface: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetProgramResourceName", catch_unwind(||(self.getprogramresourcename)(program, programInterface, index, bufSize, length, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceName", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramResourceiv(&self, program: GLuint, programInterface: GLenum, index: GLuint, propCount: GLsizei, props: *const GLenum, count: GLsizei, length: *mut GLsizei, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramResourceiv", catch_unwind(||(self.getprogramresourceiv)(program, programInterface, index, propCount, props, count, length, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramResourceLocation(&self, program: GLuint, programInterface: GLenum, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetProgramResourceLocation", catch_unwind(||(self.getprogramresourcelocation)(program, programInterface, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceLocation", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramResourceLocationIndex(&self, program: GLuint, programInterface: GLenum, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetProgramResourceLocationIndex", catch_unwind(||(self.getprogramresourcelocationindex)(program, programInterface, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceLocationIndex", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glShaderStorageBlockBinding(&self, program: GLuint, storageBlockIndex: GLuint, storageBlockBinding: GLuint) -> Result<()> {
		let ret = process_catch("glShaderStorageBlockBinding", catch_unwind(||(self.shaderstorageblockbinding)(program, storageBlockIndex, storageBlockBinding)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glShaderStorageBlockBinding", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexBufferRange(&self, target: GLenum, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glTexBufferRange", catch_unwind(||(self.texbufferrange)(target, internalformat, buffer, offset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexBufferRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexStorage2DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTexStorage2DMultisample", catch_unwind(||(self.texstorage2dmultisample)(target, samples, internalformat, width, height, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage2DMultisample", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexStorage3DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTexStorage3DMultisample", catch_unwind(||(self.texstorage3dmultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage3DMultisample", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureView(&self, texture: GLuint, target: GLenum, origtexture: GLuint, internalformat: GLenum, minlevel: GLuint, numlevels: GLuint, minlayer: GLuint, numlayers: GLuint) -> Result<()> {
		let ret = process_catch("glTextureView", catch_unwind(||(self.textureview)(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureView", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindVertexBuffer(&self, bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glBindVertexBuffer", catch_unwind(||(self.bindvertexbuffer)(bindingindex, buffer, offset, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindVertexBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribFormat(&self, attribindex: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribFormat", catch_unwind(||(self.vertexattribformat)(attribindex, size, type_, normalized, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribFormat", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribIFormat(&self, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribIFormat", catch_unwind(||(self.vertexattribiformat)(attribindex, size, type_, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribIFormat", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribLFormat(&self, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribLFormat", catch_unwind(||(self.vertexattriblformat)(attribindex, size, type_, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribLFormat", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribBinding(&self, attribindex: GLuint, bindingindex: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribBinding", catch_unwind(||(self.vertexattribbinding)(attribindex, bindingindex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribBinding", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexBindingDivisor(&self, bindingindex: GLuint, divisor: GLuint) -> Result<()> {
		let ret = process_catch("glVertexBindingDivisor", catch_unwind(||(self.vertexbindingdivisor)(bindingindex, divisor)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexBindingDivisor", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDebugMessageControl(&self, source: GLenum, type_: GLenum, severity: GLenum, count: GLsizei, ids: *const GLuint, enabled: GLboolean) -> Result<()> {
		let ret = process_catch("glDebugMessageControl", catch_unwind(||(self.debugmessagecontrol)(source, type_, severity, count, ids, enabled)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDebugMessageControl", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDebugMessageInsert(&self, source: GLenum, type_: GLenum, id: GLuint, severity: GLenum, length: GLsizei, buf: *const GLchar) -> Result<()> {
		let ret = process_catch("glDebugMessageInsert", catch_unwind(||(self.debugmessageinsert)(source, type_, id, severity, length, buf)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDebugMessageInsert", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDebugMessageCallback(&self, callback: GLDEBUGPROC, userParam: *const c_void) -> Result<()> {
		let ret = process_catch("glDebugMessageCallback", catch_unwind(||(self.debugmessagecallback)(callback, userParam)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDebugMessageCallback", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetDebugMessageLog(&self, count: GLuint, bufSize: GLsizei, sources: *mut GLenum, types: *mut GLenum, ids: *mut GLuint, severities: *mut GLenum, lengths: *mut GLsizei, messageLog: *mut GLchar) -> Result<GLuint> {
		let ret = process_catch("glGetDebugMessageLog", catch_unwind(||(self.getdebugmessagelog)(count, bufSize, sources, types, ids, severities, lengths, messageLog)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetDebugMessageLog", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPushDebugGroup(&self, source: GLenum, id: GLuint, length: GLsizei, message: *const GLchar) -> Result<()> {
		let ret = process_catch("glPushDebugGroup", catch_unwind(||(self.pushdebuggroup)(source, id, length, message)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPushDebugGroup", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPopDebugGroup(&self) -> Result<()> {
		let ret = process_catch("glPopDebugGroup", catch_unwind(||(self.popdebuggroup)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPopDebugGroup", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glObjectLabel(&self, identifier: GLenum, name: GLuint, length: GLsizei, label: *const GLchar) -> Result<()> {
		let ret = process_catch("glObjectLabel", catch_unwind(||(self.objectlabel)(identifier, name, length, label)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glObjectLabel", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetObjectLabel(&self, identifier: GLenum, name: GLuint, bufSize: GLsizei, length: *mut GLsizei, label: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetObjectLabel", catch_unwind(||(self.getobjectlabel)(identifier, name, bufSize, length, label)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetObjectLabel", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glObjectPtrLabel(&self, ptr: *const c_void, length: GLsizei, label: *const GLchar) -> Result<()> {
		let ret = process_catch("glObjectPtrLabel", catch_unwind(||(self.objectptrlabel)(ptr, length, label)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glObjectPtrLabel", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetObjectPtrLabel(&self, ptr: *const c_void, bufSize: GLsizei, length: *mut GLsizei, label: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetObjectPtrLabel", catch_unwind(||(self.getobjectptrlabel)(ptr, bufSize, length, label)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetObjectPtrLabel", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version43 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (4, 3, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			clearbufferdata: {let proc = get_proc_address("glClearBufferData"); if proc == null() {dummy_pfnglclearbufferdataproc} else {unsafe{transmute(proc)}}},
			clearbuffersubdata: {let proc = get_proc_address("glClearBufferSubData"); if proc == null() {dummy_pfnglclearbuffersubdataproc} else {unsafe{transmute(proc)}}},
			dispatchcompute: {let proc = get_proc_address("glDispatchCompute"); if proc == null() {dummy_pfngldispatchcomputeproc} else {unsafe{transmute(proc)}}},
			dispatchcomputeindirect: {let proc = get_proc_address("glDispatchComputeIndirect"); if proc == null() {dummy_pfngldispatchcomputeindirectproc} else {unsafe{transmute(proc)}}},
			copyimagesubdata: {let proc = get_proc_address("glCopyImageSubData"); if proc == null() {dummy_pfnglcopyimagesubdataproc} else {unsafe{transmute(proc)}}},
			framebufferparameteri: {let proc = get_proc_address("glFramebufferParameteri"); if proc == null() {dummy_pfnglframebufferparameteriproc} else {unsafe{transmute(proc)}}},
			getframebufferparameteriv: {let proc = get_proc_address("glGetFramebufferParameteriv"); if proc == null() {dummy_pfnglgetframebufferparameterivproc} else {unsafe{transmute(proc)}}},
			getinternalformati64v: {let proc = get_proc_address("glGetInternalformati64v"); if proc == null() {dummy_pfnglgetinternalformati64vproc} else {unsafe{transmute(proc)}}},
			invalidatetexsubimage: {let proc = get_proc_address("glInvalidateTexSubImage"); if proc == null() {dummy_pfnglinvalidatetexsubimageproc} else {unsafe{transmute(proc)}}},
			invalidateteximage: {let proc = get_proc_address("glInvalidateTexImage"); if proc == null() {dummy_pfnglinvalidateteximageproc} else {unsafe{transmute(proc)}}},
			invalidatebuffersubdata: {let proc = get_proc_address("glInvalidateBufferSubData"); if proc == null() {dummy_pfnglinvalidatebuffersubdataproc} else {unsafe{transmute(proc)}}},
			invalidatebufferdata: {let proc = get_proc_address("glInvalidateBufferData"); if proc == null() {dummy_pfnglinvalidatebufferdataproc} else {unsafe{transmute(proc)}}},
			invalidateframebuffer: {let proc = get_proc_address("glInvalidateFramebuffer"); if proc == null() {dummy_pfnglinvalidateframebufferproc} else {unsafe{transmute(proc)}}},
			invalidatesubframebuffer: {let proc = get_proc_address("glInvalidateSubFramebuffer"); if proc == null() {dummy_pfnglinvalidatesubframebufferproc} else {unsafe{transmute(proc)}}},
			multidrawarraysindirect: {let proc = get_proc_address("glMultiDrawArraysIndirect"); if proc == null() {dummy_pfnglmultidrawarraysindirectproc} else {unsafe{transmute(proc)}}},
			multidrawelementsindirect: {let proc = get_proc_address("glMultiDrawElementsIndirect"); if proc == null() {dummy_pfnglmultidrawelementsindirectproc} else {unsafe{transmute(proc)}}},
			getprograminterfaceiv: {let proc = get_proc_address("glGetProgramInterfaceiv"); if proc == null() {dummy_pfnglgetprograminterfaceivproc} else {unsafe{transmute(proc)}}},
			getprogramresourceindex: {let proc = get_proc_address("glGetProgramResourceIndex"); if proc == null() {dummy_pfnglgetprogramresourceindexproc} else {unsafe{transmute(proc)}}},
			getprogramresourcename: {let proc = get_proc_address("glGetProgramResourceName"); if proc == null() {dummy_pfnglgetprogramresourcenameproc} else {unsafe{transmute(proc)}}},
			getprogramresourceiv: {let proc = get_proc_address("glGetProgramResourceiv"); if proc == null() {dummy_pfnglgetprogramresourceivproc} else {unsafe{transmute(proc)}}},
			getprogramresourcelocation: {let proc = get_proc_address("glGetProgramResourceLocation"); if proc == null() {dummy_pfnglgetprogramresourcelocationproc} else {unsafe{transmute(proc)}}},
			getprogramresourcelocationindex: {let proc = get_proc_address("glGetProgramResourceLocationIndex"); if proc == null() {dummy_pfnglgetprogramresourcelocationindexproc} else {unsafe{transmute(proc)}}},
			shaderstorageblockbinding: {let proc = get_proc_address("glShaderStorageBlockBinding"); if proc == null() {dummy_pfnglshaderstorageblockbindingproc} else {unsafe{transmute(proc)}}},
			texbufferrange: {let proc = get_proc_address("glTexBufferRange"); if proc == null() {dummy_pfngltexbufferrangeproc} else {unsafe{transmute(proc)}}},
			texstorage2dmultisample: {let proc = get_proc_address("glTexStorage2DMultisample"); if proc == null() {dummy_pfngltexstorage2dmultisampleproc} else {unsafe{transmute(proc)}}},
			texstorage3dmultisample: {let proc = get_proc_address("glTexStorage3DMultisample"); if proc == null() {dummy_pfngltexstorage3dmultisampleproc} else {unsafe{transmute(proc)}}},
			textureview: {let proc = get_proc_address("glTextureView"); if proc == null() {dummy_pfngltextureviewproc} else {unsafe{transmute(proc)}}},
			bindvertexbuffer: {let proc = get_proc_address("glBindVertexBuffer"); if proc == null() {dummy_pfnglbindvertexbufferproc} else {unsafe{transmute(proc)}}},
			vertexattribformat: {let proc = get_proc_address("glVertexAttribFormat"); if proc == null() {dummy_pfnglvertexattribformatproc} else {unsafe{transmute(proc)}}},
			vertexattribiformat: {let proc = get_proc_address("glVertexAttribIFormat"); if proc == null() {dummy_pfnglvertexattribiformatproc} else {unsafe{transmute(proc)}}},
			vertexattriblformat: {let proc = get_proc_address("glVertexAttribLFormat"); if proc == null() {dummy_pfnglvertexattriblformatproc} else {unsafe{transmute(proc)}}},
			vertexattribbinding: {let proc = get_proc_address("glVertexAttribBinding"); if proc == null() {dummy_pfnglvertexattribbindingproc} else {unsafe{transmute(proc)}}},
			vertexbindingdivisor: {let proc = get_proc_address("glVertexBindingDivisor"); if proc == null() {dummy_pfnglvertexbindingdivisorproc} else {unsafe{transmute(proc)}}},
			debugmessagecontrol: {let proc = get_proc_address("glDebugMessageControl"); if proc == null() {dummy_pfngldebugmessagecontrolproc} else {unsafe{transmute(proc)}}},
			debugmessageinsert: {let proc = get_proc_address("glDebugMessageInsert"); if proc == null() {dummy_pfngldebugmessageinsertproc} else {unsafe{transmute(proc)}}},
			debugmessagecallback: {let proc = get_proc_address("glDebugMessageCallback"); if proc == null() {dummy_pfngldebugmessagecallbackproc} else {unsafe{transmute(proc)}}},
			getdebugmessagelog: {let proc = get_proc_address("glGetDebugMessageLog"); if proc == null() {dummy_pfnglgetdebugmessagelogproc} else {unsafe{transmute(proc)}}},
			pushdebuggroup: {let proc = get_proc_address("glPushDebugGroup"); if proc == null() {dummy_pfnglpushdebuggroupproc} else {unsafe{transmute(proc)}}},
			popdebuggroup: {let proc = get_proc_address("glPopDebugGroup"); if proc == null() {dummy_pfnglpopdebuggroupproc} else {unsafe{transmute(proc)}}},
			objectlabel: {let proc = get_proc_address("glObjectLabel"); if proc == null() {dummy_pfnglobjectlabelproc} else {unsafe{transmute(proc)}}},
			getobjectlabel: {let proc = get_proc_address("glGetObjectLabel"); if proc == null() {dummy_pfnglgetobjectlabelproc} else {unsafe{transmute(proc)}}},
			objectptrlabel: {let proc = get_proc_address("glObjectPtrLabel"); if proc == null() {dummy_pfnglobjectptrlabelproc} else {unsafe{transmute(proc)}}},
			getobjectptrlabel: {let proc = get_proc_address("glGetObjectPtrLabel"); if proc == null() {dummy_pfnglgetobjectptrlabelproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version43 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			clearbufferdata: dummy_pfnglclearbufferdataproc,
			clearbuffersubdata: dummy_pfnglclearbuffersubdataproc,
			dispatchcompute: dummy_pfngldispatchcomputeproc,
			dispatchcomputeindirect: dummy_pfngldispatchcomputeindirectproc,
			copyimagesubdata: dummy_pfnglcopyimagesubdataproc,
			framebufferparameteri: dummy_pfnglframebufferparameteriproc,
			getframebufferparameteriv: dummy_pfnglgetframebufferparameterivproc,
			getinternalformati64v: dummy_pfnglgetinternalformati64vproc,
			invalidatetexsubimage: dummy_pfnglinvalidatetexsubimageproc,
			invalidateteximage: dummy_pfnglinvalidateteximageproc,
			invalidatebuffersubdata: dummy_pfnglinvalidatebuffersubdataproc,
			invalidatebufferdata: dummy_pfnglinvalidatebufferdataproc,
			invalidateframebuffer: dummy_pfnglinvalidateframebufferproc,
			invalidatesubframebuffer: dummy_pfnglinvalidatesubframebufferproc,
			multidrawarraysindirect: dummy_pfnglmultidrawarraysindirectproc,
			multidrawelementsindirect: dummy_pfnglmultidrawelementsindirectproc,
			getprograminterfaceiv: dummy_pfnglgetprograminterfaceivproc,
			getprogramresourceindex: dummy_pfnglgetprogramresourceindexproc,
			getprogramresourcename: dummy_pfnglgetprogramresourcenameproc,
			getprogramresourceiv: dummy_pfnglgetprogramresourceivproc,
			getprogramresourcelocation: dummy_pfnglgetprogramresourcelocationproc,
			getprogramresourcelocationindex: dummy_pfnglgetprogramresourcelocationindexproc,
			shaderstorageblockbinding: dummy_pfnglshaderstorageblockbindingproc,
			texbufferrange: dummy_pfngltexbufferrangeproc,
			texstorage2dmultisample: dummy_pfngltexstorage2dmultisampleproc,
			texstorage3dmultisample: dummy_pfngltexstorage3dmultisampleproc,
			textureview: dummy_pfngltextureviewproc,
			bindvertexbuffer: dummy_pfnglbindvertexbufferproc,
			vertexattribformat: dummy_pfnglvertexattribformatproc,
			vertexattribiformat: dummy_pfnglvertexattribiformatproc,
			vertexattriblformat: dummy_pfnglvertexattriblformatproc,
			vertexattribbinding: dummy_pfnglvertexattribbindingproc,
			vertexbindingdivisor: dummy_pfnglvertexbindingdivisorproc,
			debugmessagecontrol: dummy_pfngldebugmessagecontrolproc,
			debugmessageinsert: dummy_pfngldebugmessageinsertproc,
			debugmessagecallback: dummy_pfngldebugmessagecallbackproc,
			getdebugmessagelog: dummy_pfnglgetdebugmessagelogproc,
			pushdebuggroup: dummy_pfnglpushdebuggroupproc,
			popdebuggroup: dummy_pfnglpopdebuggroupproc,
			objectlabel: dummy_pfnglobjectlabelproc,
			getobjectlabel: dummy_pfnglgetobjectlabelproc,
			objectptrlabel: dummy_pfnglobjectptrlabelproc,
			getobjectptrlabel: dummy_pfnglgetobjectptrlabelproc,
		}
	}
}
impl Debug for Version43 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version43")
			.field("available", &self.available)
			.field("clearbufferdata", unsafe{if transmute::<_, *const c_void>(self.clearbufferdata) == (dummy_pfnglclearbufferdataproc as *const c_void) {&null::<PFNGLCLEARBUFFERDATAPROC>()} else {&self.clearbufferdata}})
			.field("clearbuffersubdata", unsafe{if transmute::<_, *const c_void>(self.clearbuffersubdata) == (dummy_pfnglclearbuffersubdataproc as *const c_void) {&null::<PFNGLCLEARBUFFERSUBDATAPROC>()} else {&self.clearbuffersubdata}})
			.field("dispatchcompute", unsafe{if transmute::<_, *const c_void>(self.dispatchcompute) == (dummy_pfngldispatchcomputeproc as *const c_void) {&null::<PFNGLDISPATCHCOMPUTEPROC>()} else {&self.dispatchcompute}})
			.field("dispatchcomputeindirect", unsafe{if transmute::<_, *const c_void>(self.dispatchcomputeindirect) == (dummy_pfngldispatchcomputeindirectproc as *const c_void) {&null::<PFNGLDISPATCHCOMPUTEINDIRECTPROC>()} else {&self.dispatchcomputeindirect}})
			.field("copyimagesubdata", unsafe{if transmute::<_, *const c_void>(self.copyimagesubdata) == (dummy_pfnglcopyimagesubdataproc as *const c_void) {&null::<PFNGLCOPYIMAGESUBDATAPROC>()} else {&self.copyimagesubdata}})
			.field("framebufferparameteri", unsafe{if transmute::<_, *const c_void>(self.framebufferparameteri) == (dummy_pfnglframebufferparameteriproc as *const c_void) {&null::<PFNGLFRAMEBUFFERPARAMETERIPROC>()} else {&self.framebufferparameteri}})
			.field("getframebufferparameteriv", unsafe{if transmute::<_, *const c_void>(self.getframebufferparameteriv) == (dummy_pfnglgetframebufferparameterivproc as *const c_void) {&null::<PFNGLGETFRAMEBUFFERPARAMETERIVPROC>()} else {&self.getframebufferparameteriv}})
			.field("getinternalformati64v", unsafe{if transmute::<_, *const c_void>(self.getinternalformati64v) == (dummy_pfnglgetinternalformati64vproc as *const c_void) {&null::<PFNGLGETINTERNALFORMATI64VPROC>()} else {&self.getinternalformati64v}})
			.field("invalidatetexsubimage", unsafe{if transmute::<_, *const c_void>(self.invalidatetexsubimage) == (dummy_pfnglinvalidatetexsubimageproc as *const c_void) {&null::<PFNGLINVALIDATETEXSUBIMAGEPROC>()} else {&self.invalidatetexsubimage}})
			.field("invalidateteximage", unsafe{if transmute::<_, *const c_void>(self.invalidateteximage) == (dummy_pfnglinvalidateteximageproc as *const c_void) {&null::<PFNGLINVALIDATETEXIMAGEPROC>()} else {&self.invalidateteximage}})
			.field("invalidatebuffersubdata", unsafe{if transmute::<_, *const c_void>(self.invalidatebuffersubdata) == (dummy_pfnglinvalidatebuffersubdataproc as *const c_void) {&null::<PFNGLINVALIDATEBUFFERSUBDATAPROC>()} else {&self.invalidatebuffersubdata}})
			.field("invalidatebufferdata", unsafe{if transmute::<_, *const c_void>(self.invalidatebufferdata) == (dummy_pfnglinvalidatebufferdataproc as *const c_void) {&null::<PFNGLINVALIDATEBUFFERDATAPROC>()} else {&self.invalidatebufferdata}})
			.field("invalidateframebuffer", unsafe{if transmute::<_, *const c_void>(self.invalidateframebuffer) == (dummy_pfnglinvalidateframebufferproc as *const c_void) {&null::<PFNGLINVALIDATEFRAMEBUFFERPROC>()} else {&self.invalidateframebuffer}})
			.field("invalidatesubframebuffer", unsafe{if transmute::<_, *const c_void>(self.invalidatesubframebuffer) == (dummy_pfnglinvalidatesubframebufferproc as *const c_void) {&null::<PFNGLINVALIDATESUBFRAMEBUFFERPROC>()} else {&self.invalidatesubframebuffer}})
			.field("multidrawarraysindirect", unsafe{if transmute::<_, *const c_void>(self.multidrawarraysindirect) == (dummy_pfnglmultidrawarraysindirectproc as *const c_void) {&null::<PFNGLMULTIDRAWARRAYSINDIRECTPROC>()} else {&self.multidrawarraysindirect}})
			.field("multidrawelementsindirect", unsafe{if transmute::<_, *const c_void>(self.multidrawelementsindirect) == (dummy_pfnglmultidrawelementsindirectproc as *const c_void) {&null::<PFNGLMULTIDRAWELEMENTSINDIRECTPROC>()} else {&self.multidrawelementsindirect}})
			.field("getprograminterfaceiv", unsafe{if transmute::<_, *const c_void>(self.getprograminterfaceiv) == (dummy_pfnglgetprograminterfaceivproc as *const c_void) {&null::<PFNGLGETPROGRAMINTERFACEIVPROC>()} else {&self.getprograminterfaceiv}})
			.field("getprogramresourceindex", unsafe{if transmute::<_, *const c_void>(self.getprogramresourceindex) == (dummy_pfnglgetprogramresourceindexproc as *const c_void) {&null::<PFNGLGETPROGRAMRESOURCEINDEXPROC>()} else {&self.getprogramresourceindex}})
			.field("getprogramresourcename", unsafe{if transmute::<_, *const c_void>(self.getprogramresourcename) == (dummy_pfnglgetprogramresourcenameproc as *const c_void) {&null::<PFNGLGETPROGRAMRESOURCENAMEPROC>()} else {&self.getprogramresourcename}})
			.field("getprogramresourceiv", unsafe{if transmute::<_, *const c_void>(self.getprogramresourceiv) == (dummy_pfnglgetprogramresourceivproc as *const c_void) {&null::<PFNGLGETPROGRAMRESOURCEIVPROC>()} else {&self.getprogramresourceiv}})
			.field("getprogramresourcelocation", unsafe{if transmute::<_, *const c_void>(self.getprogramresourcelocation) == (dummy_pfnglgetprogramresourcelocationproc as *const c_void) {&null::<PFNGLGETPROGRAMRESOURCELOCATIONPROC>()} else {&self.getprogramresourcelocation}})
			.field("getprogramresourcelocationindex", unsafe{if transmute::<_, *const c_void>(self.getprogramresourcelocationindex) == (dummy_pfnglgetprogramresourcelocationindexproc as *const c_void) {&null::<PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC>()} else {&self.getprogramresourcelocationindex}})
			.field("shaderstorageblockbinding", unsafe{if transmute::<_, *const c_void>(self.shaderstorageblockbinding) == (dummy_pfnglshaderstorageblockbindingproc as *const c_void) {&null::<PFNGLSHADERSTORAGEBLOCKBINDINGPROC>()} else {&self.shaderstorageblockbinding}})
			.field("texbufferrange", unsafe{if transmute::<_, *const c_void>(self.texbufferrange) == (dummy_pfngltexbufferrangeproc as *const c_void) {&null::<PFNGLTEXBUFFERRANGEPROC>()} else {&self.texbufferrange}})
			.field("texstorage2dmultisample", unsafe{if transmute::<_, *const c_void>(self.texstorage2dmultisample) == (dummy_pfngltexstorage2dmultisampleproc as *const c_void) {&null::<PFNGLTEXSTORAGE2DMULTISAMPLEPROC>()} else {&self.texstorage2dmultisample}})
			.field("texstorage3dmultisample", unsafe{if transmute::<_, *const c_void>(self.texstorage3dmultisample) == (dummy_pfngltexstorage3dmultisampleproc as *const c_void) {&null::<PFNGLTEXSTORAGE3DMULTISAMPLEPROC>()} else {&self.texstorage3dmultisample}})
			.field("textureview", unsafe{if transmute::<_, *const c_void>(self.textureview) == (dummy_pfngltextureviewproc as *const c_void) {&null::<PFNGLTEXTUREVIEWPROC>()} else {&self.textureview}})
			.field("bindvertexbuffer", unsafe{if transmute::<_, *const c_void>(self.bindvertexbuffer) == (dummy_pfnglbindvertexbufferproc as *const c_void) {&null::<PFNGLBINDVERTEXBUFFERPROC>()} else {&self.bindvertexbuffer}})
			.field("vertexattribformat", unsafe{if transmute::<_, *const c_void>(self.vertexattribformat) == (dummy_pfnglvertexattribformatproc as *const c_void) {&null::<PFNGLVERTEXATTRIBFORMATPROC>()} else {&self.vertexattribformat}})
			.field("vertexattribiformat", unsafe{if transmute::<_, *const c_void>(self.vertexattribiformat) == (dummy_pfnglvertexattribiformatproc as *const c_void) {&null::<PFNGLVERTEXATTRIBIFORMATPROC>()} else {&self.vertexattribiformat}})
			.field("vertexattriblformat", unsafe{if transmute::<_, *const c_void>(self.vertexattriblformat) == (dummy_pfnglvertexattriblformatproc as *const c_void) {&null::<PFNGLVERTEXATTRIBLFORMATPROC>()} else {&self.vertexattriblformat}})
			.field("vertexattribbinding", unsafe{if transmute::<_, *const c_void>(self.vertexattribbinding) == (dummy_pfnglvertexattribbindingproc as *const c_void) {&null::<PFNGLVERTEXATTRIBBINDINGPROC>()} else {&self.vertexattribbinding}})
			.field("vertexbindingdivisor", unsafe{if transmute::<_, *const c_void>(self.vertexbindingdivisor) == (dummy_pfnglvertexbindingdivisorproc as *const c_void) {&null::<PFNGLVERTEXBINDINGDIVISORPROC>()} else {&self.vertexbindingdivisor}})
			.field("debugmessagecontrol", unsafe{if transmute::<_, *const c_void>(self.debugmessagecontrol) == (dummy_pfngldebugmessagecontrolproc as *const c_void) {&null::<PFNGLDEBUGMESSAGECONTROLPROC>()} else {&self.debugmessagecontrol}})
			.field("debugmessageinsert", unsafe{if transmute::<_, *const c_void>(self.debugmessageinsert) == (dummy_pfngldebugmessageinsertproc as *const c_void) {&null::<PFNGLDEBUGMESSAGEINSERTPROC>()} else {&self.debugmessageinsert}})
			.field("debugmessagecallback", unsafe{if transmute::<_, *const c_void>(self.debugmessagecallback) == (dummy_pfngldebugmessagecallbackproc as *const c_void) {&null::<PFNGLDEBUGMESSAGECALLBACKPROC>()} else {&self.debugmessagecallback}})
			.field("getdebugmessagelog", unsafe{if transmute::<_, *const c_void>(self.getdebugmessagelog) == (dummy_pfnglgetdebugmessagelogproc as *const c_void) {&null::<PFNGLGETDEBUGMESSAGELOGPROC>()} else {&self.getdebugmessagelog}})
			.field("pushdebuggroup", unsafe{if transmute::<_, *const c_void>(self.pushdebuggroup) == (dummy_pfnglpushdebuggroupproc as *const c_void) {&null::<PFNGLPUSHDEBUGGROUPPROC>()} else {&self.pushdebuggroup}})
			.field("popdebuggroup", unsafe{if transmute::<_, *const c_void>(self.popdebuggroup) == (dummy_pfnglpopdebuggroupproc as *const c_void) {&null::<PFNGLPOPDEBUGGROUPPROC>()} else {&self.popdebuggroup}})
			.field("objectlabel", unsafe{if transmute::<_, *const c_void>(self.objectlabel) == (dummy_pfnglobjectlabelproc as *const c_void) {&null::<PFNGLOBJECTLABELPROC>()} else {&self.objectlabel}})
			.field("getobjectlabel", unsafe{if transmute::<_, *const c_void>(self.getobjectlabel) == (dummy_pfnglgetobjectlabelproc as *const c_void) {&null::<PFNGLGETOBJECTLABELPROC>()} else {&self.getobjectlabel}})
			.field("objectptrlabel", unsafe{if transmute::<_, *const c_void>(self.objectptrlabel) == (dummy_pfnglobjectptrlabelproc as *const c_void) {&null::<PFNGLOBJECTPTRLABELPROC>()} else {&self.objectptrlabel}})
			.field("getobjectptrlabel", unsafe{if transmute::<_, *const c_void>(self.getobjectptrlabel) == (dummy_pfnglgetobjectptrlabelproc as *const c_void) {&null::<PFNGLGETOBJECTPTRLABELPROC>()} else {&self.getobjectptrlabel}})
			.finish()
		} else {
			f.debug_struct("Version43")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}
type PFNGLBUFFERSTORAGEPROC = extern "system" fn(GLenum, GLsizeiptr, *const c_void, GLbitfield);
type PFNGLCLEARTEXIMAGEPROC = extern "system" fn(GLuint, GLint, GLenum, GLenum, *const c_void);
type PFNGLCLEARTEXSUBIMAGEPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, *const c_void);
type PFNGLBINDBUFFERSBASEPROC = extern "system" fn(GLenum, GLuint, GLsizei, *const GLuint);
type PFNGLBINDBUFFERSRANGEPROC = extern "system" fn(GLenum, GLuint, GLsizei, *const GLuint, *const GLintptr, *const GLsizeiptr);
type PFNGLBINDTEXTURESPROC = extern "system" fn(GLuint, GLsizei, *const GLuint);
type PFNGLBINDSAMPLERSPROC = extern "system" fn(GLuint, GLsizei, *const GLuint);
type PFNGLBINDIMAGETEXTURESPROC = extern "system" fn(GLuint, GLsizei, *const GLuint);
type PFNGLBINDVERTEXBUFFERSPROC = extern "system" fn(GLuint, GLsizei, *const GLuint, *const GLintptr, *const GLsizei);
extern "system" fn dummy_pfnglbufferstorageproc (_: GLenum, _: GLsizeiptr, _: *const c_void, _: GLbitfield) {
	panic!("OpenGL function pointer `glBufferStorage()` is null.")
}
extern "system" fn dummy_pfnglclearteximageproc (_: GLuint, _: GLint, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glClearTexImage()` is null.")
}
extern "system" fn dummy_pfnglcleartexsubimageproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glClearTexSubImage()` is null.")
}
extern "system" fn dummy_pfnglbindbuffersbaseproc (_: GLenum, _: GLuint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glBindBuffersBase()` is null.")
}
extern "system" fn dummy_pfnglbindbuffersrangeproc (_: GLenum, _: GLuint, _: GLsizei, _: *const GLuint, _: *const GLintptr, _: *const GLsizeiptr) {
	panic!("OpenGL function pointer `glBindBuffersRange()` is null.")
}
extern "system" fn dummy_pfnglbindtexturesproc (_: GLuint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glBindTextures()` is null.")
}
extern "system" fn dummy_pfnglbindsamplersproc (_: GLuint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glBindSamplers()` is null.")
}
extern "system" fn dummy_pfnglbindimagetexturesproc (_: GLuint, _: GLsizei, _: *const GLuint) {
	panic!("OpenGL function pointer `glBindImageTextures()` is null.")
}
extern "system" fn dummy_pfnglbindvertexbuffersproc (_: GLuint, _: GLsizei, _: *const GLuint, _: *const GLintptr, _: *const GLsizei) {
	panic!("OpenGL function pointer `glBindVertexBuffers()` is null.")
}
pub const GL_MAX_VERTEX_ATTRIB_STRIDE: GLenum = 0x82E5;
pub const GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED: GLenum = 0x8221;
pub const GL_TEXTURE_BUFFER_BINDING: GLenum = 0x8C2A;
pub const GL_MAP_PERSISTENT_BIT: GLbitfield = 0x0040;
pub const GL_MAP_COHERENT_BIT: GLbitfield = 0x0080;
pub const GL_DYNAMIC_STORAGE_BIT: GLbitfield = 0x0100;
pub const GL_CLIENT_STORAGE_BIT: GLbitfield = 0x0200;
pub const GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT: GLbitfield = 0x00004000;
pub const GL_BUFFER_IMMUTABLE_STORAGE: GLenum = 0x821F;
pub const GL_BUFFER_STORAGE_FLAGS: GLenum = 0x8220;
pub const GL_CLEAR_TEXTURE: GLenum = 0x9365;
pub const GL_LOCATION_COMPONENT: GLenum = 0x934A;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_INDEX: GLenum = 0x934B;
pub const GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE: GLenum = 0x934C;
pub const GL_QUERY_BUFFER: GLenum = 0x9192;
pub const GL_QUERY_BUFFER_BARRIER_BIT: GLbitfield = 0x00008000;
pub const GL_QUERY_BUFFER_BINDING: GLenum = 0x9193;
pub const GL_QUERY_RESULT_NO_WAIT: GLenum = 0x9194;
pub const GL_MIRROR_CLAMP_TO_EDGE: GLenum = 0x8743;

pub trait GL_4_4 {
	fn glGetError(&self) -> GLenum;
	fn glBufferStorage(&self, target: GLenum, size: GLsizeiptr, data: *const c_void, flags: GLbitfield) -> Result<()>;
	fn glClearTexImage(&self, texture: GLuint, level: GLint, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()>;
	fn glClearTexSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()>;
	fn glBindBuffersBase(&self, target: GLenum, first: GLuint, count: GLsizei, buffers: *const GLuint) -> Result<()>;
	fn glBindBuffersRange(&self, target: GLenum, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, sizes: *const GLsizeiptr) -> Result<()>;
	fn glBindTextures(&self, first: GLuint, count: GLsizei, textures: *const GLuint) -> Result<()>;
	fn glBindSamplers(&self, first: GLuint, count: GLsizei, samplers: *const GLuint) -> Result<()>;
	fn glBindImageTextures(&self, first: GLuint, count: GLsizei, textures: *const GLuint) -> Result<()>;
	fn glBindVertexBuffers(&self, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, strides: *const GLsizei) -> Result<()>;
}

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version44 {
	available: bool,
	geterror: PFNGLGETERRORPROC,
	bufferstorage: PFNGLBUFFERSTORAGEPROC,
	clearteximage: PFNGLCLEARTEXIMAGEPROC,
	cleartexsubimage: PFNGLCLEARTEXSUBIMAGEPROC,
	bindbuffersbase: PFNGLBINDBUFFERSBASEPROC,
	bindbuffersrange: PFNGLBINDBUFFERSRANGEPROC,
	bindtextures: PFNGLBINDTEXTURESPROC,
	bindsamplers: PFNGLBINDSAMPLERSPROC,
	bindimagetextures: PFNGLBINDIMAGETEXTURESPROC,
	bindvertexbuffers: PFNGLBINDVERTEXBUFFERSPROC,
}

impl GL_4_4 for Version44 {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	#[inline(always)]
	fn glBufferStorage(&self, target: GLenum, size: GLsizeiptr, data: *const c_void, flags: GLbitfield) -> Result<()> {
		let ret = process_catch("glBufferStorage", catch_unwind(||(self.bufferstorage)(target, size, data, flags)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBufferStorage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearTexImage(&self, texture: GLuint, level: GLint, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearTexImage", catch_unwind(||(self.clearteximage)(texture, level, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearTexImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearTexSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearTexSubImage", catch_unwind(||(self.cleartexsubimage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearTexSubImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindBuffersBase(&self, target: GLenum, first: GLuint, count: GLsizei, buffers: *const GLuint) -> Result<()> {
		let ret = process_catch("glBindBuffersBase", catch_unwind(||(self.bindbuffersbase)(target, first, count, buffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBuffersBase", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindBuffersRange(&self, target: GLenum, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, sizes: *const GLsizeiptr) -> Result<()> {
		let ret = process_catch("glBindBuffersRange", catch_unwind(||(self.bindbuffersrange)(target, first, count, buffers, offsets, sizes)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBuffersRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindTextures(&self, first: GLuint, count: GLsizei, textures: *const GLuint) -> Result<()> {
		let ret = process_catch("glBindTextures", catch_unwind(||(self.bindtextures)(first, count, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindTextures", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindSamplers(&self, first: GLuint, count: GLsizei, samplers: *const GLuint) -> Result<()> {
		let ret = process_catch("glBindSamplers", catch_unwind(||(self.bindsamplers)(first, count, samplers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindSamplers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindImageTextures(&self, first: GLuint, count: GLsizei, textures: *const GLuint) -> Result<()> {
		let ret = process_catch("glBindImageTextures", catch_unwind(||(self.bindimagetextures)(first, count, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindImageTextures", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindVertexBuffers(&self, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, strides: *const GLsizei) -> Result<()> {
		let ret = process_catch("glBindVertexBuffers", catch_unwind(||(self.bindvertexbuffers)(first, count, buffers, offsets, strides)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindVertexBuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version44 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (4, 4, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			bufferstorage: {let proc = get_proc_address("glBufferStorage"); if proc == null() {dummy_pfnglbufferstorageproc} else {unsafe{transmute(proc)}}},
			clearteximage: {let proc = get_proc_address("glClearTexImage"); if proc == null() {dummy_pfnglclearteximageproc} else {unsafe{transmute(proc)}}},
			cleartexsubimage: {let proc = get_proc_address("glClearTexSubImage"); if proc == null() {dummy_pfnglcleartexsubimageproc} else {unsafe{transmute(proc)}}},
			bindbuffersbase: {let proc = get_proc_address("glBindBuffersBase"); if proc == null() {dummy_pfnglbindbuffersbaseproc} else {unsafe{transmute(proc)}}},
			bindbuffersrange: {let proc = get_proc_address("glBindBuffersRange"); if proc == null() {dummy_pfnglbindbuffersrangeproc} else {unsafe{transmute(proc)}}},
			bindtextures: {let proc = get_proc_address("glBindTextures"); if proc == null() {dummy_pfnglbindtexturesproc} else {unsafe{transmute(proc)}}},
			bindsamplers: {let proc = get_proc_address("glBindSamplers"); if proc == null() {dummy_pfnglbindsamplersproc} else {unsafe{transmute(proc)}}},
			bindimagetextures: {let proc = get_proc_address("glBindImageTextures"); if proc == null() {dummy_pfnglbindimagetexturesproc} else {unsafe{transmute(proc)}}},
			bindvertexbuffers: {let proc = get_proc_address("glBindVertexBuffers"); if proc == null() {dummy_pfnglbindvertexbuffersproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version44 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			bufferstorage: dummy_pfnglbufferstorageproc,
			clearteximage: dummy_pfnglclearteximageproc,
			cleartexsubimage: dummy_pfnglcleartexsubimageproc,
			bindbuffersbase: dummy_pfnglbindbuffersbaseproc,
			bindbuffersrange: dummy_pfnglbindbuffersrangeproc,
			bindtextures: dummy_pfnglbindtexturesproc,
			bindsamplers: dummy_pfnglbindsamplersproc,
			bindimagetextures: dummy_pfnglbindimagetexturesproc,
			bindvertexbuffers: dummy_pfnglbindvertexbuffersproc,
		}
	}
}
impl Debug for Version44 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version44")
			.field("available", &self.available)
			.field("bufferstorage", unsafe{if transmute::<_, *const c_void>(self.bufferstorage) == (dummy_pfnglbufferstorageproc as *const c_void) {&null::<PFNGLBUFFERSTORAGEPROC>()} else {&self.bufferstorage}})
			.field("clearteximage", unsafe{if transmute::<_, *const c_void>(self.clearteximage) == (dummy_pfnglclearteximageproc as *const c_void) {&null::<PFNGLCLEARTEXIMAGEPROC>()} else {&self.clearteximage}})
			.field("cleartexsubimage", unsafe{if transmute::<_, *const c_void>(self.cleartexsubimage) == (dummy_pfnglcleartexsubimageproc as *const c_void) {&null::<PFNGLCLEARTEXSUBIMAGEPROC>()} else {&self.cleartexsubimage}})
			.field("bindbuffersbase", unsafe{if transmute::<_, *const c_void>(self.bindbuffersbase) == (dummy_pfnglbindbuffersbaseproc as *const c_void) {&null::<PFNGLBINDBUFFERSBASEPROC>()} else {&self.bindbuffersbase}})
			.field("bindbuffersrange", unsafe{if transmute::<_, *const c_void>(self.bindbuffersrange) == (dummy_pfnglbindbuffersrangeproc as *const c_void) {&null::<PFNGLBINDBUFFERSRANGEPROC>()} else {&self.bindbuffersrange}})
			.field("bindtextures", unsafe{if transmute::<_, *const c_void>(self.bindtextures) == (dummy_pfnglbindtexturesproc as *const c_void) {&null::<PFNGLBINDTEXTURESPROC>()} else {&self.bindtextures}})
			.field("bindsamplers", unsafe{if transmute::<_, *const c_void>(self.bindsamplers) == (dummy_pfnglbindsamplersproc as *const c_void) {&null::<PFNGLBINDSAMPLERSPROC>()} else {&self.bindsamplers}})
			.field("bindimagetextures", unsafe{if transmute::<_, *const c_void>(self.bindimagetextures) == (dummy_pfnglbindimagetexturesproc as *const c_void) {&null::<PFNGLBINDIMAGETEXTURESPROC>()} else {&self.bindimagetextures}})
			.field("bindvertexbuffers", unsafe{if transmute::<_, *const c_void>(self.bindvertexbuffers) == (dummy_pfnglbindvertexbuffersproc as *const c_void) {&null::<PFNGLBINDVERTEXBUFFERSPROC>()} else {&self.bindvertexbuffers}})
			.finish()
		} else {
			f.debug_struct("Version44")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}
type PFNGLCLIPCONTROLPROC = extern "system" fn(GLenum, GLenum);
type PFNGLCREATETRANSFORMFEEDBACKSPROC = extern "system" fn(GLsizei, *mut GLuint);
type PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC = extern "system" fn(GLuint, GLuint, GLuint);
type PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC = extern "system" fn(GLuint, GLuint, GLuint, GLintptr, GLsizeiptr);
type PFNGLGETTRANSFORMFEEDBACKIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);
type PFNGLGETTRANSFORMFEEDBACKI_VPROC = extern "system" fn(GLuint, GLenum, GLuint, *mut GLint);
type PFNGLGETTRANSFORMFEEDBACKI64_VPROC = extern "system" fn(GLuint, GLenum, GLuint, *mut GLint64);
type PFNGLCREATEBUFFERSPROC = extern "system" fn(GLsizei, *mut GLuint);
type PFNGLNAMEDBUFFERSTORAGEPROC = extern "system" fn(GLuint, GLsizeiptr, *const c_void, GLbitfield);
type PFNGLNAMEDBUFFERDATAPROC = extern "system" fn(GLuint, GLsizeiptr, *const c_void, GLenum);
type PFNGLNAMEDBUFFERSUBDATAPROC = extern "system" fn(GLuint, GLintptr, GLsizeiptr, *const c_void);
type PFNGLCOPYNAMEDBUFFERSUBDATAPROC = extern "system" fn(GLuint, GLuint, GLintptr, GLintptr, GLsizeiptr);
type PFNGLCLEARNAMEDBUFFERDATAPROC = extern "system" fn(GLuint, GLenum, GLenum, GLenum, *const c_void);
type PFNGLCLEARNAMEDBUFFERSUBDATAPROC = extern "system" fn(GLuint, GLenum, GLintptr, GLsizeiptr, GLenum, GLenum, *const c_void);
type PFNGLMAPNAMEDBUFFERPROC = extern "system" fn(GLuint, GLenum) -> *mut c_void;
type PFNGLMAPNAMEDBUFFERRANGEPROC = extern "system" fn(GLuint, GLintptr, GLsizeiptr, GLbitfield) -> *mut c_void;
type PFNGLUNMAPNAMEDBUFFERPROC = extern "system" fn(GLuint) -> GLboolean;
type PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC = extern "system" fn(GLuint, GLintptr, GLsizeiptr);
type PFNGLGETNAMEDBUFFERPARAMETERIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);
type PFNGLGETNAMEDBUFFERPARAMETERI64VPROC = extern "system" fn(GLuint, GLenum, *mut GLint64);
type PFNGLGETNAMEDBUFFERPOINTERVPROC = extern "system" fn(GLuint, GLenum, *mut *mut c_void);
type PFNGLGETNAMEDBUFFERSUBDATAPROC = extern "system" fn(GLuint, GLintptr, GLsizeiptr, *mut c_void);
type PFNGLCREATEFRAMEBUFFERSPROC = extern "system" fn(GLsizei, *mut GLuint);
type PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC = extern "system" fn(GLuint, GLenum, GLenum, GLuint);
type PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC = extern "system" fn(GLuint, GLenum, GLint);
type PFNGLNAMEDFRAMEBUFFERTEXTUREPROC = extern "system" fn(GLuint, GLenum, GLuint, GLint);
type PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC = extern "system" fn(GLuint, GLenum, GLuint, GLint, GLint);
type PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC = extern "system" fn(GLuint, GLenum);
type PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC = extern "system" fn(GLuint, GLsizei, *const GLenum);
type PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC = extern "system" fn(GLuint, GLenum);
type PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC = extern "system" fn(GLuint, GLsizei, *const GLenum);
type PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC = extern "system" fn(GLuint, GLsizei, *const GLenum, GLint, GLint, GLsizei, GLsizei);
type PFNGLCLEARNAMEDFRAMEBUFFERIVPROC = extern "system" fn(GLuint, GLenum, GLint, *const GLint);
type PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC = extern "system" fn(GLuint, GLenum, GLint, *const GLuint);
type PFNGLCLEARNAMEDFRAMEBUFFERFVPROC = extern "system" fn(GLuint, GLenum, GLint, *const GLfloat);
type PFNGLCLEARNAMEDFRAMEBUFFERFIPROC = extern "system" fn(GLuint, GLenum, GLint, GLfloat, GLint);
type PFNGLBLITNAMEDFRAMEBUFFERPROC = extern "system" fn(GLuint, GLuint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLbitfield, GLenum);
type PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC = extern "system" fn(GLuint, GLenum) -> GLenum;
type PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);
type PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC = extern "system" fn(GLuint, GLenum, GLenum, *mut GLint);
type PFNGLCREATERENDERBUFFERSPROC = extern "system" fn(GLsizei, *mut GLuint);
type PFNGLNAMEDRENDERBUFFERSTORAGEPROC = extern "system" fn(GLuint, GLenum, GLsizei, GLsizei);
type PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC = extern "system" fn(GLuint, GLsizei, GLenum, GLsizei, GLsizei);
type PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);
type PFNGLCREATETEXTURESPROC = extern "system" fn(GLenum, GLsizei, *mut GLuint);
type PFNGLTEXTUREBUFFERPROC = extern "system" fn(GLuint, GLenum, GLuint);
type PFNGLTEXTUREBUFFERRANGEPROC = extern "system" fn(GLuint, GLenum, GLuint, GLintptr, GLsizeiptr);
type PFNGLTEXTURESTORAGE1DPROC = extern "system" fn(GLuint, GLsizei, GLenum, GLsizei);
type PFNGLTEXTURESTORAGE2DPROC = extern "system" fn(GLuint, GLsizei, GLenum, GLsizei, GLsizei);
type PFNGLTEXTURESTORAGE3DPROC = extern "system" fn(GLuint, GLsizei, GLenum, GLsizei, GLsizei, GLsizei);
type PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC = extern "system" fn(GLuint, GLsizei, GLenum, GLsizei, GLsizei, GLboolean);
type PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC = extern "system" fn(GLuint, GLsizei, GLenum, GLsizei, GLsizei, GLsizei, GLboolean);
type PFNGLTEXTURESUBIMAGE1DPROC = extern "system" fn(GLuint, GLint, GLint, GLsizei, GLenum, GLenum, *const c_void);
type PFNGLTEXTURESUBIMAGE2DPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, *const c_void);
type PFNGLTEXTURESUBIMAGE3DPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, *const c_void);
type PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC = extern "system" fn(GLuint, GLint, GLint, GLsizei, GLenum, GLsizei, *const c_void);
type PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, *const c_void);
type PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, *const c_void);
type PFNGLCOPYTEXTURESUBIMAGE1DPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLsizei);
type PFNGLCOPYTEXTURESUBIMAGE2DPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
type PFNGLCOPYTEXTURESUBIMAGE3DPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
type PFNGLTEXTUREPARAMETERFPROC = extern "system" fn(GLuint, GLenum, GLfloat);
type PFNGLTEXTUREPARAMETERFVPROC = extern "system" fn(GLuint, GLenum, *const GLfloat);
type PFNGLTEXTUREPARAMETERIPROC = extern "system" fn(GLuint, GLenum, GLint);
type PFNGLTEXTUREPARAMETERIIVPROC = extern "system" fn(GLuint, GLenum, *const GLint);
type PFNGLTEXTUREPARAMETERIUIVPROC = extern "system" fn(GLuint, GLenum, *const GLuint);
type PFNGLTEXTUREPARAMETERIVPROC = extern "system" fn(GLuint, GLenum, *const GLint);
type PFNGLGENERATETEXTUREMIPMAPPROC = extern "system" fn(GLuint);
type PFNGLBINDTEXTUREUNITPROC = extern "system" fn(GLuint, GLuint);
type PFNGLGETTEXTUREIMAGEPROC = extern "system" fn(GLuint, GLint, GLenum, GLenum, GLsizei, *mut c_void);
type PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC = extern "system" fn(GLuint, GLint, GLsizei, *mut c_void);
type PFNGLGETTEXTURELEVELPARAMETERFVPROC = extern "system" fn(GLuint, GLint, GLenum, *mut GLfloat);
type PFNGLGETTEXTURELEVELPARAMETERIVPROC = extern "system" fn(GLuint, GLint, GLenum, *mut GLint);
type PFNGLGETTEXTUREPARAMETERFVPROC = extern "system" fn(GLuint, GLenum, *mut GLfloat);
type PFNGLGETTEXTUREPARAMETERIIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);
type PFNGLGETTEXTUREPARAMETERIUIVPROC = extern "system" fn(GLuint, GLenum, *mut GLuint);
type PFNGLGETTEXTUREPARAMETERIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);
type PFNGLCREATEVERTEXARRAYSPROC = extern "system" fn(GLsizei, *mut GLuint);
type PFNGLDISABLEVERTEXARRAYATTRIBPROC = extern "system" fn(GLuint, GLuint);
type PFNGLENABLEVERTEXARRAYATTRIBPROC = extern "system" fn(GLuint, GLuint);
type PFNGLVERTEXARRAYELEMENTBUFFERPROC = extern "system" fn(GLuint, GLuint);
type PFNGLVERTEXARRAYVERTEXBUFFERPROC = extern "system" fn(GLuint, GLuint, GLuint, GLintptr, GLsizei);
type PFNGLVERTEXARRAYVERTEXBUFFERSPROC = extern "system" fn(GLuint, GLuint, GLsizei, *const GLuint, *const GLintptr, *const GLsizei);
type PFNGLVERTEXARRAYATTRIBBINDINGPROC = extern "system" fn(GLuint, GLuint, GLuint);
type PFNGLVERTEXARRAYATTRIBFORMATPROC = extern "system" fn(GLuint, GLuint, GLint, GLenum, GLboolean, GLuint);
type PFNGLVERTEXARRAYATTRIBIFORMATPROC = extern "system" fn(GLuint, GLuint, GLint, GLenum, GLuint);
type PFNGLVERTEXARRAYATTRIBLFORMATPROC = extern "system" fn(GLuint, GLuint, GLint, GLenum, GLuint);
type PFNGLVERTEXARRAYBINDINGDIVISORPROC = extern "system" fn(GLuint, GLuint, GLuint);
type PFNGLGETVERTEXARRAYIVPROC = extern "system" fn(GLuint, GLenum, *mut GLint);
type PFNGLGETVERTEXARRAYINDEXEDIVPROC = extern "system" fn(GLuint, GLuint, GLenum, *mut GLint);
type PFNGLGETVERTEXARRAYINDEXED64IVPROC = extern "system" fn(GLuint, GLuint, GLenum, *mut GLint64);
type PFNGLCREATESAMPLERSPROC = extern "system" fn(GLsizei, *mut GLuint);
type PFNGLCREATEPROGRAMPIPELINESPROC = extern "system" fn(GLsizei, *mut GLuint);
type PFNGLCREATEQUERIESPROC = extern "system" fn(GLenum, GLsizei, *mut GLuint);
type PFNGLGETQUERYBUFFEROBJECTI64VPROC = extern "system" fn(GLuint, GLuint, GLenum, GLintptr);
type PFNGLGETQUERYBUFFEROBJECTIVPROC = extern "system" fn(GLuint, GLuint, GLenum, GLintptr);
type PFNGLGETQUERYBUFFEROBJECTUI64VPROC = extern "system" fn(GLuint, GLuint, GLenum, GLintptr);
type PFNGLGETQUERYBUFFEROBJECTUIVPROC = extern "system" fn(GLuint, GLuint, GLenum, GLintptr);
type PFNGLMEMORYBARRIERBYREGIONPROC = extern "system" fn(GLbitfield);
type PFNGLGETTEXTURESUBIMAGEPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, GLsizei, *mut c_void);
type PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC = extern "system" fn(GLuint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLsizei, *mut c_void);
type PFNGLGETGRAPHICSRESETSTATUSPROC = extern "system" fn() -> GLenum;
type PFNGLGETNCOMPRESSEDTEXIMAGEPROC = extern "system" fn(GLenum, GLint, GLsizei, *mut c_void);
type PFNGLGETNTEXIMAGEPROC = extern "system" fn(GLenum, GLint, GLenum, GLenum, GLsizei, *mut c_void);
type PFNGLGETNUNIFORMDVPROC = extern "system" fn(GLuint, GLint, GLsizei, *mut GLdouble);
type PFNGLGETNUNIFORMFVPROC = extern "system" fn(GLuint, GLint, GLsizei, *mut GLfloat);
type PFNGLGETNUNIFORMIVPROC = extern "system" fn(GLuint, GLint, GLsizei, *mut GLint);
type PFNGLGETNUNIFORMUIVPROC = extern "system" fn(GLuint, GLint, GLsizei, *mut GLuint);
type PFNGLREADNPIXELSPROC = extern "system" fn(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLsizei, *mut c_void);
type PFNGLGETNMAPDVPROC = extern "system" fn(GLenum, GLenum, GLsizei, *mut GLdouble);
type PFNGLGETNMAPFVPROC = extern "system" fn(GLenum, GLenum, GLsizei, *mut GLfloat);
type PFNGLGETNMAPIVPROC = extern "system" fn(GLenum, GLenum, GLsizei, *mut GLint);
type PFNGLGETNPIXELMAPFVPROC = extern "system" fn(GLenum, GLsizei, *mut GLfloat);
type PFNGLGETNPIXELMAPUIVPROC = extern "system" fn(GLenum, GLsizei, *mut GLuint);
type PFNGLGETNPIXELMAPUSVPROC = extern "system" fn(GLenum, GLsizei, *mut GLushort);
type PFNGLGETNPOLYGONSTIPPLEPROC = extern "system" fn(GLsizei, *mut GLubyte);
type PFNGLGETNCOLORTABLEPROC = extern "system" fn(GLenum, GLenum, GLenum, GLsizei, *mut c_void);
type PFNGLGETNCONVOLUTIONFILTERPROC = extern "system" fn(GLenum, GLenum, GLenum, GLsizei, *mut c_void);
type PFNGLGETNSEPARABLEFILTERPROC = extern "system" fn(GLenum, GLenum, GLenum, GLsizei, *mut c_void, GLsizei, *mut c_void, *mut c_void);
type PFNGLGETNHISTOGRAMPROC = extern "system" fn(GLenum, GLboolean, GLenum, GLenum, GLsizei, *mut c_void);
type PFNGLGETNMINMAXPROC = extern "system" fn(GLenum, GLboolean, GLenum, GLenum, GLsizei, *mut c_void);
type PFNGLTEXTUREBARRIERPROC = extern "system" fn();
extern "system" fn dummy_pfnglclipcontrolproc (_: GLenum, _: GLenum) {
	panic!("OpenGL function pointer `glClipControl()` is null.")
}
extern "system" fn dummy_pfnglcreatetransformfeedbacksproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glCreateTransformFeedbacks()` is null.")
}
extern "system" fn dummy_pfngltransformfeedbackbufferbaseproc (_: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glTransformFeedbackBufferBase()` is null.")
}
extern "system" fn dummy_pfngltransformfeedbackbufferrangeproc (_: GLuint, _: GLuint, _: GLuint, _: GLintptr, _: GLsizeiptr) {
	panic!("OpenGL function pointer `glTransformFeedbackBufferRange()` is null.")
}
extern "system" fn dummy_pfnglgettransformfeedbackivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetTransformFeedbackiv()` is null.")
}
extern "system" fn dummy_pfnglgettransformfeedbacki_vproc (_: GLuint, _: GLenum, _: GLuint, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetTransformFeedbacki_v()` is null.")
}
extern "system" fn dummy_pfnglgettransformfeedbacki64_vproc (_: GLuint, _: GLenum, _: GLuint, _: *mut GLint64) {
	panic!("OpenGL function pointer `glGetTransformFeedbacki64_v()` is null.")
}
extern "system" fn dummy_pfnglcreatebuffersproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glCreateBuffers()` is null.")
}
extern "system" fn dummy_pfnglnamedbufferstorageproc (_: GLuint, _: GLsizeiptr, _: *const c_void, _: GLbitfield) {
	panic!("OpenGL function pointer `glNamedBufferStorage()` is null.")
}
extern "system" fn dummy_pfnglnamedbufferdataproc (_: GLuint, _: GLsizeiptr, _: *const c_void, _: GLenum) {
	panic!("OpenGL function pointer `glNamedBufferData()` is null.")
}
extern "system" fn dummy_pfnglnamedbuffersubdataproc (_: GLuint, _: GLintptr, _: GLsizeiptr, _: *const c_void) {
	panic!("OpenGL function pointer `glNamedBufferSubData()` is null.")
}
extern "system" fn dummy_pfnglcopynamedbuffersubdataproc (_: GLuint, _: GLuint, _: GLintptr, _: GLintptr, _: GLsizeiptr) {
	panic!("OpenGL function pointer `glCopyNamedBufferSubData()` is null.")
}
extern "system" fn dummy_pfnglclearnamedbufferdataproc (_: GLuint, _: GLenum, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glClearNamedBufferData()` is null.")
}
extern "system" fn dummy_pfnglclearnamedbuffersubdataproc (_: GLuint, _: GLenum, _: GLintptr, _: GLsizeiptr, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glClearNamedBufferSubData()` is null.")
}
extern "system" fn dummy_pfnglmapnamedbufferproc (_: GLuint, _: GLenum) -> *mut c_void {
	panic!("OpenGL function pointer `glMapNamedBuffer()` is null.")
}
extern "system" fn dummy_pfnglmapnamedbufferrangeproc (_: GLuint, _: GLintptr, _: GLsizeiptr, _: GLbitfield) -> *mut c_void {
	panic!("OpenGL function pointer `glMapNamedBufferRange()` is null.")
}
extern "system" fn dummy_pfnglunmapnamedbufferproc (_: GLuint) -> GLboolean {
	panic!("OpenGL function pointer `glUnmapNamedBuffer()` is null.")
}
extern "system" fn dummy_pfnglflushmappednamedbufferrangeproc (_: GLuint, _: GLintptr, _: GLsizeiptr) {
	panic!("OpenGL function pointer `glFlushMappedNamedBufferRange()` is null.")
}
extern "system" fn dummy_pfnglgetnamedbufferparameterivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetNamedBufferParameteriv()` is null.")
}
extern "system" fn dummy_pfnglgetnamedbufferparameteri64vproc (_: GLuint, _: GLenum, _: *mut GLint64) {
	panic!("OpenGL function pointer `glGetNamedBufferParameteri64v()` is null.")
}
extern "system" fn dummy_pfnglgetnamedbufferpointervproc (_: GLuint, _: GLenum, _: *mut *mut c_void) {
	panic!("OpenGL function pointer `glGetNamedBufferPointerv()` is null.")
}
extern "system" fn dummy_pfnglgetnamedbuffersubdataproc (_: GLuint, _: GLintptr, _: GLsizeiptr, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetNamedBufferSubData()` is null.")
}
extern "system" fn dummy_pfnglcreateframebuffersproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glCreateFramebuffers()` is null.")
}
extern "system" fn dummy_pfnglnamedframebufferrenderbufferproc (_: GLuint, _: GLenum, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glNamedFramebufferRenderbuffer()` is null.")
}
extern "system" fn dummy_pfnglnamedframebufferparameteriproc (_: GLuint, _: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glNamedFramebufferParameteri()` is null.")
}
extern "system" fn dummy_pfnglnamedframebuffertextureproc (_: GLuint, _: GLenum, _: GLuint, _: GLint) {
	panic!("OpenGL function pointer `glNamedFramebufferTexture()` is null.")
}
extern "system" fn dummy_pfnglnamedframebuffertexturelayerproc (_: GLuint, _: GLenum, _: GLuint, _: GLint, _: GLint) {
	panic!("OpenGL function pointer `glNamedFramebufferTextureLayer()` is null.")
}
extern "system" fn dummy_pfnglnamedframebufferdrawbufferproc (_: GLuint, _: GLenum) {
	panic!("OpenGL function pointer `glNamedFramebufferDrawBuffer()` is null.")
}
extern "system" fn dummy_pfnglnamedframebufferdrawbuffersproc (_: GLuint, _: GLsizei, _: *const GLenum) {
	panic!("OpenGL function pointer `glNamedFramebufferDrawBuffers()` is null.")
}
extern "system" fn dummy_pfnglnamedframebufferreadbufferproc (_: GLuint, _: GLenum) {
	panic!("OpenGL function pointer `glNamedFramebufferReadBuffer()` is null.")
}
extern "system" fn dummy_pfnglinvalidatenamedframebufferdataproc (_: GLuint, _: GLsizei, _: *const GLenum) {
	panic!("OpenGL function pointer `glInvalidateNamedFramebufferData()` is null.")
}
extern "system" fn dummy_pfnglinvalidatenamedframebuffersubdataproc (_: GLuint, _: GLsizei, _: *const GLenum, _: GLint, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glInvalidateNamedFramebufferSubData()` is null.")
}
extern "system" fn dummy_pfnglclearnamedframebufferivproc (_: GLuint, _: GLenum, _: GLint, _: *const GLint) {
	panic!("OpenGL function pointer `glClearNamedFramebufferiv()` is null.")
}
extern "system" fn dummy_pfnglclearnamedframebufferuivproc (_: GLuint, _: GLenum, _: GLint, _: *const GLuint) {
	panic!("OpenGL function pointer `glClearNamedFramebufferuiv()` is null.")
}
extern "system" fn dummy_pfnglclearnamedframebufferfvproc (_: GLuint, _: GLenum, _: GLint, _: *const GLfloat) {
	panic!("OpenGL function pointer `glClearNamedFramebufferfv()` is null.")
}
extern "system" fn dummy_pfnglclearnamedframebufferfiproc (_: GLuint, _: GLenum, _: GLint, _: GLfloat, _: GLint) {
	panic!("OpenGL function pointer `glClearNamedFramebufferfi()` is null.")
}
extern "system" fn dummy_pfnglblitnamedframebufferproc (_: GLuint, _: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLbitfield, _: GLenum) {
	panic!("OpenGL function pointer `glBlitNamedFramebuffer()` is null.")
}
extern "system" fn dummy_pfnglchecknamedframebufferstatusproc (_: GLuint, _: GLenum) -> GLenum {
	panic!("OpenGL function pointer `glCheckNamedFramebufferStatus()` is null.")
}
extern "system" fn dummy_pfnglgetnamedframebufferparameterivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetNamedFramebufferParameteriv()` is null.")
}
extern "system" fn dummy_pfnglgetnamedframebufferattachmentparameterivproc (_: GLuint, _: GLenum, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetNamedFramebufferAttachmentParameteriv()` is null.")
}
extern "system" fn dummy_pfnglcreaterenderbuffersproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glCreateRenderbuffers()` is null.")
}
extern "system" fn dummy_pfnglnamedrenderbufferstorageproc (_: GLuint, _: GLenum, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glNamedRenderbufferStorage()` is null.")
}
extern "system" fn dummy_pfnglnamedrenderbufferstoragemultisampleproc (_: GLuint, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glNamedRenderbufferStorageMultisample()` is null.")
}
extern "system" fn dummy_pfnglgetnamedrenderbufferparameterivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetNamedRenderbufferParameteriv()` is null.")
}
extern "system" fn dummy_pfnglcreatetexturesproc (_: GLenum, _: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glCreateTextures()` is null.")
}
extern "system" fn dummy_pfngltexturebufferproc (_: GLuint, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glTextureBuffer()` is null.")
}
extern "system" fn dummy_pfngltexturebufferrangeproc (_: GLuint, _: GLenum, _: GLuint, _: GLintptr, _: GLsizeiptr) {
	panic!("OpenGL function pointer `glTextureBufferRange()` is null.")
}
extern "system" fn dummy_pfngltexturestorage1dproc (_: GLuint, _: GLsizei, _: GLenum, _: GLsizei) {
	panic!("OpenGL function pointer `glTextureStorage1D()` is null.")
}
extern "system" fn dummy_pfngltexturestorage2dproc (_: GLuint, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glTextureStorage2D()` is null.")
}
extern "system" fn dummy_pfngltexturestorage3dproc (_: GLuint, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glTextureStorage3D()` is null.")
}
extern "system" fn dummy_pfngltexturestorage2dmultisampleproc (_: GLuint, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei, _: GLboolean) {
	panic!("OpenGL function pointer `glTextureStorage2DMultisample()` is null.")
}
extern "system" fn dummy_pfngltexturestorage3dmultisampleproc (_: GLuint, _: GLsizei, _: GLenum, _: GLsizei, _: GLsizei, _: GLsizei, _: GLboolean) {
	panic!("OpenGL function pointer `glTextureStorage3DMultisample()` is null.")
}
extern "system" fn dummy_pfngltexturesubimage1dproc (_: GLuint, _: GLint, _: GLint, _: GLsizei, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glTextureSubImage1D()` is null.")
}
extern "system" fn dummy_pfngltexturesubimage2dproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glTextureSubImage2D()` is null.")
}
extern "system" fn dummy_pfngltexturesubimage3dproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei, _: GLenum, _: GLenum, _: *const c_void) {
	panic!("OpenGL function pointer `glTextureSubImage3D()` is null.")
}
extern "system" fn dummy_pfnglcompressedtexturesubimage1dproc (_: GLuint, _: GLint, _: GLint, _: GLsizei, _: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glCompressedTextureSubImage1D()` is null.")
}
extern "system" fn dummy_pfnglcompressedtexturesubimage2dproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glCompressedTextureSubImage2D()` is null.")
}
extern "system" fn dummy_pfnglcompressedtexturesubimage3dproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei, _: GLenum, _: GLsizei, _: *const c_void) {
	panic!("OpenGL function pointer `glCompressedTextureSubImage3D()` is null.")
}
extern "system" fn dummy_pfnglcopytexturesubimage1dproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei) {
	panic!("OpenGL function pointer `glCopyTextureSubImage1D()` is null.")
}
extern "system" fn dummy_pfnglcopytexturesubimage2dproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glCopyTextureSubImage2D()` is null.")
}
extern "system" fn dummy_pfnglcopytexturesubimage3dproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glCopyTextureSubImage3D()` is null.")
}
extern "system" fn dummy_pfngltextureparameterfproc (_: GLuint, _: GLenum, _: GLfloat) {
	panic!("OpenGL function pointer `glTextureParameterf()` is null.")
}
extern "system" fn dummy_pfngltextureparameterfvproc (_: GLuint, _: GLenum, _: *const GLfloat) {
	panic!("OpenGL function pointer `glTextureParameterfv()` is null.")
}
extern "system" fn dummy_pfngltextureparameteriproc (_: GLuint, _: GLenum, _: GLint) {
	panic!("OpenGL function pointer `glTextureParameteri()` is null.")
}
extern "system" fn dummy_pfngltextureparameteriivproc (_: GLuint, _: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glTextureParameterIiv()` is null.")
}
extern "system" fn dummy_pfngltextureparameteriuivproc (_: GLuint, _: GLenum, _: *const GLuint) {
	panic!("OpenGL function pointer `glTextureParameterIuiv()` is null.")
}
extern "system" fn dummy_pfngltextureparameterivproc (_: GLuint, _: GLenum, _: *const GLint) {
	panic!("OpenGL function pointer `glTextureParameteriv()` is null.")
}
extern "system" fn dummy_pfnglgeneratetexturemipmapproc (_: GLuint) {
	panic!("OpenGL function pointer `glGenerateTextureMipmap()` is null.")
}
extern "system" fn dummy_pfnglbindtextureunitproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glBindTextureUnit()` is null.")
}
extern "system" fn dummy_pfnglgettextureimageproc (_: GLuint, _: GLint, _: GLenum, _: GLenum, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetTextureImage()` is null.")
}
extern "system" fn dummy_pfnglgetcompressedtextureimageproc (_: GLuint, _: GLint, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetCompressedTextureImage()` is null.")
}
extern "system" fn dummy_pfnglgettexturelevelparameterfvproc (_: GLuint, _: GLint, _: GLenum, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetTextureLevelParameterfv()` is null.")
}
extern "system" fn dummy_pfnglgettexturelevelparameterivproc (_: GLuint, _: GLint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetTextureLevelParameteriv()` is null.")
}
extern "system" fn dummy_pfnglgettextureparameterfvproc (_: GLuint, _: GLenum, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetTextureParameterfv()` is null.")
}
extern "system" fn dummy_pfnglgettextureparameteriivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetTextureParameterIiv()` is null.")
}
extern "system" fn dummy_pfnglgettextureparameteriuivproc (_: GLuint, _: GLenum, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetTextureParameterIuiv()` is null.")
}
extern "system" fn dummy_pfnglgettextureparameterivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetTextureParameteriv()` is null.")
}
extern "system" fn dummy_pfnglcreatevertexarraysproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glCreateVertexArrays()` is null.")
}
extern "system" fn dummy_pfngldisablevertexarrayattribproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glDisableVertexArrayAttrib()` is null.")
}
extern "system" fn dummy_pfnglenablevertexarrayattribproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glEnableVertexArrayAttrib()` is null.")
}
extern "system" fn dummy_pfnglvertexarrayelementbufferproc (_: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexArrayElementBuffer()` is null.")
}
extern "system" fn dummy_pfnglvertexarrayvertexbufferproc (_: GLuint, _: GLuint, _: GLuint, _: GLintptr, _: GLsizei) {
	panic!("OpenGL function pointer `glVertexArrayVertexBuffer()` is null.")
}
extern "system" fn dummy_pfnglvertexarrayvertexbuffersproc (_: GLuint, _: GLuint, _: GLsizei, _: *const GLuint, _: *const GLintptr, _: *const GLsizei) {
	panic!("OpenGL function pointer `glVertexArrayVertexBuffers()` is null.")
}
extern "system" fn dummy_pfnglvertexarrayattribbindingproc (_: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexArrayAttribBinding()` is null.")
}
extern "system" fn dummy_pfnglvertexarrayattribformatproc (_: GLuint, _: GLuint, _: GLint, _: GLenum, _: GLboolean, _: GLuint) {
	panic!("OpenGL function pointer `glVertexArrayAttribFormat()` is null.")
}
extern "system" fn dummy_pfnglvertexarrayattribiformatproc (_: GLuint, _: GLuint, _: GLint, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glVertexArrayAttribIFormat()` is null.")
}
extern "system" fn dummy_pfnglvertexarrayattriblformatproc (_: GLuint, _: GLuint, _: GLint, _: GLenum, _: GLuint) {
	panic!("OpenGL function pointer `glVertexArrayAttribLFormat()` is null.")
}
extern "system" fn dummy_pfnglvertexarraybindingdivisorproc (_: GLuint, _: GLuint, _: GLuint) {
	panic!("OpenGL function pointer `glVertexArrayBindingDivisor()` is null.")
}
extern "system" fn dummy_pfnglgetvertexarrayivproc (_: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetVertexArrayiv()` is null.")
}
extern "system" fn dummy_pfnglgetvertexarrayindexedivproc (_: GLuint, _: GLuint, _: GLenum, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetVertexArrayIndexediv()` is null.")
}
extern "system" fn dummy_pfnglgetvertexarrayindexed64ivproc (_: GLuint, _: GLuint, _: GLenum, _: *mut GLint64) {
	panic!("OpenGL function pointer `glGetVertexArrayIndexed64iv()` is null.")
}
extern "system" fn dummy_pfnglcreatesamplersproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glCreateSamplers()` is null.")
}
extern "system" fn dummy_pfnglcreateprogrampipelinesproc (_: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glCreateProgramPipelines()` is null.")
}
extern "system" fn dummy_pfnglcreatequeriesproc (_: GLenum, _: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glCreateQueries()` is null.")
}
extern "system" fn dummy_pfnglgetquerybufferobjecti64vproc (_: GLuint, _: GLuint, _: GLenum, _: GLintptr) {
	panic!("OpenGL function pointer `glGetQueryBufferObjecti64v()` is null.")
}
extern "system" fn dummy_pfnglgetquerybufferobjectivproc (_: GLuint, _: GLuint, _: GLenum, _: GLintptr) {
	panic!("OpenGL function pointer `glGetQueryBufferObjectiv()` is null.")
}
extern "system" fn dummy_pfnglgetquerybufferobjectui64vproc (_: GLuint, _: GLuint, _: GLenum, _: GLintptr) {
	panic!("OpenGL function pointer `glGetQueryBufferObjectui64v()` is null.")
}
extern "system" fn dummy_pfnglgetquerybufferobjectuivproc (_: GLuint, _: GLuint, _: GLenum, _: GLintptr) {
	panic!("OpenGL function pointer `glGetQueryBufferObjectuiv()` is null.")
}
extern "system" fn dummy_pfnglmemorybarrierbyregionproc (_: GLbitfield) {
	panic!("OpenGL function pointer `glMemoryBarrierByRegion()` is null.")
}
extern "system" fn dummy_pfnglgettexturesubimageproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei, _: GLenum, _: GLenum, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetTextureSubImage()` is null.")
}
extern "system" fn dummy_pfnglgetcompressedtexturesubimageproc (_: GLuint, _: GLint, _: GLint, _: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLsizei, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetCompressedTextureSubImage()` is null.")
}
extern "system" fn dummy_pfnglgetgraphicsresetstatusproc () -> GLenum {
	panic!("OpenGL function pointer `glGetGraphicsResetStatus()` is null.")
}
extern "system" fn dummy_pfnglgetncompressedteximageproc (_: GLenum, _: GLint, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetnCompressedTexImage()` is null.")
}
extern "system" fn dummy_pfnglgetnteximageproc (_: GLenum, _: GLint, _: GLenum, _: GLenum, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetnTexImage()` is null.")
}
extern "system" fn dummy_pfnglgetnuniformdvproc (_: GLuint, _: GLint, _: GLsizei, _: *mut GLdouble) {
	panic!("OpenGL function pointer `glGetnUniformdv()` is null.")
}
extern "system" fn dummy_pfnglgetnuniformfvproc (_: GLuint, _: GLint, _: GLsizei, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetnUniformfv()` is null.")
}
extern "system" fn dummy_pfnglgetnuniformivproc (_: GLuint, _: GLint, _: GLsizei, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetnUniformiv()` is null.")
}
extern "system" fn dummy_pfnglgetnuniformuivproc (_: GLuint, _: GLint, _: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetnUniformuiv()` is null.")
}
extern "system" fn dummy_pfnglreadnpixelsproc (_: GLint, _: GLint, _: GLsizei, _: GLsizei, _: GLenum, _: GLenum, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glReadnPixels()` is null.")
}
extern "system" fn dummy_pfnglgetnmapdvproc (_: GLenum, _: GLenum, _: GLsizei, _: *mut GLdouble) {
	panic!("OpenGL function pointer `glGetnMapdv()` is null.")
}
extern "system" fn dummy_pfnglgetnmapfvproc (_: GLenum, _: GLenum, _: GLsizei, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetnMapfv()` is null.")
}
extern "system" fn dummy_pfnglgetnmapivproc (_: GLenum, _: GLenum, _: GLsizei, _: *mut GLint) {
	panic!("OpenGL function pointer `glGetnMapiv()` is null.")
}
extern "system" fn dummy_pfnglgetnpixelmapfvproc (_: GLenum, _: GLsizei, _: *mut GLfloat) {
	panic!("OpenGL function pointer `glGetnPixelMapfv()` is null.")
}
extern "system" fn dummy_pfnglgetnpixelmapuivproc (_: GLenum, _: GLsizei, _: *mut GLuint) {
	panic!("OpenGL function pointer `glGetnPixelMapuiv()` is null.")
}
extern "system" fn dummy_pfnglgetnpixelmapusvproc (_: GLenum, _: GLsizei, _: *mut GLushort) {
	panic!("OpenGL function pointer `glGetnPixelMapusv()` is null.")
}
extern "system" fn dummy_pfnglgetnpolygonstippleproc (_: GLsizei, _: *mut GLubyte) {
	panic!("OpenGL function pointer `glGetnPolygonStipple()` is null.")
}
extern "system" fn dummy_pfnglgetncolortableproc (_: GLenum, _: GLenum, _: GLenum, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetnColorTable()` is null.")
}
extern "system" fn dummy_pfnglgetnconvolutionfilterproc (_: GLenum, _: GLenum, _: GLenum, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetnConvolutionFilter()` is null.")
}
extern "system" fn dummy_pfnglgetnseparablefilterproc (_: GLenum, _: GLenum, _: GLenum, _: GLsizei, _: *mut c_void, _: GLsizei, _: *mut c_void, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetnSeparableFilter()` is null.")
}
extern "system" fn dummy_pfnglgetnhistogramproc (_: GLenum, _: GLboolean, _: GLenum, _: GLenum, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetnHistogram()` is null.")
}
extern "system" fn dummy_pfnglgetnminmaxproc (_: GLenum, _: GLboolean, _: GLenum, _: GLenum, _: GLsizei, _: *mut c_void) {
	panic!("OpenGL function pointer `glGetnMinmax()` is null.")
}
extern "system" fn dummy_pfngltexturebarrierproc () {
	panic!("OpenGL function pointer `glTextureBarrier()` is null.")
}
pub const GL_CONTEXT_LOST: GLenum = 0x0507;
pub const GL_NEGATIVE_ONE_TO_ONE: GLenum = 0x935E;
pub const GL_ZERO_TO_ONE: GLenum = 0x935F;
pub const GL_CLIP_ORIGIN: GLenum = 0x935C;
pub const GL_CLIP_DEPTH_MODE: GLenum = 0x935D;
pub const GL_QUERY_WAIT_INVERTED: GLenum = 0x8E17;
pub const GL_QUERY_NO_WAIT_INVERTED: GLenum = 0x8E18;
pub const GL_QUERY_BY_REGION_WAIT_INVERTED: GLenum = 0x8E19;
pub const GL_QUERY_BY_REGION_NO_WAIT_INVERTED: GLenum = 0x8E1A;
pub const GL_MAX_CULL_DISTANCES: GLenum = 0x82F9;
pub const GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES: GLenum = 0x82FA;
pub const GL_TEXTURE_TARGET: GLenum = 0x1006;
pub const GL_QUERY_TARGET: GLenum = 0x82EA;
pub const GL_GUILTY_CONTEXT_RESET: GLenum = 0x8253;
pub const GL_INNOCENT_CONTEXT_RESET: GLenum = 0x8254;
pub const GL_UNKNOWN_CONTEXT_RESET: GLenum = 0x8255;
pub const GL_RESET_NOTIFICATION_STRATEGY: GLenum = 0x8256;
pub const GL_LOSE_CONTEXT_ON_RESET: GLenum = 0x8252;
pub const GL_NO_RESET_NOTIFICATION: GLenum = 0x8261;
pub const GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT: GLbitfield = 0x00000004;
pub const GL_COLOR_TABLE: GLenum = 0x80D0;
pub const GL_POST_CONVOLUTION_COLOR_TABLE: GLenum = 0x80D1;
pub const GL_POST_COLOR_MATRIX_COLOR_TABLE: GLenum = 0x80D2;
pub const GL_PROXY_COLOR_TABLE: GLenum = 0x80D3;
pub const GL_PROXY_POST_CONVOLUTION_COLOR_TABLE: GLenum = 0x80D4;
pub const GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE: GLenum = 0x80D5;
pub const GL_CONVOLUTION_1D: GLenum = 0x8010;
pub const GL_CONVOLUTION_2D: GLenum = 0x8011;
pub const GL_SEPARABLE_2D: GLenum = 0x8012;
pub const GL_HISTOGRAM: GLenum = 0x8024;
pub const GL_PROXY_HISTOGRAM: GLenum = 0x8025;
pub const GL_MINMAX: GLenum = 0x802E;
pub const GL_CONTEXT_RELEASE_BEHAVIOR: GLenum = 0x82FB;
pub const GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH: GLenum = 0x82FC;

pub trait GL_4_5 {
	fn glGetError(&self) -> GLenum;
	fn glClipControl(&self, origin: GLenum, depth: GLenum) -> Result<()>;
	fn glCreateTransformFeedbacks(&self, n: GLsizei, ids: *mut GLuint) -> Result<()>;
	fn glTransformFeedbackBufferBase(&self, xfb: GLuint, index: GLuint, buffer: GLuint) -> Result<()>;
	fn glTransformFeedbackBufferRange(&self, xfb: GLuint, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()>;
	fn glGetTransformFeedbackiv(&self, xfb: GLuint, pname: GLenum, param: *mut GLint) -> Result<()>;
	fn glGetTransformFeedbacki_v(&self, xfb: GLuint, pname: GLenum, index: GLuint, param: *mut GLint) -> Result<()>;
	fn glGetTransformFeedbacki64_v(&self, xfb: GLuint, pname: GLenum, index: GLuint, param: *mut GLint64) -> Result<()>;
	fn glCreateBuffers(&self, n: GLsizei, buffers: *mut GLuint) -> Result<()>;
	fn glNamedBufferStorage(&self, buffer: GLuint, size: GLsizeiptr, data: *const c_void, flags: GLbitfield) -> Result<()>;
	fn glNamedBufferData(&self, buffer: GLuint, size: GLsizeiptr, data: *const c_void, usage: GLenum) -> Result<()>;
	fn glNamedBufferSubData(&self, buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: *const c_void) -> Result<()>;
	fn glCopyNamedBufferSubData(&self, readBuffer: GLuint, writeBuffer: GLuint, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr) -> Result<()>;
	fn glClearNamedBufferData(&self, buffer: GLuint, internalformat: GLenum, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()>;
	fn glClearNamedBufferSubData(&self, buffer: GLuint, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()>;
	fn glMapNamedBuffer(&self, buffer: GLuint, access: GLenum) -> Result<*mut c_void>;
	fn glMapNamedBufferRange(&self, buffer: GLuint, offset: GLintptr, length: GLsizeiptr, access: GLbitfield) -> Result<*mut c_void>;
	fn glUnmapNamedBuffer(&self, buffer: GLuint) -> Result<GLboolean>;
	fn glFlushMappedNamedBufferRange(&self, buffer: GLuint, offset: GLintptr, length: GLsizeiptr) -> Result<()>;
	fn glGetNamedBufferParameteriv(&self, buffer: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glGetNamedBufferParameteri64v(&self, buffer: GLuint, pname: GLenum, params: *mut GLint64) -> Result<()>;
	fn glGetNamedBufferPointerv(&self, buffer: GLuint, pname: GLenum, params: *mut *mut c_void) -> Result<()>;
	fn glGetNamedBufferSubData(&self, buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: *mut c_void) -> Result<()>;
	fn glCreateFramebuffers(&self, n: GLsizei, framebuffers: *mut GLuint) -> Result<()>;
	fn glNamedFramebufferRenderbuffer(&self, framebuffer: GLuint, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint) -> Result<()>;
	fn glNamedFramebufferParameteri(&self, framebuffer: GLuint, pname: GLenum, param: GLint) -> Result<()>;
	fn glNamedFramebufferTexture(&self, framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint) -> Result<()>;
	fn glNamedFramebufferTextureLayer(&self, framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint) -> Result<()>;
	fn glNamedFramebufferDrawBuffer(&self, framebuffer: GLuint, buf: GLenum) -> Result<()>;
	fn glNamedFramebufferDrawBuffers(&self, framebuffer: GLuint, n: GLsizei, bufs: *const GLenum) -> Result<()>;
	fn glNamedFramebufferReadBuffer(&self, framebuffer: GLuint, src: GLenum) -> Result<()>;
	fn glInvalidateNamedFramebufferData(&self, framebuffer: GLuint, numAttachments: GLsizei, attachments: *const GLenum) -> Result<()>;
	fn glInvalidateNamedFramebufferSubData(&self, framebuffer: GLuint, numAttachments: GLsizei, attachments: *const GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()>;
	fn glClearNamedFramebufferiv(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLint) -> Result<()>;
	fn glClearNamedFramebufferuiv(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLuint) -> Result<()>;
	fn glClearNamedFramebufferfv(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLfloat) -> Result<()>;
	fn glClearNamedFramebufferfi(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint) -> Result<()>;
	fn glBlitNamedFramebuffer(&self, readFramebuffer: GLuint, drawFramebuffer: GLuint, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum) -> Result<()>;
	fn glCheckNamedFramebufferStatus(&self, framebuffer: GLuint, target: GLenum) -> Result<GLenum>;
	fn glGetNamedFramebufferParameteriv(&self, framebuffer: GLuint, pname: GLenum, param: *mut GLint) -> Result<()>;
	fn glGetNamedFramebufferAttachmentParameteriv(&self, framebuffer: GLuint, attachment: GLenum, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glCreateRenderbuffers(&self, n: GLsizei, renderbuffers: *mut GLuint) -> Result<()>;
	fn glNamedRenderbufferStorage(&self, renderbuffer: GLuint, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()>;
	fn glNamedRenderbufferStorageMultisample(&self, renderbuffer: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()>;
	fn glGetNamedRenderbufferParameteriv(&self, renderbuffer: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glCreateTextures(&self, target: GLenum, n: GLsizei, textures: *mut GLuint) -> Result<()>;
	fn glTextureBuffer(&self, texture: GLuint, internalformat: GLenum, buffer: GLuint) -> Result<()>;
	fn glTextureBufferRange(&self, texture: GLuint, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()>;
	fn glTextureStorage1D(&self, texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei) -> Result<()>;
	fn glTextureStorage2D(&self, texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()>;
	fn glTextureStorage3D(&self, texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei) -> Result<()>;
	fn glTextureStorage2DMultisample(&self, texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean) -> Result<()>;
	fn glTextureStorage3DMultisample(&self, texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean) -> Result<()>;
	fn glTextureSubImage1D(&self, texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()>;
	fn glTextureSubImage2D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()>;
	fn glTextureSubImage3D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()>;
	fn glCompressedTextureSubImage1D(&self, texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()>;
	fn glCompressedTextureSubImage2D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()>;
	fn glCompressedTextureSubImage3D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()>;
	fn glCopyTextureSubImage1D(&self, texture: GLuint, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei) -> Result<()>;
	fn glCopyTextureSubImage2D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()>;
	fn glCopyTextureSubImage3D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()>;
	fn glTextureParameterf(&self, texture: GLuint, pname: GLenum, param: GLfloat) -> Result<()>;
	fn glTextureParameterfv(&self, texture: GLuint, pname: GLenum, param: *const GLfloat) -> Result<()>;
	fn glTextureParameteri(&self, texture: GLuint, pname: GLenum, param: GLint) -> Result<()>;
	fn glTextureParameterIiv(&self, texture: GLuint, pname: GLenum, params: *const GLint) -> Result<()>;
	fn glTextureParameterIuiv(&self, texture: GLuint, pname: GLenum, params: *const GLuint) -> Result<()>;
	fn glTextureParameteriv(&self, texture: GLuint, pname: GLenum, param: *const GLint) -> Result<()>;
	fn glGenerateTextureMipmap(&self, texture: GLuint) -> Result<()>;
	fn glBindTextureUnit(&self, unit: GLuint, texture: GLuint) -> Result<()>;
	fn glGetTextureImage(&self, texture: GLuint, level: GLint, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut c_void) -> Result<()>;
	fn glGetCompressedTextureImage(&self, texture: GLuint, level: GLint, bufSize: GLsizei, pixels: *mut c_void) -> Result<()>;
	fn glGetTextureLevelParameterfv(&self, texture: GLuint, level: GLint, pname: GLenum, params: *mut GLfloat) -> Result<()>;
	fn glGetTextureLevelParameteriv(&self, texture: GLuint, level: GLint, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glGetTextureParameterfv(&self, texture: GLuint, pname: GLenum, params: *mut GLfloat) -> Result<()>;
	fn glGetTextureParameterIiv(&self, texture: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glGetTextureParameterIuiv(&self, texture: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()>;
	fn glGetTextureParameteriv(&self, texture: GLuint, pname: GLenum, params: *mut GLint) -> Result<()>;
	fn glCreateVertexArrays(&self, n: GLsizei, arrays: *mut GLuint) -> Result<()>;
	fn glDisableVertexArrayAttrib(&self, vaobj: GLuint, index: GLuint) -> Result<()>;
	fn glEnableVertexArrayAttrib(&self, vaobj: GLuint, index: GLuint) -> Result<()>;
	fn glVertexArrayElementBuffer(&self, vaobj: GLuint, buffer: GLuint) -> Result<()>;
	fn glVertexArrayVertexBuffer(&self, vaobj: GLuint, bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei) -> Result<()>;
	fn glVertexArrayVertexBuffers(&self, vaobj: GLuint, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, strides: *const GLsizei) -> Result<()>;
	fn glVertexArrayAttribBinding(&self, vaobj: GLuint, attribindex: GLuint, bindingindex: GLuint) -> Result<()>;
	fn glVertexArrayAttribFormat(&self, vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, relativeoffset: GLuint) -> Result<()>;
	fn glVertexArrayAttribIFormat(&self, vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()>;
	fn glVertexArrayAttribLFormat(&self, vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()>;
	fn glVertexArrayBindingDivisor(&self, vaobj: GLuint, bindingindex: GLuint, divisor: GLuint) -> Result<()>;
	fn glGetVertexArrayiv(&self, vaobj: GLuint, pname: GLenum, param: *mut GLint) -> Result<()>;
	fn glGetVertexArrayIndexediv(&self, vaobj: GLuint, index: GLuint, pname: GLenum, param: *mut GLint) -> Result<()>;
	fn glGetVertexArrayIndexed64iv(&self, vaobj: GLuint, index: GLuint, pname: GLenum, param: *mut GLint64) -> Result<()>;
	fn glCreateSamplers(&self, n: GLsizei, samplers: *mut GLuint) -> Result<()>;
	fn glCreateProgramPipelines(&self, n: GLsizei, pipelines: *mut GLuint) -> Result<()>;
	fn glCreateQueries(&self, target: GLenum, n: GLsizei, ids: *mut GLuint) -> Result<()>;
	fn glGetQueryBufferObjecti64v(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()>;
	fn glGetQueryBufferObjectiv(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()>;
	fn glGetQueryBufferObjectui64v(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()>;
	fn glGetQueryBufferObjectuiv(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()>;
	fn glMemoryBarrierByRegion(&self, barriers: GLbitfield) -> Result<()>;
	fn glGetTextureSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut c_void) -> Result<()>;
	fn glGetCompressedTextureSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, bufSize: GLsizei, pixels: *mut c_void) -> Result<()>;
	fn glGetGraphicsResetStatus(&self) -> Result<GLenum>;
	fn glGetnCompressedTexImage(&self, target: GLenum, lod: GLint, bufSize: GLsizei, pixels: *mut c_void) -> Result<()>;
	fn glGetnTexImage(&self, target: GLenum, level: GLint, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut c_void) -> Result<()>;
	fn glGetnUniformdv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLdouble) -> Result<()>;
	fn glGetnUniformfv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLfloat) -> Result<()>;
	fn glGetnUniformiv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLint) -> Result<()>;
	fn glGetnUniformuiv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLuint) -> Result<()>;
	fn glReadnPixels(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, bufSize: GLsizei, data: *mut c_void) -> Result<()>;
	fn glGetnMapdv(&self, target: GLenum, query: GLenum, bufSize: GLsizei, v: *mut GLdouble) -> Result<()>;
	fn glGetnMapfv(&self, target: GLenum, query: GLenum, bufSize: GLsizei, v: *mut GLfloat) -> Result<()>;
	fn glGetnMapiv(&self, target: GLenum, query: GLenum, bufSize: GLsizei, v: *mut GLint) -> Result<()>;
	fn glGetnPixelMapfv(&self, map: GLenum, bufSize: GLsizei, values: *mut GLfloat) -> Result<()>;
	fn glGetnPixelMapuiv(&self, map: GLenum, bufSize: GLsizei, values: *mut GLuint) -> Result<()>;
	fn glGetnPixelMapusv(&self, map: GLenum, bufSize: GLsizei, values: *mut GLushort) -> Result<()>;
	fn glGetnPolygonStipple(&self, bufSize: GLsizei, pattern: *mut GLubyte) -> Result<()>;
	fn glGetnColorTable(&self, target: GLenum, format: GLenum, type_: GLenum, bufSize: GLsizei, table: *mut c_void) -> Result<()>;
	fn glGetnConvolutionFilter(&self, target: GLenum, format: GLenum, type_: GLenum, bufSize: GLsizei, image: *mut c_void) -> Result<()>;
	fn glGetnSeparableFilter(&self, target: GLenum, format: GLenum, type_: GLenum, rowBufSize: GLsizei, row: *mut c_void, columnBufSize: GLsizei, column: *mut c_void, span: *mut c_void) -> Result<()>;
	fn glGetnHistogram(&self, target: GLenum, reset: GLboolean, format: GLenum, type_: GLenum, bufSize: GLsizei, values: *mut c_void) -> Result<()>;
	fn glGetnMinmax(&self, target: GLenum, reset: GLboolean, format: GLenum, type_: GLenum, bufSize: GLsizei, values: *mut c_void) -> Result<()>;
	fn glTextureBarrier(&self) -> Result<()>;
}

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version45 {
	available: bool,
	geterror: PFNGLGETERRORPROC,
	clipcontrol: PFNGLCLIPCONTROLPROC,
	createtransformfeedbacks: PFNGLCREATETRANSFORMFEEDBACKSPROC,
	transformfeedbackbufferbase: PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC,
	transformfeedbackbufferrange: PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC,
	gettransformfeedbackiv: PFNGLGETTRANSFORMFEEDBACKIVPROC,
	gettransformfeedbacki_v: PFNGLGETTRANSFORMFEEDBACKI_VPROC,
	gettransformfeedbacki64_v: PFNGLGETTRANSFORMFEEDBACKI64_VPROC,
	createbuffers: PFNGLCREATEBUFFERSPROC,
	namedbufferstorage: PFNGLNAMEDBUFFERSTORAGEPROC,
	namedbufferdata: PFNGLNAMEDBUFFERDATAPROC,
	namedbuffersubdata: PFNGLNAMEDBUFFERSUBDATAPROC,
	copynamedbuffersubdata: PFNGLCOPYNAMEDBUFFERSUBDATAPROC,
	clearnamedbufferdata: PFNGLCLEARNAMEDBUFFERDATAPROC,
	clearnamedbuffersubdata: PFNGLCLEARNAMEDBUFFERSUBDATAPROC,
	mapnamedbuffer: PFNGLMAPNAMEDBUFFERPROC,
	mapnamedbufferrange: PFNGLMAPNAMEDBUFFERRANGEPROC,
	unmapnamedbuffer: PFNGLUNMAPNAMEDBUFFERPROC,
	flushmappednamedbufferrange: PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC,
	getnamedbufferparameteriv: PFNGLGETNAMEDBUFFERPARAMETERIVPROC,
	getnamedbufferparameteri64v: PFNGLGETNAMEDBUFFERPARAMETERI64VPROC,
	getnamedbufferpointerv: PFNGLGETNAMEDBUFFERPOINTERVPROC,
	getnamedbuffersubdata: PFNGLGETNAMEDBUFFERSUBDATAPROC,
	createframebuffers: PFNGLCREATEFRAMEBUFFERSPROC,
	namedframebufferrenderbuffer: PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC,
	namedframebufferparameteri: PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC,
	namedframebuffertexture: PFNGLNAMEDFRAMEBUFFERTEXTUREPROC,
	namedframebuffertexturelayer: PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC,
	namedframebufferdrawbuffer: PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC,
	namedframebufferdrawbuffers: PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC,
	namedframebufferreadbuffer: PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC,
	invalidatenamedframebufferdata: PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC,
	invalidatenamedframebuffersubdata: PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC,
	clearnamedframebufferiv: PFNGLCLEARNAMEDFRAMEBUFFERIVPROC,
	clearnamedframebufferuiv: PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC,
	clearnamedframebufferfv: PFNGLCLEARNAMEDFRAMEBUFFERFVPROC,
	clearnamedframebufferfi: PFNGLCLEARNAMEDFRAMEBUFFERFIPROC,
	blitnamedframebuffer: PFNGLBLITNAMEDFRAMEBUFFERPROC,
	checknamedframebufferstatus: PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC,
	getnamedframebufferparameteriv: PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC,
	getnamedframebufferattachmentparameteriv: PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC,
	createrenderbuffers: PFNGLCREATERENDERBUFFERSPROC,
	namedrenderbufferstorage: PFNGLNAMEDRENDERBUFFERSTORAGEPROC,
	namedrenderbufferstoragemultisample: PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC,
	getnamedrenderbufferparameteriv: PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC,
	createtextures: PFNGLCREATETEXTURESPROC,
	texturebuffer: PFNGLTEXTUREBUFFERPROC,
	texturebufferrange: PFNGLTEXTUREBUFFERRANGEPROC,
	texturestorage1d: PFNGLTEXTURESTORAGE1DPROC,
	texturestorage2d: PFNGLTEXTURESTORAGE2DPROC,
	texturestorage3d: PFNGLTEXTURESTORAGE3DPROC,
	texturestorage2dmultisample: PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC,
	texturestorage3dmultisample: PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC,
	texturesubimage1d: PFNGLTEXTURESUBIMAGE1DPROC,
	texturesubimage2d: PFNGLTEXTURESUBIMAGE2DPROC,
	texturesubimage3d: PFNGLTEXTURESUBIMAGE3DPROC,
	compressedtexturesubimage1d: PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC,
	compressedtexturesubimage2d: PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC,
	compressedtexturesubimage3d: PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC,
	copytexturesubimage1d: PFNGLCOPYTEXTURESUBIMAGE1DPROC,
	copytexturesubimage2d: PFNGLCOPYTEXTURESUBIMAGE2DPROC,
	copytexturesubimage3d: PFNGLCOPYTEXTURESUBIMAGE3DPROC,
	textureparameterf: PFNGLTEXTUREPARAMETERFPROC,
	textureparameterfv: PFNGLTEXTUREPARAMETERFVPROC,
	textureparameteri: PFNGLTEXTUREPARAMETERIPROC,
	textureparameteriiv: PFNGLTEXTUREPARAMETERIIVPROC,
	textureparameteriuiv: PFNGLTEXTUREPARAMETERIUIVPROC,
	textureparameteriv: PFNGLTEXTUREPARAMETERIVPROC,
	generatetexturemipmap: PFNGLGENERATETEXTUREMIPMAPPROC,
	bindtextureunit: PFNGLBINDTEXTUREUNITPROC,
	gettextureimage: PFNGLGETTEXTUREIMAGEPROC,
	getcompressedtextureimage: PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC,
	gettexturelevelparameterfv: PFNGLGETTEXTURELEVELPARAMETERFVPROC,
	gettexturelevelparameteriv: PFNGLGETTEXTURELEVELPARAMETERIVPROC,
	gettextureparameterfv: PFNGLGETTEXTUREPARAMETERFVPROC,
	gettextureparameteriiv: PFNGLGETTEXTUREPARAMETERIIVPROC,
	gettextureparameteriuiv: PFNGLGETTEXTUREPARAMETERIUIVPROC,
	gettextureparameteriv: PFNGLGETTEXTUREPARAMETERIVPROC,
	createvertexarrays: PFNGLCREATEVERTEXARRAYSPROC,
	disablevertexarrayattrib: PFNGLDISABLEVERTEXARRAYATTRIBPROC,
	enablevertexarrayattrib: PFNGLENABLEVERTEXARRAYATTRIBPROC,
	vertexarrayelementbuffer: PFNGLVERTEXARRAYELEMENTBUFFERPROC,
	vertexarrayvertexbuffer: PFNGLVERTEXARRAYVERTEXBUFFERPROC,
	vertexarrayvertexbuffers: PFNGLVERTEXARRAYVERTEXBUFFERSPROC,
	vertexarrayattribbinding: PFNGLVERTEXARRAYATTRIBBINDINGPROC,
	vertexarrayattribformat: PFNGLVERTEXARRAYATTRIBFORMATPROC,
	vertexarrayattribiformat: PFNGLVERTEXARRAYATTRIBIFORMATPROC,
	vertexarrayattriblformat: PFNGLVERTEXARRAYATTRIBLFORMATPROC,
	vertexarraybindingdivisor: PFNGLVERTEXARRAYBINDINGDIVISORPROC,
	getvertexarrayiv: PFNGLGETVERTEXARRAYIVPROC,
	getvertexarrayindexediv: PFNGLGETVERTEXARRAYINDEXEDIVPROC,
	getvertexarrayindexed64iv: PFNGLGETVERTEXARRAYINDEXED64IVPROC,
	createsamplers: PFNGLCREATESAMPLERSPROC,
	createprogrampipelines: PFNGLCREATEPROGRAMPIPELINESPROC,
	createqueries: PFNGLCREATEQUERIESPROC,
	getquerybufferobjecti64v: PFNGLGETQUERYBUFFEROBJECTI64VPROC,
	getquerybufferobjectiv: PFNGLGETQUERYBUFFEROBJECTIVPROC,
	getquerybufferobjectui64v: PFNGLGETQUERYBUFFEROBJECTUI64VPROC,
	getquerybufferobjectuiv: PFNGLGETQUERYBUFFEROBJECTUIVPROC,
	memorybarrierbyregion: PFNGLMEMORYBARRIERBYREGIONPROC,
	gettexturesubimage: PFNGLGETTEXTURESUBIMAGEPROC,
	getcompressedtexturesubimage: PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC,
	getgraphicsresetstatus: PFNGLGETGRAPHICSRESETSTATUSPROC,
	getncompressedteximage: PFNGLGETNCOMPRESSEDTEXIMAGEPROC,
	getnteximage: PFNGLGETNTEXIMAGEPROC,
	getnuniformdv: PFNGLGETNUNIFORMDVPROC,
	getnuniformfv: PFNGLGETNUNIFORMFVPROC,
	getnuniformiv: PFNGLGETNUNIFORMIVPROC,
	getnuniformuiv: PFNGLGETNUNIFORMUIVPROC,
	readnpixels: PFNGLREADNPIXELSPROC,
	getnmapdv: PFNGLGETNMAPDVPROC,
	getnmapfv: PFNGLGETNMAPFVPROC,
	getnmapiv: PFNGLGETNMAPIVPROC,
	getnpixelmapfv: PFNGLGETNPIXELMAPFVPROC,
	getnpixelmapuiv: PFNGLGETNPIXELMAPUIVPROC,
	getnpixelmapusv: PFNGLGETNPIXELMAPUSVPROC,
	getnpolygonstipple: PFNGLGETNPOLYGONSTIPPLEPROC,
	getncolortable: PFNGLGETNCOLORTABLEPROC,
	getnconvolutionfilter: PFNGLGETNCONVOLUTIONFILTERPROC,
	getnseparablefilter: PFNGLGETNSEPARABLEFILTERPROC,
	getnhistogram: PFNGLGETNHISTOGRAMPROC,
	getnminmax: PFNGLGETNMINMAXPROC,
	texturebarrier: PFNGLTEXTUREBARRIERPROC,
}

impl GL_4_5 for Version45 {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	#[inline(always)]
	fn glClipControl(&self, origin: GLenum, depth: GLenum) -> Result<()> {
		let ret = process_catch("glClipControl", catch_unwind(||(self.clipcontrol)(origin, depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClipControl", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateTransformFeedbacks(&self, n: GLsizei, ids: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateTransformFeedbacks", catch_unwind(||(self.createtransformfeedbacks)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateTransformFeedbacks", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTransformFeedbackBufferBase(&self, xfb: GLuint, index: GLuint, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glTransformFeedbackBufferBase", catch_unwind(||(self.transformfeedbackbufferbase)(xfb, index, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTransformFeedbackBufferBase", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTransformFeedbackBufferRange(&self, xfb: GLuint, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glTransformFeedbackBufferRange", catch_unwind(||(self.transformfeedbackbufferrange)(xfb, index, buffer, offset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTransformFeedbackBufferRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTransformFeedbackiv(&self, xfb: GLuint, pname: GLenum, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTransformFeedbackiv", catch_unwind(||(self.gettransformfeedbackiv)(xfb, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTransformFeedbackiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTransformFeedbacki_v(&self, xfb: GLuint, pname: GLenum, index: GLuint, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTransformFeedbacki_v", catch_unwind(||(self.gettransformfeedbacki_v)(xfb, pname, index, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTransformFeedbacki_v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTransformFeedbacki64_v(&self, xfb: GLuint, pname: GLenum, index: GLuint, param: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetTransformFeedbacki64_v", catch_unwind(||(self.gettransformfeedbacki64_v)(xfb, pname, index, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTransformFeedbacki64_v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateBuffers(&self, n: GLsizei, buffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateBuffers", catch_unwind(||(self.createbuffers)(n, buffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateBuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedBufferStorage(&self, buffer: GLuint, size: GLsizeiptr, data: *const c_void, flags: GLbitfield) -> Result<()> {
		let ret = process_catch("glNamedBufferStorage", catch_unwind(||(self.namedbufferstorage)(buffer, size, data, flags)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedBufferStorage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedBufferData(&self, buffer: GLuint, size: GLsizeiptr, data: *const c_void, usage: GLenum) -> Result<()> {
		let ret = process_catch("glNamedBufferData", catch_unwind(||(self.namedbufferdata)(buffer, size, data, usage)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedBufferData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedBufferSubData(&self, buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: *const c_void) -> Result<()> {
		let ret = process_catch("glNamedBufferSubData", catch_unwind(||(self.namedbuffersubdata)(buffer, offset, size, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedBufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyNamedBufferSubData(&self, readBuffer: GLuint, writeBuffer: GLuint, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glCopyNamedBufferSubData", catch_unwind(||(self.copynamedbuffersubdata)(readBuffer, writeBuffer, readOffset, writeOffset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyNamedBufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearNamedBufferData(&self, buffer: GLuint, internalformat: GLenum, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearNamedBufferData", catch_unwind(||(self.clearnamedbufferdata)(buffer, internalformat, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedBufferData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearNamedBufferSubData(&self, buffer: GLuint, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearNamedBufferSubData", catch_unwind(||(self.clearnamedbuffersubdata)(buffer, internalformat, offset, size, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedBufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMapNamedBuffer(&self, buffer: GLuint, access: GLenum) -> Result<*mut c_void> {
		let ret = process_catch("glMapNamedBuffer", catch_unwind(||(self.mapnamedbuffer)(buffer, access)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMapNamedBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMapNamedBufferRange(&self, buffer: GLuint, offset: GLintptr, length: GLsizeiptr, access: GLbitfield) -> Result<*mut c_void> {
		let ret = process_catch("glMapNamedBufferRange", catch_unwind(||(self.mapnamedbufferrange)(buffer, offset, length, access)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMapNamedBufferRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUnmapNamedBuffer(&self, buffer: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glUnmapNamedBuffer", catch_unwind(||(self.unmapnamedbuffer)(buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUnmapNamedBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFlushMappedNamedBufferRange(&self, buffer: GLuint, offset: GLintptr, length: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glFlushMappedNamedBufferRange", catch_unwind(||(self.flushmappednamedbufferrange)(buffer, offset, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFlushMappedNamedBufferRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetNamedBufferParameteriv(&self, buffer: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetNamedBufferParameteriv", catch_unwind(||(self.getnamedbufferparameteriv)(buffer, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedBufferParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetNamedBufferParameteri64v(&self, buffer: GLuint, pname: GLenum, params: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetNamedBufferParameteri64v", catch_unwind(||(self.getnamedbufferparameteri64v)(buffer, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedBufferParameteri64v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetNamedBufferPointerv(&self, buffer: GLuint, pname: GLenum, params: *mut *mut c_void) -> Result<()> {
		let ret = process_catch("glGetNamedBufferPointerv", catch_unwind(||(self.getnamedbufferpointerv)(buffer, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedBufferPointerv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetNamedBufferSubData(&self, buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetNamedBufferSubData", catch_unwind(||(self.getnamedbuffersubdata)(buffer, offset, size, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedBufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateFramebuffers(&self, n: GLsizei, framebuffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateFramebuffers", catch_unwind(||(self.createframebuffers)(n, framebuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateFramebuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedFramebufferRenderbuffer(&self, framebuffer: GLuint, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint) -> Result<()> {
		let ret = process_catch("glNamedFramebufferRenderbuffer", catch_unwind(||(self.namedframebufferrenderbuffer)(framebuffer, attachment, renderbuffertarget, renderbuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferRenderbuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedFramebufferParameteri(&self, framebuffer: GLuint, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glNamedFramebufferParameteri", catch_unwind(||(self.namedframebufferparameteri)(framebuffer, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferParameteri", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedFramebufferTexture(&self, framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glNamedFramebufferTexture", catch_unwind(||(self.namedframebuffertexture)(framebuffer, attachment, texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferTexture", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedFramebufferTextureLayer(&self, framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint) -> Result<()> {
		let ret = process_catch("glNamedFramebufferTextureLayer", catch_unwind(||(self.namedframebuffertexturelayer)(framebuffer, attachment, texture, level, layer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferTextureLayer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedFramebufferDrawBuffer(&self, framebuffer: GLuint, buf: GLenum) -> Result<()> {
		let ret = process_catch("glNamedFramebufferDrawBuffer", catch_unwind(||(self.namedframebufferdrawbuffer)(framebuffer, buf)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferDrawBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedFramebufferDrawBuffers(&self, framebuffer: GLuint, n: GLsizei, bufs: *const GLenum) -> Result<()> {
		let ret = process_catch("glNamedFramebufferDrawBuffers", catch_unwind(||(self.namedframebufferdrawbuffers)(framebuffer, n, bufs)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferDrawBuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedFramebufferReadBuffer(&self, framebuffer: GLuint, src: GLenum) -> Result<()> {
		let ret = process_catch("glNamedFramebufferReadBuffer", catch_unwind(||(self.namedframebufferreadbuffer)(framebuffer, src)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferReadBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glInvalidateNamedFramebufferData(&self, framebuffer: GLuint, numAttachments: GLsizei, attachments: *const GLenum) -> Result<()> {
		let ret = process_catch("glInvalidateNamedFramebufferData", catch_unwind(||(self.invalidatenamedframebufferdata)(framebuffer, numAttachments, attachments)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateNamedFramebufferData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glInvalidateNamedFramebufferSubData(&self, framebuffer: GLuint, numAttachments: GLsizei, attachments: *const GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glInvalidateNamedFramebufferSubData", catch_unwind(||(self.invalidatenamedframebuffersubdata)(framebuffer, numAttachments, attachments, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateNamedFramebufferSubData", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearNamedFramebufferiv(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLint) -> Result<()> {
		let ret = process_catch("glClearNamedFramebufferiv", catch_unwind(||(self.clearnamedframebufferiv)(framebuffer, buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedFramebufferiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearNamedFramebufferuiv(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glClearNamedFramebufferuiv", catch_unwind(||(self.clearnamedframebufferuiv)(framebuffer, buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedFramebufferuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearNamedFramebufferfv(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glClearNamedFramebufferfv", catch_unwind(||(self.clearnamedframebufferfv)(framebuffer, buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedFramebufferfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearNamedFramebufferfi(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint) -> Result<()> {
		let ret = process_catch("glClearNamedFramebufferfi", catch_unwind(||(self.clearnamedframebufferfi)(framebuffer, buffer, drawbuffer, depth, stencil)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedFramebufferfi", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBlitNamedFramebuffer(&self, readFramebuffer: GLuint, drawFramebuffer: GLuint, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum) -> Result<()> {
		let ret = process_catch("glBlitNamedFramebuffer", catch_unwind(||(self.blitnamedframebuffer)(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlitNamedFramebuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCheckNamedFramebufferStatus(&self, framebuffer: GLuint, target: GLenum) -> Result<GLenum> {
		let ret = process_catch("glCheckNamedFramebufferStatus", catch_unwind(||(self.checknamedframebufferstatus)(framebuffer, target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCheckNamedFramebufferStatus", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetNamedFramebufferParameteriv(&self, framebuffer: GLuint, pname: GLenum, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetNamedFramebufferParameteriv", catch_unwind(||(self.getnamedframebufferparameteriv)(framebuffer, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedFramebufferParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetNamedFramebufferAttachmentParameteriv(&self, framebuffer: GLuint, attachment: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetNamedFramebufferAttachmentParameteriv", catch_unwind(||(self.getnamedframebufferattachmentparameteriv)(framebuffer, attachment, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedFramebufferAttachmentParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateRenderbuffers(&self, n: GLsizei, renderbuffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateRenderbuffers", catch_unwind(||(self.createrenderbuffers)(n, renderbuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateRenderbuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedRenderbufferStorage(&self, renderbuffer: GLuint, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glNamedRenderbufferStorage", catch_unwind(||(self.namedrenderbufferstorage)(renderbuffer, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedRenderbufferStorage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedRenderbufferStorageMultisample(&self, renderbuffer: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glNamedRenderbufferStorageMultisample", catch_unwind(||(self.namedrenderbufferstoragemultisample)(renderbuffer, samples, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedRenderbufferStorageMultisample", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetNamedRenderbufferParameteriv(&self, renderbuffer: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetNamedRenderbufferParameteriv", catch_unwind(||(self.getnamedrenderbufferparameteriv)(renderbuffer, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedRenderbufferParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateTextures(&self, target: GLenum, n: GLsizei, textures: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateTextures", catch_unwind(||(self.createtextures)(target, n, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateTextures", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureBuffer(&self, texture: GLuint, internalformat: GLenum, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glTextureBuffer", catch_unwind(||(self.texturebuffer)(texture, internalformat, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureBufferRange(&self, texture: GLuint, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glTextureBufferRange", catch_unwind(||(self.texturebufferrange)(texture, internalformat, buffer, offset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureBufferRange", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureStorage1D(&self, texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei) -> Result<()> {
		let ret = process_catch("glTextureStorage1D", catch_unwind(||(self.texturestorage1d)(texture, levels, internalformat, width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureStorage2D(&self, texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glTextureStorage2D", catch_unwind(||(self.texturestorage2d)(texture, levels, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureStorage3D(&self, texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei) -> Result<()> {
		let ret = process_catch("glTextureStorage3D", catch_unwind(||(self.texturestorage3d)(texture, levels, internalformat, width, height, depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureStorage2DMultisample(&self, texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTextureStorage2DMultisample", catch_unwind(||(self.texturestorage2dmultisample)(texture, samples, internalformat, width, height, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage2DMultisample", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureStorage3DMultisample(&self, texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTextureStorage3DMultisample", catch_unwind(||(self.texturestorage3dmultisample)(texture, samples, internalformat, width, height, depth, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage3DMultisample", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureSubImage1D(&self, texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTextureSubImage1D", catch_unwind(||(self.texturesubimage1d)(texture, level, xoffset, width, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureSubImage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureSubImage2D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTextureSubImage2D", catch_unwind(||(self.texturesubimage2d)(texture, level, xoffset, yoffset, width, height, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureSubImage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureSubImage3D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTextureSubImage3D", catch_unwind(||(self.texturesubimage3d)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureSubImage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompressedTextureSubImage1D(&self, texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTextureSubImage1D", catch_unwind(||(self.compressedtexturesubimage1d)(texture, level, xoffset, width, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTextureSubImage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompressedTextureSubImage2D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTextureSubImage2D", catch_unwind(||(self.compressedtexturesubimage2d)(texture, level, xoffset, yoffset, width, height, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTextureSubImage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompressedTextureSubImage3D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTextureSubImage3D", catch_unwind(||(self.compressedtexturesubimage3d)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTextureSubImage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyTextureSubImage1D(&self, texture: GLuint, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTextureSubImage1D", catch_unwind(||(self.copytexturesubimage1d)(texture, level, xoffset, x, y, width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTextureSubImage1D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyTextureSubImage2D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTextureSubImage2D", catch_unwind(||(self.copytexturesubimage2d)(texture, level, xoffset, yoffset, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTextureSubImage2D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyTextureSubImage3D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTextureSubImage3D", catch_unwind(||(self.copytexturesubimage3d)(texture, level, xoffset, yoffset, zoffset, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTextureSubImage3D", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureParameterf(&self, texture: GLuint, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glTextureParameterf", catch_unwind(||(self.textureparameterf)(texture, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameterf", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureParameterfv(&self, texture: GLuint, pname: GLenum, param: *const GLfloat) -> Result<()> {
		let ret = process_catch("glTextureParameterfv", catch_unwind(||(self.textureparameterfv)(texture, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureParameteri(&self, texture: GLuint, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glTextureParameteri", catch_unwind(||(self.textureparameteri)(texture, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameteri", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureParameterIiv(&self, texture: GLuint, pname: GLenum, params: *const GLint) -> Result<()> {
		let ret = process_catch("glTextureParameterIiv", catch_unwind(||(self.textureparameteriiv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameterIiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureParameterIuiv(&self, texture: GLuint, pname: GLenum, params: *const GLuint) -> Result<()> {
		let ret = process_catch("glTextureParameterIuiv", catch_unwind(||(self.textureparameteriuiv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameterIuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureParameteriv(&self, texture: GLuint, pname: GLenum, param: *const GLint) -> Result<()> {
		let ret = process_catch("glTextureParameteriv", catch_unwind(||(self.textureparameteriv)(texture, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenerateTextureMipmap(&self, texture: GLuint) -> Result<()> {
		let ret = process_catch("glGenerateTextureMipmap", catch_unwind(||(self.generatetexturemipmap)(texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenerateTextureMipmap", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindTextureUnit(&self, unit: GLuint, texture: GLuint) -> Result<()> {
		let ret = process_catch("glBindTextureUnit", catch_unwind(||(self.bindtextureunit)(unit, texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindTextureUnit", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTextureImage(&self, texture: GLuint, level: GLint, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetTextureImage", catch_unwind(||(self.gettextureimage)(texture, level, format, type_, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetCompressedTextureImage(&self, texture: GLuint, level: GLint, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetCompressedTextureImage", catch_unwind(||(self.getcompressedtextureimage)(texture, level, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetCompressedTextureImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTextureLevelParameterfv(&self, texture: GLuint, level: GLint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetTextureLevelParameterfv", catch_unwind(||(self.gettexturelevelparameterfv)(texture, level, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureLevelParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTextureLevelParameteriv(&self, texture: GLuint, level: GLint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTextureLevelParameteriv", catch_unwind(||(self.gettexturelevelparameteriv)(texture, level, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureLevelParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTextureParameterfv(&self, texture: GLuint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetTextureParameterfv", catch_unwind(||(self.gettextureparameterfv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureParameterfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTextureParameterIiv(&self, texture: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTextureParameterIiv", catch_unwind(||(self.gettextureparameteriiv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureParameterIiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTextureParameterIuiv(&self, texture: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetTextureParameterIuiv", catch_unwind(||(self.gettextureparameteriuiv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureParameterIuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTextureParameteriv(&self, texture: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTextureParameteriv", catch_unwind(||(self.gettextureparameteriv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureParameteriv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateVertexArrays(&self, n: GLsizei, arrays: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateVertexArrays", catch_unwind(||(self.createvertexarrays)(n, arrays)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateVertexArrays", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDisableVertexArrayAttrib(&self, vaobj: GLuint, index: GLuint) -> Result<()> {
		let ret = process_catch("glDisableVertexArrayAttrib", catch_unwind(||(self.disablevertexarrayattrib)(vaobj, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDisableVertexArrayAttrib", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glEnableVertexArrayAttrib(&self, vaobj: GLuint, index: GLuint) -> Result<()> {
		let ret = process_catch("glEnableVertexArrayAttrib", catch_unwind(||(self.enablevertexarrayattrib)(vaobj, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEnableVertexArrayAttrib", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexArrayElementBuffer(&self, vaobj: GLuint, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayElementBuffer", catch_unwind(||(self.vertexarrayelementbuffer)(vaobj, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayElementBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexArrayVertexBuffer(&self, vaobj: GLuint, bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glVertexArrayVertexBuffer", catch_unwind(||(self.vertexarrayvertexbuffer)(vaobj, bindingindex, buffer, offset, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayVertexBuffer", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexArrayVertexBuffers(&self, vaobj: GLuint, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, strides: *const GLsizei) -> Result<()> {
		let ret = process_catch("glVertexArrayVertexBuffers", catch_unwind(||(self.vertexarrayvertexbuffers)(vaobj, first, count, buffers, offsets, strides)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayVertexBuffers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexArrayAttribBinding(&self, vaobj: GLuint, attribindex: GLuint, bindingindex: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayAttribBinding", catch_unwind(||(self.vertexarrayattribbinding)(vaobj, attribindex, bindingindex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayAttribBinding", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexArrayAttribFormat(&self, vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayAttribFormat", catch_unwind(||(self.vertexarrayattribformat)(vaobj, attribindex, size, type_, normalized, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayAttribFormat", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexArrayAttribIFormat(&self, vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayAttribIFormat", catch_unwind(||(self.vertexarrayattribiformat)(vaobj, attribindex, size, type_, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayAttribIFormat", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexArrayAttribLFormat(&self, vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayAttribLFormat", catch_unwind(||(self.vertexarrayattriblformat)(vaobj, attribindex, size, type_, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayAttribLFormat", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexArrayBindingDivisor(&self, vaobj: GLuint, bindingindex: GLuint, divisor: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayBindingDivisor", catch_unwind(||(self.vertexarraybindingdivisor)(vaobj, bindingindex, divisor)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayBindingDivisor", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexArrayiv(&self, vaobj: GLuint, pname: GLenum, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetVertexArrayiv", catch_unwind(||(self.getvertexarrayiv)(vaobj, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexArrayiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexArrayIndexediv(&self, vaobj: GLuint, index: GLuint, pname: GLenum, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetVertexArrayIndexediv", catch_unwind(||(self.getvertexarrayindexediv)(vaobj, index, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexArrayIndexediv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexArrayIndexed64iv(&self, vaobj: GLuint, index: GLuint, pname: GLenum, param: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetVertexArrayIndexed64iv", catch_unwind(||(self.getvertexarrayindexed64iv)(vaobj, index, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexArrayIndexed64iv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateSamplers(&self, n: GLsizei, samplers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateSamplers", catch_unwind(||(self.createsamplers)(n, samplers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateSamplers", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateProgramPipelines(&self, n: GLsizei, pipelines: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateProgramPipelines", catch_unwind(||(self.createprogrampipelines)(n, pipelines)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateProgramPipelines", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateQueries(&self, target: GLenum, n: GLsizei, ids: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateQueries", catch_unwind(||(self.createqueries)(target, n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateQueries", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryBufferObjecti64v(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()> {
		let ret = process_catch("glGetQueryBufferObjecti64v", catch_unwind(||(self.getquerybufferobjecti64v)(id, buffer, pname, offset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryBufferObjecti64v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryBufferObjectiv(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()> {
		let ret = process_catch("glGetQueryBufferObjectiv", catch_unwind(||(self.getquerybufferobjectiv)(id, buffer, pname, offset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryBufferObjectiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryBufferObjectui64v(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()> {
		let ret = process_catch("glGetQueryBufferObjectui64v", catch_unwind(||(self.getquerybufferobjectui64v)(id, buffer, pname, offset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryBufferObjectui64v", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryBufferObjectuiv(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()> {
		let ret = process_catch("glGetQueryBufferObjectuiv", catch_unwind(||(self.getquerybufferobjectuiv)(id, buffer, pname, offset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryBufferObjectuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMemoryBarrierByRegion(&self, barriers: GLbitfield) -> Result<()> {
		let ret = process_catch("glMemoryBarrierByRegion", catch_unwind(||(self.memorybarrierbyregion)(barriers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMemoryBarrierByRegion", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTextureSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetTextureSubImage", catch_unwind(||(self.gettexturesubimage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureSubImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetCompressedTextureSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetCompressedTextureSubImage", catch_unwind(||(self.getcompressedtexturesubimage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetCompressedTextureSubImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetGraphicsResetStatus(&self) -> Result<GLenum> {
		let ret = process_catch("glGetGraphicsResetStatus", catch_unwind(||(self.getgraphicsresetstatus)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetGraphicsResetStatus", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnCompressedTexImage(&self, target: GLenum, lod: GLint, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnCompressedTexImage", catch_unwind(||(self.getncompressedteximage)(target, lod, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnCompressedTexImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnTexImage(&self, target: GLenum, level: GLint, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnTexImage", catch_unwind(||(self.getnteximage)(target, level, format, type_, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnTexImage", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnUniformdv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetnUniformdv", catch_unwind(||(self.getnuniformdv)(program, location, bufSize, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnUniformdv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnUniformfv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetnUniformfv", catch_unwind(||(self.getnuniformfv)(program, location, bufSize, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnUniformfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnUniformiv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetnUniformiv", catch_unwind(||(self.getnuniformiv)(program, location, bufSize, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnUniformiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnUniformuiv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetnUniformuiv", catch_unwind(||(self.getnuniformuiv)(program, location, bufSize, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnUniformuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glReadnPixels(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, bufSize: GLsizei, data: *mut c_void) -> Result<()> {
		let ret = process_catch("glReadnPixels", catch_unwind(||(self.readnpixels)(x, y, width, height, format, type_, bufSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glReadnPixels", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnMapdv(&self, target: GLenum, query: GLenum, bufSize: GLsizei, v: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetnMapdv", catch_unwind(||(self.getnmapdv)(target, query, bufSize, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnMapdv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnMapfv(&self, target: GLenum, query: GLenum, bufSize: GLsizei, v: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetnMapfv", catch_unwind(||(self.getnmapfv)(target, query, bufSize, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnMapfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnMapiv(&self, target: GLenum, query: GLenum, bufSize: GLsizei, v: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetnMapiv", catch_unwind(||(self.getnmapiv)(target, query, bufSize, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnMapiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnPixelMapfv(&self, map: GLenum, bufSize: GLsizei, values: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetnPixelMapfv", catch_unwind(||(self.getnpixelmapfv)(map, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnPixelMapfv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnPixelMapuiv(&self, map: GLenum, bufSize: GLsizei, values: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetnPixelMapuiv", catch_unwind(||(self.getnpixelmapuiv)(map, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnPixelMapuiv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnPixelMapusv(&self, map: GLenum, bufSize: GLsizei, values: *mut GLushort) -> Result<()> {
		let ret = process_catch("glGetnPixelMapusv", catch_unwind(||(self.getnpixelmapusv)(map, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnPixelMapusv", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnPolygonStipple(&self, bufSize: GLsizei, pattern: *mut GLubyte) -> Result<()> {
		let ret = process_catch("glGetnPolygonStipple", catch_unwind(||(self.getnpolygonstipple)(bufSize, pattern)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnPolygonStipple", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnColorTable(&self, target: GLenum, format: GLenum, type_: GLenum, bufSize: GLsizei, table: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnColorTable", catch_unwind(||(self.getncolortable)(target, format, type_, bufSize, table)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnColorTable", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnConvolutionFilter(&self, target: GLenum, format: GLenum, type_: GLenum, bufSize: GLsizei, image: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnConvolutionFilter", catch_unwind(||(self.getnconvolutionfilter)(target, format, type_, bufSize, image)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnConvolutionFilter", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnSeparableFilter(&self, target: GLenum, format: GLenum, type_: GLenum, rowBufSize: GLsizei, row: *mut c_void, columnBufSize: GLsizei, column: *mut c_void, span: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnSeparableFilter", catch_unwind(||(self.getnseparablefilter)(target, format, type_, rowBufSize, row, columnBufSize, column, span)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnSeparableFilter", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnHistogram(&self, target: GLenum, reset: GLboolean, format: GLenum, type_: GLenum, bufSize: GLsizei, values: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnHistogram", catch_unwind(||(self.getnhistogram)(target, reset, format, type_, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnHistogram", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnMinmax(&self, target: GLenum, reset: GLboolean, format: GLenum, type_: GLenum, bufSize: GLsizei, values: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnMinmax", catch_unwind(||(self.getnminmax)(target, reset, format, type_, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnMinmax", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureBarrier(&self) -> Result<()> {
		let ret = process_catch("glTextureBarrier", catch_unwind(||(self.texturebarrier)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureBarrier", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version45 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (4, 5, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			clipcontrol: {let proc = get_proc_address("glClipControl"); if proc == null() {dummy_pfnglclipcontrolproc} else {unsafe{transmute(proc)}}},
			createtransformfeedbacks: {let proc = get_proc_address("glCreateTransformFeedbacks"); if proc == null() {dummy_pfnglcreatetransformfeedbacksproc} else {unsafe{transmute(proc)}}},
			transformfeedbackbufferbase: {let proc = get_proc_address("glTransformFeedbackBufferBase"); if proc == null() {dummy_pfngltransformfeedbackbufferbaseproc} else {unsafe{transmute(proc)}}},
			transformfeedbackbufferrange: {let proc = get_proc_address("glTransformFeedbackBufferRange"); if proc == null() {dummy_pfngltransformfeedbackbufferrangeproc} else {unsafe{transmute(proc)}}},
			gettransformfeedbackiv: {let proc = get_proc_address("glGetTransformFeedbackiv"); if proc == null() {dummy_pfnglgettransformfeedbackivproc} else {unsafe{transmute(proc)}}},
			gettransformfeedbacki_v: {let proc = get_proc_address("glGetTransformFeedbacki_v"); if proc == null() {dummy_pfnglgettransformfeedbacki_vproc} else {unsafe{transmute(proc)}}},
			gettransformfeedbacki64_v: {let proc = get_proc_address("glGetTransformFeedbacki64_v"); if proc == null() {dummy_pfnglgettransformfeedbacki64_vproc} else {unsafe{transmute(proc)}}},
			createbuffers: {let proc = get_proc_address("glCreateBuffers"); if proc == null() {dummy_pfnglcreatebuffersproc} else {unsafe{transmute(proc)}}},
			namedbufferstorage: {let proc = get_proc_address("glNamedBufferStorage"); if proc == null() {dummy_pfnglnamedbufferstorageproc} else {unsafe{transmute(proc)}}},
			namedbufferdata: {let proc = get_proc_address("glNamedBufferData"); if proc == null() {dummy_pfnglnamedbufferdataproc} else {unsafe{transmute(proc)}}},
			namedbuffersubdata: {let proc = get_proc_address("glNamedBufferSubData"); if proc == null() {dummy_pfnglnamedbuffersubdataproc} else {unsafe{transmute(proc)}}},
			copynamedbuffersubdata: {let proc = get_proc_address("glCopyNamedBufferSubData"); if proc == null() {dummy_pfnglcopynamedbuffersubdataproc} else {unsafe{transmute(proc)}}},
			clearnamedbufferdata: {let proc = get_proc_address("glClearNamedBufferData"); if proc == null() {dummy_pfnglclearnamedbufferdataproc} else {unsafe{transmute(proc)}}},
			clearnamedbuffersubdata: {let proc = get_proc_address("glClearNamedBufferSubData"); if proc == null() {dummy_pfnglclearnamedbuffersubdataproc} else {unsafe{transmute(proc)}}},
			mapnamedbuffer: {let proc = get_proc_address("glMapNamedBuffer"); if proc == null() {dummy_pfnglmapnamedbufferproc} else {unsafe{transmute(proc)}}},
			mapnamedbufferrange: {let proc = get_proc_address("glMapNamedBufferRange"); if proc == null() {dummy_pfnglmapnamedbufferrangeproc} else {unsafe{transmute(proc)}}},
			unmapnamedbuffer: {let proc = get_proc_address("glUnmapNamedBuffer"); if proc == null() {dummy_pfnglunmapnamedbufferproc} else {unsafe{transmute(proc)}}},
			flushmappednamedbufferrange: {let proc = get_proc_address("glFlushMappedNamedBufferRange"); if proc == null() {dummy_pfnglflushmappednamedbufferrangeproc} else {unsafe{transmute(proc)}}},
			getnamedbufferparameteriv: {let proc = get_proc_address("glGetNamedBufferParameteriv"); if proc == null() {dummy_pfnglgetnamedbufferparameterivproc} else {unsafe{transmute(proc)}}},
			getnamedbufferparameteri64v: {let proc = get_proc_address("glGetNamedBufferParameteri64v"); if proc == null() {dummy_pfnglgetnamedbufferparameteri64vproc} else {unsafe{transmute(proc)}}},
			getnamedbufferpointerv: {let proc = get_proc_address("glGetNamedBufferPointerv"); if proc == null() {dummy_pfnglgetnamedbufferpointervproc} else {unsafe{transmute(proc)}}},
			getnamedbuffersubdata: {let proc = get_proc_address("glGetNamedBufferSubData"); if proc == null() {dummy_pfnglgetnamedbuffersubdataproc} else {unsafe{transmute(proc)}}},
			createframebuffers: {let proc = get_proc_address("glCreateFramebuffers"); if proc == null() {dummy_pfnglcreateframebuffersproc} else {unsafe{transmute(proc)}}},
			namedframebufferrenderbuffer: {let proc = get_proc_address("glNamedFramebufferRenderbuffer"); if proc == null() {dummy_pfnglnamedframebufferrenderbufferproc} else {unsafe{transmute(proc)}}},
			namedframebufferparameteri: {let proc = get_proc_address("glNamedFramebufferParameteri"); if proc == null() {dummy_pfnglnamedframebufferparameteriproc} else {unsafe{transmute(proc)}}},
			namedframebuffertexture: {let proc = get_proc_address("glNamedFramebufferTexture"); if proc == null() {dummy_pfnglnamedframebuffertextureproc} else {unsafe{transmute(proc)}}},
			namedframebuffertexturelayer: {let proc = get_proc_address("glNamedFramebufferTextureLayer"); if proc == null() {dummy_pfnglnamedframebuffertexturelayerproc} else {unsafe{transmute(proc)}}},
			namedframebufferdrawbuffer: {let proc = get_proc_address("glNamedFramebufferDrawBuffer"); if proc == null() {dummy_pfnglnamedframebufferdrawbufferproc} else {unsafe{transmute(proc)}}},
			namedframebufferdrawbuffers: {let proc = get_proc_address("glNamedFramebufferDrawBuffers"); if proc == null() {dummy_pfnglnamedframebufferdrawbuffersproc} else {unsafe{transmute(proc)}}},
			namedframebufferreadbuffer: {let proc = get_proc_address("glNamedFramebufferReadBuffer"); if proc == null() {dummy_pfnglnamedframebufferreadbufferproc} else {unsafe{transmute(proc)}}},
			invalidatenamedframebufferdata: {let proc = get_proc_address("glInvalidateNamedFramebufferData"); if proc == null() {dummy_pfnglinvalidatenamedframebufferdataproc} else {unsafe{transmute(proc)}}},
			invalidatenamedframebuffersubdata: {let proc = get_proc_address("glInvalidateNamedFramebufferSubData"); if proc == null() {dummy_pfnglinvalidatenamedframebuffersubdataproc} else {unsafe{transmute(proc)}}},
			clearnamedframebufferiv: {let proc = get_proc_address("glClearNamedFramebufferiv"); if proc == null() {dummy_pfnglclearnamedframebufferivproc} else {unsafe{transmute(proc)}}},
			clearnamedframebufferuiv: {let proc = get_proc_address("glClearNamedFramebufferuiv"); if proc == null() {dummy_pfnglclearnamedframebufferuivproc} else {unsafe{transmute(proc)}}},
			clearnamedframebufferfv: {let proc = get_proc_address("glClearNamedFramebufferfv"); if proc == null() {dummy_pfnglclearnamedframebufferfvproc} else {unsafe{transmute(proc)}}},
			clearnamedframebufferfi: {let proc = get_proc_address("glClearNamedFramebufferfi"); if proc == null() {dummy_pfnglclearnamedframebufferfiproc} else {unsafe{transmute(proc)}}},
			blitnamedframebuffer: {let proc = get_proc_address("glBlitNamedFramebuffer"); if proc == null() {dummy_pfnglblitnamedframebufferproc} else {unsafe{transmute(proc)}}},
			checknamedframebufferstatus: {let proc = get_proc_address("glCheckNamedFramebufferStatus"); if proc == null() {dummy_pfnglchecknamedframebufferstatusproc} else {unsafe{transmute(proc)}}},
			getnamedframebufferparameteriv: {let proc = get_proc_address("glGetNamedFramebufferParameteriv"); if proc == null() {dummy_pfnglgetnamedframebufferparameterivproc} else {unsafe{transmute(proc)}}},
			getnamedframebufferattachmentparameteriv: {let proc = get_proc_address("glGetNamedFramebufferAttachmentParameteriv"); if proc == null() {dummy_pfnglgetnamedframebufferattachmentparameterivproc} else {unsafe{transmute(proc)}}},
			createrenderbuffers: {let proc = get_proc_address("glCreateRenderbuffers"); if proc == null() {dummy_pfnglcreaterenderbuffersproc} else {unsafe{transmute(proc)}}},
			namedrenderbufferstorage: {let proc = get_proc_address("glNamedRenderbufferStorage"); if proc == null() {dummy_pfnglnamedrenderbufferstorageproc} else {unsafe{transmute(proc)}}},
			namedrenderbufferstoragemultisample: {let proc = get_proc_address("glNamedRenderbufferStorageMultisample"); if proc == null() {dummy_pfnglnamedrenderbufferstoragemultisampleproc} else {unsafe{transmute(proc)}}},
			getnamedrenderbufferparameteriv: {let proc = get_proc_address("glGetNamedRenderbufferParameteriv"); if proc == null() {dummy_pfnglgetnamedrenderbufferparameterivproc} else {unsafe{transmute(proc)}}},
			createtextures: {let proc = get_proc_address("glCreateTextures"); if proc == null() {dummy_pfnglcreatetexturesproc} else {unsafe{transmute(proc)}}},
			texturebuffer: {let proc = get_proc_address("glTextureBuffer"); if proc == null() {dummy_pfngltexturebufferproc} else {unsafe{transmute(proc)}}},
			texturebufferrange: {let proc = get_proc_address("glTextureBufferRange"); if proc == null() {dummy_pfngltexturebufferrangeproc} else {unsafe{transmute(proc)}}},
			texturestorage1d: {let proc = get_proc_address("glTextureStorage1D"); if proc == null() {dummy_pfngltexturestorage1dproc} else {unsafe{transmute(proc)}}},
			texturestorage2d: {let proc = get_proc_address("glTextureStorage2D"); if proc == null() {dummy_pfngltexturestorage2dproc} else {unsafe{transmute(proc)}}},
			texturestorage3d: {let proc = get_proc_address("glTextureStorage3D"); if proc == null() {dummy_pfngltexturestorage3dproc} else {unsafe{transmute(proc)}}},
			texturestorage2dmultisample: {let proc = get_proc_address("glTextureStorage2DMultisample"); if proc == null() {dummy_pfngltexturestorage2dmultisampleproc} else {unsafe{transmute(proc)}}},
			texturestorage3dmultisample: {let proc = get_proc_address("glTextureStorage3DMultisample"); if proc == null() {dummy_pfngltexturestorage3dmultisampleproc} else {unsafe{transmute(proc)}}},
			texturesubimage1d: {let proc = get_proc_address("glTextureSubImage1D"); if proc == null() {dummy_pfngltexturesubimage1dproc} else {unsafe{transmute(proc)}}},
			texturesubimage2d: {let proc = get_proc_address("glTextureSubImage2D"); if proc == null() {dummy_pfngltexturesubimage2dproc} else {unsafe{transmute(proc)}}},
			texturesubimage3d: {let proc = get_proc_address("glTextureSubImage3D"); if proc == null() {dummy_pfngltexturesubimage3dproc} else {unsafe{transmute(proc)}}},
			compressedtexturesubimage1d: {let proc = get_proc_address("glCompressedTextureSubImage1D"); if proc == null() {dummy_pfnglcompressedtexturesubimage1dproc} else {unsafe{transmute(proc)}}},
			compressedtexturesubimage2d: {let proc = get_proc_address("glCompressedTextureSubImage2D"); if proc == null() {dummy_pfnglcompressedtexturesubimage2dproc} else {unsafe{transmute(proc)}}},
			compressedtexturesubimage3d: {let proc = get_proc_address("glCompressedTextureSubImage3D"); if proc == null() {dummy_pfnglcompressedtexturesubimage3dproc} else {unsafe{transmute(proc)}}},
			copytexturesubimage1d: {let proc = get_proc_address("glCopyTextureSubImage1D"); if proc == null() {dummy_pfnglcopytexturesubimage1dproc} else {unsafe{transmute(proc)}}},
			copytexturesubimage2d: {let proc = get_proc_address("glCopyTextureSubImage2D"); if proc == null() {dummy_pfnglcopytexturesubimage2dproc} else {unsafe{transmute(proc)}}},
			copytexturesubimage3d: {let proc = get_proc_address("glCopyTextureSubImage3D"); if proc == null() {dummy_pfnglcopytexturesubimage3dproc} else {unsafe{transmute(proc)}}},
			textureparameterf: {let proc = get_proc_address("glTextureParameterf"); if proc == null() {dummy_pfngltextureparameterfproc} else {unsafe{transmute(proc)}}},
			textureparameterfv: {let proc = get_proc_address("glTextureParameterfv"); if proc == null() {dummy_pfngltextureparameterfvproc} else {unsafe{transmute(proc)}}},
			textureparameteri: {let proc = get_proc_address("glTextureParameteri"); if proc == null() {dummy_pfngltextureparameteriproc} else {unsafe{transmute(proc)}}},
			textureparameteriiv: {let proc = get_proc_address("glTextureParameterIiv"); if proc == null() {dummy_pfngltextureparameteriivproc} else {unsafe{transmute(proc)}}},
			textureparameteriuiv: {let proc = get_proc_address("glTextureParameterIuiv"); if proc == null() {dummy_pfngltextureparameteriuivproc} else {unsafe{transmute(proc)}}},
			textureparameteriv: {let proc = get_proc_address("glTextureParameteriv"); if proc == null() {dummy_pfngltextureparameterivproc} else {unsafe{transmute(proc)}}},
			generatetexturemipmap: {let proc = get_proc_address("glGenerateTextureMipmap"); if proc == null() {dummy_pfnglgeneratetexturemipmapproc} else {unsafe{transmute(proc)}}},
			bindtextureunit: {let proc = get_proc_address("glBindTextureUnit"); if proc == null() {dummy_pfnglbindtextureunitproc} else {unsafe{transmute(proc)}}},
			gettextureimage: {let proc = get_proc_address("glGetTextureImage"); if proc == null() {dummy_pfnglgettextureimageproc} else {unsafe{transmute(proc)}}},
			getcompressedtextureimage: {let proc = get_proc_address("glGetCompressedTextureImage"); if proc == null() {dummy_pfnglgetcompressedtextureimageproc} else {unsafe{transmute(proc)}}},
			gettexturelevelparameterfv: {let proc = get_proc_address("glGetTextureLevelParameterfv"); if proc == null() {dummy_pfnglgettexturelevelparameterfvproc} else {unsafe{transmute(proc)}}},
			gettexturelevelparameteriv: {let proc = get_proc_address("glGetTextureLevelParameteriv"); if proc == null() {dummy_pfnglgettexturelevelparameterivproc} else {unsafe{transmute(proc)}}},
			gettextureparameterfv: {let proc = get_proc_address("glGetTextureParameterfv"); if proc == null() {dummy_pfnglgettextureparameterfvproc} else {unsafe{transmute(proc)}}},
			gettextureparameteriiv: {let proc = get_proc_address("glGetTextureParameterIiv"); if proc == null() {dummy_pfnglgettextureparameteriivproc} else {unsafe{transmute(proc)}}},
			gettextureparameteriuiv: {let proc = get_proc_address("glGetTextureParameterIuiv"); if proc == null() {dummy_pfnglgettextureparameteriuivproc} else {unsafe{transmute(proc)}}},
			gettextureparameteriv: {let proc = get_proc_address("glGetTextureParameteriv"); if proc == null() {dummy_pfnglgettextureparameterivproc} else {unsafe{transmute(proc)}}},
			createvertexarrays: {let proc = get_proc_address("glCreateVertexArrays"); if proc == null() {dummy_pfnglcreatevertexarraysproc} else {unsafe{transmute(proc)}}},
			disablevertexarrayattrib: {let proc = get_proc_address("glDisableVertexArrayAttrib"); if proc == null() {dummy_pfngldisablevertexarrayattribproc} else {unsafe{transmute(proc)}}},
			enablevertexarrayattrib: {let proc = get_proc_address("glEnableVertexArrayAttrib"); if proc == null() {dummy_pfnglenablevertexarrayattribproc} else {unsafe{transmute(proc)}}},
			vertexarrayelementbuffer: {let proc = get_proc_address("glVertexArrayElementBuffer"); if proc == null() {dummy_pfnglvertexarrayelementbufferproc} else {unsafe{transmute(proc)}}},
			vertexarrayvertexbuffer: {let proc = get_proc_address("glVertexArrayVertexBuffer"); if proc == null() {dummy_pfnglvertexarrayvertexbufferproc} else {unsafe{transmute(proc)}}},
			vertexarrayvertexbuffers: {let proc = get_proc_address("glVertexArrayVertexBuffers"); if proc == null() {dummy_pfnglvertexarrayvertexbuffersproc} else {unsafe{transmute(proc)}}},
			vertexarrayattribbinding: {let proc = get_proc_address("glVertexArrayAttribBinding"); if proc == null() {dummy_pfnglvertexarrayattribbindingproc} else {unsafe{transmute(proc)}}},
			vertexarrayattribformat: {let proc = get_proc_address("glVertexArrayAttribFormat"); if proc == null() {dummy_pfnglvertexarrayattribformatproc} else {unsafe{transmute(proc)}}},
			vertexarrayattribiformat: {let proc = get_proc_address("glVertexArrayAttribIFormat"); if proc == null() {dummy_pfnglvertexarrayattribiformatproc} else {unsafe{transmute(proc)}}},
			vertexarrayattriblformat: {let proc = get_proc_address("glVertexArrayAttribLFormat"); if proc == null() {dummy_pfnglvertexarrayattriblformatproc} else {unsafe{transmute(proc)}}},
			vertexarraybindingdivisor: {let proc = get_proc_address("glVertexArrayBindingDivisor"); if proc == null() {dummy_pfnglvertexarraybindingdivisorproc} else {unsafe{transmute(proc)}}},
			getvertexarrayiv: {let proc = get_proc_address("glGetVertexArrayiv"); if proc == null() {dummy_pfnglgetvertexarrayivproc} else {unsafe{transmute(proc)}}},
			getvertexarrayindexediv: {let proc = get_proc_address("glGetVertexArrayIndexediv"); if proc == null() {dummy_pfnglgetvertexarrayindexedivproc} else {unsafe{transmute(proc)}}},
			getvertexarrayindexed64iv: {let proc = get_proc_address("glGetVertexArrayIndexed64iv"); if proc == null() {dummy_pfnglgetvertexarrayindexed64ivproc} else {unsafe{transmute(proc)}}},
			createsamplers: {let proc = get_proc_address("glCreateSamplers"); if proc == null() {dummy_pfnglcreatesamplersproc} else {unsafe{transmute(proc)}}},
			createprogrampipelines: {let proc = get_proc_address("glCreateProgramPipelines"); if proc == null() {dummy_pfnglcreateprogrampipelinesproc} else {unsafe{transmute(proc)}}},
			createqueries: {let proc = get_proc_address("glCreateQueries"); if proc == null() {dummy_pfnglcreatequeriesproc} else {unsafe{transmute(proc)}}},
			getquerybufferobjecti64v: {let proc = get_proc_address("glGetQueryBufferObjecti64v"); if proc == null() {dummy_pfnglgetquerybufferobjecti64vproc} else {unsafe{transmute(proc)}}},
			getquerybufferobjectiv: {let proc = get_proc_address("glGetQueryBufferObjectiv"); if proc == null() {dummy_pfnglgetquerybufferobjectivproc} else {unsafe{transmute(proc)}}},
			getquerybufferobjectui64v: {let proc = get_proc_address("glGetQueryBufferObjectui64v"); if proc == null() {dummy_pfnglgetquerybufferobjectui64vproc} else {unsafe{transmute(proc)}}},
			getquerybufferobjectuiv: {let proc = get_proc_address("glGetQueryBufferObjectuiv"); if proc == null() {dummy_pfnglgetquerybufferobjectuivproc} else {unsafe{transmute(proc)}}},
			memorybarrierbyregion: {let proc = get_proc_address("glMemoryBarrierByRegion"); if proc == null() {dummy_pfnglmemorybarrierbyregionproc} else {unsafe{transmute(proc)}}},
			gettexturesubimage: {let proc = get_proc_address("glGetTextureSubImage"); if proc == null() {dummy_pfnglgettexturesubimageproc} else {unsafe{transmute(proc)}}},
			getcompressedtexturesubimage: {let proc = get_proc_address("glGetCompressedTextureSubImage"); if proc == null() {dummy_pfnglgetcompressedtexturesubimageproc} else {unsafe{transmute(proc)}}},
			getgraphicsresetstatus: {let proc = get_proc_address("glGetGraphicsResetStatus"); if proc == null() {dummy_pfnglgetgraphicsresetstatusproc} else {unsafe{transmute(proc)}}},
			getncompressedteximage: {let proc = get_proc_address("glGetnCompressedTexImage"); if proc == null() {dummy_pfnglgetncompressedteximageproc} else {unsafe{transmute(proc)}}},
			getnteximage: {let proc = get_proc_address("glGetnTexImage"); if proc == null() {dummy_pfnglgetnteximageproc} else {unsafe{transmute(proc)}}},
			getnuniformdv: {let proc = get_proc_address("glGetnUniformdv"); if proc == null() {dummy_pfnglgetnuniformdvproc} else {unsafe{transmute(proc)}}},
			getnuniformfv: {let proc = get_proc_address("glGetnUniformfv"); if proc == null() {dummy_pfnglgetnuniformfvproc} else {unsafe{transmute(proc)}}},
			getnuniformiv: {let proc = get_proc_address("glGetnUniformiv"); if proc == null() {dummy_pfnglgetnuniformivproc} else {unsafe{transmute(proc)}}},
			getnuniformuiv: {let proc = get_proc_address("glGetnUniformuiv"); if proc == null() {dummy_pfnglgetnuniformuivproc} else {unsafe{transmute(proc)}}},
			readnpixels: {let proc = get_proc_address("glReadnPixels"); if proc == null() {dummy_pfnglreadnpixelsproc} else {unsafe{transmute(proc)}}},
			getnmapdv: {let proc = get_proc_address("glGetnMapdv"); if proc == null() {dummy_pfnglgetnmapdvproc} else {unsafe{transmute(proc)}}},
			getnmapfv: {let proc = get_proc_address("glGetnMapfv"); if proc == null() {dummy_pfnglgetnmapfvproc} else {unsafe{transmute(proc)}}},
			getnmapiv: {let proc = get_proc_address("glGetnMapiv"); if proc == null() {dummy_pfnglgetnmapivproc} else {unsafe{transmute(proc)}}},
			getnpixelmapfv: {let proc = get_proc_address("glGetnPixelMapfv"); if proc == null() {dummy_pfnglgetnpixelmapfvproc} else {unsafe{transmute(proc)}}},
			getnpixelmapuiv: {let proc = get_proc_address("glGetnPixelMapuiv"); if proc == null() {dummy_pfnglgetnpixelmapuivproc} else {unsafe{transmute(proc)}}},
			getnpixelmapusv: {let proc = get_proc_address("glGetnPixelMapusv"); if proc == null() {dummy_pfnglgetnpixelmapusvproc} else {unsafe{transmute(proc)}}},
			getnpolygonstipple: {let proc = get_proc_address("glGetnPolygonStipple"); if proc == null() {dummy_pfnglgetnpolygonstippleproc} else {unsafe{transmute(proc)}}},
			getncolortable: {let proc = get_proc_address("glGetnColorTable"); if proc == null() {dummy_pfnglgetncolortableproc} else {unsafe{transmute(proc)}}},
			getnconvolutionfilter: {let proc = get_proc_address("glGetnConvolutionFilter"); if proc == null() {dummy_pfnglgetnconvolutionfilterproc} else {unsafe{transmute(proc)}}},
			getnseparablefilter: {let proc = get_proc_address("glGetnSeparableFilter"); if proc == null() {dummy_pfnglgetnseparablefilterproc} else {unsafe{transmute(proc)}}},
			getnhistogram: {let proc = get_proc_address("glGetnHistogram"); if proc == null() {dummy_pfnglgetnhistogramproc} else {unsafe{transmute(proc)}}},
			getnminmax: {let proc = get_proc_address("glGetnMinmax"); if proc == null() {dummy_pfnglgetnminmaxproc} else {unsafe{transmute(proc)}}},
			texturebarrier: {let proc = get_proc_address("glTextureBarrier"); if proc == null() {dummy_pfngltexturebarrierproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version45 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			clipcontrol: dummy_pfnglclipcontrolproc,
			createtransformfeedbacks: dummy_pfnglcreatetransformfeedbacksproc,
			transformfeedbackbufferbase: dummy_pfngltransformfeedbackbufferbaseproc,
			transformfeedbackbufferrange: dummy_pfngltransformfeedbackbufferrangeproc,
			gettransformfeedbackiv: dummy_pfnglgettransformfeedbackivproc,
			gettransformfeedbacki_v: dummy_pfnglgettransformfeedbacki_vproc,
			gettransformfeedbacki64_v: dummy_pfnglgettransformfeedbacki64_vproc,
			createbuffers: dummy_pfnglcreatebuffersproc,
			namedbufferstorage: dummy_pfnglnamedbufferstorageproc,
			namedbufferdata: dummy_pfnglnamedbufferdataproc,
			namedbuffersubdata: dummy_pfnglnamedbuffersubdataproc,
			copynamedbuffersubdata: dummy_pfnglcopynamedbuffersubdataproc,
			clearnamedbufferdata: dummy_pfnglclearnamedbufferdataproc,
			clearnamedbuffersubdata: dummy_pfnglclearnamedbuffersubdataproc,
			mapnamedbuffer: dummy_pfnglmapnamedbufferproc,
			mapnamedbufferrange: dummy_pfnglmapnamedbufferrangeproc,
			unmapnamedbuffer: dummy_pfnglunmapnamedbufferproc,
			flushmappednamedbufferrange: dummy_pfnglflushmappednamedbufferrangeproc,
			getnamedbufferparameteriv: dummy_pfnglgetnamedbufferparameterivproc,
			getnamedbufferparameteri64v: dummy_pfnglgetnamedbufferparameteri64vproc,
			getnamedbufferpointerv: dummy_pfnglgetnamedbufferpointervproc,
			getnamedbuffersubdata: dummy_pfnglgetnamedbuffersubdataproc,
			createframebuffers: dummy_pfnglcreateframebuffersproc,
			namedframebufferrenderbuffer: dummy_pfnglnamedframebufferrenderbufferproc,
			namedframebufferparameteri: dummy_pfnglnamedframebufferparameteriproc,
			namedframebuffertexture: dummy_pfnglnamedframebuffertextureproc,
			namedframebuffertexturelayer: dummy_pfnglnamedframebuffertexturelayerproc,
			namedframebufferdrawbuffer: dummy_pfnglnamedframebufferdrawbufferproc,
			namedframebufferdrawbuffers: dummy_pfnglnamedframebufferdrawbuffersproc,
			namedframebufferreadbuffer: dummy_pfnglnamedframebufferreadbufferproc,
			invalidatenamedframebufferdata: dummy_pfnglinvalidatenamedframebufferdataproc,
			invalidatenamedframebuffersubdata: dummy_pfnglinvalidatenamedframebuffersubdataproc,
			clearnamedframebufferiv: dummy_pfnglclearnamedframebufferivproc,
			clearnamedframebufferuiv: dummy_pfnglclearnamedframebufferuivproc,
			clearnamedframebufferfv: dummy_pfnglclearnamedframebufferfvproc,
			clearnamedframebufferfi: dummy_pfnglclearnamedframebufferfiproc,
			blitnamedframebuffer: dummy_pfnglblitnamedframebufferproc,
			checknamedframebufferstatus: dummy_pfnglchecknamedframebufferstatusproc,
			getnamedframebufferparameteriv: dummy_pfnglgetnamedframebufferparameterivproc,
			getnamedframebufferattachmentparameteriv: dummy_pfnglgetnamedframebufferattachmentparameterivproc,
			createrenderbuffers: dummy_pfnglcreaterenderbuffersproc,
			namedrenderbufferstorage: dummy_pfnglnamedrenderbufferstorageproc,
			namedrenderbufferstoragemultisample: dummy_pfnglnamedrenderbufferstoragemultisampleproc,
			getnamedrenderbufferparameteriv: dummy_pfnglgetnamedrenderbufferparameterivproc,
			createtextures: dummy_pfnglcreatetexturesproc,
			texturebuffer: dummy_pfngltexturebufferproc,
			texturebufferrange: dummy_pfngltexturebufferrangeproc,
			texturestorage1d: dummy_pfngltexturestorage1dproc,
			texturestorage2d: dummy_pfngltexturestorage2dproc,
			texturestorage3d: dummy_pfngltexturestorage3dproc,
			texturestorage2dmultisample: dummy_pfngltexturestorage2dmultisampleproc,
			texturestorage3dmultisample: dummy_pfngltexturestorage3dmultisampleproc,
			texturesubimage1d: dummy_pfngltexturesubimage1dproc,
			texturesubimage2d: dummy_pfngltexturesubimage2dproc,
			texturesubimage3d: dummy_pfngltexturesubimage3dproc,
			compressedtexturesubimage1d: dummy_pfnglcompressedtexturesubimage1dproc,
			compressedtexturesubimage2d: dummy_pfnglcompressedtexturesubimage2dproc,
			compressedtexturesubimage3d: dummy_pfnglcompressedtexturesubimage3dproc,
			copytexturesubimage1d: dummy_pfnglcopytexturesubimage1dproc,
			copytexturesubimage2d: dummy_pfnglcopytexturesubimage2dproc,
			copytexturesubimage3d: dummy_pfnglcopytexturesubimage3dproc,
			textureparameterf: dummy_pfngltextureparameterfproc,
			textureparameterfv: dummy_pfngltextureparameterfvproc,
			textureparameteri: dummy_pfngltextureparameteriproc,
			textureparameteriiv: dummy_pfngltextureparameteriivproc,
			textureparameteriuiv: dummy_pfngltextureparameteriuivproc,
			textureparameteriv: dummy_pfngltextureparameterivproc,
			generatetexturemipmap: dummy_pfnglgeneratetexturemipmapproc,
			bindtextureunit: dummy_pfnglbindtextureunitproc,
			gettextureimage: dummy_pfnglgettextureimageproc,
			getcompressedtextureimage: dummy_pfnglgetcompressedtextureimageproc,
			gettexturelevelparameterfv: dummy_pfnglgettexturelevelparameterfvproc,
			gettexturelevelparameteriv: dummy_pfnglgettexturelevelparameterivproc,
			gettextureparameterfv: dummy_pfnglgettextureparameterfvproc,
			gettextureparameteriiv: dummy_pfnglgettextureparameteriivproc,
			gettextureparameteriuiv: dummy_pfnglgettextureparameteriuivproc,
			gettextureparameteriv: dummy_pfnglgettextureparameterivproc,
			createvertexarrays: dummy_pfnglcreatevertexarraysproc,
			disablevertexarrayattrib: dummy_pfngldisablevertexarrayattribproc,
			enablevertexarrayattrib: dummy_pfnglenablevertexarrayattribproc,
			vertexarrayelementbuffer: dummy_pfnglvertexarrayelementbufferproc,
			vertexarrayvertexbuffer: dummy_pfnglvertexarrayvertexbufferproc,
			vertexarrayvertexbuffers: dummy_pfnglvertexarrayvertexbuffersproc,
			vertexarrayattribbinding: dummy_pfnglvertexarrayattribbindingproc,
			vertexarrayattribformat: dummy_pfnglvertexarrayattribformatproc,
			vertexarrayattribiformat: dummy_pfnglvertexarrayattribiformatproc,
			vertexarrayattriblformat: dummy_pfnglvertexarrayattriblformatproc,
			vertexarraybindingdivisor: dummy_pfnglvertexarraybindingdivisorproc,
			getvertexarrayiv: dummy_pfnglgetvertexarrayivproc,
			getvertexarrayindexediv: dummy_pfnglgetvertexarrayindexedivproc,
			getvertexarrayindexed64iv: dummy_pfnglgetvertexarrayindexed64ivproc,
			createsamplers: dummy_pfnglcreatesamplersproc,
			createprogrampipelines: dummy_pfnglcreateprogrampipelinesproc,
			createqueries: dummy_pfnglcreatequeriesproc,
			getquerybufferobjecti64v: dummy_pfnglgetquerybufferobjecti64vproc,
			getquerybufferobjectiv: dummy_pfnglgetquerybufferobjectivproc,
			getquerybufferobjectui64v: dummy_pfnglgetquerybufferobjectui64vproc,
			getquerybufferobjectuiv: dummy_pfnglgetquerybufferobjectuivproc,
			memorybarrierbyregion: dummy_pfnglmemorybarrierbyregionproc,
			gettexturesubimage: dummy_pfnglgettexturesubimageproc,
			getcompressedtexturesubimage: dummy_pfnglgetcompressedtexturesubimageproc,
			getgraphicsresetstatus: dummy_pfnglgetgraphicsresetstatusproc,
			getncompressedteximage: dummy_pfnglgetncompressedteximageproc,
			getnteximage: dummy_pfnglgetnteximageproc,
			getnuniformdv: dummy_pfnglgetnuniformdvproc,
			getnuniformfv: dummy_pfnglgetnuniformfvproc,
			getnuniformiv: dummy_pfnglgetnuniformivproc,
			getnuniformuiv: dummy_pfnglgetnuniformuivproc,
			readnpixels: dummy_pfnglreadnpixelsproc,
			getnmapdv: dummy_pfnglgetnmapdvproc,
			getnmapfv: dummy_pfnglgetnmapfvproc,
			getnmapiv: dummy_pfnglgetnmapivproc,
			getnpixelmapfv: dummy_pfnglgetnpixelmapfvproc,
			getnpixelmapuiv: dummy_pfnglgetnpixelmapuivproc,
			getnpixelmapusv: dummy_pfnglgetnpixelmapusvproc,
			getnpolygonstipple: dummy_pfnglgetnpolygonstippleproc,
			getncolortable: dummy_pfnglgetncolortableproc,
			getnconvolutionfilter: dummy_pfnglgetnconvolutionfilterproc,
			getnseparablefilter: dummy_pfnglgetnseparablefilterproc,
			getnhistogram: dummy_pfnglgetnhistogramproc,
			getnminmax: dummy_pfnglgetnminmaxproc,
			texturebarrier: dummy_pfngltexturebarrierproc,
		}
	}
}
impl Debug for Version45 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version45")
			.field("available", &self.available)
			.field("clipcontrol", unsafe{if transmute::<_, *const c_void>(self.clipcontrol) == (dummy_pfnglclipcontrolproc as *const c_void) {&null::<PFNGLCLIPCONTROLPROC>()} else {&self.clipcontrol}})
			.field("createtransformfeedbacks", unsafe{if transmute::<_, *const c_void>(self.createtransformfeedbacks) == (dummy_pfnglcreatetransformfeedbacksproc as *const c_void) {&null::<PFNGLCREATETRANSFORMFEEDBACKSPROC>()} else {&self.createtransformfeedbacks}})
			.field("transformfeedbackbufferbase", unsafe{if transmute::<_, *const c_void>(self.transformfeedbackbufferbase) == (dummy_pfngltransformfeedbackbufferbaseproc as *const c_void) {&null::<PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC>()} else {&self.transformfeedbackbufferbase}})
			.field("transformfeedbackbufferrange", unsafe{if transmute::<_, *const c_void>(self.transformfeedbackbufferrange) == (dummy_pfngltransformfeedbackbufferrangeproc as *const c_void) {&null::<PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC>()} else {&self.transformfeedbackbufferrange}})
			.field("gettransformfeedbackiv", unsafe{if transmute::<_, *const c_void>(self.gettransformfeedbackiv) == (dummy_pfnglgettransformfeedbackivproc as *const c_void) {&null::<PFNGLGETTRANSFORMFEEDBACKIVPROC>()} else {&self.gettransformfeedbackiv}})
			.field("gettransformfeedbacki_v", unsafe{if transmute::<_, *const c_void>(self.gettransformfeedbacki_v) == (dummy_pfnglgettransformfeedbacki_vproc as *const c_void) {&null::<PFNGLGETTRANSFORMFEEDBACKI_VPROC>()} else {&self.gettransformfeedbacki_v}})
			.field("gettransformfeedbacki64_v", unsafe{if transmute::<_, *const c_void>(self.gettransformfeedbacki64_v) == (dummy_pfnglgettransformfeedbacki64_vproc as *const c_void) {&null::<PFNGLGETTRANSFORMFEEDBACKI64_VPROC>()} else {&self.gettransformfeedbacki64_v}})
			.field("createbuffers", unsafe{if transmute::<_, *const c_void>(self.createbuffers) == (dummy_pfnglcreatebuffersproc as *const c_void) {&null::<PFNGLCREATEBUFFERSPROC>()} else {&self.createbuffers}})
			.field("namedbufferstorage", unsafe{if transmute::<_, *const c_void>(self.namedbufferstorage) == (dummy_pfnglnamedbufferstorageproc as *const c_void) {&null::<PFNGLNAMEDBUFFERSTORAGEPROC>()} else {&self.namedbufferstorage}})
			.field("namedbufferdata", unsafe{if transmute::<_, *const c_void>(self.namedbufferdata) == (dummy_pfnglnamedbufferdataproc as *const c_void) {&null::<PFNGLNAMEDBUFFERDATAPROC>()} else {&self.namedbufferdata}})
			.field("namedbuffersubdata", unsafe{if transmute::<_, *const c_void>(self.namedbuffersubdata) == (dummy_pfnglnamedbuffersubdataproc as *const c_void) {&null::<PFNGLNAMEDBUFFERSUBDATAPROC>()} else {&self.namedbuffersubdata}})
			.field("copynamedbuffersubdata", unsafe{if transmute::<_, *const c_void>(self.copynamedbuffersubdata) == (dummy_pfnglcopynamedbuffersubdataproc as *const c_void) {&null::<PFNGLCOPYNAMEDBUFFERSUBDATAPROC>()} else {&self.copynamedbuffersubdata}})
			.field("clearnamedbufferdata", unsafe{if transmute::<_, *const c_void>(self.clearnamedbufferdata) == (dummy_pfnglclearnamedbufferdataproc as *const c_void) {&null::<PFNGLCLEARNAMEDBUFFERDATAPROC>()} else {&self.clearnamedbufferdata}})
			.field("clearnamedbuffersubdata", unsafe{if transmute::<_, *const c_void>(self.clearnamedbuffersubdata) == (dummy_pfnglclearnamedbuffersubdataproc as *const c_void) {&null::<PFNGLCLEARNAMEDBUFFERSUBDATAPROC>()} else {&self.clearnamedbuffersubdata}})
			.field("mapnamedbuffer", unsafe{if transmute::<_, *const c_void>(self.mapnamedbuffer) == (dummy_pfnglmapnamedbufferproc as *const c_void) {&null::<PFNGLMAPNAMEDBUFFERPROC>()} else {&self.mapnamedbuffer}})
			.field("mapnamedbufferrange", unsafe{if transmute::<_, *const c_void>(self.mapnamedbufferrange) == (dummy_pfnglmapnamedbufferrangeproc as *const c_void) {&null::<PFNGLMAPNAMEDBUFFERRANGEPROC>()} else {&self.mapnamedbufferrange}})
			.field("unmapnamedbuffer", unsafe{if transmute::<_, *const c_void>(self.unmapnamedbuffer) == (dummy_pfnglunmapnamedbufferproc as *const c_void) {&null::<PFNGLUNMAPNAMEDBUFFERPROC>()} else {&self.unmapnamedbuffer}})
			.field("flushmappednamedbufferrange", unsafe{if transmute::<_, *const c_void>(self.flushmappednamedbufferrange) == (dummy_pfnglflushmappednamedbufferrangeproc as *const c_void) {&null::<PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC>()} else {&self.flushmappednamedbufferrange}})
			.field("getnamedbufferparameteriv", unsafe{if transmute::<_, *const c_void>(self.getnamedbufferparameteriv) == (dummy_pfnglgetnamedbufferparameterivproc as *const c_void) {&null::<PFNGLGETNAMEDBUFFERPARAMETERIVPROC>()} else {&self.getnamedbufferparameteriv}})
			.field("getnamedbufferparameteri64v", unsafe{if transmute::<_, *const c_void>(self.getnamedbufferparameteri64v) == (dummy_pfnglgetnamedbufferparameteri64vproc as *const c_void) {&null::<PFNGLGETNAMEDBUFFERPARAMETERI64VPROC>()} else {&self.getnamedbufferparameteri64v}})
			.field("getnamedbufferpointerv", unsafe{if transmute::<_, *const c_void>(self.getnamedbufferpointerv) == (dummy_pfnglgetnamedbufferpointervproc as *const c_void) {&null::<PFNGLGETNAMEDBUFFERPOINTERVPROC>()} else {&self.getnamedbufferpointerv}})
			.field("getnamedbuffersubdata", unsafe{if transmute::<_, *const c_void>(self.getnamedbuffersubdata) == (dummy_pfnglgetnamedbuffersubdataproc as *const c_void) {&null::<PFNGLGETNAMEDBUFFERSUBDATAPROC>()} else {&self.getnamedbuffersubdata}})
			.field("createframebuffers", unsafe{if transmute::<_, *const c_void>(self.createframebuffers) == (dummy_pfnglcreateframebuffersproc as *const c_void) {&null::<PFNGLCREATEFRAMEBUFFERSPROC>()} else {&self.createframebuffers}})
			.field("namedframebufferrenderbuffer", unsafe{if transmute::<_, *const c_void>(self.namedframebufferrenderbuffer) == (dummy_pfnglnamedframebufferrenderbufferproc as *const c_void) {&null::<PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC>()} else {&self.namedframebufferrenderbuffer}})
			.field("namedframebufferparameteri", unsafe{if transmute::<_, *const c_void>(self.namedframebufferparameteri) == (dummy_pfnglnamedframebufferparameteriproc as *const c_void) {&null::<PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC>()} else {&self.namedframebufferparameteri}})
			.field("namedframebuffertexture", unsafe{if transmute::<_, *const c_void>(self.namedframebuffertexture) == (dummy_pfnglnamedframebuffertextureproc as *const c_void) {&null::<PFNGLNAMEDFRAMEBUFFERTEXTUREPROC>()} else {&self.namedframebuffertexture}})
			.field("namedframebuffertexturelayer", unsafe{if transmute::<_, *const c_void>(self.namedframebuffertexturelayer) == (dummy_pfnglnamedframebuffertexturelayerproc as *const c_void) {&null::<PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC>()} else {&self.namedframebuffertexturelayer}})
			.field("namedframebufferdrawbuffer", unsafe{if transmute::<_, *const c_void>(self.namedframebufferdrawbuffer) == (dummy_pfnglnamedframebufferdrawbufferproc as *const c_void) {&null::<PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC>()} else {&self.namedframebufferdrawbuffer}})
			.field("namedframebufferdrawbuffers", unsafe{if transmute::<_, *const c_void>(self.namedframebufferdrawbuffers) == (dummy_pfnglnamedframebufferdrawbuffersproc as *const c_void) {&null::<PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC>()} else {&self.namedframebufferdrawbuffers}})
			.field("namedframebufferreadbuffer", unsafe{if transmute::<_, *const c_void>(self.namedframebufferreadbuffer) == (dummy_pfnglnamedframebufferreadbufferproc as *const c_void) {&null::<PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC>()} else {&self.namedframebufferreadbuffer}})
			.field("invalidatenamedframebufferdata", unsafe{if transmute::<_, *const c_void>(self.invalidatenamedframebufferdata) == (dummy_pfnglinvalidatenamedframebufferdataproc as *const c_void) {&null::<PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC>()} else {&self.invalidatenamedframebufferdata}})
			.field("invalidatenamedframebuffersubdata", unsafe{if transmute::<_, *const c_void>(self.invalidatenamedframebuffersubdata) == (dummy_pfnglinvalidatenamedframebuffersubdataproc as *const c_void) {&null::<PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC>()} else {&self.invalidatenamedframebuffersubdata}})
			.field("clearnamedframebufferiv", unsafe{if transmute::<_, *const c_void>(self.clearnamedframebufferiv) == (dummy_pfnglclearnamedframebufferivproc as *const c_void) {&null::<PFNGLCLEARNAMEDFRAMEBUFFERIVPROC>()} else {&self.clearnamedframebufferiv}})
			.field("clearnamedframebufferuiv", unsafe{if transmute::<_, *const c_void>(self.clearnamedframebufferuiv) == (dummy_pfnglclearnamedframebufferuivproc as *const c_void) {&null::<PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC>()} else {&self.clearnamedframebufferuiv}})
			.field("clearnamedframebufferfv", unsafe{if transmute::<_, *const c_void>(self.clearnamedframebufferfv) == (dummy_pfnglclearnamedframebufferfvproc as *const c_void) {&null::<PFNGLCLEARNAMEDFRAMEBUFFERFVPROC>()} else {&self.clearnamedframebufferfv}})
			.field("clearnamedframebufferfi", unsafe{if transmute::<_, *const c_void>(self.clearnamedframebufferfi) == (dummy_pfnglclearnamedframebufferfiproc as *const c_void) {&null::<PFNGLCLEARNAMEDFRAMEBUFFERFIPROC>()} else {&self.clearnamedframebufferfi}})
			.field("blitnamedframebuffer", unsafe{if transmute::<_, *const c_void>(self.blitnamedframebuffer) == (dummy_pfnglblitnamedframebufferproc as *const c_void) {&null::<PFNGLBLITNAMEDFRAMEBUFFERPROC>()} else {&self.blitnamedframebuffer}})
			.field("checknamedframebufferstatus", unsafe{if transmute::<_, *const c_void>(self.checknamedframebufferstatus) == (dummy_pfnglchecknamedframebufferstatusproc as *const c_void) {&null::<PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC>()} else {&self.checknamedframebufferstatus}})
			.field("getnamedframebufferparameteriv", unsafe{if transmute::<_, *const c_void>(self.getnamedframebufferparameteriv) == (dummy_pfnglgetnamedframebufferparameterivproc as *const c_void) {&null::<PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC>()} else {&self.getnamedframebufferparameteriv}})
			.field("getnamedframebufferattachmentparameteriv", unsafe{if transmute::<_, *const c_void>(self.getnamedframebufferattachmentparameteriv) == (dummy_pfnglgetnamedframebufferattachmentparameterivproc as *const c_void) {&null::<PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC>()} else {&self.getnamedframebufferattachmentparameteriv}})
			.field("createrenderbuffers", unsafe{if transmute::<_, *const c_void>(self.createrenderbuffers) == (dummy_pfnglcreaterenderbuffersproc as *const c_void) {&null::<PFNGLCREATERENDERBUFFERSPROC>()} else {&self.createrenderbuffers}})
			.field("namedrenderbufferstorage", unsafe{if transmute::<_, *const c_void>(self.namedrenderbufferstorage) == (dummy_pfnglnamedrenderbufferstorageproc as *const c_void) {&null::<PFNGLNAMEDRENDERBUFFERSTORAGEPROC>()} else {&self.namedrenderbufferstorage}})
			.field("namedrenderbufferstoragemultisample", unsafe{if transmute::<_, *const c_void>(self.namedrenderbufferstoragemultisample) == (dummy_pfnglnamedrenderbufferstoragemultisampleproc as *const c_void) {&null::<PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC>()} else {&self.namedrenderbufferstoragemultisample}})
			.field("getnamedrenderbufferparameteriv", unsafe{if transmute::<_, *const c_void>(self.getnamedrenderbufferparameteriv) == (dummy_pfnglgetnamedrenderbufferparameterivproc as *const c_void) {&null::<PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC>()} else {&self.getnamedrenderbufferparameteriv}})
			.field("createtextures", unsafe{if transmute::<_, *const c_void>(self.createtextures) == (dummy_pfnglcreatetexturesproc as *const c_void) {&null::<PFNGLCREATETEXTURESPROC>()} else {&self.createtextures}})
			.field("texturebuffer", unsafe{if transmute::<_, *const c_void>(self.texturebuffer) == (dummy_pfngltexturebufferproc as *const c_void) {&null::<PFNGLTEXTUREBUFFERPROC>()} else {&self.texturebuffer}})
			.field("texturebufferrange", unsafe{if transmute::<_, *const c_void>(self.texturebufferrange) == (dummy_pfngltexturebufferrangeproc as *const c_void) {&null::<PFNGLTEXTUREBUFFERRANGEPROC>()} else {&self.texturebufferrange}})
			.field("texturestorage1d", unsafe{if transmute::<_, *const c_void>(self.texturestorage1d) == (dummy_pfngltexturestorage1dproc as *const c_void) {&null::<PFNGLTEXTURESTORAGE1DPROC>()} else {&self.texturestorage1d}})
			.field("texturestorage2d", unsafe{if transmute::<_, *const c_void>(self.texturestorage2d) == (dummy_pfngltexturestorage2dproc as *const c_void) {&null::<PFNGLTEXTURESTORAGE2DPROC>()} else {&self.texturestorage2d}})
			.field("texturestorage3d", unsafe{if transmute::<_, *const c_void>(self.texturestorage3d) == (dummy_pfngltexturestorage3dproc as *const c_void) {&null::<PFNGLTEXTURESTORAGE3DPROC>()} else {&self.texturestorage3d}})
			.field("texturestorage2dmultisample", unsafe{if transmute::<_, *const c_void>(self.texturestorage2dmultisample) == (dummy_pfngltexturestorage2dmultisampleproc as *const c_void) {&null::<PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC>()} else {&self.texturestorage2dmultisample}})
			.field("texturestorage3dmultisample", unsafe{if transmute::<_, *const c_void>(self.texturestorage3dmultisample) == (dummy_pfngltexturestorage3dmultisampleproc as *const c_void) {&null::<PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC>()} else {&self.texturestorage3dmultisample}})
			.field("texturesubimage1d", unsafe{if transmute::<_, *const c_void>(self.texturesubimage1d) == (dummy_pfngltexturesubimage1dproc as *const c_void) {&null::<PFNGLTEXTURESUBIMAGE1DPROC>()} else {&self.texturesubimage1d}})
			.field("texturesubimage2d", unsafe{if transmute::<_, *const c_void>(self.texturesubimage2d) == (dummy_pfngltexturesubimage2dproc as *const c_void) {&null::<PFNGLTEXTURESUBIMAGE2DPROC>()} else {&self.texturesubimage2d}})
			.field("texturesubimage3d", unsafe{if transmute::<_, *const c_void>(self.texturesubimage3d) == (dummy_pfngltexturesubimage3dproc as *const c_void) {&null::<PFNGLTEXTURESUBIMAGE3DPROC>()} else {&self.texturesubimage3d}})
			.field("compressedtexturesubimage1d", unsafe{if transmute::<_, *const c_void>(self.compressedtexturesubimage1d) == (dummy_pfnglcompressedtexturesubimage1dproc as *const c_void) {&null::<PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC>()} else {&self.compressedtexturesubimage1d}})
			.field("compressedtexturesubimage2d", unsafe{if transmute::<_, *const c_void>(self.compressedtexturesubimage2d) == (dummy_pfnglcompressedtexturesubimage2dproc as *const c_void) {&null::<PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC>()} else {&self.compressedtexturesubimage2d}})
			.field("compressedtexturesubimage3d", unsafe{if transmute::<_, *const c_void>(self.compressedtexturesubimage3d) == (dummy_pfnglcompressedtexturesubimage3dproc as *const c_void) {&null::<PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC>()} else {&self.compressedtexturesubimage3d}})
			.field("copytexturesubimage1d", unsafe{if transmute::<_, *const c_void>(self.copytexturesubimage1d) == (dummy_pfnglcopytexturesubimage1dproc as *const c_void) {&null::<PFNGLCOPYTEXTURESUBIMAGE1DPROC>()} else {&self.copytexturesubimage1d}})
			.field("copytexturesubimage2d", unsafe{if transmute::<_, *const c_void>(self.copytexturesubimage2d) == (dummy_pfnglcopytexturesubimage2dproc as *const c_void) {&null::<PFNGLCOPYTEXTURESUBIMAGE2DPROC>()} else {&self.copytexturesubimage2d}})
			.field("copytexturesubimage3d", unsafe{if transmute::<_, *const c_void>(self.copytexturesubimage3d) == (dummy_pfnglcopytexturesubimage3dproc as *const c_void) {&null::<PFNGLCOPYTEXTURESUBIMAGE3DPROC>()} else {&self.copytexturesubimage3d}})
			.field("textureparameterf", unsafe{if transmute::<_, *const c_void>(self.textureparameterf) == (dummy_pfngltextureparameterfproc as *const c_void) {&null::<PFNGLTEXTUREPARAMETERFPROC>()} else {&self.textureparameterf}})
			.field("textureparameterfv", unsafe{if transmute::<_, *const c_void>(self.textureparameterfv) == (dummy_pfngltextureparameterfvproc as *const c_void) {&null::<PFNGLTEXTUREPARAMETERFVPROC>()} else {&self.textureparameterfv}})
			.field("textureparameteri", unsafe{if transmute::<_, *const c_void>(self.textureparameteri) == (dummy_pfngltextureparameteriproc as *const c_void) {&null::<PFNGLTEXTUREPARAMETERIPROC>()} else {&self.textureparameteri}})
			.field("textureparameteriiv", unsafe{if transmute::<_, *const c_void>(self.textureparameteriiv) == (dummy_pfngltextureparameteriivproc as *const c_void) {&null::<PFNGLTEXTUREPARAMETERIIVPROC>()} else {&self.textureparameteriiv}})
			.field("textureparameteriuiv", unsafe{if transmute::<_, *const c_void>(self.textureparameteriuiv) == (dummy_pfngltextureparameteriuivproc as *const c_void) {&null::<PFNGLTEXTUREPARAMETERIUIVPROC>()} else {&self.textureparameteriuiv}})
			.field("textureparameteriv", unsafe{if transmute::<_, *const c_void>(self.textureparameteriv) == (dummy_pfngltextureparameterivproc as *const c_void) {&null::<PFNGLTEXTUREPARAMETERIVPROC>()} else {&self.textureparameteriv}})
			.field("generatetexturemipmap", unsafe{if transmute::<_, *const c_void>(self.generatetexturemipmap) == (dummy_pfnglgeneratetexturemipmapproc as *const c_void) {&null::<PFNGLGENERATETEXTUREMIPMAPPROC>()} else {&self.generatetexturemipmap}})
			.field("bindtextureunit", unsafe{if transmute::<_, *const c_void>(self.bindtextureunit) == (dummy_pfnglbindtextureunitproc as *const c_void) {&null::<PFNGLBINDTEXTUREUNITPROC>()} else {&self.bindtextureunit}})
			.field("gettextureimage", unsafe{if transmute::<_, *const c_void>(self.gettextureimage) == (dummy_pfnglgettextureimageproc as *const c_void) {&null::<PFNGLGETTEXTUREIMAGEPROC>()} else {&self.gettextureimage}})
			.field("getcompressedtextureimage", unsafe{if transmute::<_, *const c_void>(self.getcompressedtextureimage) == (dummy_pfnglgetcompressedtextureimageproc as *const c_void) {&null::<PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC>()} else {&self.getcompressedtextureimage}})
			.field("gettexturelevelparameterfv", unsafe{if transmute::<_, *const c_void>(self.gettexturelevelparameterfv) == (dummy_pfnglgettexturelevelparameterfvproc as *const c_void) {&null::<PFNGLGETTEXTURELEVELPARAMETERFVPROC>()} else {&self.gettexturelevelparameterfv}})
			.field("gettexturelevelparameteriv", unsafe{if transmute::<_, *const c_void>(self.gettexturelevelparameteriv) == (dummy_pfnglgettexturelevelparameterivproc as *const c_void) {&null::<PFNGLGETTEXTURELEVELPARAMETERIVPROC>()} else {&self.gettexturelevelparameteriv}})
			.field("gettextureparameterfv", unsafe{if transmute::<_, *const c_void>(self.gettextureparameterfv) == (dummy_pfnglgettextureparameterfvproc as *const c_void) {&null::<PFNGLGETTEXTUREPARAMETERFVPROC>()} else {&self.gettextureparameterfv}})
			.field("gettextureparameteriiv", unsafe{if transmute::<_, *const c_void>(self.gettextureparameteriiv) == (dummy_pfnglgettextureparameteriivproc as *const c_void) {&null::<PFNGLGETTEXTUREPARAMETERIIVPROC>()} else {&self.gettextureparameteriiv}})
			.field("gettextureparameteriuiv", unsafe{if transmute::<_, *const c_void>(self.gettextureparameteriuiv) == (dummy_pfnglgettextureparameteriuivproc as *const c_void) {&null::<PFNGLGETTEXTUREPARAMETERIUIVPROC>()} else {&self.gettextureparameteriuiv}})
			.field("gettextureparameteriv", unsafe{if transmute::<_, *const c_void>(self.gettextureparameteriv) == (dummy_pfnglgettextureparameterivproc as *const c_void) {&null::<PFNGLGETTEXTUREPARAMETERIVPROC>()} else {&self.gettextureparameteriv}})
			.field("createvertexarrays", unsafe{if transmute::<_, *const c_void>(self.createvertexarrays) == (dummy_pfnglcreatevertexarraysproc as *const c_void) {&null::<PFNGLCREATEVERTEXARRAYSPROC>()} else {&self.createvertexarrays}})
			.field("disablevertexarrayattrib", unsafe{if transmute::<_, *const c_void>(self.disablevertexarrayattrib) == (dummy_pfngldisablevertexarrayattribproc as *const c_void) {&null::<PFNGLDISABLEVERTEXARRAYATTRIBPROC>()} else {&self.disablevertexarrayattrib}})
			.field("enablevertexarrayattrib", unsafe{if transmute::<_, *const c_void>(self.enablevertexarrayattrib) == (dummy_pfnglenablevertexarrayattribproc as *const c_void) {&null::<PFNGLENABLEVERTEXARRAYATTRIBPROC>()} else {&self.enablevertexarrayattrib}})
			.field("vertexarrayelementbuffer", unsafe{if transmute::<_, *const c_void>(self.vertexarrayelementbuffer) == (dummy_pfnglvertexarrayelementbufferproc as *const c_void) {&null::<PFNGLVERTEXARRAYELEMENTBUFFERPROC>()} else {&self.vertexarrayelementbuffer}})
			.field("vertexarrayvertexbuffer", unsafe{if transmute::<_, *const c_void>(self.vertexarrayvertexbuffer) == (dummy_pfnglvertexarrayvertexbufferproc as *const c_void) {&null::<PFNGLVERTEXARRAYVERTEXBUFFERPROC>()} else {&self.vertexarrayvertexbuffer}})
			.field("vertexarrayvertexbuffers", unsafe{if transmute::<_, *const c_void>(self.vertexarrayvertexbuffers) == (dummy_pfnglvertexarrayvertexbuffersproc as *const c_void) {&null::<PFNGLVERTEXARRAYVERTEXBUFFERSPROC>()} else {&self.vertexarrayvertexbuffers}})
			.field("vertexarrayattribbinding", unsafe{if transmute::<_, *const c_void>(self.vertexarrayattribbinding) == (dummy_pfnglvertexarrayattribbindingproc as *const c_void) {&null::<PFNGLVERTEXARRAYATTRIBBINDINGPROC>()} else {&self.vertexarrayattribbinding}})
			.field("vertexarrayattribformat", unsafe{if transmute::<_, *const c_void>(self.vertexarrayattribformat) == (dummy_pfnglvertexarrayattribformatproc as *const c_void) {&null::<PFNGLVERTEXARRAYATTRIBFORMATPROC>()} else {&self.vertexarrayattribformat}})
			.field("vertexarrayattribiformat", unsafe{if transmute::<_, *const c_void>(self.vertexarrayattribiformat) == (dummy_pfnglvertexarrayattribiformatproc as *const c_void) {&null::<PFNGLVERTEXARRAYATTRIBIFORMATPROC>()} else {&self.vertexarrayattribiformat}})
			.field("vertexarrayattriblformat", unsafe{if transmute::<_, *const c_void>(self.vertexarrayattriblformat) == (dummy_pfnglvertexarrayattriblformatproc as *const c_void) {&null::<PFNGLVERTEXARRAYATTRIBLFORMATPROC>()} else {&self.vertexarrayattriblformat}})
			.field("vertexarraybindingdivisor", unsafe{if transmute::<_, *const c_void>(self.vertexarraybindingdivisor) == (dummy_pfnglvertexarraybindingdivisorproc as *const c_void) {&null::<PFNGLVERTEXARRAYBINDINGDIVISORPROC>()} else {&self.vertexarraybindingdivisor}})
			.field("getvertexarrayiv", unsafe{if transmute::<_, *const c_void>(self.getvertexarrayiv) == (dummy_pfnglgetvertexarrayivproc as *const c_void) {&null::<PFNGLGETVERTEXARRAYIVPROC>()} else {&self.getvertexarrayiv}})
			.field("getvertexarrayindexediv", unsafe{if transmute::<_, *const c_void>(self.getvertexarrayindexediv) == (dummy_pfnglgetvertexarrayindexedivproc as *const c_void) {&null::<PFNGLGETVERTEXARRAYINDEXEDIVPROC>()} else {&self.getvertexarrayindexediv}})
			.field("getvertexarrayindexed64iv", unsafe{if transmute::<_, *const c_void>(self.getvertexarrayindexed64iv) == (dummy_pfnglgetvertexarrayindexed64ivproc as *const c_void) {&null::<PFNGLGETVERTEXARRAYINDEXED64IVPROC>()} else {&self.getvertexarrayindexed64iv}})
			.field("createsamplers", unsafe{if transmute::<_, *const c_void>(self.createsamplers) == (dummy_pfnglcreatesamplersproc as *const c_void) {&null::<PFNGLCREATESAMPLERSPROC>()} else {&self.createsamplers}})
			.field("createprogrampipelines", unsafe{if transmute::<_, *const c_void>(self.createprogrampipelines) == (dummy_pfnglcreateprogrampipelinesproc as *const c_void) {&null::<PFNGLCREATEPROGRAMPIPELINESPROC>()} else {&self.createprogrampipelines}})
			.field("createqueries", unsafe{if transmute::<_, *const c_void>(self.createqueries) == (dummy_pfnglcreatequeriesproc as *const c_void) {&null::<PFNGLCREATEQUERIESPROC>()} else {&self.createqueries}})
			.field("getquerybufferobjecti64v", unsafe{if transmute::<_, *const c_void>(self.getquerybufferobjecti64v) == (dummy_pfnglgetquerybufferobjecti64vproc as *const c_void) {&null::<PFNGLGETQUERYBUFFEROBJECTI64VPROC>()} else {&self.getquerybufferobjecti64v}})
			.field("getquerybufferobjectiv", unsafe{if transmute::<_, *const c_void>(self.getquerybufferobjectiv) == (dummy_pfnglgetquerybufferobjectivproc as *const c_void) {&null::<PFNGLGETQUERYBUFFEROBJECTIVPROC>()} else {&self.getquerybufferobjectiv}})
			.field("getquerybufferobjectui64v", unsafe{if transmute::<_, *const c_void>(self.getquerybufferobjectui64v) == (dummy_pfnglgetquerybufferobjectui64vproc as *const c_void) {&null::<PFNGLGETQUERYBUFFEROBJECTUI64VPROC>()} else {&self.getquerybufferobjectui64v}})
			.field("getquerybufferobjectuiv", unsafe{if transmute::<_, *const c_void>(self.getquerybufferobjectuiv) == (dummy_pfnglgetquerybufferobjectuivproc as *const c_void) {&null::<PFNGLGETQUERYBUFFEROBJECTUIVPROC>()} else {&self.getquerybufferobjectuiv}})
			.field("memorybarrierbyregion", unsafe{if transmute::<_, *const c_void>(self.memorybarrierbyregion) == (dummy_pfnglmemorybarrierbyregionproc as *const c_void) {&null::<PFNGLMEMORYBARRIERBYREGIONPROC>()} else {&self.memorybarrierbyregion}})
			.field("gettexturesubimage", unsafe{if transmute::<_, *const c_void>(self.gettexturesubimage) == (dummy_pfnglgettexturesubimageproc as *const c_void) {&null::<PFNGLGETTEXTURESUBIMAGEPROC>()} else {&self.gettexturesubimage}})
			.field("getcompressedtexturesubimage", unsafe{if transmute::<_, *const c_void>(self.getcompressedtexturesubimage) == (dummy_pfnglgetcompressedtexturesubimageproc as *const c_void) {&null::<PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC>()} else {&self.getcompressedtexturesubimage}})
			.field("getgraphicsresetstatus", unsafe{if transmute::<_, *const c_void>(self.getgraphicsresetstatus) == (dummy_pfnglgetgraphicsresetstatusproc as *const c_void) {&null::<PFNGLGETGRAPHICSRESETSTATUSPROC>()} else {&self.getgraphicsresetstatus}})
			.field("getncompressedteximage", unsafe{if transmute::<_, *const c_void>(self.getncompressedteximage) == (dummy_pfnglgetncompressedteximageproc as *const c_void) {&null::<PFNGLGETNCOMPRESSEDTEXIMAGEPROC>()} else {&self.getncompressedteximage}})
			.field("getnteximage", unsafe{if transmute::<_, *const c_void>(self.getnteximage) == (dummy_pfnglgetnteximageproc as *const c_void) {&null::<PFNGLGETNTEXIMAGEPROC>()} else {&self.getnteximage}})
			.field("getnuniformdv", unsafe{if transmute::<_, *const c_void>(self.getnuniformdv) == (dummy_pfnglgetnuniformdvproc as *const c_void) {&null::<PFNGLGETNUNIFORMDVPROC>()} else {&self.getnuniformdv}})
			.field("getnuniformfv", unsafe{if transmute::<_, *const c_void>(self.getnuniformfv) == (dummy_pfnglgetnuniformfvproc as *const c_void) {&null::<PFNGLGETNUNIFORMFVPROC>()} else {&self.getnuniformfv}})
			.field("getnuniformiv", unsafe{if transmute::<_, *const c_void>(self.getnuniformiv) == (dummy_pfnglgetnuniformivproc as *const c_void) {&null::<PFNGLGETNUNIFORMIVPROC>()} else {&self.getnuniformiv}})
			.field("getnuniformuiv", unsafe{if transmute::<_, *const c_void>(self.getnuniformuiv) == (dummy_pfnglgetnuniformuivproc as *const c_void) {&null::<PFNGLGETNUNIFORMUIVPROC>()} else {&self.getnuniformuiv}})
			.field("readnpixels", unsafe{if transmute::<_, *const c_void>(self.readnpixels) == (dummy_pfnglreadnpixelsproc as *const c_void) {&null::<PFNGLREADNPIXELSPROC>()} else {&self.readnpixels}})
			.field("getnmapdv", unsafe{if transmute::<_, *const c_void>(self.getnmapdv) == (dummy_pfnglgetnmapdvproc as *const c_void) {&null::<PFNGLGETNMAPDVPROC>()} else {&self.getnmapdv}})
			.field("getnmapfv", unsafe{if transmute::<_, *const c_void>(self.getnmapfv) == (dummy_pfnglgetnmapfvproc as *const c_void) {&null::<PFNGLGETNMAPFVPROC>()} else {&self.getnmapfv}})
			.field("getnmapiv", unsafe{if transmute::<_, *const c_void>(self.getnmapiv) == (dummy_pfnglgetnmapivproc as *const c_void) {&null::<PFNGLGETNMAPIVPROC>()} else {&self.getnmapiv}})
			.field("getnpixelmapfv", unsafe{if transmute::<_, *const c_void>(self.getnpixelmapfv) == (dummy_pfnglgetnpixelmapfvproc as *const c_void) {&null::<PFNGLGETNPIXELMAPFVPROC>()} else {&self.getnpixelmapfv}})
			.field("getnpixelmapuiv", unsafe{if transmute::<_, *const c_void>(self.getnpixelmapuiv) == (dummy_pfnglgetnpixelmapuivproc as *const c_void) {&null::<PFNGLGETNPIXELMAPUIVPROC>()} else {&self.getnpixelmapuiv}})
			.field("getnpixelmapusv", unsafe{if transmute::<_, *const c_void>(self.getnpixelmapusv) == (dummy_pfnglgetnpixelmapusvproc as *const c_void) {&null::<PFNGLGETNPIXELMAPUSVPROC>()} else {&self.getnpixelmapusv}})
			.field("getnpolygonstipple", unsafe{if transmute::<_, *const c_void>(self.getnpolygonstipple) == (dummy_pfnglgetnpolygonstippleproc as *const c_void) {&null::<PFNGLGETNPOLYGONSTIPPLEPROC>()} else {&self.getnpolygonstipple}})
			.field("getncolortable", unsafe{if transmute::<_, *const c_void>(self.getncolortable) == (dummy_pfnglgetncolortableproc as *const c_void) {&null::<PFNGLGETNCOLORTABLEPROC>()} else {&self.getncolortable}})
			.field("getnconvolutionfilter", unsafe{if transmute::<_, *const c_void>(self.getnconvolutionfilter) == (dummy_pfnglgetnconvolutionfilterproc as *const c_void) {&null::<PFNGLGETNCONVOLUTIONFILTERPROC>()} else {&self.getnconvolutionfilter}})
			.field("getnseparablefilter", unsafe{if transmute::<_, *const c_void>(self.getnseparablefilter) == (dummy_pfnglgetnseparablefilterproc as *const c_void) {&null::<PFNGLGETNSEPARABLEFILTERPROC>()} else {&self.getnseparablefilter}})
			.field("getnhistogram", unsafe{if transmute::<_, *const c_void>(self.getnhistogram) == (dummy_pfnglgetnhistogramproc as *const c_void) {&null::<PFNGLGETNHISTOGRAMPROC>()} else {&self.getnhistogram}})
			.field("getnminmax", unsafe{if transmute::<_, *const c_void>(self.getnminmax) == (dummy_pfnglgetnminmaxproc as *const c_void) {&null::<PFNGLGETNMINMAXPROC>()} else {&self.getnminmax}})
			.field("texturebarrier", unsafe{if transmute::<_, *const c_void>(self.texturebarrier) == (dummy_pfngltexturebarrierproc as *const c_void) {&null::<PFNGLTEXTUREBARRIERPROC>()} else {&self.texturebarrier}})
			.finish()
		} else {
			f.debug_struct("Version45")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}
type PFNGLSPECIALIZESHADERPROC = extern "system" fn(GLuint, *const GLchar, GLuint, *const GLuint, *const GLuint);
type PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC = extern "system" fn(GLenum, *const c_void, GLintptr, GLsizei, GLsizei);
type PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC = extern "system" fn(GLenum, GLenum, *const c_void, GLintptr, GLsizei, GLsizei);
type PFNGLPOLYGONOFFSETCLAMPPROC = extern "system" fn(GLfloat, GLfloat, GLfloat);
extern "system" fn dummy_pfnglspecializeshaderproc (_: GLuint, _: *const GLchar, _: GLuint, _: *const GLuint, _: *const GLuint) {
	panic!("OpenGL function pointer `glSpecializeShader()` is null.")
}
extern "system" fn dummy_pfnglmultidrawarraysindirectcountproc (_: GLenum, _: *const c_void, _: GLintptr, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glMultiDrawArraysIndirectCount()` is null.")
}
extern "system" fn dummy_pfnglmultidrawelementsindirectcountproc (_: GLenum, _: GLenum, _: *const c_void, _: GLintptr, _: GLsizei, _: GLsizei) {
	panic!("OpenGL function pointer `glMultiDrawElementsIndirectCount()` is null.")
}
extern "system" fn dummy_pfnglpolygonoffsetclampproc (_: GLfloat, _: GLfloat, _: GLfloat) {
	panic!("OpenGL function pointer `glPolygonOffsetClamp()` is null.")
}
pub const GL_SHADER_BINARY_FORMAT_SPIR_V: GLenum = 0x9551;
pub const GL_SPIR_V_BINARY: GLenum = 0x9552;
pub const GL_PARAMETER_BUFFER: GLenum = 0x80EE;
pub const GL_PARAMETER_BUFFER_BINDING: GLenum = 0x80EF;
pub const GL_CONTEXT_FLAG_NO_ERROR_BIT: GLbitfield = 0x00000008;
pub const GL_VERTICES_SUBMITTED: GLenum = 0x82EE;
pub const GL_PRIMITIVES_SUBMITTED: GLenum = 0x82EF;
pub const GL_VERTEX_SHADER_INVOCATIONS: GLenum = 0x82F0;
pub const GL_TESS_CONTROL_SHADER_PATCHES: GLenum = 0x82F1;
pub const GL_TESS_EVALUATION_SHADER_INVOCATIONS: GLenum = 0x82F2;
pub const GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED: GLenum = 0x82F3;
pub const GL_FRAGMENT_SHADER_INVOCATIONS: GLenum = 0x82F4;
pub const GL_COMPUTE_SHADER_INVOCATIONS: GLenum = 0x82F5;
pub const GL_CLIPPING_INPUT_PRIMITIVES: GLenum = 0x82F6;
pub const GL_CLIPPING_OUTPUT_PRIMITIVES: GLenum = 0x82F7;
pub const GL_POLYGON_OFFSET_CLAMP: GLenum = 0x8E1B;
pub const GL_SPIR_V_EXTENSIONS: GLenum = 0x9553;
pub const GL_NUM_SPIR_V_EXTENSIONS: GLenum = 0x9554;
pub const GL_TEXTURE_MAX_ANISOTROPY: GLenum = 0x84FE;
pub const GL_MAX_TEXTURE_MAX_ANISOTROPY: GLenum = 0x84FF;
pub const GL_TRANSFORM_FEEDBACK_OVERFLOW: GLenum = 0x82EC;
pub const GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW: GLenum = 0x82ED;

pub trait GL_4_6 {
	fn glGetError(&self) -> GLenum;
	fn glSpecializeShader(&self, shader: GLuint, pEntryPoint: *const GLchar, numSpecializationConstants: GLuint, pConstantIndex: *const GLuint, pConstantValue: *const GLuint) -> Result<()>;
	fn glMultiDrawArraysIndirectCount(&self, mode: GLenum, indirect: *const c_void, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei) -> Result<()>;
	fn glMultiDrawElementsIndirectCount(&self, mode: GLenum, type_: GLenum, indirect: *const c_void, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei) -> Result<()>;
	fn glPolygonOffsetClamp(&self, factor: GLfloat, units: GLfloat, clamp: GLfloat) -> Result<()>;
}

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Version46 {
	available: bool,
	geterror: PFNGLGETERRORPROC,
	specializeshader: PFNGLSPECIALIZESHADERPROC,
	multidrawarraysindirectcount: PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC,
	multidrawelementsindirectcount: PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC,
	polygonoffsetclamp: PFNGLPOLYGONOFFSETCLAMPPROC,
}

impl GL_4_6 for Version46 {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.geterror)()
	}
	#[inline(always)]
	fn glSpecializeShader(&self, shader: GLuint, pEntryPoint: *const GLchar, numSpecializationConstants: GLuint, pConstantIndex: *const GLuint, pConstantValue: *const GLuint) -> Result<()> {
		let ret = process_catch("glSpecializeShader", catch_unwind(||(self.specializeshader)(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSpecializeShader", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiDrawArraysIndirectCount(&self, mode: GLenum, indirect: *const c_void, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawArraysIndirectCount", catch_unwind(||(self.multidrawarraysindirectcount)(mode, indirect, drawcount, maxdrawcount, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawArraysIndirectCount", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiDrawElementsIndirectCount(&self, mode: GLenum, type_: GLenum, indirect: *const c_void, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawElementsIndirectCount", catch_unwind(||(self.multidrawelementsindirectcount)(mode, type_, indirect, drawcount, maxdrawcount, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawElementsIndirectCount", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPolygonOffsetClamp(&self, factor: GLfloat, units: GLfloat, clamp: GLfloat) -> Result<()> {
		let ret = process_catch("glPolygonOffsetClamp", catch_unwind(||(self.polygonoffsetclamp)(factor, units, clamp)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPolygonOffsetClamp", ret, self.glGetError());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl Version46 {
	pub fn new(base: impl GL_1_0, mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Self {
		let (_spec, major, minor, release) = base.get_version();
		if (major, minor, release) < (4, 6, 0) {
			return Self::default();
		}
		Self {
			available: true,
			geterror: {let proc = get_proc_address("glGetError"); if proc == null() {dummy_pfnglgeterrorproc} else {unsafe{transmute(proc)}}},
			specializeshader: {let proc = get_proc_address("glSpecializeShader"); if proc == null() {dummy_pfnglspecializeshaderproc} else {unsafe{transmute(proc)}}},
			multidrawarraysindirectcount: {let proc = get_proc_address("glMultiDrawArraysIndirectCount"); if proc == null() {dummy_pfnglmultidrawarraysindirectcountproc} else {unsafe{transmute(proc)}}},
			multidrawelementsindirectcount: {let proc = get_proc_address("glMultiDrawElementsIndirectCount"); if proc == null() {dummy_pfnglmultidrawelementsindirectcountproc} else {unsafe{transmute(proc)}}},
			polygonoffsetclamp: {let proc = get_proc_address("glPolygonOffsetClamp"); if proc == null() {dummy_pfnglpolygonoffsetclampproc} else {unsafe{transmute(proc)}}},
		}
	}
	#[inline(always)]
	pub fn get_available(&self) -> bool {
		self.available
	}
}

impl Default for Version46 {
	fn default() -> Self {
		Self {
			available: false,
			geterror: dummy_pfnglgeterrorproc,
			specializeshader: dummy_pfnglspecializeshaderproc,
			multidrawarraysindirectcount: dummy_pfnglmultidrawarraysindirectcountproc,
			multidrawelementsindirectcount: dummy_pfnglmultidrawelementsindirectcountproc,
			polygonoffsetclamp: dummy_pfnglpolygonoffsetclampproc,
		}
	}
}
impl Debug for Version46 {
	fn fmt(&self, f: &mut Formatter) -> fmt::Result {
		if self.available {
			f.debug_struct("Version46")
			.field("available", &self.available)
			.field("specializeshader", unsafe{if transmute::<_, *const c_void>(self.specializeshader) == (dummy_pfnglspecializeshaderproc as *const c_void) {&null::<PFNGLSPECIALIZESHADERPROC>()} else {&self.specializeshader}})
			.field("multidrawarraysindirectcount", unsafe{if transmute::<_, *const c_void>(self.multidrawarraysindirectcount) == (dummy_pfnglmultidrawarraysindirectcountproc as *const c_void) {&null::<PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC>()} else {&self.multidrawarraysindirectcount}})
			.field("multidrawelementsindirectcount", unsafe{if transmute::<_, *const c_void>(self.multidrawelementsindirectcount) == (dummy_pfnglmultidrawelementsindirectcountproc as *const c_void) {&null::<PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC>()} else {&self.multidrawelementsindirectcount}})
			.field("polygonoffsetclamp", unsafe{if transmute::<_, *const c_void>(self.polygonoffsetclamp) == (dummy_pfnglpolygonoffsetclampproc as *const c_void) {&null::<PFNGLPOLYGONOFFSETCLAMPPROC>()} else {&self.polygonoffsetclamp}})
			.finish()
		} else {
			f.debug_struct("Version46")
			.field("available", &self.available)
			.finish_non_exhaustive()
		}
	}
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct GLCore {
	pub version_1_0: Version10,
	pub version_1_1: Version11,
	pub version_1_2: Version12,
	pub version_1_3: Version13,
	pub version_1_4: Version14,
	pub version_1_5: Version15,
	pub version_2_0: Version20,
	pub version_2_1: Version21,
	pub version_3_0: Version30,
	pub version_3_1: Version31,
	pub version_3_2: Version32,
	pub version_3_3: Version33,
	pub version_4_0: Version40,
	pub version_4_1: Version41,
	pub version_4_2: Version42,
	pub version_4_3: Version43,
	pub version_4_4: Version44,
	pub version_4_5: Version45,
	pub version_4_6: Version46,
}

impl GL_1_0 for GLCore {
	#[inline(always)]
	fn glCullFace(&self, mode: GLenum) -> Result<()> {
		let ret = process_catch("glCullFace", catch_unwind(||(self.version_1_0.cullface)(mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCullFace", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFrontFace(&self, mode: GLenum) -> Result<()> {
		let ret = process_catch("glFrontFace", catch_unwind(||(self.version_1_0.frontface)(mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFrontFace", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glHint(&self, target: GLenum, mode: GLenum) -> Result<()> {
		let ret = process_catch("glHint", catch_unwind(||(self.version_1_0.hint)(target, mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glHint", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glLineWidth(&self, width: GLfloat) -> Result<()> {
		let ret = process_catch("glLineWidth", catch_unwind(||(self.version_1_0.linewidth)(width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLineWidth", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPointSize(&self, size: GLfloat) -> Result<()> {
		let ret = process_catch("glPointSize", catch_unwind(||(self.version_1_0.pointsize)(size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointSize", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPolygonMode(&self, face: GLenum, mode: GLenum) -> Result<()> {
		let ret = process_catch("glPolygonMode", catch_unwind(||(self.version_1_0.polygonmode)(face, mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPolygonMode", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glScissor(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glScissor", catch_unwind(||(self.version_1_0.scissor)(x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glScissor", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexParameterf(&self, target: GLenum, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glTexParameterf", catch_unwind(||(self.version_1_0.texparameterf)(target, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameterf", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexParameterfv(&self, target: GLenum, pname: GLenum, params: *const GLfloat) -> Result<()> {
		let ret = process_catch("glTexParameterfv", catch_unwind(||(self.version_1_0.texparameterfv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameterfv", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexParameteri(&self, target: GLenum, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glTexParameteri", catch_unwind(||(self.version_1_0.texparameteri)(target, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameteri", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexParameteriv(&self, target: GLenum, pname: GLenum, params: *const GLint) -> Result<()> {
		let ret = process_catch("glTexParameteriv", catch_unwind(||(self.version_1_0.texparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameteriv", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexImage1D(&self, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexImage1D", catch_unwind(||(self.version_1_0.teximage1d)(target, level, internalformat, width, border, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage1D", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexImage2D(&self, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexImage2D", catch_unwind(||(self.version_1_0.teximage2d)(target, level, internalformat, width, height, border, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage2D", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawBuffer(&self, buf: GLenum) -> Result<()> {
		let ret = process_catch("glDrawBuffer", catch_unwind(||(self.version_1_0.drawbuffer)(buf)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawBuffer", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClear(&self, mask: GLbitfield) -> Result<()> {
		let ret = process_catch("glClear", catch_unwind(||(self.version_1_0.clear)(mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClear", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearColor(&self, red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) -> Result<()> {
		let ret = process_catch("glClearColor", catch_unwind(||(self.version_1_0.clearcolor)(red, green, blue, alpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearColor", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearStencil(&self, s: GLint) -> Result<()> {
		let ret = process_catch("glClearStencil", catch_unwind(||(self.version_1_0.clearstencil)(s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearStencil", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearDepth(&self, depth: GLdouble) -> Result<()> {
		let ret = process_catch("glClearDepth", catch_unwind(||(self.version_1_0.cleardepth)(depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearDepth", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glStencilMask(&self, mask: GLuint) -> Result<()> {
		let ret = process_catch("glStencilMask", catch_unwind(||(self.version_1_0.stencilmask)(mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilMask", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glColorMask(&self, red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean) -> Result<()> {
		let ret = process_catch("glColorMask", catch_unwind(||(self.version_1_0.colormask)(red, green, blue, alpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorMask", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDepthMask(&self, flag: GLboolean) -> Result<()> {
		let ret = process_catch("glDepthMask", catch_unwind(||(self.version_1_0.depthmask)(flag)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthMask", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDisable(&self, cap: GLenum) -> Result<()> {
		let ret = process_catch("glDisable", catch_unwind(||(self.version_1_0.disable)(cap)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDisable", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glEnable(&self, cap: GLenum) -> Result<()> {
		let ret = process_catch("glEnable", catch_unwind(||(self.version_1_0.enable)(cap)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEnable", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFinish(&self) -> Result<()> {
		let ret = process_catch("glFinish", catch_unwind(||(self.version_1_0.finish)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFinish", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFlush(&self) -> Result<()> {
		let ret = process_catch("glFlush", catch_unwind(||(self.version_1_0.flush)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFlush", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBlendFunc(&self, sfactor: GLenum, dfactor: GLenum) -> Result<()> {
		let ret = process_catch("glBlendFunc", catch_unwind(||(self.version_1_0.blendfunc)(sfactor, dfactor)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendFunc", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glLogicOp(&self, opcode: GLenum) -> Result<()> {
		let ret = process_catch("glLogicOp", catch_unwind(||(self.version_1_0.logicop)(opcode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLogicOp", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glStencilFunc(&self, func: GLenum, ref_: GLint, mask: GLuint) -> Result<()> {
		let ret = process_catch("glStencilFunc", catch_unwind(||(self.version_1_0.stencilfunc)(func, ref_, mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilFunc", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glStencilOp(&self, fail: GLenum, zfail: GLenum, zpass: GLenum) -> Result<()> {
		let ret = process_catch("glStencilOp", catch_unwind(||(self.version_1_0.stencilop)(fail, zfail, zpass)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilOp", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDepthFunc(&self, func: GLenum) -> Result<()> {
		let ret = process_catch("glDepthFunc", catch_unwind(||(self.version_1_0.depthfunc)(func)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthFunc", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPixelStoref(&self, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glPixelStoref", catch_unwind(||(self.version_1_0.pixelstoref)(pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPixelStoref", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPixelStorei(&self, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glPixelStorei", catch_unwind(||(self.version_1_0.pixelstorei)(pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPixelStorei", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glReadBuffer(&self, src: GLenum) -> Result<()> {
		let ret = process_catch("glReadBuffer", catch_unwind(||(self.version_1_0.readbuffer)(src)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glReadBuffer", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glReadPixels(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glReadPixels", catch_unwind(||(self.version_1_0.readpixels)(x, y, width, height, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glReadPixels", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetBooleanv(&self, pname: GLenum, data: *mut GLboolean) -> Result<()> {
		let ret = process_catch("glGetBooleanv", catch_unwind(||(self.version_1_0.getbooleanv)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBooleanv", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetDoublev(&self, pname: GLenum, data: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetDoublev", catch_unwind(||(self.version_1_0.getdoublev)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetDoublev", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_1_0.geterror)()
	}
	#[inline(always)]
	fn glGetFloatv(&self, pname: GLenum, data: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetFloatv", catch_unwind(||(self.version_1_0.getfloatv)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFloatv", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetIntegerv(&self, pname: GLenum, data: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetIntegerv", catch_unwind(||(self.version_1_0.getintegerv)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetIntegerv", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetString(&self, name: GLenum) -> Result<&'static str> {
		let ret = process_catch("glGetString", catch_unwind(||unsafe{CStr::from_ptr((self.version_1_0.getstring)(name) as *const i8)}.to_str().unwrap()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetString", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTexImage(&self, target: GLenum, level: GLint, format: GLenum, type_: GLenum, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetTexImage", catch_unwind(||(self.version_1_0.getteximage)(target, level, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexImage", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTexParameterfv(&self, target: GLenum, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetTexParameterfv", catch_unwind(||(self.version_1_0.gettexparameterfv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexParameterfv", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTexParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTexParameteriv", catch_unwind(||(self.version_1_0.gettexparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexParameteriv", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTexLevelParameterfv(&self, target: GLenum, level: GLint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetTexLevelParameterfv", catch_unwind(||(self.version_1_0.gettexlevelparameterfv)(target, level, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexLevelParameterfv", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTexLevelParameteriv(&self, target: GLenum, level: GLint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTexLevelParameteriv", catch_unwind(||(self.version_1_0.gettexlevelparameteriv)(target, level, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexLevelParameteriv", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsEnabled(&self, cap: GLenum) -> Result<GLboolean> {
		let ret = process_catch("glIsEnabled", catch_unwind(||(self.version_1_0.isenabled)(cap)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsEnabled", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDepthRange(&self, n: GLdouble, f: GLdouble) -> Result<()> {
		let ret = process_catch("glDepthRange", catch_unwind(||(self.version_1_0.depthrange)(n, f)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthRange", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glViewport(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glViewport", catch_unwind(||(self.version_1_0.viewport)(x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glViewport", ret, (self.version_1_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn get_version(&self) -> (&'static str, u32, u32, u32) {
		self.version_1_0.get_version()
	}
	#[inline(always)]
	fn get_vendor(&self) -> &'static str {
		self.version_1_0.get_vendor()
	}
	#[inline(always)]
	fn get_renderer(&self) -> &'static str {
		self.version_1_0.get_renderer()
	}
	#[inline(always)]
	fn get_versionstr(&self) -> &'static str {
		self.version_1_0.get_versionstr()
	}
}

impl GL_1_1 for GLCore {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_1_1.geterror)()
	}
	#[inline(always)]
	fn glDrawArrays(&self, mode: GLenum, first: GLint, count: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawArrays", catch_unwind(||(self.version_1_1.drawarrays)(mode, first, count)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawArrays", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawElements(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void) -> Result<()> {
		let ret = process_catch("glDrawElements", catch_unwind(||(self.version_1_1.drawelements)(mode, count, type_, indices)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElements", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetPointerv(&self, pname: GLenum, params: *mut *mut c_void) -> Result<()> {
		let ret = process_catch("glGetPointerv", catch_unwind(||(self.version_1_1.getpointerv)(pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetPointerv", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPolygonOffset(&self, factor: GLfloat, units: GLfloat) -> Result<()> {
		let ret = process_catch("glPolygonOffset", catch_unwind(||(self.version_1_1.polygonoffset)(factor, units)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPolygonOffset", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyTexImage1D(&self, target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, border: GLint) -> Result<()> {
		let ret = process_catch("glCopyTexImage1D", catch_unwind(||(self.version_1_1.copyteximage1d)(target, level, internalformat, x, y, width, border)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexImage1D", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyTexImage2D(&self, target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint) -> Result<()> {
		let ret = process_catch("glCopyTexImage2D", catch_unwind(||(self.version_1_1.copyteximage2d)(target, level, internalformat, x, y, width, height, border)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexImage2D", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyTexSubImage1D(&self, target: GLenum, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTexSubImage1D", catch_unwind(||(self.version_1_1.copytexsubimage1d)(target, level, xoffset, x, y, width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexSubImage1D", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyTexSubImage2D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTexSubImage2D", catch_unwind(||(self.version_1_1.copytexsubimage2d)(target, level, xoffset, yoffset, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexSubImage2D", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexSubImage1D(&self, target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexSubImage1D", catch_unwind(||(self.version_1_1.texsubimage1d)(target, level, xoffset, width, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexSubImage1D", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexSubImage2D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexSubImage2D", catch_unwind(||(self.version_1_1.texsubimage2d)(target, level, xoffset, yoffset, width, height, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexSubImage2D", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindTexture(&self, target: GLenum, texture: GLuint) -> Result<()> {
		let ret = process_catch("glBindTexture", catch_unwind(||(self.version_1_1.bindtexture)(target, texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindTexture", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteTextures(&self, n: GLsizei, textures: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteTextures", catch_unwind(||(self.version_1_1.deletetextures)(n, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteTextures", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenTextures(&self, n: GLsizei, textures: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenTextures", catch_unwind(||(self.version_1_1.gentextures)(n, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenTextures", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsTexture(&self, texture: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsTexture", catch_unwind(||(self.version_1_1.istexture)(texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsTexture", ret, (self.version_1_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_1_2 for GLCore {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_1_2.geterror)()
	}
	#[inline(always)]
	fn glDrawRangeElements(&self, mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type_: GLenum, indices: *const c_void) -> Result<()> {
		let ret = process_catch("glDrawRangeElements", catch_unwind(||(self.version_1_2.drawrangeelements)(mode, start, end, count, type_, indices)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawRangeElements", ret, (self.version_1_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexImage3D(&self, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexImage3D", catch_unwind(||(self.version_1_2.teximage3d)(target, level, internalformat, width, height, depth, border, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage3D", ret, (self.version_1_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexSubImage3D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTexSubImage3D", catch_unwind(||(self.version_1_2.texsubimage3d)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexSubImage3D", ret, (self.version_1_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyTexSubImage3D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTexSubImage3D", catch_unwind(||(self.version_1_2.copytexsubimage3d)(target, level, xoffset, yoffset, zoffset, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTexSubImage3D", ret, (self.version_1_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_1_3 for GLCore {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_1_3.geterror)()
	}
	#[inline(always)]
	fn glActiveTexture(&self, texture: GLenum) -> Result<()> {
		let ret = process_catch("glActiveTexture", catch_unwind(||(self.version_1_3.activetexture)(texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glActiveTexture", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSampleCoverage(&self, value: GLfloat, invert: GLboolean) -> Result<()> {
		let ret = process_catch("glSampleCoverage", catch_unwind(||(self.version_1_3.samplecoverage)(value, invert)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSampleCoverage", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompressedTexImage3D(&self, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexImage3D", catch_unwind(||(self.version_1_3.compressedteximage3d)(target, level, internalformat, width, height, depth, border, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexImage3D", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompressedTexImage2D(&self, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexImage2D", catch_unwind(||(self.version_1_3.compressedteximage2d)(target, level, internalformat, width, height, border, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexImage2D", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompressedTexImage1D(&self, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, border: GLint, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexImage1D", catch_unwind(||(self.version_1_3.compressedteximage1d)(target, level, internalformat, width, border, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexImage1D", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompressedTexSubImage3D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexSubImage3D", catch_unwind(||(self.version_1_3.compressedtexsubimage3d)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexSubImage3D", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompressedTexSubImage2D(&self, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexSubImage2D", catch_unwind(||(self.version_1_3.compressedtexsubimage2d)(target, level, xoffset, yoffset, width, height, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexSubImage2D", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompressedTexSubImage1D(&self, target: GLenum, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTexSubImage1D", catch_unwind(||(self.version_1_3.compressedtexsubimage1d)(target, level, xoffset, width, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTexSubImage1D", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetCompressedTexImage(&self, target: GLenum, level: GLint, img: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetCompressedTexImage", catch_unwind(||(self.version_1_3.getcompressedteximage)(target, level, img)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetCompressedTexImage", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClientActiveTexture(&self, texture: GLenum) -> Result<()> {
		let ret = process_catch("glClientActiveTexture", catch_unwind(||(self.version_1_3.clientactivetexture)(texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClientActiveTexture", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord1d(&self, target: GLenum, s: GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1d", catch_unwind(||(self.version_1_3.multitexcoord1d)(target, s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1d", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord1dv(&self, target: GLenum, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1dv", catch_unwind(||(self.version_1_3.multitexcoord1dv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1dv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord1f(&self, target: GLenum, s: GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1f", catch_unwind(||(self.version_1_3.multitexcoord1f)(target, s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1f", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord1fv(&self, target: GLenum, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1fv", catch_unwind(||(self.version_1_3.multitexcoord1fv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1fv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord1i(&self, target: GLenum, s: GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1i", catch_unwind(||(self.version_1_3.multitexcoord1i)(target, s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1i", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord1iv(&self, target: GLenum, v: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1iv", catch_unwind(||(self.version_1_3.multitexcoord1iv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1iv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord1s(&self, target: GLenum, s: GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1s", catch_unwind(||(self.version_1_3.multitexcoord1s)(target, s)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1s", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord1sv(&self, target: GLenum, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord1sv", catch_unwind(||(self.version_1_3.multitexcoord1sv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord1sv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord2d(&self, target: GLenum, s: GLdouble, t: GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2d", catch_unwind(||(self.version_1_3.multitexcoord2d)(target, s, t)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2d", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord2dv(&self, target: GLenum, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2dv", catch_unwind(||(self.version_1_3.multitexcoord2dv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2dv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord2f(&self, target: GLenum, s: GLfloat, t: GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2f", catch_unwind(||(self.version_1_3.multitexcoord2f)(target, s, t)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2f", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord2fv(&self, target: GLenum, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2fv", catch_unwind(||(self.version_1_3.multitexcoord2fv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2fv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord2i(&self, target: GLenum, s: GLint, t: GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2i", catch_unwind(||(self.version_1_3.multitexcoord2i)(target, s, t)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2i", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord2iv(&self, target: GLenum, v: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2iv", catch_unwind(||(self.version_1_3.multitexcoord2iv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2iv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord2s(&self, target: GLenum, s: GLshort, t: GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2s", catch_unwind(||(self.version_1_3.multitexcoord2s)(target, s, t)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2s", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord2sv(&self, target: GLenum, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord2sv", catch_unwind(||(self.version_1_3.multitexcoord2sv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord2sv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord3d(&self, target: GLenum, s: GLdouble, t: GLdouble, r: GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3d", catch_unwind(||(self.version_1_3.multitexcoord3d)(target, s, t, r)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3d", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord3dv(&self, target: GLenum, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3dv", catch_unwind(||(self.version_1_3.multitexcoord3dv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3dv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord3f(&self, target: GLenum, s: GLfloat, t: GLfloat, r: GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3f", catch_unwind(||(self.version_1_3.multitexcoord3f)(target, s, t, r)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3f", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord3fv(&self, target: GLenum, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3fv", catch_unwind(||(self.version_1_3.multitexcoord3fv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3fv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord3i(&self, target: GLenum, s: GLint, t: GLint, r: GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3i", catch_unwind(||(self.version_1_3.multitexcoord3i)(target, s, t, r)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3i", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord3iv(&self, target: GLenum, v: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3iv", catch_unwind(||(self.version_1_3.multitexcoord3iv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3iv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord3s(&self, target: GLenum, s: GLshort, t: GLshort, r: GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3s", catch_unwind(||(self.version_1_3.multitexcoord3s)(target, s, t, r)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3s", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord3sv(&self, target: GLenum, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord3sv", catch_unwind(||(self.version_1_3.multitexcoord3sv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord3sv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord4d(&self, target: GLenum, s: GLdouble, t: GLdouble, r: GLdouble, q: GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4d", catch_unwind(||(self.version_1_3.multitexcoord4d)(target, s, t, r, q)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4d", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord4dv(&self, target: GLenum, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4dv", catch_unwind(||(self.version_1_3.multitexcoord4dv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4dv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord4f(&self, target: GLenum, s: GLfloat, t: GLfloat, r: GLfloat, q: GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4f", catch_unwind(||(self.version_1_3.multitexcoord4f)(target, s, t, r, q)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4f", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord4fv(&self, target: GLenum, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4fv", catch_unwind(||(self.version_1_3.multitexcoord4fv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4fv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord4i(&self, target: GLenum, s: GLint, t: GLint, r: GLint, q: GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4i", catch_unwind(||(self.version_1_3.multitexcoord4i)(target, s, t, r, q)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4i", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord4iv(&self, target: GLenum, v: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4iv", catch_unwind(||(self.version_1_3.multitexcoord4iv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4iv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord4s(&self, target: GLenum, s: GLshort, t: GLshort, r: GLshort, q: GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4s", catch_unwind(||(self.version_1_3.multitexcoord4s)(target, s, t, r, q)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4s", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoord4sv(&self, target: GLenum, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glMultiTexCoord4sv", catch_unwind(||(self.version_1_3.multitexcoord4sv)(target, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoord4sv", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glLoadTransposeMatrixf(&self, m: *const GLfloat) -> Result<()> {
		let ret = process_catch("glLoadTransposeMatrixf", catch_unwind(||(self.version_1_3.loadtransposematrixf)(m)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLoadTransposeMatrixf", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glLoadTransposeMatrixd(&self, m: *const GLdouble) -> Result<()> {
		let ret = process_catch("glLoadTransposeMatrixd", catch_unwind(||(self.version_1_3.loadtransposematrixd)(m)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLoadTransposeMatrixd", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultTransposeMatrixf(&self, m: *const GLfloat) -> Result<()> {
		let ret = process_catch("glMultTransposeMatrixf", catch_unwind(||(self.version_1_3.multtransposematrixf)(m)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultTransposeMatrixf", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultTransposeMatrixd(&self, m: *const GLdouble) -> Result<()> {
		let ret = process_catch("glMultTransposeMatrixd", catch_unwind(||(self.version_1_3.multtransposematrixd)(m)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultTransposeMatrixd", ret, (self.version_1_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_1_4 for GLCore {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_1_4.geterror)()
	}
	#[inline(always)]
	fn glBlendFuncSeparate(&self, sfactorRGB: GLenum, dfactorRGB: GLenum, sfactorAlpha: GLenum, dfactorAlpha: GLenum) -> Result<()> {
		let ret = process_catch("glBlendFuncSeparate", catch_unwind(||(self.version_1_4.blendfuncseparate)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendFuncSeparate", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiDrawArrays(&self, mode: GLenum, first: *const GLint, count: *const GLsizei, drawcount: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawArrays", catch_unwind(||(self.version_1_4.multidrawarrays)(mode, first, count, drawcount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawArrays", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiDrawElements(&self, mode: GLenum, count: *const GLsizei, type_: GLenum, indices: *const *const c_void, drawcount: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawElements", catch_unwind(||(self.version_1_4.multidrawelements)(mode, count, type_, indices, drawcount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawElements", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPointParameterf(&self, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glPointParameterf", catch_unwind(||(self.version_1_4.pointparameterf)(pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointParameterf", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPointParameterfv(&self, pname: GLenum, params: *const GLfloat) -> Result<()> {
		let ret = process_catch("glPointParameterfv", catch_unwind(||(self.version_1_4.pointparameterfv)(pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointParameterfv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPointParameteri(&self, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glPointParameteri", catch_unwind(||(self.version_1_4.pointparameteri)(pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointParameteri", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPointParameteriv(&self, pname: GLenum, params: *const GLint) -> Result<()> {
		let ret = process_catch("glPointParameteriv", catch_unwind(||(self.version_1_4.pointparameteriv)(pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPointParameteriv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFogCoordf(&self, coord: GLfloat) -> Result<()> {
		let ret = process_catch("glFogCoordf", catch_unwind(||(self.version_1_4.fogcoordf)(coord)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoordf", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFogCoordfv(&self, coord: *const GLfloat) -> Result<()> {
		let ret = process_catch("glFogCoordfv", catch_unwind(||(self.version_1_4.fogcoordfv)(coord)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoordfv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFogCoordd(&self, coord: GLdouble) -> Result<()> {
		let ret = process_catch("glFogCoordd", catch_unwind(||(self.version_1_4.fogcoordd)(coord)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoordd", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFogCoorddv(&self, coord: *const GLdouble) -> Result<()> {
		let ret = process_catch("glFogCoorddv", catch_unwind(||(self.version_1_4.fogcoorddv)(coord)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoorddv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFogCoordPointer(&self, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glFogCoordPointer", catch_unwind(||(self.version_1_4.fogcoordpointer)(type_, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFogCoordPointer", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3b(&self, red: GLbyte, green: GLbyte, blue: GLbyte) -> Result<()> {
		let ret = process_catch("glSecondaryColor3b", catch_unwind(||(self.version_1_4.secondarycolor3b)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3b", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3bv(&self, v: *const GLbyte) -> Result<()> {
		let ret = process_catch("glSecondaryColor3bv", catch_unwind(||(self.version_1_4.secondarycolor3bv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3bv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3d(&self, red: GLdouble, green: GLdouble, blue: GLdouble) -> Result<()> {
		let ret = process_catch("glSecondaryColor3d", catch_unwind(||(self.version_1_4.secondarycolor3d)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3d", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3dv(&self, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glSecondaryColor3dv", catch_unwind(||(self.version_1_4.secondarycolor3dv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3dv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3f(&self, red: GLfloat, green: GLfloat, blue: GLfloat) -> Result<()> {
		let ret = process_catch("glSecondaryColor3f", catch_unwind(||(self.version_1_4.secondarycolor3f)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3f", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3fv(&self, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glSecondaryColor3fv", catch_unwind(||(self.version_1_4.secondarycolor3fv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3fv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3i(&self, red: GLint, green: GLint, blue: GLint) -> Result<()> {
		let ret = process_catch("glSecondaryColor3i", catch_unwind(||(self.version_1_4.secondarycolor3i)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3i", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3iv(&self, v: *const GLint) -> Result<()> {
		let ret = process_catch("glSecondaryColor3iv", catch_unwind(||(self.version_1_4.secondarycolor3iv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3iv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3s(&self, red: GLshort, green: GLshort, blue: GLshort) -> Result<()> {
		let ret = process_catch("glSecondaryColor3s", catch_unwind(||(self.version_1_4.secondarycolor3s)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3s", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3sv(&self, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glSecondaryColor3sv", catch_unwind(||(self.version_1_4.secondarycolor3sv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3sv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3ub(&self, red: GLubyte, green: GLubyte, blue: GLubyte) -> Result<()> {
		let ret = process_catch("glSecondaryColor3ub", catch_unwind(||(self.version_1_4.secondarycolor3ub)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3ub", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3ubv(&self, v: *const GLubyte) -> Result<()> {
		let ret = process_catch("glSecondaryColor3ubv", catch_unwind(||(self.version_1_4.secondarycolor3ubv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3ubv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3ui(&self, red: GLuint, green: GLuint, blue: GLuint) -> Result<()> {
		let ret = process_catch("glSecondaryColor3ui", catch_unwind(||(self.version_1_4.secondarycolor3ui)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3ui", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3uiv(&self, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glSecondaryColor3uiv", catch_unwind(||(self.version_1_4.secondarycolor3uiv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3uiv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3us(&self, red: GLushort, green: GLushort, blue: GLushort) -> Result<()> {
		let ret = process_catch("glSecondaryColor3us", catch_unwind(||(self.version_1_4.secondarycolor3us)(red, green, blue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3us", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColor3usv(&self, v: *const GLushort) -> Result<()> {
		let ret = process_catch("glSecondaryColor3usv", catch_unwind(||(self.version_1_4.secondarycolor3usv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColor3usv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColorPointer(&self, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glSecondaryColorPointer", catch_unwind(||(self.version_1_4.secondarycolorpointer)(size, type_, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColorPointer", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos2d(&self, x: GLdouble, y: GLdouble) -> Result<()> {
		let ret = process_catch("glWindowPos2d", catch_unwind(||(self.version_1_4.windowpos2d)(x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2d", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos2dv(&self, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glWindowPos2dv", catch_unwind(||(self.version_1_4.windowpos2dv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2dv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos2f(&self, x: GLfloat, y: GLfloat) -> Result<()> {
		let ret = process_catch("glWindowPos2f", catch_unwind(||(self.version_1_4.windowpos2f)(x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2f", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos2fv(&self, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glWindowPos2fv", catch_unwind(||(self.version_1_4.windowpos2fv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2fv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos2i(&self, x: GLint, y: GLint) -> Result<()> {
		let ret = process_catch("glWindowPos2i", catch_unwind(||(self.version_1_4.windowpos2i)(x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2i", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos2iv(&self, v: *const GLint) -> Result<()> {
		let ret = process_catch("glWindowPos2iv", catch_unwind(||(self.version_1_4.windowpos2iv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2iv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos2s(&self, x: GLshort, y: GLshort) -> Result<()> {
		let ret = process_catch("glWindowPos2s", catch_unwind(||(self.version_1_4.windowpos2s)(x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2s", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos2sv(&self, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glWindowPos2sv", catch_unwind(||(self.version_1_4.windowpos2sv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos2sv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos3d(&self, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()> {
		let ret = process_catch("glWindowPos3d", catch_unwind(||(self.version_1_4.windowpos3d)(x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3d", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos3dv(&self, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glWindowPos3dv", catch_unwind(||(self.version_1_4.windowpos3dv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3dv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos3f(&self, x: GLfloat, y: GLfloat, z: GLfloat) -> Result<()> {
		let ret = process_catch("glWindowPos3f", catch_unwind(||(self.version_1_4.windowpos3f)(x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3f", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos3fv(&self, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glWindowPos3fv", catch_unwind(||(self.version_1_4.windowpos3fv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3fv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos3i(&self, x: GLint, y: GLint, z: GLint) -> Result<()> {
		let ret = process_catch("glWindowPos3i", catch_unwind(||(self.version_1_4.windowpos3i)(x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3i", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos3iv(&self, v: *const GLint) -> Result<()> {
		let ret = process_catch("glWindowPos3iv", catch_unwind(||(self.version_1_4.windowpos3iv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3iv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos3s(&self, x: GLshort, y: GLshort, z: GLshort) -> Result<()> {
		let ret = process_catch("glWindowPos3s", catch_unwind(||(self.version_1_4.windowpos3s)(x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3s", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWindowPos3sv(&self, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glWindowPos3sv", catch_unwind(||(self.version_1_4.windowpos3sv)(v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWindowPos3sv", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBlendColor(&self, red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) -> Result<()> {
		let ret = process_catch("glBlendColor", catch_unwind(||(self.version_1_4.blendcolor)(red, green, blue, alpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendColor", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBlendEquation(&self, mode: GLenum) -> Result<()> {
		let ret = process_catch("glBlendEquation", catch_unwind(||(self.version_1_4.blendequation)(mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendEquation", ret, (self.version_1_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_1_5 for GLCore {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_1_5.geterror)()
	}
	#[inline(always)]
	fn glGenQueries(&self, n: GLsizei, ids: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenQueries", catch_unwind(||(self.version_1_5.genqueries)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenQueries", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteQueries(&self, n: GLsizei, ids: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteQueries", catch_unwind(||(self.version_1_5.deletequeries)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteQueries", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsQuery(&self, id: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsQuery", catch_unwind(||(self.version_1_5.isquery)(id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsQuery", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBeginQuery(&self, target: GLenum, id: GLuint) -> Result<()> {
		let ret = process_catch("glBeginQuery", catch_unwind(||(self.version_1_5.beginquery)(target, id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBeginQuery", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glEndQuery(&self, target: GLenum) -> Result<()> {
		let ret = process_catch("glEndQuery", catch_unwind(||(self.version_1_5.endquery)(target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEndQuery", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryiv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetQueryiv", catch_unwind(||(self.version_1_5.getqueryiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryiv", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryObjectiv(&self, id: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetQueryObjectiv", catch_unwind(||(self.version_1_5.getqueryobjectiv)(id, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryObjectiv", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryObjectuiv(&self, id: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetQueryObjectuiv", catch_unwind(||(self.version_1_5.getqueryobjectuiv)(id, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryObjectuiv", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindBuffer(&self, target: GLenum, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glBindBuffer", catch_unwind(||(self.version_1_5.bindbuffer)(target, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBuffer", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteBuffers(&self, n: GLsizei, buffers: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteBuffers", catch_unwind(||(self.version_1_5.deletebuffers)(n, buffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteBuffers", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenBuffers(&self, n: GLsizei, buffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenBuffers", catch_unwind(||(self.version_1_5.genbuffers)(n, buffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenBuffers", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsBuffer(&self, buffer: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsBuffer", catch_unwind(||(self.version_1_5.isbuffer)(buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsBuffer", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBufferData(&self, target: GLenum, size: GLsizeiptr, data: *const c_void, usage: GLenum) -> Result<()> {
		let ret = process_catch("glBufferData", catch_unwind(||(self.version_1_5.bufferdata)(target, size, data, usage)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBufferData", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBufferSubData(&self, target: GLenum, offset: GLintptr, size: GLsizeiptr, data: *const c_void) -> Result<()> {
		let ret = process_catch("glBufferSubData", catch_unwind(||(self.version_1_5.buffersubdata)(target, offset, size, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBufferSubData", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetBufferSubData(&self, target: GLenum, offset: GLintptr, size: GLsizeiptr, data: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetBufferSubData", catch_unwind(||(self.version_1_5.getbuffersubdata)(target, offset, size, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBufferSubData", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMapBuffer(&self, target: GLenum, access: GLenum) -> Result<*mut c_void> {
		let ret = process_catch("glMapBuffer", catch_unwind(||(self.version_1_5.mapbuffer)(target, access)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMapBuffer", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUnmapBuffer(&self, target: GLenum) -> Result<GLboolean> {
		let ret = process_catch("glUnmapBuffer", catch_unwind(||(self.version_1_5.unmapbuffer)(target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUnmapBuffer", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetBufferParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetBufferParameteriv", catch_unwind(||(self.version_1_5.getbufferparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBufferParameteriv", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetBufferPointerv(&self, target: GLenum, pname: GLenum, params: *mut *mut c_void) -> Result<()> {
		let ret = process_catch("glGetBufferPointerv", catch_unwind(||(self.version_1_5.getbufferpointerv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBufferPointerv", ret, (self.version_1_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_2_0 for GLCore {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_2_0.geterror)()
	}
	#[inline(always)]
	fn glBlendEquationSeparate(&self, modeRGB: GLenum, modeAlpha: GLenum) -> Result<()> {
		let ret = process_catch("glBlendEquationSeparate", catch_unwind(||(self.version_2_0.blendequationseparate)(modeRGB, modeAlpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendEquationSeparate", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawBuffers(&self, n: GLsizei, bufs: *const GLenum) -> Result<()> {
		let ret = process_catch("glDrawBuffers", catch_unwind(||(self.version_2_0.drawbuffers)(n, bufs)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawBuffers", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glStencilOpSeparate(&self, face: GLenum, sfail: GLenum, dpfail: GLenum, dppass: GLenum) -> Result<()> {
		let ret = process_catch("glStencilOpSeparate", catch_unwind(||(self.version_2_0.stencilopseparate)(face, sfail, dpfail, dppass)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilOpSeparate", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glStencilFuncSeparate(&self, face: GLenum, func: GLenum, ref_: GLint, mask: GLuint) -> Result<()> {
		let ret = process_catch("glStencilFuncSeparate", catch_unwind(||(self.version_2_0.stencilfuncseparate)(face, func, ref_, mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilFuncSeparate", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glStencilMaskSeparate(&self, face: GLenum, mask: GLuint) -> Result<()> {
		let ret = process_catch("glStencilMaskSeparate", catch_unwind(||(self.version_2_0.stencilmaskseparate)(face, mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glStencilMaskSeparate", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glAttachShader(&self, program: GLuint, shader: GLuint) -> Result<()> {
		let ret = process_catch("glAttachShader", catch_unwind(||(self.version_2_0.attachshader)(program, shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glAttachShader", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindAttribLocation(&self, program: GLuint, index: GLuint, name: *const GLchar) -> Result<()> {
		let ret = process_catch("glBindAttribLocation", catch_unwind(||(self.version_2_0.bindattriblocation)(program, index, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindAttribLocation", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompileShader(&self, shader: GLuint) -> Result<()> {
		let ret = process_catch("glCompileShader", catch_unwind(||(self.version_2_0.compileshader)(shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompileShader", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateProgram(&self) -> Result<GLuint> {
		let ret = process_catch("glCreateProgram", catch_unwind(||(self.version_2_0.createprogram)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateProgram", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateShader(&self, type_: GLenum) -> Result<GLuint> {
		let ret = process_catch("glCreateShader", catch_unwind(||(self.version_2_0.createshader)(type_)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateShader", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteProgram(&self, program: GLuint) -> Result<()> {
		let ret = process_catch("glDeleteProgram", catch_unwind(||(self.version_2_0.deleteprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteProgram", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteShader(&self, shader: GLuint) -> Result<()> {
		let ret = process_catch("glDeleteShader", catch_unwind(||(self.version_2_0.deleteshader)(shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteShader", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDetachShader(&self, program: GLuint, shader: GLuint) -> Result<()> {
		let ret = process_catch("glDetachShader", catch_unwind(||(self.version_2_0.detachshader)(program, shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDetachShader", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDisableVertexAttribArray(&self, index: GLuint) -> Result<()> {
		let ret = process_catch("glDisableVertexAttribArray", catch_unwind(||(self.version_2_0.disablevertexattribarray)(index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDisableVertexAttribArray", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glEnableVertexAttribArray(&self, index: GLuint) -> Result<()> {
		let ret = process_catch("glEnableVertexAttribArray", catch_unwind(||(self.version_2_0.enablevertexattribarray)(index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEnableVertexAttribArray", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveAttrib(&self, program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLint, type_: *mut GLenum, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveAttrib", catch_unwind(||(self.version_2_0.getactiveattrib)(program, index, bufSize, length, size, type_, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveAttrib", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveUniform(&self, program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLint, type_: *mut GLenum, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveUniform", catch_unwind(||(self.version_2_0.getactiveuniform)(program, index, bufSize, length, size, type_, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniform", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetAttachedShaders(&self, program: GLuint, maxCount: GLsizei, count: *mut GLsizei, shaders: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetAttachedShaders", catch_unwind(||(self.version_2_0.getattachedshaders)(program, maxCount, count, shaders)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetAttachedShaders", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetAttribLocation(&self, program: GLuint, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetAttribLocation", catch_unwind(||(self.version_2_0.getattriblocation)(program, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetAttribLocation", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramiv(&self, program: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramiv", catch_unwind(||(self.version_2_0.getprogramiv)(program, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramiv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramInfoLog(&self, program: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetProgramInfoLog", catch_unwind(||(self.version_2_0.getprograminfolog)(program, bufSize, length, infoLog)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramInfoLog", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetShaderiv(&self, shader: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetShaderiv", catch_unwind(||(self.version_2_0.getshaderiv)(shader, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetShaderiv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetShaderInfoLog(&self, shader: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetShaderInfoLog", catch_unwind(||(self.version_2_0.getshaderinfolog)(shader, bufSize, length, infoLog)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetShaderInfoLog", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetShaderSource(&self, shader: GLuint, bufSize: GLsizei, length: *mut GLsizei, source: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetShaderSource", catch_unwind(||(self.version_2_0.getshadersource)(shader, bufSize, length, source)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetShaderSource", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetUniformLocation(&self, program: GLuint, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetUniformLocation", catch_unwind(||(self.version_2_0.getuniformlocation)(program, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformLocation", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetUniformfv(&self, program: GLuint, location: GLint, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetUniformfv", catch_unwind(||(self.version_2_0.getuniformfv)(program, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformfv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetUniformiv(&self, program: GLuint, location: GLint, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetUniformiv", catch_unwind(||(self.version_2_0.getuniformiv)(program, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformiv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexAttribdv(&self, index: GLuint, pname: GLenum, params: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetVertexAttribdv", catch_unwind(||(self.version_2_0.getvertexattribdv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribdv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexAttribfv(&self, index: GLuint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetVertexAttribfv", catch_unwind(||(self.version_2_0.getvertexattribfv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribfv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexAttribiv(&self, index: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetVertexAttribiv", catch_unwind(||(self.version_2_0.getvertexattribiv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribiv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexAttribPointerv(&self, index: GLuint, pname: GLenum, pointer: *mut *mut c_void) -> Result<()> {
		let ret = process_catch("glGetVertexAttribPointerv", catch_unwind(||(self.version_2_0.getvertexattribpointerv)(index, pname, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribPointerv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsProgram(&self, program: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsProgram", catch_unwind(||(self.version_2_0.isprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsProgram", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsShader(&self, shader: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsShader", catch_unwind(||(self.version_2_0.isshader)(shader)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsShader", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glLinkProgram(&self, program: GLuint) -> Result<()> {
		let ret = process_catch("glLinkProgram", catch_unwind(||(self.version_2_0.linkprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glLinkProgram", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glShaderSource(&self, shader: GLuint, count: GLsizei, string_: *const *const GLchar, length: *const GLint) -> Result<()> {
		let ret = process_catch("glShaderSource", catch_unwind(||(self.version_2_0.shadersource)(shader, count, string_, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glShaderSource", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUseProgram(&self, program: GLuint) -> Result<()> {
		let ret = process_catch("glUseProgram", catch_unwind(||(self.version_2_0.useprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUseProgram", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform1f(&self, location: GLint, v0: GLfloat) -> Result<()> {
		let ret = process_catch("glUniform1f", catch_unwind(||(self.version_2_0.uniform1f)(location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1f", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform2f(&self, location: GLint, v0: GLfloat, v1: GLfloat) -> Result<()> {
		let ret = process_catch("glUniform2f", catch_unwind(||(self.version_2_0.uniform2f)(location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2f", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform3f(&self, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat) -> Result<()> {
		let ret = process_catch("glUniform3f", catch_unwind(||(self.version_2_0.uniform3f)(location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3f", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform4f(&self, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat) -> Result<()> {
		let ret = process_catch("glUniform4f", catch_unwind(||(self.version_2_0.uniform4f)(location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4f", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform1i(&self, location: GLint, v0: GLint) -> Result<()> {
		let ret = process_catch("glUniform1i", catch_unwind(||(self.version_2_0.uniform1i)(location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1i", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform2i(&self, location: GLint, v0: GLint, v1: GLint) -> Result<()> {
		let ret = process_catch("glUniform2i", catch_unwind(||(self.version_2_0.uniform2i)(location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2i", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform3i(&self, location: GLint, v0: GLint, v1: GLint, v2: GLint) -> Result<()> {
		let ret = process_catch("glUniform3i", catch_unwind(||(self.version_2_0.uniform3i)(location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3i", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform4i(&self, location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint) -> Result<()> {
		let ret = process_catch("glUniform4i", catch_unwind(||(self.version_2_0.uniform4i)(location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4i", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform1fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniform1fv", catch_unwind(||(self.version_2_0.uniform1fv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform2fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniform2fv", catch_unwind(||(self.version_2_0.uniform2fv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform3fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniform3fv", catch_unwind(||(self.version_2_0.uniform3fv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform4fv(&self, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniform4fv", catch_unwind(||(self.version_2_0.uniform4fv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform1iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glUniform1iv", catch_unwind(||(self.version_2_0.uniform1iv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1iv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform2iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glUniform2iv", catch_unwind(||(self.version_2_0.uniform2iv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2iv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform3iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glUniform3iv", catch_unwind(||(self.version_2_0.uniform3iv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3iv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform4iv(&self, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glUniform4iv", catch_unwind(||(self.version_2_0.uniform4iv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4iv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix2fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix2fv", catch_unwind(||(self.version_2_0.uniformmatrix2fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix3fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix3fv", catch_unwind(||(self.version_2_0.uniformmatrix3fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix4fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix4fv", catch_unwind(||(self.version_2_0.uniformmatrix4fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glValidateProgram(&self, program: GLuint) -> Result<()> {
		let ret = process_catch("glValidateProgram", catch_unwind(||(self.version_2_0.validateprogram)(program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glValidateProgram", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib1d(&self, index: GLuint, x: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib1d", catch_unwind(||(self.version_2_0.vertexattrib1d)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1d", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib1dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib1dv", catch_unwind(||(self.version_2_0.vertexattrib1dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1dv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib1f(&self, index: GLuint, x: GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib1f", catch_unwind(||(self.version_2_0.vertexattrib1f)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1f", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib1fv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib1fv", catch_unwind(||(self.version_2_0.vertexattrib1fv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib1s(&self, index: GLuint, x: GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib1s", catch_unwind(||(self.version_2_0.vertexattrib1s)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1s", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib1sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib1sv", catch_unwind(||(self.version_2_0.vertexattrib1sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib1sv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib2d(&self, index: GLuint, x: GLdouble, y: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib2d", catch_unwind(||(self.version_2_0.vertexattrib2d)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2d", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib2dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib2dv", catch_unwind(||(self.version_2_0.vertexattrib2dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2dv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib2f(&self, index: GLuint, x: GLfloat, y: GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib2f", catch_unwind(||(self.version_2_0.vertexattrib2f)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2f", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib2fv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib2fv", catch_unwind(||(self.version_2_0.vertexattrib2fv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib2s(&self, index: GLuint, x: GLshort, y: GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib2s", catch_unwind(||(self.version_2_0.vertexattrib2s)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2s", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib2sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib2sv", catch_unwind(||(self.version_2_0.vertexattrib2sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib2sv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib3d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib3d", catch_unwind(||(self.version_2_0.vertexattrib3d)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3d", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib3dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib3dv", catch_unwind(||(self.version_2_0.vertexattrib3dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3dv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib3f(&self, index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib3f", catch_unwind(||(self.version_2_0.vertexattrib3f)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3f", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib3fv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib3fv", catch_unwind(||(self.version_2_0.vertexattrib3fv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib3s(&self, index: GLuint, x: GLshort, y: GLshort, z: GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib3s", catch_unwind(||(self.version_2_0.vertexattrib3s)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3s", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib3sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib3sv", catch_unwind(||(self.version_2_0.vertexattrib3sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib3sv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4Nbv(&self, index: GLuint, v: *const GLbyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nbv", catch_unwind(||(self.version_2_0.vertexattrib4nbv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nbv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4Niv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Niv", catch_unwind(||(self.version_2_0.vertexattrib4niv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Niv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4Nsv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nsv", catch_unwind(||(self.version_2_0.vertexattrib4nsv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nsv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4Nub(&self, index: GLuint, x: GLubyte, y: GLubyte, z: GLubyte, w: GLubyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nub", catch_unwind(||(self.version_2_0.vertexattrib4nub)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nub", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4Nubv(&self, index: GLuint, v: *const GLubyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nubv", catch_unwind(||(self.version_2_0.vertexattrib4nubv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nubv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4Nuiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nuiv", catch_unwind(||(self.version_2_0.vertexattrib4nuiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nuiv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4Nusv(&self, index: GLuint, v: *const GLushort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4Nusv", catch_unwind(||(self.version_2_0.vertexattrib4nusv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4Nusv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4bv(&self, index: GLuint, v: *const GLbyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4bv", catch_unwind(||(self.version_2_0.vertexattrib4bv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4bv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib4d", catch_unwind(||(self.version_2_0.vertexattrib4d)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4d", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttrib4dv", catch_unwind(||(self.version_2_0.vertexattrib4dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4dv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4f(&self, index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib4f", catch_unwind(||(self.version_2_0.vertexattrib4f)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4f", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4fv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glVertexAttrib4fv", catch_unwind(||(self.version_2_0.vertexattrib4fv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4fv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttrib4iv", catch_unwind(||(self.version_2_0.vertexattrib4iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4iv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4s(&self, index: GLuint, x: GLshort, y: GLshort, z: GLshort, w: GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4s", catch_unwind(||(self.version_2_0.vertexattrib4s)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4s", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4sv", catch_unwind(||(self.version_2_0.vertexattrib4sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4sv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4ubv(&self, index: GLuint, v: *const GLubyte) -> Result<()> {
		let ret = process_catch("glVertexAttrib4ubv", catch_unwind(||(self.version_2_0.vertexattrib4ubv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4ubv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttrib4uiv", catch_unwind(||(self.version_2_0.vertexattrib4uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4uiv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttrib4usv(&self, index: GLuint, v: *const GLushort) -> Result<()> {
		let ret = process_catch("glVertexAttrib4usv", catch_unwind(||(self.version_2_0.vertexattrib4usv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttrib4usv", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribPointer(&self, index: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glVertexAttribPointer", catch_unwind(||(self.version_2_0.vertexattribpointer)(index, size, type_, normalized, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribPointer", ret, (self.version_2_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn get_shading_language_version(&self) -> &'static str {
		self.version_2_0.shading_language_version
	}
}

impl GL_2_1 for GLCore {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_2_1.geterror)()
	}
	#[inline(always)]
	fn glUniformMatrix2x3fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix2x3fv", catch_unwind(||(self.version_2_1.uniformmatrix2x3fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2x3fv", ret, (self.version_2_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix3x2fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix3x2fv", catch_unwind(||(self.version_2_1.uniformmatrix3x2fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3x2fv", ret, (self.version_2_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix2x4fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix2x4fv", catch_unwind(||(self.version_2_1.uniformmatrix2x4fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2x4fv", ret, (self.version_2_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix4x2fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix4x2fv", catch_unwind(||(self.version_2_1.uniformmatrix4x2fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4x2fv", ret, (self.version_2_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix3x4fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix3x4fv", catch_unwind(||(self.version_2_1.uniformmatrix3x4fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3x4fv", ret, (self.version_2_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix4x3fv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glUniformMatrix4x3fv", catch_unwind(||(self.version_2_1.uniformmatrix4x3fv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4x3fv", ret, (self.version_2_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_3_0 for GLCore {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_3_0.geterror)()
	}
	#[inline(always)]
	fn glColorMaski(&self, index: GLuint, r: GLboolean, g: GLboolean, b: GLboolean, a: GLboolean) -> Result<()> {
		let ret = process_catch("glColorMaski", catch_unwind(||(self.version_3_0.colormaski)(index, r, g, b, a)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorMaski", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetBooleani_v(&self, target: GLenum, index: GLuint, data: *mut GLboolean) -> Result<()> {
		let ret = process_catch("glGetBooleani_v", catch_unwind(||(self.version_3_0.getbooleani_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBooleani_v", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetIntegeri_v(&self, target: GLenum, index: GLuint, data: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetIntegeri_v", catch_unwind(||(self.version_3_0.getintegeri_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetIntegeri_v", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glEnablei(&self, target: GLenum, index: GLuint) -> Result<()> {
		let ret = process_catch("glEnablei", catch_unwind(||(self.version_3_0.enablei)(target, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEnablei", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDisablei(&self, target: GLenum, index: GLuint) -> Result<()> {
		let ret = process_catch("glDisablei", catch_unwind(||(self.version_3_0.disablei)(target, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDisablei", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsEnabledi(&self, target: GLenum, index: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsEnabledi", catch_unwind(||(self.version_3_0.isenabledi)(target, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsEnabledi", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBeginTransformFeedback(&self, primitiveMode: GLenum) -> Result<()> {
		let ret = process_catch("glBeginTransformFeedback", catch_unwind(||(self.version_3_0.begintransformfeedback)(primitiveMode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBeginTransformFeedback", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glEndTransformFeedback(&self) -> Result<()> {
		let ret = process_catch("glEndTransformFeedback", catch_unwind(||(self.version_3_0.endtransformfeedback)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEndTransformFeedback", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindBufferRange(&self, target: GLenum, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glBindBufferRange", catch_unwind(||(self.version_3_0.bindbufferrange)(target, index, buffer, offset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBufferRange", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindBufferBase(&self, target: GLenum, index: GLuint, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glBindBufferBase", catch_unwind(||(self.version_3_0.bindbufferbase)(target, index, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBufferBase", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTransformFeedbackVaryings(&self, program: GLuint, count: GLsizei, varyings: *const *const GLchar, bufferMode: GLenum) -> Result<()> {
		let ret = process_catch("glTransformFeedbackVaryings", catch_unwind(||(self.version_3_0.transformfeedbackvaryings)(program, count, varyings, bufferMode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTransformFeedbackVaryings", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTransformFeedbackVarying(&self, program: GLuint, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, size: *mut GLsizei, type_: *mut GLenum, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetTransformFeedbackVarying", catch_unwind(||(self.version_3_0.gettransformfeedbackvarying)(program, index, bufSize, length, size, type_, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTransformFeedbackVarying", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClampColor(&self, target: GLenum, clamp: GLenum) -> Result<()> {
		let ret = process_catch("glClampColor", catch_unwind(||(self.version_3_0.clampcolor)(target, clamp)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClampColor", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBeginConditionalRender(&self, id: GLuint, mode: GLenum) -> Result<()> {
		let ret = process_catch("glBeginConditionalRender", catch_unwind(||(self.version_3_0.beginconditionalrender)(id, mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBeginConditionalRender", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glEndConditionalRender(&self) -> Result<()> {
		let ret = process_catch("glEndConditionalRender", catch_unwind(||(self.version_3_0.endconditionalrender)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEndConditionalRender", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribIPointer(&self, index: GLuint, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glVertexAttribIPointer", catch_unwind(||(self.version_3_0.vertexattribipointer)(index, size, type_, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribIPointer", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexAttribIiv(&self, index: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetVertexAttribIiv", catch_unwind(||(self.version_3_0.getvertexattribiiv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribIiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexAttribIuiv(&self, index: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetVertexAttribIuiv", catch_unwind(||(self.version_3_0.getvertexattribiuiv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribIuiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI1i(&self, index: GLuint, x: GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI1i", catch_unwind(||(self.version_3_0.vertexattribi1i)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI1i", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI2i(&self, index: GLuint, x: GLint, y: GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI2i", catch_unwind(||(self.version_3_0.vertexattribi2i)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI2i", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI3i(&self, index: GLuint, x: GLint, y: GLint, z: GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI3i", catch_unwind(||(self.version_3_0.vertexattribi3i)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI3i", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI4i(&self, index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI4i", catch_unwind(||(self.version_3_0.vertexattribi4i)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4i", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI1ui(&self, index: GLuint, x: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI1ui", catch_unwind(||(self.version_3_0.vertexattribi1ui)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI1ui", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI2ui(&self, index: GLuint, x: GLuint, y: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI2ui", catch_unwind(||(self.version_3_0.vertexattribi2ui)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI2ui", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI3ui(&self, index: GLuint, x: GLuint, y: GLuint, z: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI3ui", catch_unwind(||(self.version_3_0.vertexattribi3ui)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI3ui", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI4ui(&self, index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI4ui", catch_unwind(||(self.version_3_0.vertexattribi4ui)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4ui", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI1iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI1iv", catch_unwind(||(self.version_3_0.vertexattribi1iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI1iv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI2iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI2iv", catch_unwind(||(self.version_3_0.vertexattribi2iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI2iv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI3iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI3iv", catch_unwind(||(self.version_3_0.vertexattribi3iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI3iv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI4iv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glVertexAttribI4iv", catch_unwind(||(self.version_3_0.vertexattribi4iv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4iv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI1uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI1uiv", catch_unwind(||(self.version_3_0.vertexattribi1uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI1uiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI2uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI2uiv", catch_unwind(||(self.version_3_0.vertexattribi2uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI2uiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI3uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI3uiv", catch_unwind(||(self.version_3_0.vertexattribi3uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI3uiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI4uiv(&self, index: GLuint, v: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribI4uiv", catch_unwind(||(self.version_3_0.vertexattribi4uiv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4uiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI4bv(&self, index: GLuint, v: *const GLbyte) -> Result<()> {
		let ret = process_catch("glVertexAttribI4bv", catch_unwind(||(self.version_3_0.vertexattribi4bv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4bv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI4sv(&self, index: GLuint, v: *const GLshort) -> Result<()> {
		let ret = process_catch("glVertexAttribI4sv", catch_unwind(||(self.version_3_0.vertexattribi4sv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4sv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI4ubv(&self, index: GLuint, v: *const GLubyte) -> Result<()> {
		let ret = process_catch("glVertexAttribI4ubv", catch_unwind(||(self.version_3_0.vertexattribi4ubv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4ubv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribI4usv(&self, index: GLuint, v: *const GLushort) -> Result<()> {
		let ret = process_catch("glVertexAttribI4usv", catch_unwind(||(self.version_3_0.vertexattribi4usv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribI4usv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetUniformuiv(&self, program: GLuint, location: GLint, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetUniformuiv", catch_unwind(||(self.version_3_0.getuniformuiv)(program, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformuiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindFragDataLocation(&self, program: GLuint, color: GLuint, name: *const GLchar) -> Result<()> {
		let ret = process_catch("glBindFragDataLocation", catch_unwind(||(self.version_3_0.bindfragdatalocation)(program, color, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindFragDataLocation", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetFragDataLocation(&self, program: GLuint, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetFragDataLocation", catch_unwind(||(self.version_3_0.getfragdatalocation)(program, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFragDataLocation", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform1ui(&self, location: GLint, v0: GLuint) -> Result<()> {
		let ret = process_catch("glUniform1ui", catch_unwind(||(self.version_3_0.uniform1ui)(location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1ui", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform2ui(&self, location: GLint, v0: GLuint, v1: GLuint) -> Result<()> {
		let ret = process_catch("glUniform2ui", catch_unwind(||(self.version_3_0.uniform2ui)(location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2ui", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform3ui(&self, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint) -> Result<()> {
		let ret = process_catch("glUniform3ui", catch_unwind(||(self.version_3_0.uniform3ui)(location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3ui", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform4ui(&self, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint) -> Result<()> {
		let ret = process_catch("glUniform4ui", catch_unwind(||(self.version_3_0.uniform4ui)(location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4ui", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform1uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniform1uiv", catch_unwind(||(self.version_3_0.uniform1uiv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1uiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform2uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniform2uiv", catch_unwind(||(self.version_3_0.uniform2uiv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2uiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform3uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniform3uiv", catch_unwind(||(self.version_3_0.uniform3uiv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3uiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform4uiv(&self, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniform4uiv", catch_unwind(||(self.version_3_0.uniform4uiv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4uiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexParameterIiv(&self, target: GLenum, pname: GLenum, params: *const GLint) -> Result<()> {
		let ret = process_catch("glTexParameterIiv", catch_unwind(||(self.version_3_0.texparameteriiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameterIiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexParameterIuiv(&self, target: GLenum, pname: GLenum, params: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexParameterIuiv", catch_unwind(||(self.version_3_0.texparameteriuiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexParameterIuiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTexParameterIiv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTexParameterIiv", catch_unwind(||(self.version_3_0.gettexparameteriiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexParameterIiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTexParameterIuiv(&self, target: GLenum, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetTexParameterIuiv", catch_unwind(||(self.version_3_0.gettexparameteriuiv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTexParameterIuiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearBufferiv(&self, buffer: GLenum, drawbuffer: GLint, value: *const GLint) -> Result<()> {
		let ret = process_catch("glClearBufferiv", catch_unwind(||(self.version_3_0.clearbufferiv)(buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearBufferuiv(&self, buffer: GLenum, drawbuffer: GLint, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glClearBufferuiv", catch_unwind(||(self.version_3_0.clearbufferuiv)(buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferuiv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearBufferfv(&self, buffer: GLenum, drawbuffer: GLint, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glClearBufferfv", catch_unwind(||(self.version_3_0.clearbufferfv)(buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferfv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearBufferfi(&self, buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint) -> Result<()> {
		let ret = process_catch("glClearBufferfi", catch_unwind(||(self.version_3_0.clearbufferfi)(buffer, drawbuffer, depth, stencil)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferfi", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetStringi(&self, name: GLenum, index: GLuint) -> Result<&'static str> {
		let ret = process_catch("glGetStringi", catch_unwind(||unsafe{CStr::from_ptr((self.version_3_0.getstringi)(name, index) as *const i8)}.to_str().unwrap()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetStringi", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsRenderbuffer(&self, renderbuffer: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsRenderbuffer", catch_unwind(||(self.version_3_0.isrenderbuffer)(renderbuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsRenderbuffer", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindRenderbuffer(&self, target: GLenum, renderbuffer: GLuint) -> Result<()> {
		let ret = process_catch("glBindRenderbuffer", catch_unwind(||(self.version_3_0.bindrenderbuffer)(target, renderbuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindRenderbuffer", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteRenderbuffers(&self, n: GLsizei, renderbuffers: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteRenderbuffers", catch_unwind(||(self.version_3_0.deleterenderbuffers)(n, renderbuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteRenderbuffers", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenRenderbuffers(&self, n: GLsizei, renderbuffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenRenderbuffers", catch_unwind(||(self.version_3_0.genrenderbuffers)(n, renderbuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenRenderbuffers", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glRenderbufferStorage(&self, target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glRenderbufferStorage", catch_unwind(||(self.version_3_0.renderbufferstorage)(target, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glRenderbufferStorage", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetRenderbufferParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetRenderbufferParameteriv", catch_unwind(||(self.version_3_0.getrenderbufferparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetRenderbufferParameteriv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsFramebuffer(&self, framebuffer: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsFramebuffer", catch_unwind(||(self.version_3_0.isframebuffer)(framebuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsFramebuffer", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindFramebuffer(&self, target: GLenum, framebuffer: GLuint) -> Result<()> {
		let ret = process_catch("glBindFramebuffer", catch_unwind(||(self.version_3_0.bindframebuffer)(target, framebuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindFramebuffer", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteFramebuffers(&self, n: GLsizei, framebuffers: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteFramebuffers", catch_unwind(||(self.version_3_0.deleteframebuffers)(n, framebuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteFramebuffers", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenFramebuffers(&self, n: GLsizei, framebuffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenFramebuffers", catch_unwind(||(self.version_3_0.genframebuffers)(n, framebuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenFramebuffers", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCheckFramebufferStatus(&self, target: GLenum) -> Result<GLenum> {
		let ret = process_catch("glCheckFramebufferStatus", catch_unwind(||(self.version_3_0.checkframebufferstatus)(target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCheckFramebufferStatus", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFramebufferTexture1D(&self, target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTexture1D", catch_unwind(||(self.version_3_0.framebuffertexture1d)(target, attachment, textarget, texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTexture1D", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFramebufferTexture2D(&self, target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTexture2D", catch_unwind(||(self.version_3_0.framebuffertexture2d)(target, attachment, textarget, texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTexture2D", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFramebufferTexture3D(&self, target: GLenum, attachment: GLenum, textarget: GLenum, texture: GLuint, level: GLint, zoffset: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTexture3D", catch_unwind(||(self.version_3_0.framebuffertexture3d)(target, attachment, textarget, texture, level, zoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTexture3D", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFramebufferRenderbuffer(&self, target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint) -> Result<()> {
		let ret = process_catch("glFramebufferRenderbuffer", catch_unwind(||(self.version_3_0.framebufferrenderbuffer)(target, attachment, renderbuffertarget, renderbuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferRenderbuffer", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetFramebufferAttachmentParameteriv(&self, target: GLenum, attachment: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetFramebufferAttachmentParameteriv", catch_unwind(||(self.version_3_0.getframebufferattachmentparameteriv)(target, attachment, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFramebufferAttachmentParameteriv", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenerateMipmap(&self, target: GLenum) -> Result<()> {
		let ret = process_catch("glGenerateMipmap", catch_unwind(||(self.version_3_0.generatemipmap)(target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenerateMipmap", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBlitFramebuffer(&self, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum) -> Result<()> {
		let ret = process_catch("glBlitFramebuffer", catch_unwind(||(self.version_3_0.blitframebuffer)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlitFramebuffer", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glRenderbufferStorageMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glRenderbufferStorageMultisample", catch_unwind(||(self.version_3_0.renderbufferstoragemultisample)(target, samples, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glRenderbufferStorageMultisample", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFramebufferTextureLayer(&self, target: GLenum, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTextureLayer", catch_unwind(||(self.version_3_0.framebuffertexturelayer)(target, attachment, texture, level, layer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTextureLayer", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMapBufferRange(&self, target: GLenum, offset: GLintptr, length: GLsizeiptr, access: GLbitfield) -> Result<*mut c_void> {
		let ret = process_catch("glMapBufferRange", catch_unwind(||(self.version_3_0.mapbufferrange)(target, offset, length, access)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMapBufferRange", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFlushMappedBufferRange(&self, target: GLenum, offset: GLintptr, length: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glFlushMappedBufferRange", catch_unwind(||(self.version_3_0.flushmappedbufferrange)(target, offset, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFlushMappedBufferRange", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindVertexArray(&self, array: GLuint) -> Result<()> {
		let ret = process_catch("glBindVertexArray", catch_unwind(||(self.version_3_0.bindvertexarray)(array)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindVertexArray", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteVertexArrays(&self, n: GLsizei, arrays: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteVertexArrays", catch_unwind(||(self.version_3_0.deletevertexarrays)(n, arrays)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteVertexArrays", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenVertexArrays(&self, n: GLsizei, arrays: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenVertexArrays", catch_unwind(||(self.version_3_0.genvertexarrays)(n, arrays)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenVertexArrays", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsVertexArray(&self, array: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsVertexArray", catch_unwind(||(self.version_3_0.isvertexarray)(array)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsVertexArray", ret, (self.version_3_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_3_1 for GLCore {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_3_1.geterror)()
	}
	#[inline(always)]
	fn glDrawArraysInstanced(&self, mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawArraysInstanced", catch_unwind(||(self.version_3_1.drawarraysinstanced)(mode, first, count, instancecount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawArraysInstanced", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawElementsInstanced(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawElementsInstanced", catch_unwind(||(self.version_3_1.drawelementsinstanced)(mode, count, type_, indices, instancecount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsInstanced", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexBuffer(&self, target: GLenum, internalformat: GLenum, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glTexBuffer", catch_unwind(||(self.version_3_1.texbuffer)(target, internalformat, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexBuffer", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPrimitiveRestartIndex(&self, index: GLuint) -> Result<()> {
		let ret = process_catch("glPrimitiveRestartIndex", catch_unwind(||(self.version_3_1.primitiverestartindex)(index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPrimitiveRestartIndex", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyBufferSubData(&self, readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glCopyBufferSubData", catch_unwind(||(self.version_3_1.copybuffersubdata)(readTarget, writeTarget, readOffset, writeOffset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyBufferSubData", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetUniformIndices(&self, program: GLuint, uniformCount: GLsizei, uniformNames: *const *const GLchar, uniformIndices: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetUniformIndices", catch_unwind(||(self.version_3_1.getuniformindices)(program, uniformCount, uniformNames, uniformIndices)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformIndices", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveUniformsiv(&self, program: GLuint, uniformCount: GLsizei, uniformIndices: *const GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetActiveUniformsiv", catch_unwind(||(self.version_3_1.getactiveuniformsiv)(program, uniformCount, uniformIndices, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniformsiv", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveUniformName(&self, program: GLuint, uniformIndex: GLuint, bufSize: GLsizei, length: *mut GLsizei, uniformName: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveUniformName", catch_unwind(||(self.version_3_1.getactiveuniformname)(program, uniformIndex, bufSize, length, uniformName)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniformName", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetUniformBlockIndex(&self, program: GLuint, uniformBlockName: *const GLchar) -> Result<GLuint> {
		let ret = process_catch("glGetUniformBlockIndex", catch_unwind(||(self.version_3_1.getuniformblockindex)(program, uniformBlockName)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformBlockIndex", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveUniformBlockiv(&self, program: GLuint, uniformBlockIndex: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetActiveUniformBlockiv", catch_unwind(||(self.version_3_1.getactiveuniformblockiv)(program, uniformBlockIndex, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniformBlockiv", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveUniformBlockName(&self, program: GLuint, uniformBlockIndex: GLuint, bufSize: GLsizei, length: *mut GLsizei, uniformBlockName: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveUniformBlockName", catch_unwind(||(self.version_3_1.getactiveuniformblockname)(program, uniformBlockIndex, bufSize, length, uniformBlockName)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveUniformBlockName", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformBlockBinding(&self, program: GLuint, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint) -> Result<()> {
		let ret = process_catch("glUniformBlockBinding", catch_unwind(||(self.version_3_1.uniformblockbinding)(program, uniformBlockIndex, uniformBlockBinding)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformBlockBinding", ret, (self.version_3_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_3_2 for GLCore {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_3_2.geterror)()
	}
	#[inline(always)]
	fn glDrawElementsBaseVertex(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, basevertex: GLint) -> Result<()> {
		let ret = process_catch("glDrawElementsBaseVertex", catch_unwind(||(self.version_3_2.drawelementsbasevertex)(mode, count, type_, indices, basevertex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsBaseVertex", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawRangeElementsBaseVertex(&self, mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type_: GLenum, indices: *const c_void, basevertex: GLint) -> Result<()> {
		let ret = process_catch("glDrawRangeElementsBaseVertex", catch_unwind(||(self.version_3_2.drawrangeelementsbasevertex)(mode, start, end, count, type_, indices, basevertex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawRangeElementsBaseVertex", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawElementsInstancedBaseVertex(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei, basevertex: GLint) -> Result<()> {
		let ret = process_catch("glDrawElementsInstancedBaseVertex", catch_unwind(||(self.version_3_2.drawelementsinstancedbasevertex)(mode, count, type_, indices, instancecount, basevertex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsInstancedBaseVertex", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiDrawElementsBaseVertex(&self, mode: GLenum, count: *const GLsizei, type_: GLenum, indices: *const *const c_void, drawcount: GLsizei, basevertex: *const GLint) -> Result<()> {
		let ret = process_catch("glMultiDrawElementsBaseVertex", catch_unwind(||(self.version_3_2.multidrawelementsbasevertex)(mode, count, type_, indices, drawcount, basevertex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawElementsBaseVertex", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProvokingVertex(&self, mode: GLenum) -> Result<()> {
		let ret = process_catch("glProvokingVertex", catch_unwind(||(self.version_3_2.provokingvertex)(mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProvokingVertex", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFenceSync(&self, condition: GLenum, flags: GLbitfield) -> Result<GLsync> {
		let ret = process_catch("glFenceSync", catch_unwind(||(self.version_3_2.fencesync)(condition, flags)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFenceSync", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsSync(&self, sync: GLsync) -> Result<GLboolean> {
		let ret = process_catch("glIsSync", catch_unwind(||(self.version_3_2.issync)(sync)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsSync", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteSync(&self, sync: GLsync) -> Result<()> {
		let ret = process_catch("glDeleteSync", catch_unwind(||(self.version_3_2.deletesync)(sync)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteSync", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClientWaitSync(&self, sync: GLsync, flags: GLbitfield, timeout: GLuint64) -> Result<GLenum> {
		let ret = process_catch("glClientWaitSync", catch_unwind(||(self.version_3_2.clientwaitsync)(sync, flags, timeout)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClientWaitSync", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glWaitSync(&self, sync: GLsync, flags: GLbitfield, timeout: GLuint64) -> Result<()> {
		let ret = process_catch("glWaitSync", catch_unwind(||(self.version_3_2.waitsync)(sync, flags, timeout)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glWaitSync", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetInteger64v(&self, pname: GLenum, data: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetInteger64v", catch_unwind(||(self.version_3_2.getinteger64v)(pname, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetInteger64v", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetSynciv(&self, sync: GLsync, pname: GLenum, count: GLsizei, length: *mut GLsizei, values: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetSynciv", catch_unwind(||(self.version_3_2.getsynciv)(sync, pname, count, length, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSynciv", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetInteger64i_v(&self, target: GLenum, index: GLuint, data: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetInteger64i_v", catch_unwind(||(self.version_3_2.getinteger64i_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetInteger64i_v", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetBufferParameteri64v(&self, target: GLenum, pname: GLenum, params: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetBufferParameteri64v", catch_unwind(||(self.version_3_2.getbufferparameteri64v)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetBufferParameteri64v", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFramebufferTexture(&self, target: GLenum, attachment: GLenum, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferTexture", catch_unwind(||(self.version_3_2.framebuffertexture)(target, attachment, texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferTexture", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexImage2DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTexImage2DMultisample", catch_unwind(||(self.version_3_2.teximage2dmultisample)(target, samples, internalformat, width, height, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage2DMultisample", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexImage3DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTexImage3DMultisample", catch_unwind(||(self.version_3_2.teximage3dmultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexImage3DMultisample", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetMultisamplefv(&self, pname: GLenum, index: GLuint, val: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetMultisamplefv", catch_unwind(||(self.version_3_2.getmultisamplefv)(pname, index, val)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetMultisamplefv", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSampleMaski(&self, maskNumber: GLuint, mask: GLbitfield) -> Result<()> {
		let ret = process_catch("glSampleMaski", catch_unwind(||(self.version_3_2.samplemaski)(maskNumber, mask)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSampleMaski", ret, (self.version_3_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_3_3 for GLCore {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_3_3.geterror)()
	}
	#[inline(always)]
	fn glBindFragDataLocationIndexed(&self, program: GLuint, colorNumber: GLuint, index: GLuint, name: *const GLchar) -> Result<()> {
		let ret = process_catch("glBindFragDataLocationIndexed", catch_unwind(||(self.version_3_3.bindfragdatalocationindexed)(program, colorNumber, index, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindFragDataLocationIndexed", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetFragDataIndex(&self, program: GLuint, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetFragDataIndex", catch_unwind(||(self.version_3_3.getfragdataindex)(program, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFragDataIndex", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenSamplers(&self, count: GLsizei, samplers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenSamplers", catch_unwind(||(self.version_3_3.gensamplers)(count, samplers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenSamplers", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteSamplers(&self, count: GLsizei, samplers: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteSamplers", catch_unwind(||(self.version_3_3.deletesamplers)(count, samplers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteSamplers", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsSampler(&self, sampler: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsSampler", catch_unwind(||(self.version_3_3.issampler)(sampler)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsSampler", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindSampler(&self, unit: GLuint, sampler: GLuint) -> Result<()> {
		let ret = process_catch("glBindSampler", catch_unwind(||(self.version_3_3.bindsampler)(unit, sampler)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindSampler", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSamplerParameteri(&self, sampler: GLuint, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glSamplerParameteri", catch_unwind(||(self.version_3_3.samplerparameteri)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameteri", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSamplerParameteriv(&self, sampler: GLuint, pname: GLenum, param: *const GLint) -> Result<()> {
		let ret = process_catch("glSamplerParameteriv", catch_unwind(||(self.version_3_3.samplerparameteriv)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameteriv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSamplerParameterf(&self, sampler: GLuint, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glSamplerParameterf", catch_unwind(||(self.version_3_3.samplerparameterf)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameterf", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSamplerParameterfv(&self, sampler: GLuint, pname: GLenum, param: *const GLfloat) -> Result<()> {
		let ret = process_catch("glSamplerParameterfv", catch_unwind(||(self.version_3_3.samplerparameterfv)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameterfv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSamplerParameterIiv(&self, sampler: GLuint, pname: GLenum, param: *const GLint) -> Result<()> {
		let ret = process_catch("glSamplerParameterIiv", catch_unwind(||(self.version_3_3.samplerparameteriiv)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameterIiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSamplerParameterIuiv(&self, sampler: GLuint, pname: GLenum, param: *const GLuint) -> Result<()> {
		let ret = process_catch("glSamplerParameterIuiv", catch_unwind(||(self.version_3_3.samplerparameteriuiv)(sampler, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSamplerParameterIuiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetSamplerParameteriv(&self, sampler: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetSamplerParameteriv", catch_unwind(||(self.version_3_3.getsamplerparameteriv)(sampler, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSamplerParameteriv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetSamplerParameterIiv(&self, sampler: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetSamplerParameterIiv", catch_unwind(||(self.version_3_3.getsamplerparameteriiv)(sampler, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSamplerParameterIiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetSamplerParameterfv(&self, sampler: GLuint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetSamplerParameterfv", catch_unwind(||(self.version_3_3.getsamplerparameterfv)(sampler, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSamplerParameterfv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetSamplerParameterIuiv(&self, sampler: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetSamplerParameterIuiv", catch_unwind(||(self.version_3_3.getsamplerparameteriuiv)(sampler, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSamplerParameterIuiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glQueryCounter(&self, id: GLuint, target: GLenum) -> Result<()> {
		let ret = process_catch("glQueryCounter", catch_unwind(||(self.version_3_3.querycounter)(id, target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glQueryCounter", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryObjecti64v(&self, id: GLuint, pname: GLenum, params: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetQueryObjecti64v", catch_unwind(||(self.version_3_3.getqueryobjecti64v)(id, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryObjecti64v", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryObjectui64v(&self, id: GLuint, pname: GLenum, params: *mut GLuint64) -> Result<()> {
		let ret = process_catch("glGetQueryObjectui64v", catch_unwind(||(self.version_3_3.getqueryobjectui64v)(id, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryObjectui64v", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribDivisor(&self, index: GLuint, divisor: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribDivisor", catch_unwind(||(self.version_3_3.vertexattribdivisor)(index, divisor)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribDivisor", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribP1ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP1ui", catch_unwind(||(self.version_3_3.vertexattribp1ui)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP1ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribP1uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP1uiv", catch_unwind(||(self.version_3_3.vertexattribp1uiv)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP1uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribP2ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP2ui", catch_unwind(||(self.version_3_3.vertexattribp2ui)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP2ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribP2uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP2uiv", catch_unwind(||(self.version_3_3.vertexattribp2uiv)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP2uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribP3ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP3ui", catch_unwind(||(self.version_3_3.vertexattribp3ui)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP3ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribP3uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP3uiv", catch_unwind(||(self.version_3_3.vertexattribp3uiv)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP3uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribP4ui(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP4ui", catch_unwind(||(self.version_3_3.vertexattribp4ui)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP4ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribP4uiv(&self, index: GLuint, type_: GLenum, normalized: GLboolean, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribP4uiv", catch_unwind(||(self.version_3_3.vertexattribp4uiv)(index, type_, normalized, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribP4uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexP2ui(&self, type_: GLenum, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexP2ui", catch_unwind(||(self.version_3_3.vertexp2ui)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP2ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexP2uiv(&self, type_: GLenum, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexP2uiv", catch_unwind(||(self.version_3_3.vertexp2uiv)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP2uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexP3ui(&self, type_: GLenum, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexP3ui", catch_unwind(||(self.version_3_3.vertexp3ui)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP3ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexP3uiv(&self, type_: GLenum, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexP3uiv", catch_unwind(||(self.version_3_3.vertexp3uiv)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP3uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexP4ui(&self, type_: GLenum, value: GLuint) -> Result<()> {
		let ret = process_catch("glVertexP4ui", catch_unwind(||(self.version_3_3.vertexp4ui)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP4ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexP4uiv(&self, type_: GLenum, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glVertexP4uiv", catch_unwind(||(self.version_3_3.vertexp4uiv)(type_, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexP4uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexCoordP1ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP1ui", catch_unwind(||(self.version_3_3.texcoordp1ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP1ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexCoordP1uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP1uiv", catch_unwind(||(self.version_3_3.texcoordp1uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP1uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexCoordP2ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP2ui", catch_unwind(||(self.version_3_3.texcoordp2ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP2ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexCoordP2uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP2uiv", catch_unwind(||(self.version_3_3.texcoordp2uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP2uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexCoordP3ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP3ui", catch_unwind(||(self.version_3_3.texcoordp3ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP3ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexCoordP3uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP3uiv", catch_unwind(||(self.version_3_3.texcoordp3uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP3uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexCoordP4ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP4ui", catch_unwind(||(self.version_3_3.texcoordp4ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP4ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexCoordP4uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glTexCoordP4uiv", catch_unwind(||(self.version_3_3.texcoordp4uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexCoordP4uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoordP1ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP1ui", catch_unwind(||(self.version_3_3.multitexcoordp1ui)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP1ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoordP1uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP1uiv", catch_unwind(||(self.version_3_3.multitexcoordp1uiv)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP1uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoordP2ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP2ui", catch_unwind(||(self.version_3_3.multitexcoordp2ui)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP2ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoordP2uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP2uiv", catch_unwind(||(self.version_3_3.multitexcoordp2uiv)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP2uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoordP3ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP3ui", catch_unwind(||(self.version_3_3.multitexcoordp3ui)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP3ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoordP3uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP3uiv", catch_unwind(||(self.version_3_3.multitexcoordp3uiv)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP3uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoordP4ui(&self, texture: GLenum, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP4ui", catch_unwind(||(self.version_3_3.multitexcoordp4ui)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP4ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiTexCoordP4uiv(&self, texture: GLenum, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glMultiTexCoordP4uiv", catch_unwind(||(self.version_3_3.multitexcoordp4uiv)(texture, type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiTexCoordP4uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNormalP3ui(&self, type_: GLenum, coords: GLuint) -> Result<()> {
		let ret = process_catch("glNormalP3ui", catch_unwind(||(self.version_3_3.normalp3ui)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNormalP3ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNormalP3uiv(&self, type_: GLenum, coords: *const GLuint) -> Result<()> {
		let ret = process_catch("glNormalP3uiv", catch_unwind(||(self.version_3_3.normalp3uiv)(type_, coords)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNormalP3uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glColorP3ui(&self, type_: GLenum, color: GLuint) -> Result<()> {
		let ret = process_catch("glColorP3ui", catch_unwind(||(self.version_3_3.colorp3ui)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorP3ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glColorP3uiv(&self, type_: GLenum, color: *const GLuint) -> Result<()> {
		let ret = process_catch("glColorP3uiv", catch_unwind(||(self.version_3_3.colorp3uiv)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorP3uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glColorP4ui(&self, type_: GLenum, color: GLuint) -> Result<()> {
		let ret = process_catch("glColorP4ui", catch_unwind(||(self.version_3_3.colorp4ui)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorP4ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glColorP4uiv(&self, type_: GLenum, color: *const GLuint) -> Result<()> {
		let ret = process_catch("glColorP4uiv", catch_unwind(||(self.version_3_3.colorp4uiv)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glColorP4uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColorP3ui(&self, type_: GLenum, color: GLuint) -> Result<()> {
		let ret = process_catch("glSecondaryColorP3ui", catch_unwind(||(self.version_3_3.secondarycolorp3ui)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColorP3ui", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glSecondaryColorP3uiv(&self, type_: GLenum, color: *const GLuint) -> Result<()> {
		let ret = process_catch("glSecondaryColorP3uiv", catch_unwind(||(self.version_3_3.secondarycolorp3uiv)(type_, color)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSecondaryColorP3uiv", ret, (self.version_3_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_4_0 for GLCore {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_4_0.geterror)()
	}
	#[inline(always)]
	fn glMinSampleShading(&self, value: GLfloat) -> Result<()> {
		let ret = process_catch("glMinSampleShading", catch_unwind(||(self.version_4_0.minsampleshading)(value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMinSampleShading", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBlendEquationi(&self, buf: GLuint, mode: GLenum) -> Result<()> {
		let ret = process_catch("glBlendEquationi", catch_unwind(||(self.version_4_0.blendequationi)(buf, mode)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendEquationi", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBlendEquationSeparatei(&self, buf: GLuint, modeRGB: GLenum, modeAlpha: GLenum) -> Result<()> {
		let ret = process_catch("glBlendEquationSeparatei", catch_unwind(||(self.version_4_0.blendequationseparatei)(buf, modeRGB, modeAlpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendEquationSeparatei", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBlendFunci(&self, buf: GLuint, src: GLenum, dst: GLenum) -> Result<()> {
		let ret = process_catch("glBlendFunci", catch_unwind(||(self.version_4_0.blendfunci)(buf, src, dst)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendFunci", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBlendFuncSeparatei(&self, buf: GLuint, srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum) -> Result<()> {
		let ret = process_catch("glBlendFuncSeparatei", catch_unwind(||(self.version_4_0.blendfuncseparatei)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlendFuncSeparatei", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawArraysIndirect(&self, mode: GLenum, indirect: *const c_void) -> Result<()> {
		let ret = process_catch("glDrawArraysIndirect", catch_unwind(||(self.version_4_0.drawarraysindirect)(mode, indirect)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawArraysIndirect", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawElementsIndirect(&self, mode: GLenum, type_: GLenum, indirect: *const c_void) -> Result<()> {
		let ret = process_catch("glDrawElementsIndirect", catch_unwind(||(self.version_4_0.drawelementsindirect)(mode, type_, indirect)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsIndirect", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform1d(&self, location: GLint, x: GLdouble) -> Result<()> {
		let ret = process_catch("glUniform1d", catch_unwind(||(self.version_4_0.uniform1d)(location, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1d", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform2d(&self, location: GLint, x: GLdouble, y: GLdouble) -> Result<()> {
		let ret = process_catch("glUniform2d", catch_unwind(||(self.version_4_0.uniform2d)(location, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2d", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform3d(&self, location: GLint, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()> {
		let ret = process_catch("glUniform3d", catch_unwind(||(self.version_4_0.uniform3d)(location, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3d", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform4d(&self, location: GLint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble) -> Result<()> {
		let ret = process_catch("glUniform4d", catch_unwind(||(self.version_4_0.uniform4d)(location, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4d", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform1dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniform1dv", catch_unwind(||(self.version_4_0.uniform1dv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform1dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform2dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniform2dv", catch_unwind(||(self.version_4_0.uniform2dv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform2dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform3dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniform3dv", catch_unwind(||(self.version_4_0.uniform3dv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform3dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniform4dv(&self, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniform4dv", catch_unwind(||(self.version_4_0.uniform4dv)(location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniform4dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix2dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix2dv", catch_unwind(||(self.version_4_0.uniformmatrix2dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix3dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix3dv", catch_unwind(||(self.version_4_0.uniformmatrix3dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix4dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix4dv", catch_unwind(||(self.version_4_0.uniformmatrix4dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix2x3dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix2x3dv", catch_unwind(||(self.version_4_0.uniformmatrix2x3dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2x3dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix2x4dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix2x4dv", catch_unwind(||(self.version_4_0.uniformmatrix2x4dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix2x4dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix3x2dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix3x2dv", catch_unwind(||(self.version_4_0.uniformmatrix3x2dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3x2dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix3x4dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix3x4dv", catch_unwind(||(self.version_4_0.uniformmatrix3x4dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix3x4dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix4x2dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix4x2dv", catch_unwind(||(self.version_4_0.uniformmatrix4x2dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4x2dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformMatrix4x3dv(&self, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glUniformMatrix4x3dv", catch_unwind(||(self.version_4_0.uniformmatrix4x3dv)(location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformMatrix4x3dv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetUniformdv(&self, program: GLuint, location: GLint, params: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetUniformdv", catch_unwind(||(self.version_4_0.getuniformdv)(program, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformdv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetSubroutineUniformLocation(&self, program: GLuint, shadertype: GLenum, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetSubroutineUniformLocation", catch_unwind(||(self.version_4_0.getsubroutineuniformlocation)(program, shadertype, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSubroutineUniformLocation", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetSubroutineIndex(&self, program: GLuint, shadertype: GLenum, name: *const GLchar) -> Result<GLuint> {
		let ret = process_catch("glGetSubroutineIndex", catch_unwind(||(self.version_4_0.getsubroutineindex)(program, shadertype, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetSubroutineIndex", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveSubroutineUniformiv(&self, program: GLuint, shadertype: GLenum, index: GLuint, pname: GLenum, values: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetActiveSubroutineUniformiv", catch_unwind(||(self.version_4_0.getactivesubroutineuniformiv)(program, shadertype, index, pname, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveSubroutineUniformiv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveSubroutineUniformName(&self, program: GLuint, shadertype: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveSubroutineUniformName", catch_unwind(||(self.version_4_0.getactivesubroutineuniformname)(program, shadertype, index, bufSize, length, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveSubroutineUniformName", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveSubroutineName(&self, program: GLuint, shadertype: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetActiveSubroutineName", catch_unwind(||(self.version_4_0.getactivesubroutinename)(program, shadertype, index, bufSize, length, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveSubroutineName", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUniformSubroutinesuiv(&self, shadertype: GLenum, count: GLsizei, indices: *const GLuint) -> Result<()> {
		let ret = process_catch("glUniformSubroutinesuiv", catch_unwind(||(self.version_4_0.uniformsubroutinesuiv)(shadertype, count, indices)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUniformSubroutinesuiv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetUniformSubroutineuiv(&self, shadertype: GLenum, location: GLint, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetUniformSubroutineuiv", catch_unwind(||(self.version_4_0.getuniformsubroutineuiv)(shadertype, location, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetUniformSubroutineuiv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramStageiv(&self, program: GLuint, shadertype: GLenum, pname: GLenum, values: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramStageiv", catch_unwind(||(self.version_4_0.getprogramstageiv)(program, shadertype, pname, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramStageiv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPatchParameteri(&self, pname: GLenum, value: GLint) -> Result<()> {
		let ret = process_catch("glPatchParameteri", catch_unwind(||(self.version_4_0.patchparameteri)(pname, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPatchParameteri", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPatchParameterfv(&self, pname: GLenum, values: *const GLfloat) -> Result<()> {
		let ret = process_catch("glPatchParameterfv", catch_unwind(||(self.version_4_0.patchparameterfv)(pname, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPatchParameterfv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindTransformFeedback(&self, target: GLenum, id: GLuint) -> Result<()> {
		let ret = process_catch("glBindTransformFeedback", catch_unwind(||(self.version_4_0.bindtransformfeedback)(target, id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindTransformFeedback", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteTransformFeedbacks(&self, n: GLsizei, ids: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteTransformFeedbacks", catch_unwind(||(self.version_4_0.deletetransformfeedbacks)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteTransformFeedbacks", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenTransformFeedbacks(&self, n: GLsizei, ids: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenTransformFeedbacks", catch_unwind(||(self.version_4_0.gentransformfeedbacks)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenTransformFeedbacks", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsTransformFeedback(&self, id: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsTransformFeedback", catch_unwind(||(self.version_4_0.istransformfeedback)(id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsTransformFeedback", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPauseTransformFeedback(&self) -> Result<()> {
		let ret = process_catch("glPauseTransformFeedback", catch_unwind(||(self.version_4_0.pausetransformfeedback)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPauseTransformFeedback", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glResumeTransformFeedback(&self) -> Result<()> {
		let ret = process_catch("glResumeTransformFeedback", catch_unwind(||(self.version_4_0.resumetransformfeedback)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glResumeTransformFeedback", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawTransformFeedback(&self, mode: GLenum, id: GLuint) -> Result<()> {
		let ret = process_catch("glDrawTransformFeedback", catch_unwind(||(self.version_4_0.drawtransformfeedback)(mode, id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawTransformFeedback", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawTransformFeedbackStream(&self, mode: GLenum, id: GLuint, stream: GLuint) -> Result<()> {
		let ret = process_catch("glDrawTransformFeedbackStream", catch_unwind(||(self.version_4_0.drawtransformfeedbackstream)(mode, id, stream)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawTransformFeedbackStream", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBeginQueryIndexed(&self, target: GLenum, index: GLuint, id: GLuint) -> Result<()> {
		let ret = process_catch("glBeginQueryIndexed", catch_unwind(||(self.version_4_0.beginqueryindexed)(target, index, id)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBeginQueryIndexed", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glEndQueryIndexed(&self, target: GLenum, index: GLuint) -> Result<()> {
		let ret = process_catch("glEndQueryIndexed", catch_unwind(||(self.version_4_0.endqueryindexed)(target, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEndQueryIndexed", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryIndexediv(&self, target: GLenum, index: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetQueryIndexediv", catch_unwind(||(self.version_4_0.getqueryindexediv)(target, index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryIndexediv", ret, (self.version_4_0.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_4_1 for GLCore {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_4_1.geterror)()
	}
	#[inline(always)]
	fn glReleaseShaderCompiler(&self) -> Result<()> {
		let ret = process_catch("glReleaseShaderCompiler", catch_unwind(||(self.version_4_1.releaseshadercompiler)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glReleaseShaderCompiler", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glShaderBinary(&self, count: GLsizei, shaders: *const GLuint, binaryFormat: GLenum, binary: *const c_void, length: GLsizei) -> Result<()> {
		let ret = process_catch("glShaderBinary", catch_unwind(||(self.version_4_1.shaderbinary)(count, shaders, binaryFormat, binary, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glShaderBinary", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetShaderPrecisionFormat(&self, shadertype: GLenum, precisiontype: GLenum, range: *mut GLint, precision: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetShaderPrecisionFormat", catch_unwind(||(self.version_4_1.getshaderprecisionformat)(shadertype, precisiontype, range, precision)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetShaderPrecisionFormat", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDepthRangef(&self, n: GLfloat, f: GLfloat) -> Result<()> {
		let ret = process_catch("glDepthRangef", catch_unwind(||(self.version_4_1.depthrangef)(n, f)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthRangef", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearDepthf(&self, d: GLfloat) -> Result<()> {
		let ret = process_catch("glClearDepthf", catch_unwind(||(self.version_4_1.cleardepthf)(d)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearDepthf", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramBinary(&self, program: GLuint, bufSize: GLsizei, length: *mut GLsizei, binaryFormat: *mut GLenum, binary: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetProgramBinary", catch_unwind(||(self.version_4_1.getprogrambinary)(program, bufSize, length, binaryFormat, binary)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramBinary", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramBinary(&self, program: GLuint, binaryFormat: GLenum, binary: *const c_void, length: GLsizei) -> Result<()> {
		let ret = process_catch("glProgramBinary", catch_unwind(||(self.version_4_1.programbinary)(program, binaryFormat, binary, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramBinary", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramParameteri(&self, program: GLuint, pname: GLenum, value: GLint) -> Result<()> {
		let ret = process_catch("glProgramParameteri", catch_unwind(||(self.version_4_1.programparameteri)(program, pname, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramParameteri", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUseProgramStages(&self, pipeline: GLuint, stages: GLbitfield, program: GLuint) -> Result<()> {
		let ret = process_catch("glUseProgramStages", catch_unwind(||(self.version_4_1.useprogramstages)(pipeline, stages, program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUseProgramStages", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glActiveShaderProgram(&self, pipeline: GLuint, program: GLuint) -> Result<()> {
		let ret = process_catch("glActiveShaderProgram", catch_unwind(||(self.version_4_1.activeshaderprogram)(pipeline, program)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glActiveShaderProgram", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateShaderProgramv(&self, type_: GLenum, count: GLsizei, strings: *const *const GLchar) -> Result<GLuint> {
		let ret = process_catch("glCreateShaderProgramv", catch_unwind(||(self.version_4_1.createshaderprogramv)(type_, count, strings)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateShaderProgramv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindProgramPipeline(&self, pipeline: GLuint) -> Result<()> {
		let ret = process_catch("glBindProgramPipeline", catch_unwind(||(self.version_4_1.bindprogrampipeline)(pipeline)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindProgramPipeline", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDeleteProgramPipelines(&self, n: GLsizei, pipelines: *const GLuint) -> Result<()> {
		let ret = process_catch("glDeleteProgramPipelines", catch_unwind(||(self.version_4_1.deleteprogrampipelines)(n, pipelines)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDeleteProgramPipelines", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenProgramPipelines(&self, n: GLsizei, pipelines: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGenProgramPipelines", catch_unwind(||(self.version_4_1.genprogrampipelines)(n, pipelines)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenProgramPipelines", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glIsProgramPipeline(&self, pipeline: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glIsProgramPipeline", catch_unwind(||(self.version_4_1.isprogrampipeline)(pipeline)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glIsProgramPipeline", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramPipelineiv(&self, pipeline: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramPipelineiv", catch_unwind(||(self.version_4_1.getprogrampipelineiv)(pipeline, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramPipelineiv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform1i(&self, program: GLuint, location: GLint, v0: GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform1i", catch_unwind(||(self.version_4_1.programuniform1i)(program, location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1i", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform1iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform1iv", catch_unwind(||(self.version_4_1.programuniform1iv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1iv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform1f(&self, program: GLuint, location: GLint, v0: GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform1f", catch_unwind(||(self.version_4_1.programuniform1f)(program, location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1f", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform1fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform1fv", catch_unwind(||(self.version_4_1.programuniform1fv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform1d(&self, program: GLuint, location: GLint, v0: GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform1d", catch_unwind(||(self.version_4_1.programuniform1d)(program, location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1d", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform1dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform1dv", catch_unwind(||(self.version_4_1.programuniform1dv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform1ui(&self, program: GLuint, location: GLint, v0: GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform1ui", catch_unwind(||(self.version_4_1.programuniform1ui)(program, location, v0)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1ui", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform1uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform1uiv", catch_unwind(||(self.version_4_1.programuniform1uiv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform1uiv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform2i(&self, program: GLuint, location: GLint, v0: GLint, v1: GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform2i", catch_unwind(||(self.version_4_1.programuniform2i)(program, location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2i", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform2iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform2iv", catch_unwind(||(self.version_4_1.programuniform2iv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2iv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform2f(&self, program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform2f", catch_unwind(||(self.version_4_1.programuniform2f)(program, location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2f", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform2fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform2fv", catch_unwind(||(self.version_4_1.programuniform2fv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform2d(&self, program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform2d", catch_unwind(||(self.version_4_1.programuniform2d)(program, location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2d", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform2dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform2dv", catch_unwind(||(self.version_4_1.programuniform2dv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform2ui(&self, program: GLuint, location: GLint, v0: GLuint, v1: GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform2ui", catch_unwind(||(self.version_4_1.programuniform2ui)(program, location, v0, v1)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2ui", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform2uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform2uiv", catch_unwind(||(self.version_4_1.programuniform2uiv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform2uiv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform3i(&self, program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform3i", catch_unwind(||(self.version_4_1.programuniform3i)(program, location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3i", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform3iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform3iv", catch_unwind(||(self.version_4_1.programuniform3iv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3iv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform3f(&self, program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform3f", catch_unwind(||(self.version_4_1.programuniform3f)(program, location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3f", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform3fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform3fv", catch_unwind(||(self.version_4_1.programuniform3fv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform3d(&self, program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform3d", catch_unwind(||(self.version_4_1.programuniform3d)(program, location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3d", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform3dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform3dv", catch_unwind(||(self.version_4_1.programuniform3dv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform3ui(&self, program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform3ui", catch_unwind(||(self.version_4_1.programuniform3ui)(program, location, v0, v1, v2)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3ui", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform3uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform3uiv", catch_unwind(||(self.version_4_1.programuniform3uiv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform3uiv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform4i(&self, program: GLuint, location: GLint, v0: GLint, v1: GLint, v2: GLint, v3: GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform4i", catch_unwind(||(self.version_4_1.programuniform4i)(program, location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4i", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform4iv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLint) -> Result<()> {
		let ret = process_catch("glProgramUniform4iv", catch_unwind(||(self.version_4_1.programuniform4iv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4iv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform4f(&self, program: GLuint, location: GLint, v0: GLfloat, v1: GLfloat, v2: GLfloat, v3: GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform4f", catch_unwind(||(self.version_4_1.programuniform4f)(program, location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4f", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform4fv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniform4fv", catch_unwind(||(self.version_4_1.programuniform4fv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform4d(&self, program: GLuint, location: GLint, v0: GLdouble, v1: GLdouble, v2: GLdouble, v3: GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform4d", catch_unwind(||(self.version_4_1.programuniform4d)(program, location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4d", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform4dv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniform4dv", catch_unwind(||(self.version_4_1.programuniform4dv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform4ui(&self, program: GLuint, location: GLint, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform4ui", catch_unwind(||(self.version_4_1.programuniform4ui)(program, location, v0, v1, v2, v3)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4ui", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniform4uiv(&self, program: GLuint, location: GLint, count: GLsizei, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glProgramUniform4uiv", catch_unwind(||(self.version_4_1.programuniform4uiv)(program, location, count, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniform4uiv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix2fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2fv", catch_unwind(||(self.version_4_1.programuniformmatrix2fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix3fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3fv", catch_unwind(||(self.version_4_1.programuniformmatrix3fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix4fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4fv", catch_unwind(||(self.version_4_1.programuniformmatrix4fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix2dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2dv", catch_unwind(||(self.version_4_1.programuniformmatrix2dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix3dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3dv", catch_unwind(||(self.version_4_1.programuniformmatrix3dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix4dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4dv", catch_unwind(||(self.version_4_1.programuniformmatrix4dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix2x3fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2x3fv", catch_unwind(||(self.version_4_1.programuniformmatrix2x3fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2x3fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix3x2fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3x2fv", catch_unwind(||(self.version_4_1.programuniformmatrix3x2fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3x2fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix2x4fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2x4fv", catch_unwind(||(self.version_4_1.programuniformmatrix2x4fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2x4fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix4x2fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4x2fv", catch_unwind(||(self.version_4_1.programuniformmatrix4x2fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4x2fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix3x4fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3x4fv", catch_unwind(||(self.version_4_1.programuniformmatrix3x4fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3x4fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix4x3fv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4x3fv", catch_unwind(||(self.version_4_1.programuniformmatrix4x3fv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4x3fv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix2x3dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2x3dv", catch_unwind(||(self.version_4_1.programuniformmatrix2x3dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2x3dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix3x2dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3x2dv", catch_unwind(||(self.version_4_1.programuniformmatrix3x2dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3x2dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix2x4dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix2x4dv", catch_unwind(||(self.version_4_1.programuniformmatrix2x4dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix2x4dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix4x2dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4x2dv", catch_unwind(||(self.version_4_1.programuniformmatrix4x2dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4x2dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix3x4dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix3x4dv", catch_unwind(||(self.version_4_1.programuniformmatrix3x4dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix3x4dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glProgramUniformMatrix4x3dv(&self, program: GLuint, location: GLint, count: GLsizei, transpose: GLboolean, value: *const GLdouble) -> Result<()> {
		let ret = process_catch("glProgramUniformMatrix4x3dv", catch_unwind(||(self.version_4_1.programuniformmatrix4x3dv)(program, location, count, transpose, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glProgramUniformMatrix4x3dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glValidateProgramPipeline(&self, pipeline: GLuint) -> Result<()> {
		let ret = process_catch("glValidateProgramPipeline", catch_unwind(||(self.version_4_1.validateprogrampipeline)(pipeline)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glValidateProgramPipeline", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramPipelineInfoLog(&self, pipeline: GLuint, bufSize: GLsizei, length: *mut GLsizei, infoLog: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetProgramPipelineInfoLog", catch_unwind(||(self.version_4_1.getprogrampipelineinfolog)(pipeline, bufSize, length, infoLog)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramPipelineInfoLog", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribL1d(&self, index: GLuint, x: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL1d", catch_unwind(||(self.version_4_1.vertexattribl1d)(index, x)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL1d", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribL2d(&self, index: GLuint, x: GLdouble, y: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL2d", catch_unwind(||(self.version_4_1.vertexattribl2d)(index, x, y)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL2d", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribL3d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL3d", catch_unwind(||(self.version_4_1.vertexattribl3d)(index, x, y, z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL3d", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribL4d(&self, index: GLuint, x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL4d", catch_unwind(||(self.version_4_1.vertexattribl4d)(index, x, y, z, w)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL4d", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribL1dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL1dv", catch_unwind(||(self.version_4_1.vertexattribl1dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL1dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribL2dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL2dv", catch_unwind(||(self.version_4_1.vertexattribl2dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL2dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribL3dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL3dv", catch_unwind(||(self.version_4_1.vertexattribl3dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL3dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribL4dv(&self, index: GLuint, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glVertexAttribL4dv", catch_unwind(||(self.version_4_1.vertexattribl4dv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribL4dv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribLPointer(&self, index: GLuint, size: GLint, type_: GLenum, stride: GLsizei, pointer: *const c_void) -> Result<()> {
		let ret = process_catch("glVertexAttribLPointer", catch_unwind(||(self.version_4_1.vertexattriblpointer)(index, size, type_, stride, pointer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribLPointer", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexAttribLdv(&self, index: GLuint, pname: GLenum, params: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetVertexAttribLdv", catch_unwind(||(self.version_4_1.getvertexattribldv)(index, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexAttribLdv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glViewportArrayv(&self, first: GLuint, count: GLsizei, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glViewportArrayv", catch_unwind(||(self.version_4_1.viewportarrayv)(first, count, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glViewportArrayv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glViewportIndexedf(&self, index: GLuint, x: GLfloat, y: GLfloat, w: GLfloat, h: GLfloat) -> Result<()> {
		let ret = process_catch("glViewportIndexedf", catch_unwind(||(self.version_4_1.viewportindexedf)(index, x, y, w, h)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glViewportIndexedf", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glViewportIndexedfv(&self, index: GLuint, v: *const GLfloat) -> Result<()> {
		let ret = process_catch("glViewportIndexedfv", catch_unwind(||(self.version_4_1.viewportindexedfv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glViewportIndexedfv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glScissorArrayv(&self, first: GLuint, count: GLsizei, v: *const GLint) -> Result<()> {
		let ret = process_catch("glScissorArrayv", catch_unwind(||(self.version_4_1.scissorarrayv)(first, count, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glScissorArrayv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glScissorIndexed(&self, index: GLuint, left: GLint, bottom: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glScissorIndexed", catch_unwind(||(self.version_4_1.scissorindexed)(index, left, bottom, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glScissorIndexed", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glScissorIndexedv(&self, index: GLuint, v: *const GLint) -> Result<()> {
		let ret = process_catch("glScissorIndexedv", catch_unwind(||(self.version_4_1.scissorindexedv)(index, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glScissorIndexedv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDepthRangeArrayv(&self, first: GLuint, count: GLsizei, v: *const GLdouble) -> Result<()> {
		let ret = process_catch("glDepthRangeArrayv", catch_unwind(||(self.version_4_1.depthrangearrayv)(first, count, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthRangeArrayv", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDepthRangeIndexed(&self, index: GLuint, n: GLdouble, f: GLdouble) -> Result<()> {
		let ret = process_catch("glDepthRangeIndexed", catch_unwind(||(self.version_4_1.depthrangeindexed)(index, n, f)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDepthRangeIndexed", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetFloati_v(&self, target: GLenum, index: GLuint, data: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetFloati_v", catch_unwind(||(self.version_4_1.getfloati_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFloati_v", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetDoublei_v(&self, target: GLenum, index: GLuint, data: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetDoublei_v", catch_unwind(||(self.version_4_1.getdoublei_v)(target, index, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetDoublei_v", ret, (self.version_4_1.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_4_2 for GLCore {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_4_2.geterror)()
	}
	#[inline(always)]
	fn glDrawArraysInstancedBaseInstance(&self, mode: GLenum, first: GLint, count: GLsizei, instancecount: GLsizei, baseinstance: GLuint) -> Result<()> {
		let ret = process_catch("glDrawArraysInstancedBaseInstance", catch_unwind(||(self.version_4_2.drawarraysinstancedbaseinstance)(mode, first, count, instancecount, baseinstance)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawArraysInstancedBaseInstance", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawElementsInstancedBaseInstance(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei, baseinstance: GLuint) -> Result<()> {
		let ret = process_catch("glDrawElementsInstancedBaseInstance", catch_unwind(||(self.version_4_2.drawelementsinstancedbaseinstance)(mode, count, type_, indices, instancecount, baseinstance)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsInstancedBaseInstance", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawElementsInstancedBaseVertexBaseInstance(&self, mode: GLenum, count: GLsizei, type_: GLenum, indices: *const c_void, instancecount: GLsizei, basevertex: GLint, baseinstance: GLuint) -> Result<()> {
		let ret = process_catch("glDrawElementsInstancedBaseVertexBaseInstance", catch_unwind(||(self.version_4_2.drawelementsinstancedbasevertexbaseinstance)(mode, count, type_, indices, instancecount, basevertex, baseinstance)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawElementsInstancedBaseVertexBaseInstance", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetInternalformativ(&self, target: GLenum, internalformat: GLenum, pname: GLenum, count: GLsizei, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetInternalformativ", catch_unwind(||(self.version_4_2.getinternalformativ)(target, internalformat, pname, count, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetInternalformativ", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetActiveAtomicCounterBufferiv(&self, program: GLuint, bufferIndex: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetActiveAtomicCounterBufferiv", catch_unwind(||(self.version_4_2.getactiveatomiccounterbufferiv)(program, bufferIndex, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetActiveAtomicCounterBufferiv", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindImageTexture(&self, unit: GLuint, texture: GLuint, level: GLint, layered: GLboolean, layer: GLint, access: GLenum, format: GLenum) -> Result<()> {
		let ret = process_catch("glBindImageTexture", catch_unwind(||(self.version_4_2.bindimagetexture)(unit, texture, level, layered, layer, access, format)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindImageTexture", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMemoryBarrier(&self, barriers: GLbitfield) -> Result<()> {
		let ret = process_catch("glMemoryBarrier", catch_unwind(||(self.version_4_2.memorybarrier)(barriers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMemoryBarrier", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexStorage1D(&self, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei) -> Result<()> {
		let ret = process_catch("glTexStorage1D", catch_unwind(||(self.version_4_2.texstorage1d)(target, levels, internalformat, width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage1D", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexStorage2D(&self, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glTexStorage2D", catch_unwind(||(self.version_4_2.texstorage2d)(target, levels, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage2D", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexStorage3D(&self, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei) -> Result<()> {
		let ret = process_catch("glTexStorage3D", catch_unwind(||(self.version_4_2.texstorage3d)(target, levels, internalformat, width, height, depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage3D", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawTransformFeedbackInstanced(&self, mode: GLenum, id: GLuint, instancecount: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawTransformFeedbackInstanced", catch_unwind(||(self.version_4_2.drawtransformfeedbackinstanced)(mode, id, instancecount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawTransformFeedbackInstanced", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDrawTransformFeedbackStreamInstanced(&self, mode: GLenum, id: GLuint, stream: GLuint, instancecount: GLsizei) -> Result<()> {
		let ret = process_catch("glDrawTransformFeedbackStreamInstanced", catch_unwind(||(self.version_4_2.drawtransformfeedbackstreaminstanced)(mode, id, stream, instancecount)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDrawTransformFeedbackStreamInstanced", ret, (self.version_4_2.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_4_3 for GLCore {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_4_3.geterror)()
	}
	#[inline(always)]
	fn glClearBufferData(&self, target: GLenum, internalformat: GLenum, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearBufferData", catch_unwind(||(self.version_4_3.clearbufferdata)(target, internalformat, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferData", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearBufferSubData(&self, target: GLenum, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearBufferSubData", catch_unwind(||(self.version_4_3.clearbuffersubdata)(target, internalformat, offset, size, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearBufferSubData", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDispatchCompute(&self, num_groups_x: GLuint, num_groups_y: GLuint, num_groups_z: GLuint) -> Result<()> {
		let ret = process_catch("glDispatchCompute", catch_unwind(||(self.version_4_3.dispatchcompute)(num_groups_x, num_groups_y, num_groups_z)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDispatchCompute", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDispatchComputeIndirect(&self, indirect: GLintptr) -> Result<()> {
		let ret = process_catch("glDispatchComputeIndirect", catch_unwind(||(self.version_4_3.dispatchcomputeindirect)(indirect)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDispatchComputeIndirect", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyImageSubData(&self, srcName: GLuint, srcTarget: GLenum, srcLevel: GLint, srcX: GLint, srcY: GLint, srcZ: GLint, dstName: GLuint, dstTarget: GLenum, dstLevel: GLint, dstX: GLint, dstY: GLint, dstZ: GLint, srcWidth: GLsizei, srcHeight: GLsizei, srcDepth: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyImageSubData", catch_unwind(||(self.version_4_3.copyimagesubdata)(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyImageSubData", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFramebufferParameteri(&self, target: GLenum, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glFramebufferParameteri", catch_unwind(||(self.version_4_3.framebufferparameteri)(target, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFramebufferParameteri", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetFramebufferParameteriv(&self, target: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetFramebufferParameteriv", catch_unwind(||(self.version_4_3.getframebufferparameteriv)(target, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetFramebufferParameteriv", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetInternalformati64v(&self, target: GLenum, internalformat: GLenum, pname: GLenum, count: GLsizei, params: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetInternalformati64v", catch_unwind(||(self.version_4_3.getinternalformati64v)(target, internalformat, pname, count, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetInternalformati64v", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glInvalidateTexSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei) -> Result<()> {
		let ret = process_catch("glInvalidateTexSubImage", catch_unwind(||(self.version_4_3.invalidatetexsubimage)(texture, level, xoffset, yoffset, zoffset, width, height, depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateTexSubImage", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glInvalidateTexImage(&self, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glInvalidateTexImage", catch_unwind(||(self.version_4_3.invalidateteximage)(texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateTexImage", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glInvalidateBufferSubData(&self, buffer: GLuint, offset: GLintptr, length: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glInvalidateBufferSubData", catch_unwind(||(self.version_4_3.invalidatebuffersubdata)(buffer, offset, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateBufferSubData", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glInvalidateBufferData(&self, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glInvalidateBufferData", catch_unwind(||(self.version_4_3.invalidatebufferdata)(buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateBufferData", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glInvalidateFramebuffer(&self, target: GLenum, numAttachments: GLsizei, attachments: *const GLenum) -> Result<()> {
		let ret = process_catch("glInvalidateFramebuffer", catch_unwind(||(self.version_4_3.invalidateframebuffer)(target, numAttachments, attachments)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateFramebuffer", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glInvalidateSubFramebuffer(&self, target: GLenum, numAttachments: GLsizei, attachments: *const GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glInvalidateSubFramebuffer", catch_unwind(||(self.version_4_3.invalidatesubframebuffer)(target, numAttachments, attachments, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateSubFramebuffer", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiDrawArraysIndirect(&self, mode: GLenum, indirect: *const c_void, drawcount: GLsizei, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawArraysIndirect", catch_unwind(||(self.version_4_3.multidrawarraysindirect)(mode, indirect, drawcount, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawArraysIndirect", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiDrawElementsIndirect(&self, mode: GLenum, type_: GLenum, indirect: *const c_void, drawcount: GLsizei, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawElementsIndirect", catch_unwind(||(self.version_4_3.multidrawelementsindirect)(mode, type_, indirect, drawcount, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawElementsIndirect", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramInterfaceiv(&self, program: GLuint, programInterface: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramInterfaceiv", catch_unwind(||(self.version_4_3.getprograminterfaceiv)(program, programInterface, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramInterfaceiv", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramResourceIndex(&self, program: GLuint, programInterface: GLenum, name: *const GLchar) -> Result<GLuint> {
		let ret = process_catch("glGetProgramResourceIndex", catch_unwind(||(self.version_4_3.getprogramresourceindex)(program, programInterface, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceIndex", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramResourceName(&self, program: GLuint, programInterface: GLenum, index: GLuint, bufSize: GLsizei, length: *mut GLsizei, name: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetProgramResourceName", catch_unwind(||(self.version_4_3.getprogramresourcename)(program, programInterface, index, bufSize, length, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceName", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramResourceiv(&self, program: GLuint, programInterface: GLenum, index: GLuint, propCount: GLsizei, props: *const GLenum, count: GLsizei, length: *mut GLsizei, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetProgramResourceiv", catch_unwind(||(self.version_4_3.getprogramresourceiv)(program, programInterface, index, propCount, props, count, length, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceiv", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramResourceLocation(&self, program: GLuint, programInterface: GLenum, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetProgramResourceLocation", catch_unwind(||(self.version_4_3.getprogramresourcelocation)(program, programInterface, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceLocation", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetProgramResourceLocationIndex(&self, program: GLuint, programInterface: GLenum, name: *const GLchar) -> Result<GLint> {
		let ret = process_catch("glGetProgramResourceLocationIndex", catch_unwind(||(self.version_4_3.getprogramresourcelocationindex)(program, programInterface, name)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetProgramResourceLocationIndex", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glShaderStorageBlockBinding(&self, program: GLuint, storageBlockIndex: GLuint, storageBlockBinding: GLuint) -> Result<()> {
		let ret = process_catch("glShaderStorageBlockBinding", catch_unwind(||(self.version_4_3.shaderstorageblockbinding)(program, storageBlockIndex, storageBlockBinding)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glShaderStorageBlockBinding", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexBufferRange(&self, target: GLenum, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glTexBufferRange", catch_unwind(||(self.version_4_3.texbufferrange)(target, internalformat, buffer, offset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexBufferRange", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexStorage2DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTexStorage2DMultisample", catch_unwind(||(self.version_4_3.texstorage2dmultisample)(target, samples, internalformat, width, height, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage2DMultisample", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTexStorage3DMultisample(&self, target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTexStorage3DMultisample", catch_unwind(||(self.version_4_3.texstorage3dmultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTexStorage3DMultisample", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureView(&self, texture: GLuint, target: GLenum, origtexture: GLuint, internalformat: GLenum, minlevel: GLuint, numlevels: GLuint, minlayer: GLuint, numlayers: GLuint) -> Result<()> {
		let ret = process_catch("glTextureView", catch_unwind(||(self.version_4_3.textureview)(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureView", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindVertexBuffer(&self, bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glBindVertexBuffer", catch_unwind(||(self.version_4_3.bindvertexbuffer)(bindingindex, buffer, offset, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindVertexBuffer", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribFormat(&self, attribindex: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribFormat", catch_unwind(||(self.version_4_3.vertexattribformat)(attribindex, size, type_, normalized, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribFormat", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribIFormat(&self, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribIFormat", catch_unwind(||(self.version_4_3.vertexattribiformat)(attribindex, size, type_, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribIFormat", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribLFormat(&self, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribLFormat", catch_unwind(||(self.version_4_3.vertexattriblformat)(attribindex, size, type_, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribLFormat", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexAttribBinding(&self, attribindex: GLuint, bindingindex: GLuint) -> Result<()> {
		let ret = process_catch("glVertexAttribBinding", catch_unwind(||(self.version_4_3.vertexattribbinding)(attribindex, bindingindex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexAttribBinding", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexBindingDivisor(&self, bindingindex: GLuint, divisor: GLuint) -> Result<()> {
		let ret = process_catch("glVertexBindingDivisor", catch_unwind(||(self.version_4_3.vertexbindingdivisor)(bindingindex, divisor)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexBindingDivisor", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDebugMessageControl(&self, source: GLenum, type_: GLenum, severity: GLenum, count: GLsizei, ids: *const GLuint, enabled: GLboolean) -> Result<()> {
		let ret = process_catch("glDebugMessageControl", catch_unwind(||(self.version_4_3.debugmessagecontrol)(source, type_, severity, count, ids, enabled)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDebugMessageControl", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDebugMessageInsert(&self, source: GLenum, type_: GLenum, id: GLuint, severity: GLenum, length: GLsizei, buf: *const GLchar) -> Result<()> {
		let ret = process_catch("glDebugMessageInsert", catch_unwind(||(self.version_4_3.debugmessageinsert)(source, type_, id, severity, length, buf)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDebugMessageInsert", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDebugMessageCallback(&self, callback: GLDEBUGPROC, userParam: *const c_void) -> Result<()> {
		let ret = process_catch("glDebugMessageCallback", catch_unwind(||(self.version_4_3.debugmessagecallback)(callback, userParam)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDebugMessageCallback", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetDebugMessageLog(&self, count: GLuint, bufSize: GLsizei, sources: *mut GLenum, types: *mut GLenum, ids: *mut GLuint, severities: *mut GLenum, lengths: *mut GLsizei, messageLog: *mut GLchar) -> Result<GLuint> {
		let ret = process_catch("glGetDebugMessageLog", catch_unwind(||(self.version_4_3.getdebugmessagelog)(count, bufSize, sources, types, ids, severities, lengths, messageLog)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetDebugMessageLog", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPushDebugGroup(&self, source: GLenum, id: GLuint, length: GLsizei, message: *const GLchar) -> Result<()> {
		let ret = process_catch("glPushDebugGroup", catch_unwind(||(self.version_4_3.pushdebuggroup)(source, id, length, message)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPushDebugGroup", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPopDebugGroup(&self) -> Result<()> {
		let ret = process_catch("glPopDebugGroup", catch_unwind(||(self.version_4_3.popdebuggroup)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPopDebugGroup", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glObjectLabel(&self, identifier: GLenum, name: GLuint, length: GLsizei, label: *const GLchar) -> Result<()> {
		let ret = process_catch("glObjectLabel", catch_unwind(||(self.version_4_3.objectlabel)(identifier, name, length, label)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glObjectLabel", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetObjectLabel(&self, identifier: GLenum, name: GLuint, bufSize: GLsizei, length: *mut GLsizei, label: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetObjectLabel", catch_unwind(||(self.version_4_3.getobjectlabel)(identifier, name, bufSize, length, label)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetObjectLabel", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glObjectPtrLabel(&self, ptr: *const c_void, length: GLsizei, label: *const GLchar) -> Result<()> {
		let ret = process_catch("glObjectPtrLabel", catch_unwind(||(self.version_4_3.objectptrlabel)(ptr, length, label)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glObjectPtrLabel", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetObjectPtrLabel(&self, ptr: *const c_void, bufSize: GLsizei, length: *mut GLsizei, label: *mut GLchar) -> Result<()> {
		let ret = process_catch("glGetObjectPtrLabel", catch_unwind(||(self.version_4_3.getobjectptrlabel)(ptr, bufSize, length, label)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetObjectPtrLabel", ret, (self.version_4_3.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_4_4 for GLCore {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_4_4.geterror)()
	}
	#[inline(always)]
	fn glBufferStorage(&self, target: GLenum, size: GLsizeiptr, data: *const c_void, flags: GLbitfield) -> Result<()> {
		let ret = process_catch("glBufferStorage", catch_unwind(||(self.version_4_4.bufferstorage)(target, size, data, flags)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBufferStorage", ret, (self.version_4_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearTexImage(&self, texture: GLuint, level: GLint, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearTexImage", catch_unwind(||(self.version_4_4.clearteximage)(texture, level, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearTexImage", ret, (self.version_4_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearTexSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearTexSubImage", catch_unwind(||(self.version_4_4.cleartexsubimage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearTexSubImage", ret, (self.version_4_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindBuffersBase(&self, target: GLenum, first: GLuint, count: GLsizei, buffers: *const GLuint) -> Result<()> {
		let ret = process_catch("glBindBuffersBase", catch_unwind(||(self.version_4_4.bindbuffersbase)(target, first, count, buffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBuffersBase", ret, (self.version_4_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindBuffersRange(&self, target: GLenum, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, sizes: *const GLsizeiptr) -> Result<()> {
		let ret = process_catch("glBindBuffersRange", catch_unwind(||(self.version_4_4.bindbuffersrange)(target, first, count, buffers, offsets, sizes)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindBuffersRange", ret, (self.version_4_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindTextures(&self, first: GLuint, count: GLsizei, textures: *const GLuint) -> Result<()> {
		let ret = process_catch("glBindTextures", catch_unwind(||(self.version_4_4.bindtextures)(first, count, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindTextures", ret, (self.version_4_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindSamplers(&self, first: GLuint, count: GLsizei, samplers: *const GLuint) -> Result<()> {
		let ret = process_catch("glBindSamplers", catch_unwind(||(self.version_4_4.bindsamplers)(first, count, samplers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindSamplers", ret, (self.version_4_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindImageTextures(&self, first: GLuint, count: GLsizei, textures: *const GLuint) -> Result<()> {
		let ret = process_catch("glBindImageTextures", catch_unwind(||(self.version_4_4.bindimagetextures)(first, count, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindImageTextures", ret, (self.version_4_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindVertexBuffers(&self, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, strides: *const GLsizei) -> Result<()> {
		let ret = process_catch("glBindVertexBuffers", catch_unwind(||(self.version_4_4.bindvertexbuffers)(first, count, buffers, offsets, strides)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindVertexBuffers", ret, (self.version_4_4.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_4_5 for GLCore {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_4_5.geterror)()
	}
	#[inline(always)]
	fn glClipControl(&self, origin: GLenum, depth: GLenum) -> Result<()> {
		let ret = process_catch("glClipControl", catch_unwind(||(self.version_4_5.clipcontrol)(origin, depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClipControl", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateTransformFeedbacks(&self, n: GLsizei, ids: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateTransformFeedbacks", catch_unwind(||(self.version_4_5.createtransformfeedbacks)(n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateTransformFeedbacks", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTransformFeedbackBufferBase(&self, xfb: GLuint, index: GLuint, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glTransformFeedbackBufferBase", catch_unwind(||(self.version_4_5.transformfeedbackbufferbase)(xfb, index, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTransformFeedbackBufferBase", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTransformFeedbackBufferRange(&self, xfb: GLuint, index: GLuint, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glTransformFeedbackBufferRange", catch_unwind(||(self.version_4_5.transformfeedbackbufferrange)(xfb, index, buffer, offset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTransformFeedbackBufferRange", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTransformFeedbackiv(&self, xfb: GLuint, pname: GLenum, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTransformFeedbackiv", catch_unwind(||(self.version_4_5.gettransformfeedbackiv)(xfb, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTransformFeedbackiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTransformFeedbacki_v(&self, xfb: GLuint, pname: GLenum, index: GLuint, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTransformFeedbacki_v", catch_unwind(||(self.version_4_5.gettransformfeedbacki_v)(xfb, pname, index, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTransformFeedbacki_v", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTransformFeedbacki64_v(&self, xfb: GLuint, pname: GLenum, index: GLuint, param: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetTransformFeedbacki64_v", catch_unwind(||(self.version_4_5.gettransformfeedbacki64_v)(xfb, pname, index, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTransformFeedbacki64_v", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateBuffers(&self, n: GLsizei, buffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateBuffers", catch_unwind(||(self.version_4_5.createbuffers)(n, buffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateBuffers", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedBufferStorage(&self, buffer: GLuint, size: GLsizeiptr, data: *const c_void, flags: GLbitfield) -> Result<()> {
		let ret = process_catch("glNamedBufferStorage", catch_unwind(||(self.version_4_5.namedbufferstorage)(buffer, size, data, flags)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedBufferStorage", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedBufferData(&self, buffer: GLuint, size: GLsizeiptr, data: *const c_void, usage: GLenum) -> Result<()> {
		let ret = process_catch("glNamedBufferData", catch_unwind(||(self.version_4_5.namedbufferdata)(buffer, size, data, usage)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedBufferData", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedBufferSubData(&self, buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: *const c_void) -> Result<()> {
		let ret = process_catch("glNamedBufferSubData", catch_unwind(||(self.version_4_5.namedbuffersubdata)(buffer, offset, size, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedBufferSubData", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyNamedBufferSubData(&self, readBuffer: GLuint, writeBuffer: GLuint, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glCopyNamedBufferSubData", catch_unwind(||(self.version_4_5.copynamedbuffersubdata)(readBuffer, writeBuffer, readOffset, writeOffset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyNamedBufferSubData", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearNamedBufferData(&self, buffer: GLuint, internalformat: GLenum, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearNamedBufferData", catch_unwind(||(self.version_4_5.clearnamedbufferdata)(buffer, internalformat, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedBufferData", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearNamedBufferSubData(&self, buffer: GLuint, internalformat: GLenum, offset: GLintptr, size: GLsizeiptr, format: GLenum, type_: GLenum, data: *const c_void) -> Result<()> {
		let ret = process_catch("glClearNamedBufferSubData", catch_unwind(||(self.version_4_5.clearnamedbuffersubdata)(buffer, internalformat, offset, size, format, type_, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedBufferSubData", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMapNamedBuffer(&self, buffer: GLuint, access: GLenum) -> Result<*mut c_void> {
		let ret = process_catch("glMapNamedBuffer", catch_unwind(||(self.version_4_5.mapnamedbuffer)(buffer, access)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMapNamedBuffer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMapNamedBufferRange(&self, buffer: GLuint, offset: GLintptr, length: GLsizeiptr, access: GLbitfield) -> Result<*mut c_void> {
		let ret = process_catch("glMapNamedBufferRange", catch_unwind(||(self.version_4_5.mapnamedbufferrange)(buffer, offset, length, access)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMapNamedBufferRange", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glUnmapNamedBuffer(&self, buffer: GLuint) -> Result<GLboolean> {
		let ret = process_catch("glUnmapNamedBuffer", catch_unwind(||(self.version_4_5.unmapnamedbuffer)(buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glUnmapNamedBuffer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glFlushMappedNamedBufferRange(&self, buffer: GLuint, offset: GLintptr, length: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glFlushMappedNamedBufferRange", catch_unwind(||(self.version_4_5.flushmappednamedbufferrange)(buffer, offset, length)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glFlushMappedNamedBufferRange", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetNamedBufferParameteriv(&self, buffer: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetNamedBufferParameteriv", catch_unwind(||(self.version_4_5.getnamedbufferparameteriv)(buffer, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedBufferParameteriv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetNamedBufferParameteri64v(&self, buffer: GLuint, pname: GLenum, params: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetNamedBufferParameteri64v", catch_unwind(||(self.version_4_5.getnamedbufferparameteri64v)(buffer, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedBufferParameteri64v", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetNamedBufferPointerv(&self, buffer: GLuint, pname: GLenum, params: *mut *mut c_void) -> Result<()> {
		let ret = process_catch("glGetNamedBufferPointerv", catch_unwind(||(self.version_4_5.getnamedbufferpointerv)(buffer, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedBufferPointerv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetNamedBufferSubData(&self, buffer: GLuint, offset: GLintptr, size: GLsizeiptr, data: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetNamedBufferSubData", catch_unwind(||(self.version_4_5.getnamedbuffersubdata)(buffer, offset, size, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedBufferSubData", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateFramebuffers(&self, n: GLsizei, framebuffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateFramebuffers", catch_unwind(||(self.version_4_5.createframebuffers)(n, framebuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateFramebuffers", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedFramebufferRenderbuffer(&self, framebuffer: GLuint, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: GLuint) -> Result<()> {
		let ret = process_catch("glNamedFramebufferRenderbuffer", catch_unwind(||(self.version_4_5.namedframebufferrenderbuffer)(framebuffer, attachment, renderbuffertarget, renderbuffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferRenderbuffer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedFramebufferParameteri(&self, framebuffer: GLuint, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glNamedFramebufferParameteri", catch_unwind(||(self.version_4_5.namedframebufferparameteri)(framebuffer, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferParameteri", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedFramebufferTexture(&self, framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint) -> Result<()> {
		let ret = process_catch("glNamedFramebufferTexture", catch_unwind(||(self.version_4_5.namedframebuffertexture)(framebuffer, attachment, texture, level)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferTexture", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedFramebufferTextureLayer(&self, framebuffer: GLuint, attachment: GLenum, texture: GLuint, level: GLint, layer: GLint) -> Result<()> {
		let ret = process_catch("glNamedFramebufferTextureLayer", catch_unwind(||(self.version_4_5.namedframebuffertexturelayer)(framebuffer, attachment, texture, level, layer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferTextureLayer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedFramebufferDrawBuffer(&self, framebuffer: GLuint, buf: GLenum) -> Result<()> {
		let ret = process_catch("glNamedFramebufferDrawBuffer", catch_unwind(||(self.version_4_5.namedframebufferdrawbuffer)(framebuffer, buf)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferDrawBuffer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedFramebufferDrawBuffers(&self, framebuffer: GLuint, n: GLsizei, bufs: *const GLenum) -> Result<()> {
		let ret = process_catch("glNamedFramebufferDrawBuffers", catch_unwind(||(self.version_4_5.namedframebufferdrawbuffers)(framebuffer, n, bufs)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferDrawBuffers", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedFramebufferReadBuffer(&self, framebuffer: GLuint, src: GLenum) -> Result<()> {
		let ret = process_catch("glNamedFramebufferReadBuffer", catch_unwind(||(self.version_4_5.namedframebufferreadbuffer)(framebuffer, src)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedFramebufferReadBuffer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glInvalidateNamedFramebufferData(&self, framebuffer: GLuint, numAttachments: GLsizei, attachments: *const GLenum) -> Result<()> {
		let ret = process_catch("glInvalidateNamedFramebufferData", catch_unwind(||(self.version_4_5.invalidatenamedframebufferdata)(framebuffer, numAttachments, attachments)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateNamedFramebufferData", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glInvalidateNamedFramebufferSubData(&self, framebuffer: GLuint, numAttachments: GLsizei, attachments: *const GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glInvalidateNamedFramebufferSubData", catch_unwind(||(self.version_4_5.invalidatenamedframebuffersubdata)(framebuffer, numAttachments, attachments, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glInvalidateNamedFramebufferSubData", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearNamedFramebufferiv(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLint) -> Result<()> {
		let ret = process_catch("glClearNamedFramebufferiv", catch_unwind(||(self.version_4_5.clearnamedframebufferiv)(framebuffer, buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedFramebufferiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearNamedFramebufferuiv(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLuint) -> Result<()> {
		let ret = process_catch("glClearNamedFramebufferuiv", catch_unwind(||(self.version_4_5.clearnamedframebufferuiv)(framebuffer, buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedFramebufferuiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearNamedFramebufferfv(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, value: *const GLfloat) -> Result<()> {
		let ret = process_catch("glClearNamedFramebufferfv", catch_unwind(||(self.version_4_5.clearnamedframebufferfv)(framebuffer, buffer, drawbuffer, value)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedFramebufferfv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glClearNamedFramebufferfi(&self, framebuffer: GLuint, buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint) -> Result<()> {
		let ret = process_catch("glClearNamedFramebufferfi", catch_unwind(||(self.version_4_5.clearnamedframebufferfi)(framebuffer, buffer, drawbuffer, depth, stencil)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glClearNamedFramebufferfi", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBlitNamedFramebuffer(&self, readFramebuffer: GLuint, drawFramebuffer: GLuint, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum) -> Result<()> {
		let ret = process_catch("glBlitNamedFramebuffer", catch_unwind(||(self.version_4_5.blitnamedframebuffer)(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBlitNamedFramebuffer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCheckNamedFramebufferStatus(&self, framebuffer: GLuint, target: GLenum) -> Result<GLenum> {
		let ret = process_catch("glCheckNamedFramebufferStatus", catch_unwind(||(self.version_4_5.checknamedframebufferstatus)(framebuffer, target)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCheckNamedFramebufferStatus", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetNamedFramebufferParameteriv(&self, framebuffer: GLuint, pname: GLenum, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetNamedFramebufferParameteriv", catch_unwind(||(self.version_4_5.getnamedframebufferparameteriv)(framebuffer, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedFramebufferParameteriv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetNamedFramebufferAttachmentParameteriv(&self, framebuffer: GLuint, attachment: GLenum, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetNamedFramebufferAttachmentParameteriv", catch_unwind(||(self.version_4_5.getnamedframebufferattachmentparameteriv)(framebuffer, attachment, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedFramebufferAttachmentParameteriv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateRenderbuffers(&self, n: GLsizei, renderbuffers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateRenderbuffers", catch_unwind(||(self.version_4_5.createrenderbuffers)(n, renderbuffers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateRenderbuffers", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedRenderbufferStorage(&self, renderbuffer: GLuint, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glNamedRenderbufferStorage", catch_unwind(||(self.version_4_5.namedrenderbufferstorage)(renderbuffer, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedRenderbufferStorage", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glNamedRenderbufferStorageMultisample(&self, renderbuffer: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glNamedRenderbufferStorageMultisample", catch_unwind(||(self.version_4_5.namedrenderbufferstoragemultisample)(renderbuffer, samples, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glNamedRenderbufferStorageMultisample", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetNamedRenderbufferParameteriv(&self, renderbuffer: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetNamedRenderbufferParameteriv", catch_unwind(||(self.version_4_5.getnamedrenderbufferparameteriv)(renderbuffer, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetNamedRenderbufferParameteriv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateTextures(&self, target: GLenum, n: GLsizei, textures: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateTextures", catch_unwind(||(self.version_4_5.createtextures)(target, n, textures)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateTextures", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureBuffer(&self, texture: GLuint, internalformat: GLenum, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glTextureBuffer", catch_unwind(||(self.version_4_5.texturebuffer)(texture, internalformat, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureBuffer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureBufferRange(&self, texture: GLuint, internalformat: GLenum, buffer: GLuint, offset: GLintptr, size: GLsizeiptr) -> Result<()> {
		let ret = process_catch("glTextureBufferRange", catch_unwind(||(self.version_4_5.texturebufferrange)(texture, internalformat, buffer, offset, size)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureBufferRange", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureStorage1D(&self, texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei) -> Result<()> {
		let ret = process_catch("glTextureStorage1D", catch_unwind(||(self.version_4_5.texturestorage1d)(texture, levels, internalformat, width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage1D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureStorage2D(&self, texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glTextureStorage2D", catch_unwind(||(self.version_4_5.texturestorage2d)(texture, levels, internalformat, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage2D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureStorage3D(&self, texture: GLuint, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei) -> Result<()> {
		let ret = process_catch("glTextureStorage3D", catch_unwind(||(self.version_4_5.texturestorage3d)(texture, levels, internalformat, width, height, depth)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage3D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureStorage2DMultisample(&self, texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTextureStorage2DMultisample", catch_unwind(||(self.version_4_5.texturestorage2dmultisample)(texture, samples, internalformat, width, height, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage2DMultisample", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureStorage3DMultisample(&self, texture: GLuint, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, fixedsamplelocations: GLboolean) -> Result<()> {
		let ret = process_catch("glTextureStorage3DMultisample", catch_unwind(||(self.version_4_5.texturestorage3dmultisample)(texture, samples, internalformat, width, height, depth, fixedsamplelocations)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureStorage3DMultisample", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureSubImage1D(&self, texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTextureSubImage1D", catch_unwind(||(self.version_4_5.texturesubimage1d)(texture, level, xoffset, width, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureSubImage1D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureSubImage2D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTextureSubImage2D", catch_unwind(||(self.version_4_5.texturesubimage2d)(texture, level, xoffset, yoffset, width, height, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureSubImage2D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureSubImage3D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, pixels: *const c_void) -> Result<()> {
		let ret = process_catch("glTextureSubImage3D", catch_unwind(||(self.version_4_5.texturesubimage3d)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureSubImage3D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompressedTextureSubImage1D(&self, texture: GLuint, level: GLint, xoffset: GLint, width: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTextureSubImage1D", catch_unwind(||(self.version_4_5.compressedtexturesubimage1d)(texture, level, xoffset, width, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTextureSubImage1D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompressedTextureSubImage2D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTextureSubImage2D", catch_unwind(||(self.version_4_5.compressedtexturesubimage2d)(texture, level, xoffset, yoffset, width, height, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTextureSubImage2D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCompressedTextureSubImage3D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, data: *const c_void) -> Result<()> {
		let ret = process_catch("glCompressedTextureSubImage3D", catch_unwind(||(self.version_4_5.compressedtexturesubimage3d)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCompressedTextureSubImage3D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyTextureSubImage1D(&self, texture: GLuint, level: GLint, xoffset: GLint, x: GLint, y: GLint, width: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTextureSubImage1D", catch_unwind(||(self.version_4_5.copytexturesubimage1d)(texture, level, xoffset, x, y, width)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTextureSubImage1D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyTextureSubImage2D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTextureSubImage2D", catch_unwind(||(self.version_4_5.copytexturesubimage2d)(texture, level, xoffset, yoffset, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTextureSubImage2D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCopyTextureSubImage3D(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei) -> Result<()> {
		let ret = process_catch("glCopyTextureSubImage3D", catch_unwind(||(self.version_4_5.copytexturesubimage3d)(texture, level, xoffset, yoffset, zoffset, x, y, width, height)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCopyTextureSubImage3D", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureParameterf(&self, texture: GLuint, pname: GLenum, param: GLfloat) -> Result<()> {
		let ret = process_catch("glTextureParameterf", catch_unwind(||(self.version_4_5.textureparameterf)(texture, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameterf", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureParameterfv(&self, texture: GLuint, pname: GLenum, param: *const GLfloat) -> Result<()> {
		let ret = process_catch("glTextureParameterfv", catch_unwind(||(self.version_4_5.textureparameterfv)(texture, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameterfv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureParameteri(&self, texture: GLuint, pname: GLenum, param: GLint) -> Result<()> {
		let ret = process_catch("glTextureParameteri", catch_unwind(||(self.version_4_5.textureparameteri)(texture, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameteri", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureParameterIiv(&self, texture: GLuint, pname: GLenum, params: *const GLint) -> Result<()> {
		let ret = process_catch("glTextureParameterIiv", catch_unwind(||(self.version_4_5.textureparameteriiv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameterIiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureParameterIuiv(&self, texture: GLuint, pname: GLenum, params: *const GLuint) -> Result<()> {
		let ret = process_catch("glTextureParameterIuiv", catch_unwind(||(self.version_4_5.textureparameteriuiv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameterIuiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureParameteriv(&self, texture: GLuint, pname: GLenum, param: *const GLint) -> Result<()> {
		let ret = process_catch("glTextureParameteriv", catch_unwind(||(self.version_4_5.textureparameteriv)(texture, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureParameteriv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGenerateTextureMipmap(&self, texture: GLuint) -> Result<()> {
		let ret = process_catch("glGenerateTextureMipmap", catch_unwind(||(self.version_4_5.generatetexturemipmap)(texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGenerateTextureMipmap", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glBindTextureUnit(&self, unit: GLuint, texture: GLuint) -> Result<()> {
		let ret = process_catch("glBindTextureUnit", catch_unwind(||(self.version_4_5.bindtextureunit)(unit, texture)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glBindTextureUnit", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTextureImage(&self, texture: GLuint, level: GLint, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetTextureImage", catch_unwind(||(self.version_4_5.gettextureimage)(texture, level, format, type_, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureImage", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetCompressedTextureImage(&self, texture: GLuint, level: GLint, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetCompressedTextureImage", catch_unwind(||(self.version_4_5.getcompressedtextureimage)(texture, level, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetCompressedTextureImage", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTextureLevelParameterfv(&self, texture: GLuint, level: GLint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetTextureLevelParameterfv", catch_unwind(||(self.version_4_5.gettexturelevelparameterfv)(texture, level, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureLevelParameterfv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTextureLevelParameteriv(&self, texture: GLuint, level: GLint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTextureLevelParameteriv", catch_unwind(||(self.version_4_5.gettexturelevelparameteriv)(texture, level, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureLevelParameteriv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTextureParameterfv(&self, texture: GLuint, pname: GLenum, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetTextureParameterfv", catch_unwind(||(self.version_4_5.gettextureparameterfv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureParameterfv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTextureParameterIiv(&self, texture: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTextureParameterIiv", catch_unwind(||(self.version_4_5.gettextureparameteriiv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureParameterIiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTextureParameterIuiv(&self, texture: GLuint, pname: GLenum, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetTextureParameterIuiv", catch_unwind(||(self.version_4_5.gettextureparameteriuiv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureParameterIuiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTextureParameteriv(&self, texture: GLuint, pname: GLenum, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetTextureParameteriv", catch_unwind(||(self.version_4_5.gettextureparameteriv)(texture, pname, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureParameteriv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateVertexArrays(&self, n: GLsizei, arrays: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateVertexArrays", catch_unwind(||(self.version_4_5.createvertexarrays)(n, arrays)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateVertexArrays", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glDisableVertexArrayAttrib(&self, vaobj: GLuint, index: GLuint) -> Result<()> {
		let ret = process_catch("glDisableVertexArrayAttrib", catch_unwind(||(self.version_4_5.disablevertexarrayattrib)(vaobj, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glDisableVertexArrayAttrib", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glEnableVertexArrayAttrib(&self, vaobj: GLuint, index: GLuint) -> Result<()> {
		let ret = process_catch("glEnableVertexArrayAttrib", catch_unwind(||(self.version_4_5.enablevertexarrayattrib)(vaobj, index)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glEnableVertexArrayAttrib", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexArrayElementBuffer(&self, vaobj: GLuint, buffer: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayElementBuffer", catch_unwind(||(self.version_4_5.vertexarrayelementbuffer)(vaobj, buffer)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayElementBuffer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexArrayVertexBuffer(&self, vaobj: GLuint, bindingindex: GLuint, buffer: GLuint, offset: GLintptr, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glVertexArrayVertexBuffer", catch_unwind(||(self.version_4_5.vertexarrayvertexbuffer)(vaobj, bindingindex, buffer, offset, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayVertexBuffer", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexArrayVertexBuffers(&self, vaobj: GLuint, first: GLuint, count: GLsizei, buffers: *const GLuint, offsets: *const GLintptr, strides: *const GLsizei) -> Result<()> {
		let ret = process_catch("glVertexArrayVertexBuffers", catch_unwind(||(self.version_4_5.vertexarrayvertexbuffers)(vaobj, first, count, buffers, offsets, strides)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayVertexBuffers", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexArrayAttribBinding(&self, vaobj: GLuint, attribindex: GLuint, bindingindex: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayAttribBinding", catch_unwind(||(self.version_4_5.vertexarrayattribbinding)(vaobj, attribindex, bindingindex)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayAttribBinding", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexArrayAttribFormat(&self, vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, normalized: GLboolean, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayAttribFormat", catch_unwind(||(self.version_4_5.vertexarrayattribformat)(vaobj, attribindex, size, type_, normalized, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayAttribFormat", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexArrayAttribIFormat(&self, vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayAttribIFormat", catch_unwind(||(self.version_4_5.vertexarrayattribiformat)(vaobj, attribindex, size, type_, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayAttribIFormat", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexArrayAttribLFormat(&self, vaobj: GLuint, attribindex: GLuint, size: GLint, type_: GLenum, relativeoffset: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayAttribLFormat", catch_unwind(||(self.version_4_5.vertexarrayattriblformat)(vaobj, attribindex, size, type_, relativeoffset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayAttribLFormat", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glVertexArrayBindingDivisor(&self, vaobj: GLuint, bindingindex: GLuint, divisor: GLuint) -> Result<()> {
		let ret = process_catch("glVertexArrayBindingDivisor", catch_unwind(||(self.version_4_5.vertexarraybindingdivisor)(vaobj, bindingindex, divisor)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glVertexArrayBindingDivisor", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexArrayiv(&self, vaobj: GLuint, pname: GLenum, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetVertexArrayiv", catch_unwind(||(self.version_4_5.getvertexarrayiv)(vaobj, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexArrayiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexArrayIndexediv(&self, vaobj: GLuint, index: GLuint, pname: GLenum, param: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetVertexArrayIndexediv", catch_unwind(||(self.version_4_5.getvertexarrayindexediv)(vaobj, index, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexArrayIndexediv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetVertexArrayIndexed64iv(&self, vaobj: GLuint, index: GLuint, pname: GLenum, param: *mut GLint64) -> Result<()> {
		let ret = process_catch("glGetVertexArrayIndexed64iv", catch_unwind(||(self.version_4_5.getvertexarrayindexed64iv)(vaobj, index, pname, param)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetVertexArrayIndexed64iv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateSamplers(&self, n: GLsizei, samplers: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateSamplers", catch_unwind(||(self.version_4_5.createsamplers)(n, samplers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateSamplers", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateProgramPipelines(&self, n: GLsizei, pipelines: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateProgramPipelines", catch_unwind(||(self.version_4_5.createprogrampipelines)(n, pipelines)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateProgramPipelines", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glCreateQueries(&self, target: GLenum, n: GLsizei, ids: *mut GLuint) -> Result<()> {
		let ret = process_catch("glCreateQueries", catch_unwind(||(self.version_4_5.createqueries)(target, n, ids)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glCreateQueries", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryBufferObjecti64v(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()> {
		let ret = process_catch("glGetQueryBufferObjecti64v", catch_unwind(||(self.version_4_5.getquerybufferobjecti64v)(id, buffer, pname, offset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryBufferObjecti64v", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryBufferObjectiv(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()> {
		let ret = process_catch("glGetQueryBufferObjectiv", catch_unwind(||(self.version_4_5.getquerybufferobjectiv)(id, buffer, pname, offset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryBufferObjectiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryBufferObjectui64v(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()> {
		let ret = process_catch("glGetQueryBufferObjectui64v", catch_unwind(||(self.version_4_5.getquerybufferobjectui64v)(id, buffer, pname, offset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryBufferObjectui64v", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetQueryBufferObjectuiv(&self, id: GLuint, buffer: GLuint, pname: GLenum, offset: GLintptr) -> Result<()> {
		let ret = process_catch("glGetQueryBufferObjectuiv", catch_unwind(||(self.version_4_5.getquerybufferobjectuiv)(id, buffer, pname, offset)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetQueryBufferObjectuiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMemoryBarrierByRegion(&self, barriers: GLbitfield) -> Result<()> {
		let ret = process_catch("glMemoryBarrierByRegion", catch_unwind(||(self.version_4_5.memorybarrierbyregion)(barriers)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMemoryBarrierByRegion", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetTextureSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetTextureSubImage", catch_unwind(||(self.version_4_5.gettexturesubimage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type_, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetTextureSubImage", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetCompressedTextureSubImage(&self, texture: GLuint, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetCompressedTextureSubImage", catch_unwind(||(self.version_4_5.getcompressedtexturesubimage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetCompressedTextureSubImage", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetGraphicsResetStatus(&self) -> Result<GLenum> {
		let ret = process_catch("glGetGraphicsResetStatus", catch_unwind(||(self.version_4_5.getgraphicsresetstatus)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetGraphicsResetStatus", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnCompressedTexImage(&self, target: GLenum, lod: GLint, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnCompressedTexImage", catch_unwind(||(self.version_4_5.getncompressedteximage)(target, lod, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnCompressedTexImage", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnTexImage(&self, target: GLenum, level: GLint, format: GLenum, type_: GLenum, bufSize: GLsizei, pixels: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnTexImage", catch_unwind(||(self.version_4_5.getnteximage)(target, level, format, type_, bufSize, pixels)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnTexImage", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnUniformdv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetnUniformdv", catch_unwind(||(self.version_4_5.getnuniformdv)(program, location, bufSize, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnUniformdv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnUniformfv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetnUniformfv", catch_unwind(||(self.version_4_5.getnuniformfv)(program, location, bufSize, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnUniformfv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnUniformiv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetnUniformiv", catch_unwind(||(self.version_4_5.getnuniformiv)(program, location, bufSize, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnUniformiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnUniformuiv(&self, program: GLuint, location: GLint, bufSize: GLsizei, params: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetnUniformuiv", catch_unwind(||(self.version_4_5.getnuniformuiv)(program, location, bufSize, params)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnUniformuiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glReadnPixels(&self, x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type_: GLenum, bufSize: GLsizei, data: *mut c_void) -> Result<()> {
		let ret = process_catch("glReadnPixels", catch_unwind(||(self.version_4_5.readnpixels)(x, y, width, height, format, type_, bufSize, data)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glReadnPixels", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnMapdv(&self, target: GLenum, query: GLenum, bufSize: GLsizei, v: *mut GLdouble) -> Result<()> {
		let ret = process_catch("glGetnMapdv", catch_unwind(||(self.version_4_5.getnmapdv)(target, query, bufSize, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnMapdv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnMapfv(&self, target: GLenum, query: GLenum, bufSize: GLsizei, v: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetnMapfv", catch_unwind(||(self.version_4_5.getnmapfv)(target, query, bufSize, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnMapfv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnMapiv(&self, target: GLenum, query: GLenum, bufSize: GLsizei, v: *mut GLint) -> Result<()> {
		let ret = process_catch("glGetnMapiv", catch_unwind(||(self.version_4_5.getnmapiv)(target, query, bufSize, v)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnMapiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnPixelMapfv(&self, map: GLenum, bufSize: GLsizei, values: *mut GLfloat) -> Result<()> {
		let ret = process_catch("glGetnPixelMapfv", catch_unwind(||(self.version_4_5.getnpixelmapfv)(map, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnPixelMapfv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnPixelMapuiv(&self, map: GLenum, bufSize: GLsizei, values: *mut GLuint) -> Result<()> {
		let ret = process_catch("glGetnPixelMapuiv", catch_unwind(||(self.version_4_5.getnpixelmapuiv)(map, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnPixelMapuiv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnPixelMapusv(&self, map: GLenum, bufSize: GLsizei, values: *mut GLushort) -> Result<()> {
		let ret = process_catch("glGetnPixelMapusv", catch_unwind(||(self.version_4_5.getnpixelmapusv)(map, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnPixelMapusv", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnPolygonStipple(&self, bufSize: GLsizei, pattern: *mut GLubyte) -> Result<()> {
		let ret = process_catch("glGetnPolygonStipple", catch_unwind(||(self.version_4_5.getnpolygonstipple)(bufSize, pattern)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnPolygonStipple", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnColorTable(&self, target: GLenum, format: GLenum, type_: GLenum, bufSize: GLsizei, table: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnColorTable", catch_unwind(||(self.version_4_5.getncolortable)(target, format, type_, bufSize, table)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnColorTable", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnConvolutionFilter(&self, target: GLenum, format: GLenum, type_: GLenum, bufSize: GLsizei, image: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnConvolutionFilter", catch_unwind(||(self.version_4_5.getnconvolutionfilter)(target, format, type_, bufSize, image)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnConvolutionFilter", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnSeparableFilter(&self, target: GLenum, format: GLenum, type_: GLenum, rowBufSize: GLsizei, row: *mut c_void, columnBufSize: GLsizei, column: *mut c_void, span: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnSeparableFilter", catch_unwind(||(self.version_4_5.getnseparablefilter)(target, format, type_, rowBufSize, row, columnBufSize, column, span)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnSeparableFilter", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnHistogram(&self, target: GLenum, reset: GLboolean, format: GLenum, type_: GLenum, bufSize: GLsizei, values: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnHistogram", catch_unwind(||(self.version_4_5.getnhistogram)(target, reset, format, type_, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnHistogram", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glGetnMinmax(&self, target: GLenum, reset: GLboolean, format: GLenum, type_: GLenum, bufSize: GLsizei, values: *mut c_void) -> Result<()> {
		let ret = process_catch("glGetnMinmax", catch_unwind(||(self.version_4_5.getnminmax)(target, reset, format, type_, bufSize, values)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glGetnMinmax", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glTextureBarrier(&self) -> Result<()> {
		let ret = process_catch("glTextureBarrier", catch_unwind(||(self.version_4_5.texturebarrier)()));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glTextureBarrier", ret, (self.version_4_5.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GL_4_6 for GLCore {
	#[inline(always)]
	fn glGetError(&self) -> GLenum {
		(self.version_4_6.geterror)()
	}
	#[inline(always)]
	fn glSpecializeShader(&self, shader: GLuint, pEntryPoint: *const GLchar, numSpecializationConstants: GLuint, pConstantIndex: *const GLuint, pConstantValue: *const GLuint) -> Result<()> {
		let ret = process_catch("glSpecializeShader", catch_unwind(||(self.version_4_6.specializeshader)(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glSpecializeShader", ret, (self.version_4_6.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiDrawArraysIndirectCount(&self, mode: GLenum, indirect: *const c_void, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawArraysIndirectCount", catch_unwind(||(self.version_4_6.multidrawarraysindirectcount)(mode, indirect, drawcount, maxdrawcount, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawArraysIndirectCount", ret, (self.version_4_6.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glMultiDrawElementsIndirectCount(&self, mode: GLenum, type_: GLenum, indirect: *const c_void, drawcount: GLintptr, maxdrawcount: GLsizei, stride: GLsizei) -> Result<()> {
		let ret = process_catch("glMultiDrawElementsIndirectCount", catch_unwind(||(self.version_4_6.multidrawelementsindirectcount)(mode, type_, indirect, drawcount, maxdrawcount, stride)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glMultiDrawElementsIndirectCount", ret, (self.version_4_6.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
	#[inline(always)]
	fn glPolygonOffsetClamp(&self, factor: GLfloat, units: GLfloat, clamp: GLfloat) -> Result<()> {
		let ret = process_catch("glPolygonOffsetClamp", catch_unwind(||(self.version_4_6.polygonoffsetclamp)(factor, units, clamp)));
		#[cfg(feature = "diagnose")]
		if let Ok(ret) = ret {
			return to_result("glPolygonOffsetClamp", ret, (self.version_4_6.geterror)());
		} else {
			return ret
		}
		#[cfg(not(feature = "diagnose"))]
		return ret;
	}
}

impl GLCore {
	pub fn new(mut get_proc_address: impl FnMut(&'static str) -> *const c_void) -> Result<Self> {
		let version_1_0 = Version10::new(&mut get_proc_address)?;
		if !version_1_0.available {
			return Ok(Self::default());
		}
		Ok(Self {
			version_1_0,
			version_1_1: Version11::new(version_1_0, &mut get_proc_address),
			version_1_2: Version12::new(version_1_0, &mut get_proc_address),
			version_1_3: Version13::new(version_1_0, &mut get_proc_address),
			version_1_4: Version14::new(version_1_0, &mut get_proc_address),
			version_1_5: Version15::new(version_1_0, &mut get_proc_address),
			version_2_0: Version20::new(version_1_0, &mut get_proc_address),
			version_2_1: Version21::new(version_1_0, &mut get_proc_address),
			version_3_0: Version30::new(version_1_0, &mut get_proc_address),
			version_3_1: Version31::new(version_1_0, &mut get_proc_address),
			version_3_2: Version32::new(version_1_0, &mut get_proc_address),
			version_3_3: Version33::new(version_1_0, &mut get_proc_address),
			version_4_0: Version40::new(version_1_0, &mut get_proc_address),
			version_4_1: Version41::new(version_1_0, &mut get_proc_address),
			version_4_2: Version42::new(version_1_0, &mut get_proc_address),
			version_4_3: Version43::new(version_1_0, &mut get_proc_address),
			version_4_4: Version44::new(version_1_0, &mut get_proc_address),
			version_4_5: Version45::new(version_1_0, &mut get_proc_address),
			version_4_6: Version46::new(version_1_0, &mut get_proc_address),
		})
	}
}

impl Default for GLCore {
	fn default() -> Self {
		Self {
			version_1_0: Version10::default(),
			version_1_1: Version11::default(),
			version_1_2: Version12::default(),
			version_1_3: Version13::default(),
			version_1_4: Version14::default(),
			version_1_5: Version15::default(),
			version_2_0: Version20::default(),
			version_2_1: Version21::default(),
			version_3_0: Version30::default(),
			version_3_1: Version31::default(),
			version_3_2: Version32::default(),
			version_3_3: Version33::default(),
			version_4_0: Version40::default(),
			version_4_1: Version41::default(),
			version_4_2: Version42::default(),
			version_4_3: Version43::default(),
			version_4_4: Version44::default(),
			version_4_5: Version45::default(),
			version_4_6: Version46::default(),
		}
	}
}

